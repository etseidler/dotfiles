exports.id=928,exports.ids=[928],exports.modules={1018:(e,t,i)=>{i.d(t,{HomeWebviewProvider:()=>HomeWebviewProvider});var s=i(1398),n=i(4692),r=i(5811),o=i(2251),a=i(1646),h=i(2710),l=i(9268),u=i(8085),c=i(5416),d=i(5302),p=i(4931),g=i(3494),v=i(6447),m=i(7628),w=i(1762),b=i(594),f=i(7023),y=i(8049),C=i(7747),R=i(892),P=i(369),S=i(4143),_=i(9011);async function D(e){let t=await e.launchpad.getCategorizedItems();if(null!=t.error)return{error:t.error};let i=S.H.get("launchpad.indicator.groups")??[];return(0,_.a)(t.items,i)}var k=i(4424),O=i(156),B=i(7686),I=i(9184),L=i(4007),q=i(124),W=i(5270),E=i(471),T=i(3503);let A="home",z=new T.Oz(A,"launchpad/summary"),$=new T.Oz(A,"overview"),F=new T.Oz(A,"overviewFilter"),M=new T.Oz(A,"overview/repository/change"),x=new T.Q2(A,"previewEnabled/toggle"),H=new T.Q2(A,"section/collapse"),G=new T.Q2(A,"walkthrough/dismiss"),Z=new T.Q2(A,"overview/filter/set"),U=new T.Q2(A,"openInGraph"),N=new T.C1(A,"repositories/didCompleteDiscovering"),j=new T.C1(A,"previewEnabled/didChange"),Q=new T.C1(A,"repository/wip/didChange"),V=new T.C1(A,"repositories/didChange"),X=new T.C1(A,"walkthroughProgress/didChange"),Y=new T.C1(A,"integrations/didChange"),J=new T.C1(A,"launchpad/didChange"),K=new T.C1(A,"subscription/didChange"),ee=new T.C1(A,"org/settings/didChange"),et=new T.C1(A,"home/ownerFilter/didChange"),ei=new T.C1(A,"account/didFocus");var es=Object.defineProperty,en=Object.getOwnPropertyDescriptor;let er=Object.freeze({dispose:()=>{}});let HomeWebviewProvider=class HomeWebviewProvider{constructor(e,t){this.container=e,this.host=t,this._disposable=s.Disposable.from(this.container.git.onDidChangeRepositories(this.onRepositoriesChanged,this),s.workspace.isTrusted?er:s.workspace.onDidGrantWorkspaceTrust(()=>this.notifyDidChangeRepositories(),this),this.container.subscription.onDidChange(this.onSubscriptionChanged,this),(0,B.wt)(this.onContextChanged,this),this.container.integrations.onDidChangeConnectionState(this.onChangeConnectionState,this),this.container.walkthrough.onProgressChanged(this.onWalkthroughChanged,this),S.H.onDidChange(this.onDidChangeConfig,this),this.container.launchpad.onDidChange(this.onDidLaunchpadChange,this))}_disposable;_discovering;_etag;_pendingFocusAccount=!1;dispose(){this._disposable.dispose()}getTelemetryContext(){return{...this.host.getTelemetryContext(),"context.preview":this.getPreviewEnabled()?"v16":void 0}}_overviewBranchFilter={recent:{threshold:"OneWeek"},stale:{threshold:"OneYear",show:!1}};onShowing(e,t,...i){this._etag=this.container.git.etag,this.ensureRepoDiscovery();let[s]=i;if(s?.focusAccount===!0){if(!e&&this.host.ready&&this.host.visible)return queueMicrotask(()=>void this.host.notify(ei,void 0)),[!0,void 0];this._pendingFocusAccount=!0}return[!0,void 0]}async ensureRepoDiscovery(){this.container.git.isDiscoveringRepositories&&(this._discovering=this.container.git.isDiscoveringRepositories,this._discovering.finally(()=>this._discovering=void 0),this._etag=await this._discovering,this.notifyDidCompleteDiscoveringRepositories())}onChangeConnectionState(){this.notifyDidChangeIntegrations()}async onChooseRepository(){let e=this.getSelectedRepository(),t=this.container.git.openRepositories.sort((t,i)=>(t===e?1:-1)-(i===e?1:-1)||(t.starred?-1:1)-(i.starred?-1:1)||t.index-i.index),i=await (0,k.oe)(`Switch Repository ${r.EO.Dot} ${e?.name}`,"Choose a repository to switch to",t);null!=i&&i!==e&&this.selectRepository(i.path)}onRepositoriesChanged(){null==this._discovering&&this._etag!==this.container.git.etag&&this.notifyDidChangeRepositories()}onWalkthroughChanged(){this.notifyDidChangeProgress()}onDidChangeConfig(e){S.H.changed(e,"home.preview.enabled")&&this.notifyDidChangeConfig()}onDidLaunchpadChange(){this.notifyDidChangeLaunchpad()}async push(e=!1){let t=this.getSelectedRepository();return t?(0,h.b)({command:"push",state:{repos:[t],flags:e?["--force"]:void 0}}):Promise.resolve()}async pull(){let e=this.getSelectedRepository();return e?(0,h.b)({command:"pull",state:{repos:[e]}}):Promise.resolve()}registerCommands(){return[(0,O.Lb)(`${this.host.id}.pull`,this.pull,this),(0,O.Lb)(`${this.host.id}.push`,e=>{this.push(e.force)},this),(0,O.Lb)(`${this.host.id}.publishBranch`,this.push,this),(0,O.Lb)(`${this.host.id}.refresh`,()=>this.host.refresh(!0),this),(0,O.Lb)(`${this.host.id}.disablePreview`,()=>this.onTogglePreviewEnabled(!1),this),(0,O.Lb)(`${this.host.id}.enablePreview`,()=>this.onTogglePreviewEnabled(!0),this),(0,O.Lb)(`${this.host.id}.previewFeedback`,()=>(0,I.CZ)("https://github.com/gitkraken/vscode-gitlens/discussions/3721"),this),(0,O.Lb)(`${this.host.id}.whatsNew`,()=>(0,I.CZ)(r.DS.releaseNotes),this),(0,O.Lb)(`${this.host.id}.help`,()=>(0,I.CZ)(r.DS.helpCenter),this),(0,O.Lb)(`${this.host.id}.issues`,()=>(0,I.CZ)(r.DS.githubIssues),this),(0,O.Lb)(`${this.host.id}.info`,()=>(0,I.CZ)(r.DS.helpCenterHome),this),(0,O.Lb)(`${this.host.id}.discussions`,()=>(0,I.CZ)(r.DS.githubDiscussions),this),(0,O.Lb)(`${this.host.id}.account.resync`,e=>this.container.subscription.validate({force:!0},e),this),(0,O.Lb)("gitlens.home.openMergeTargetComparison",this.mergeTargetCompare,this),(0,O.Lb)("gitlens.home.openPullRequestChanges",this.pullRequestChanges,this),(0,O.Lb)("gitlens.home.openPullRequestComparison",this.pullRequestCompare,this),(0,O.Lb)("gitlens.home.openPullRequestOnRemote",this.pullRequestViewOnRemote,this),(0,O.Lb)("gitlens.home.openPullRequestDetails",this.pullRequestDetails,this),(0,O.Lb)("gitlens.home.createPullRequest",this.pullRequestCreate,this),(0,O.Lb)("gitlens.home.openWorktree",this.worktreeOpen,this),(0,O.Lb)("gitlens.home.switchToBranch",this.switchToBranch,this),(0,O.Lb)("gitlens.home.fetch",this.fetch,this),(0,O.Lb)("gitlens.home.openInGraph",this.openInGraph,this),(0,O.Lb)("gitlens.home.createBranch",this.createBranch,this),(0,O.Lb)("gitlens.home.mergeIntoCurrent",this.mergeIntoCurrent,this),(0,O.Lb)("gitlens.home.rebaseCurrentOnto",this.rebaseCurrentOnto,this),(0,O.Lb)("gitlens.home.startWork",this.startWork,this),(0,O.Lb)("gitlens.home.createCloudPatch",this.createCloudPatch,this),(0,O.Lb)("gitlens.home.skipPausedOperation",this.skipPausedOperation,this),(0,O.Lb)("gitlens.home.continuePausedOperation",this.continuePausedOperation,this),(0,O.Lb)("gitlens.home.abortPausedOperation",this.abortPausedOperation,this),(0,O.Lb)("gitlens.home.openRebaseEditor",this.openRebaseEditor,this)]}setOverviewFilter(e){this._overviewBranchFilter=e,this.host.notify(et,{filter:this._overviewBranchFilter})}async onMessageReceived(e){switch(!0){case H.is(e):this.onCollapseSection(e.params);break;case G.is(e):this.dismissWalkthrough();break;case Z.is(e):this.setOverviewFilter(e.params);break;case z.is(e):this.host.respond(z,e,await D(this.container));break;case $.is(e):this.host.respond($,e,await this.getBranchOverview());break;case F.is(e):this.host.respond(F,e,this._overviewBranchFilter);break;case M.is(e):await this.onChooseRepository(),this.host.respond(M,e,void 0);break;case x.is(e):this.onTogglePreviewEnabled();break;case U.is(e):this.openInGraph(e.params)}}includeBootstrap(){return this.getState()}onRefresh(){this.resetBranchOverview(),this.notifyDidChangeRepositories()}onReloaded(){this.onRefresh(),this.notifyDidChangeProgress()}onReady(){!0===this._pendingFocusAccount&&(this._pendingFocusAccount=!1,this.host.notify(ei,void 0))}onVisibilityChanged(e){if(!e){this.stopRepositorySubscription();return}this.resumeRepositorySubscription(),null==this._discovering&&this._etag!==this.container.git.etag&&this.notifyDidChangeRepositories(!0)}openInGraph(e){let t;if(e?.type==="branch"){let t=this._repositoryBranches.get(e.repoPath);if(null==t)return;let i=t.branches.find(t=>t.id===e.branchId);if(null==i)return;let s=(0,m.iw)(i);if(null==s)return;(0,O.RS)(o.d.ShowInCommitGraph,{ref:s});return}if(null==e)t=this.getSelectedRepository();else{let i=this._repositoryBranches.get(e.repoPath);t=i?.repo}null!=t&&(0,O.RS)(o.d.ShowGraph,t)}createBranch(){this.container.telemetry.sendEvent("home/createBranch"),(0,O.RS)(o.d.GitCommands,{command:"branch",state:{subcommand:"create",suggestNameOnly:!0,suggestRepoOnly:!0,confirmOptions:["--switch","--worktree"]}})}async mergeIntoCurrent(e){let t=this._repositoryBranches.get(e.repoPath),i=t?.branches.find(t=>t.id===e.branchId);(null!=i||null!=(i=await t?.repo?.git.branches().getBranch(e.branchName)))&&u.h1(t.repo,(0,m.iw)(i))}async rebaseCurrentOnto(e){let t=this._repositoryBranches.get(e.repoPath),i=t?.branches.find(t=>t.id===e.branchId);(null!=i||null!=(i=await t?.repo?.git.branches().getBranch(e.branchName)))&&u.RU(t.repo,(0,m.iw)(i))}startWork(){this.container.telemetry.sendEvent("home/startWork"),(0,O.RS)(o.d.StartWork,{command:"startWork",source:"home"})}async abortPausedOperation(e){let t=this.container.git.status(e.repoPath).abortPausedOperation;if(null!=t)try{await t()}catch(e){s.window.showErrorMessage(e.message)}}async continuePausedOperation(e){if("revert"===e.type)return;let t=this.container.git.status(e.repoPath).continuePausedOperation;if(null!=t)try{await t()}catch(e){s.window.showErrorMessage(e.message)}}async skipPausedOperation(e){let t=this.container.git.status(e.repoPath).continuePausedOperation;if(null!=t)try{await t({skip:!0})}catch(e){s.window.showErrorMessage(e.message)}}async openRebaseEditor(e){if("rebase"!==e.type)return;let t=await this.container.git.getGitDir(e.repoPath);if(null==t)return;let i=s.Uri.joinPath(t.uri,"rebase-merge","git-rebase-todo");(0,O.S4)("vscode.openWith",i,"gitlens.rebase",{preview:!1})}async createCloudPatch(e){let t=await this.container.git.status(e.repoPath).getStatus();if(null==t)return;let i=[];for(let e of t.files){let t={repoPath:e.repoPath,path:e.path,status:e.status,originalPath:e.originalPath,staged:e.staged};i.push(t),e.staged&&e.wip&&i.push({...t,staged:!1})}let{repo:s}=this._repositoryBranches.get(e.repoPath),n={type:"wip",repository:{name:s.name,path:s.path,uri:s.uri.toString()},files:i,revision:{to:p.SU,from:"HEAD"}};(0,C.X)({mode:"create",create:{changes:[n]}})}onTogglePreviewEnabled(e){void 0===e&&(e=!this.getPreviewEnabled()),this.getPreviewCollapsed()||this.onCollapseSection({section:"newHomePreview",collapsed:!0}),this.container.telemetry.sendEvent("home/preview/toggled",{enabled:e,version:"v16"}),S.H.updateEffective("home.preview.enabled",e)}onCollapseSection(e){let t=this.container.storage.get("home:sections:collapsed");if(null==t){!0===e.collapsed&&this.container.storage.store("home:sections:collapsed",[e.section]).catch();return}let i=t.indexOf(e.section);if(!0===e.collapsed){-1===i&&this.container.storage.store("home:sections:collapsed",[...t,e.section]).catch();return}-1!==i&&(t.splice(i,1),this.container.storage.store("home:sections:collapsed",t).catch())}dismissWalkthrough(){this.container.storage.get("home:walkthrough:dismissed")||(this.container.storage.store("home:walkthrough:dismissed",!0).catch(),this.container.usage.track("home:walkthrough:dismissed").catch())}getWalkthroughDismissed(){return!!this.container.storage.get("home:walkthrough:dismissed")}getPreviewCollapsed(){return this.container.storage.get("home:sections:collapsed")?.includes("newHomePreview")??!1}getIntegrationBannerCollapsed(){return this.container.storage.get("home:sections:collapsed")?.includes("integrationBanner")??!1}getOrgSettings(){return{drafts:(0,B.SD)("gitlens:gk:organization:drafts:enabled",!1)}}onContextChanged(e){"gitlens:gk:organization:drafts:enabled"===e&&this.notifyDidChangeOrgSettings()}async onSubscriptionChanged(e){await this.notifyDidChangeSubscription(e.current),(0,R.k0)(e.current.state)!==(0,R.k0)(e.previous.state)&&this.onOverviewRepoChanged("repo")}async getState(e){let[t,i]=await Promise.allSettled([this.getSubscriptionState(e),this.getIntegrationStates(!0)]);if("rejected"===t.status)throw t.reason;let s=(0,E.Ro)(i)??[],n=s.some(e=>e.connected);return{...this.host.baseWebviewState,discovering:null!=this._discovering,repositories:this.getRepositoriesState(),webroot:this.host.getWebRoot(),subscription:t.value.subscription,avatar:t.value.avatar,organizationsCount:t.value.organizationsCount,orgSettings:this.getOrgSettings(),previewCollapsed:this.getPreviewCollapsed(),integrationBannerCollapsed:this.getIntegrationBannerCollapsed(),integrations:s,hasAnyIntegrationConnected:n,walkthroughProgress:{allCount:this.container.walkthrough.walkthroughSize,doneCount:this.container.walkthrough.doneCount,progress:this.container.walkthrough.progress},showWalkthroughProgress:!this.getWalkthroughDismissed(),previewEnabled:this.getPreviewEnabled(),newInstall:(0,B.SD)("gitlens:install:new",!1)}}getPreviewEnabled(){return S.H.get("home.preview.enabled")}getRepositoriesState(){return{count:this.container.git.repositoryCount,openCount:this.container.git.openRepositoryCount,hasUnsafe:this.container.git.hasUnsafeRepositories(),trusted:s.workspace.isTrusted}}async getBranchOverview(){null!=this._discovering&&await this._discovering;let e=this.getSelectedRepository();if(null==e)return;let t="repo"===this._invalidateOverview,i=void 0!==this._invalidateOverview,s=function(e,t,i,s){let n,r;let{branches:o,worktreesByBranch:a}=e;if(0===o.length)return;let h={active:[],recent:[],stale:[]},l=new Map,u=new Map,c=new Map,d=new Map,p=new Map,v=new Map,b=Date.now(),f=b-eo[i.recent.threshold];for(let e of o){let i=a.get(e.id),o=i?{name:i.name,uri:i.uri.toString()}:void 0,w=e.date?.getTime();if(e.current||i?.opened){let a=s?.forceActive?{force:!0}:void 0;s?.isPro!==!1&&(l.set(e.id,ec(t,e,n)),u.set(e.id,e.getEnrichedAutolinks()),c.set(e.id,(0,g.GI)(t,e).then(e=>e.value)),p.set(e.id,t.git.branches(e.repoPath).getBranchContributionsOverview(e.ref)),e.current&&v.set(e.id,el(t,e))),null!=i?d.set(e.id,i.getStatus(a)):(void 0===r&&(r=t.git.status(e.repoPath).getStatus()),d.set(e.id,r)),h.active.push({reference:(0,m.iw)(e),repoPath:e.repoPath,id:e.id,name:e.name,opened:!0,timestamp:w,state:e.state,status:e.status,upstream:e.upstream,worktree:o});continue}if(null!=w&&w>f){s?.isPro!==!1&&(l.set(e.id,ec(t,e,n)),u.set(e.id,e.getEnrichedAutolinks()),c.set(e.id,(0,g.GI)(t,e).then(e=>e.value)),p.set(e.id,t.git.branches(e.repoPath).getBranchContributionsOverview(e.ref))),null!=i&&d.set(e.id,i.getStatus()),h.recent.push({reference:(0,m.iw)(e),repoPath:e.repoPath,id:e.id,name:e.name,opened:!1,timestamp:w,state:e.state,status:e.status,upstream:e.upstream,worktree:o});continue}}if(i?.stale?.show===!0){let e=b-eo[i.stale.threshold];for(let i of((0,w.Xn)(o,{missingUpstream:!0,orderBy:"date:asc"}),o)){if(h.stale.length>9)break;if(h.active.some(e=>e.id===i.id)||h.recent.some(e=>e.id===i.id))continue;s?.isPro!==!1&&(u.set(i.id,i.getEnrichedAutolinks()),c.set(i.id,(0,g.GI)(t,i).then(e=>e.value)));let r=i.date?.getTime();if(i.upstream?.missing||null!=r&&r<e){let e=a.get(i.id),o=e?{name:e.name,uri:e.uri.toString()}:void 0;s?.isPro!==!1&&(i.upstream?.missing||l.set(i.id,ec(t,i,n)),p.set(i.id,t.git.branches(i.repoPath).getBranchContributionsOverview(i.ref))),null!=e&&d.set(i.id,e.getStatus()),h.stale.push({reference:(0,m.iw)(i),repoPath:i.repoPath,id:i.id,name:i.name,opened:!1,timestamp:r,state:i.state,status:i.status,upstream:i.upstream,worktree:o});continue}}}return function(e,t,i,s,n,r,o,a){for(let h of[...e.active,...e.recent,...e.stale]){let l=e.active.includes(h);h.pr=t.get(h.id);let u=i.get(h.id);h.autolinks=u?.then(e=>ea(e));let c=s.get(h.id);h.issues=c?.then(e=>e?.map(e=>({id:e.id,title:e.title,state:e.state,url:e.url}))??[]),h.wip=ed(a,h,n.get(h.id),l);let d=r.get(h.id);h.contributors=eh(a,d),h.mergeTarget=o.get(h.id)}}(h,l,u,c,d,p,v,t),h}(await this.getBranchesData(e,t),this.container,this._overviewBranchFilter,{forceActive:!!i||void 0,isPro:await this.isSubscriptionPro()});if(this._invalidateOverview=void 0,null!=s)return{repository:{...await this.formatRepository(e),branches:s}}}async formatRepository(e){let t=await e.git.remotes().getBestRemotesWithProviders(),i=t.find(e=>e.hasIntegration())??t[0];return{name:e.commonRepositoryName??e.name,path:e.path,provider:i?.provider?{name:i.provider.name,icon:"remote"===i.provider.icon?"cloud":i.provider.icon,url:i.provider.url({type:c.J.Repo})}:void 0}}_repositorySubscription;selectRepository(e){let t;return null!=e?t=this.container.git.getRepository(e):null==(t=this.container.git.highlander)&&(t=this.container.git.getBestRepositoryOrFirst()),null!=this._repositorySubscription&&(this._repositorySubscription.subscription?.dispose(),this._repositorySubscription=void 0),null!=t&&(this._repositorySubscription={repo:t,subscription:this.subscribeToRepository(t)}),t}stopRepositorySubscription(){null!=this._repositorySubscription&&(this._repositorySubscription.subscription?.dispose(),this._repositorySubscription.subscription=void 0)}resumeRepositorySubscription(e=!1){null!=this._repositorySubscription&&(e||null==this._repositorySubscription.subscription)&&(this._repositorySubscription.subscription?.dispose(),this._repositorySubscription.subscription=void 0,this._repositorySubscription.subscription=this.subscribeToRepository(this._repositorySubscription.repo))}resetBranchOverview(){if(this._repositoryBranches.clear(),!this.host.visible){this.stopRepositorySubscription();return}this.resumeRepositorySubscription(!0)}subscribeToRepository(e){return s.Disposable.from(e.watchFileSystem(1e3),e.onDidChangeFileSystem(()=>this.onOverviewRepoChanged("wip")),e.onDidChange(e=>{e.changed(d.Z_.Config,d.Z_.Head,d.Z_.Heads,d.Z_.Remotes,d.Z_.PausedOperationStatus,d.Z_.Unknown,d.Ti.Any)&&this.onOverviewRepoChanged("repo")}))}onOverviewRepoChanged(e){this._etag!==this.container.git.etag&&("repo"!==this._invalidateOverview&&(this._invalidateOverview=e),this.host.visible&&("wip"===e?this.host.notify(Q,void 0):this.notifyDidChangeRepositories()))}getSelectedRepository(){return null==this._repositorySubscription&&this.selectRepository(),this._repositorySubscription?.repo}_invalidateOverview;_repositoryBranches=new Map;async getBranchesData(e,t=!1){if(t||!this._repositoryBranches.has(e.path)){let t=await e.git.worktrees()?.getWorktrees()??[],i=(0,b.PU)(t,{includeDefault:!0}),[s]=await Promise.allSettled([e.git.branches().getBranches({filter:e=>!e.remote,sort:{current:!0,openedWorktreesByBranch:(0,b.vJ)(i)}})]),n=E.Ro(s)?.values??[];this._repositoryBranches.set(e.path,{repo:e,branches:n,worktreesByBranch:i})}return this._repositoryBranches.get(e.path)}_integrationStates;_defaultSupportedCloudIntegrations;async getIntegrationStates(e=!1){if(e||null==this._integrationStates){let e=(0,W.x1)(this.container.integrations.getLoaded(),async e=>(0,a.LT)(e.id)?{id:e.id,name:e.name,icon:`gl-provider-${e.icon}`,connected:e.maybeConnected??await e.isConnected(),supports:"hosting"===e.type?["prs","issues"]:"issues"===e.type?["issues"]:[]}:void 0),t=await Promise.allSettled(e),i=[...(0,W.x1)(t,e=>(0,E.Ro)(e))];this._defaultSupportedCloudIntegrations??=a.U4.map(e=>({...e,connected:!1})),this._defaultSupportedCloudIntegrations.forEach(e=>{let t=i.find(t=>t.id===e.id);null==t?i.push(e):t.icon!==e.icon&&(t.icon=e.icon)}),i.sort((e,t)=>a.rK.indexOf(e.id)-a.rK.indexOf(t.id)),this._integrationStates=i}return this._integrationStates}_subscription;async getSubscription(e){return null!=e?this._subscription=e:null!=this._subscription?e=this._subscription:this._subscription=e=await this.container.subscription.getSubscription(!0),this._subscription}async isSubscriptionPro(){let e=await this.getSubscription();return null!=e&&(0,R.k0)(e.state)}async getSubscriptionState(e){let t;return e=await this.getSubscription(e),t=e.account?.email?(0,n.ML)(e.account.email,34).toString():`${this.host.getWebRoot()??""}/media/gitlens-logo.webp`,{subscription:e,avatar:t,organizationsCount:null!=e?(await this.container.organizations.getOrganizations()??[]).length:0}}notifyDidCompleteDiscoveringRepositories(){this.host.notify(N,{discovering:null!=this._discovering,repositories:this.getRepositoriesState()})}notifyDidChangeRepositoriesCore(){this.host.notify(V,this.getRepositoriesState())}_notifyDidChangeRepositoriesDebounced=void 0;notifyDidChangeRepositories(e=!1){if(null==this._discovering){if(e){this.notifyDidChangeRepositoriesCore();return}null==this._notifyDidChangeRepositoriesDebounced&&(this._notifyDidChangeRepositoriesDebounced=(0,q.sg)(this.notifyDidChangeRepositoriesCore.bind(this),500)),this._notifyDidChangeRepositoriesDebounced()}}notifyDidChangeProgress(){this.host.notify(X,{allCount:this.container.walkthrough.walkthroughSize,doneCount:this.container.walkthrough.doneCount,progress:this.container.walkthrough.progress})}notifyDidChangeConfig(){this.host.notify(j,{previewEnabled:this.getPreviewEnabled(),previewCollapsed:this.getPreviewCollapsed()})}notifyDidChangeLaunchpad(){this.host.notify(J,void 0)}async notifyDidChangeIntegrations(){let e=await this.getIntegrationStates(!0),t=e.some(e=>e.connected);t&&this.onCollapseSection({section:"integrationBanner",collapsed:!0}),this.host.notify(Y,{hasAnyIntegrationConnected:t,integrations:e})}async notifyDidChangeSubscription(e){let t=await this.getSubscriptionState(e);this.host.notify(K,{subscription:t.subscription,avatar:t.avatar,organizationsCount:t.organizationsCount})}notifyDidChangeOrgSettings(){this.host.notify(ee,{orgSettings:this.getOrgSettings()})}mergeTargetCompare(e){return this.container.views.searchAndCompare.compare(e.repoPath,e.branchId,e.mergeTargetId)}async pullRequestCompare(e){let t=await this.findPullRequest(e);if(t?.refs?.base==null||null==t.refs.head)return;let i=(0,f.tI)(e.repoPath,t.refs);return this.container.views.searchAndCompare.compare(i.repoPath,i.head,i.base)}async pullRequestChanges(e){let t=await this.findPullRequest(e);if(t?.refs?.base==null||null==t.refs.head)return;let i=(0,f.tI)(e.repoPath,t.refs);return(0,l.$5)(this.container,{repoPath:i.repoPath,lhs:i.base.ref,rhs:i.head.ref},{title:`Changes in Pull Request #${t.id}`})}async pullRequestViewOnRemote(e,t){let i=await this.findPullRequest(e);null!=i&&(0,O.RS)(o.d.OpenPullRequestOnRemote,{pr:{url:i.url},clipboard:t})}async pullRequestDetails(e){let t=await this.findPullRequest(e);null!=t&&this.container.views.pullRequest.showPullRequest(t,e.repoPath)}async pullRequestCreate(e){let t=this._repositoryBranches.get(e.repoPath),i=t?.branches.find(t=>t.id===e.branchId);if(null==i)return;let s=await i.getRemote();null!=s&&(0,O.ph)("createPullRequest",{repoPath:e.repoPath,remote:null!=s?{name:s.name,provider:null!=s.provider?{id:s.provider.id,name:s.provider.name,domain:s.provider.domain}:void 0,url:s.url}:void 0,branch:{name:i.name,upstream:i.upstream?.name,isRemote:i.remote}})}worktreeOpen(e){let t=this.findWorktree(e);null!=t&&(0,I.OH)(t.uri)}switchToBranch(e){let t=this._repositoryBranches.get(e.repoPath),i=t?.branches.find(t=>t.id===e.branchId);null!=i&&u.S_(t.repo,(0,m.iw)(i))}async fetch(e){if(null==e){let e=this.getSelectedRepository();u.hd(e);return}let t=this._repositoryBranches.get(e.repoPath);if(null==t)return;let i=t.branches.find(t=>t.id===e.branchId);null==i&&(i=await t.repo.git.branches().getBranch(e.branchId)),null!=i&&u.hd(t.repo,(0,m.iw)(i))}findBranch(e){let t=this._repositoryBranches.get(e.repoPath)?.branches;return t?.find(t=>t.id===e.branchId)}findWorktree(e){let t=this._repositoryBranches.get(e.repoPath);if(null==t)return;let i=t.branches.find(t=>t.id===e.branchId);if(null!=i)return t.worktreesByBranch.get(i.id)}async findPullRequest(e){let t=this.findBranch(e);if(null!=t)return t.getAssociatedPullRequest()}};((e,t,i,s)=>{for(var n,r=en(t,i),o=e.length-1;o>=0;o--)(n=e[o])&&(r=n(t,i,r)||r);return s&&r&&es(t,i,r)})([(0,L.Yz)()],HomeWebviewProvider.prototype,"onOverviewRepoChanged",1);let eo={OneDay:864e5,OneWeek:6048e5,OneMonth:2592e6,OneYear:31536e6};async function ea(e){return null==e?[]:(await Promise.allSettled((0,W.x1)([...e.values()],async e=>{let t=e?.[0];if(null==t)return;let i=await t;if(null!=i)return{id:i.id,title:i.title,url:i.url,state:i.state}}))).map(e=>"fulfilled"===e.status?e.value:void 0).filter(e=>null!=e)}async function eh(e,t){if(null==t)return[];let i=await t;return i?.contributors==null?[]:(await Promise.allSettled(i.contributors.map(async e=>({name:e.name??"",email:e.email??"",current:e.current,timestamp:e.latestCommitDate?.getTime(),count:e.commits,stats:e.stats,avatarUrl:(await e.getAvatarUri())?.toString()})))).map(e=>"fulfilled"===e.status?e.value:void 0).filter(e=>null!=e)}async function el(e,t){let i;let s=await (0,v.y1)(e,t,{associatedPullRequest:t.getAssociatedPullRequest()});!s.targetBranch.paused&&s.targetBranch.value&&(i=s.targetBranch.value);let n=i??s.baseBranch??s.defaultBranch;if(null==n)return;let r=e.git.branches(t.repoPath),o=await r.getBranch(n);if(null==o)return;let[a,h,l]=await Promise.allSettled([e.git.getLeftRightCommitCount(t.repoPath,(0,y.Xn)(o.name,t.ref,"..."),{excludeMerges:!0}),r.getPotentialMergeOrRebaseConflict?.(t.name,o.name),r.getBranchMergedStatus?.(t,o)]),u=(0,E.Ro)(a),c=null!=u?{ahead:u.right,behind:u.left}:void 0,d=(0,E.Ro)(l);return{repoPath:t.repoPath,id:o.id,name:o.name,status:c,mergedStatus:d,potentialConflicts:(0,E.Ro)(h),targetBranch:o.name,baseBranch:s.baseBranch,defaultBranch:s.defaultBranch}}async function eu(e,t,i){i??=e.launchpad.getCategorizedItems();let s=await i;if(null!=s.error)return;let n=s.items.find(e=>e.url===t.url);if(null==n){if(null!=(s=await e.launchpad.getCategorizedItems({search:[{pullRequest:t,reasons:[]}]})).error)return;n=s.items.find(e=>e.url===t.url)}if(null!=n)return{uuid:n.uuid,category:n.actionableCategory,groups:(0,P._v)(n),suggestedActions:n.suggestedActions,failingCI:n.failingCI,hasConflicts:n.hasConflicts,review:{decision:n.reviewDecision,reviews:n.reviews??[],counts:{approval:n.approvalReviewCount,changeRequest:n.changeRequestReviewCount,comment:n.commentReviewCount,codeSuggest:n.codeSuggestionsCount}},author:n.author,createdDate:n.createdDate,viewer:{...n.viewer,enrichedItems:void 0}}}async function ec(e,t,i){let s=await t.getAssociatedPullRequest({avatarSize:64});if(null!=s)return{id:s.id,url:s.url,state:s.state,title:s.title,draft:s.isDraft,launchpad:eu(e,s,i)}}async function ed(e,t,i,s){if(null==i)return;let[n,r]=await Promise.allSettled([i,s?e.git.status(t.repoPath).getPausedOperationStatus?.():void 0]),o=(0,E.Ro)(n),a=(0,E.Ro)(r);return{workingTreeState:o?.getDiffStatus(),hasConflicts:o?.hasConflicts,conflictsCount:o?.conflicts.length,pausedOpStatus:a}}}};
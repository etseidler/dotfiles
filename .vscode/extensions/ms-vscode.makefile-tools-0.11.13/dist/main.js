/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 908:
/***/ (function(__unused_webpack_module, exports) {

/*!
 * 1DS JS SDK Core, 4.2.2
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
(function (global, factory) {
     true ? factory(exports) :
    0;
})(this, (function (exports) { 'use strict';

    var strShimFunction = "function";
    var strShimObject = "object";
    var strShimUndefined = "undefined";
    var strShimPrototype = "prototype";
    var ObjClass$1 = Object;
    var ObjProto$1 = ObjClass$1[strShimPrototype];

    /*! https://github.com/nevware21/ts-utils v0.11.2 */
    /*#__NO_SIDE_EFFECTS__*/
    function _pureAssign(func1, func2) {
        return func1 || func2;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _pureRef(value, name) {
        return value[name];
    }
    var UNDEF_VALUE = undefined;
    var NULL_VALUE = null;
    var EMPTY = "";
    var FUNCTION = "function";
    var OBJECT = "object";
    var PROTOTYPE = "prototype";
    var __PROTO__ = "__proto__";
    var UNDEFINED = "undefined";
    var CONSTRUCTOR = "constructor";
    var SYMBOL = "Symbol";
    var POLYFILL_TAG = "_polyfill";
    var LENGTH = "length";
    var NAME = "name";
    var CALL = "call";
    var TO_STRING = "toString";
    var ObjClass = ( /*#__PURE__*/_pureAssign(Object));
    var ObjProto = ( /*#__PURE__*/_pureRef(ObjClass, PROTOTYPE));
    var StrCls = ( /*#__PURE__*/_pureAssign(String));
    var StrProto = ( /*#__PURE__*/_pureRef(StrCls, PROTOTYPE));
    var MathCls = ( /*#__PURE__*/_pureAssign(Math));
    var ArrCls = ( /*#__PURE__*/_pureAssign(Array));
    var ArrProto = ( /*#__PURE__*/_pureRef(ArrCls, PROTOTYPE));
    var ArrSlice = ( /*#__PURE__*/_pureRef(ArrProto, "slice"));
    function safe(func, argArray) {
        try {
            return {
                v: func.apply(this, argArray)
            };
        }
        catch (e) {
            return { e: e };
        }
    }
    /*#__NO_SIDE_EFFECTS__*/
    function safeGet(cb, defValue) {
        var result = safe(cb);
        return result.e ? defValue : result.v;
    }
    var _primitiveTypes;
    /*#__NO_SIDE_EFFECTS__*/
    function _createIs(theType) {
        return function (value) {
            return typeof value === theType;
        };
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _createObjIs(theName) {
        var theType = "[object " + theName + "]";
        return function (value) {
            return !!(value && objToString(value) === theType);
        };
    }
    /*#__NO_SIDE_EFFECTS__*/
    function objToString(value) {
        return ObjProto[TO_STRING].call(value);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isTypeof(value, theType) {
        return typeof value === theType;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isUndefined(value) {
        return typeof value === UNDEFINED || value === UNDEFINED;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isNullOrUndefined(value) {
        return value === NULL_VALUE || isUndefined(value);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isStrictNullOrUndefined(value) {
        return value === NULL_VALUE || !isDefined(value);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isDefined(arg) {
        return !!arg || arg !== UNDEF_VALUE;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isPrimitiveType(theType) {
        !_primitiveTypes && (_primitiveTypes = ["string", "number", "boolean", UNDEFINED, "symbol", "bigint"]);
        return theType !== OBJECT && _primitiveTypes.indexOf(theType) !== -1;
    }
    var isString = ( /*#__PURE__*/_createIs("string"));
    var isFunction = ( /*#__PURE__*/_createIs(FUNCTION));
    /*#__NO_SIDE_EFFECTS__*/
    function isObject(value) {
        if (!value && isNullOrUndefined(value)) {
            return false;
        }
        return !!value && typeof value === OBJECT;
    }
    var isArray = ( /* #__PURE__*/_pureRef(ArrCls, "isArray"));
    var isDate = ( /*#__PURE__*/_createObjIs("Date"));
    var isNumber = ( /*#__PURE__*/_createIs("number"));
    var isBoolean = ( /*#__PURE__*/_createIs("boolean"));
    var isError = ( /*#__PURE__*/_createObjIs("Error"));
    /*#__NO_SIDE_EFFECTS__*/
    function isPromiseLike(value) {
        return !!(value && value.then && isFunction(value.then));
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isNotTruthy(value) {
        return !value || !isTruthy(value);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isTruthy(value) {
        return !(!value || safeGet(function () { return !(value && (0 + value)); }, !value));
    }
    var objGetOwnPropertyDescriptor = ( /* #__PURE__ */_pureRef(ObjClass, "getOwnPropertyDescriptor"));
    /*#__NO_SIDE_EFFECTS__*/
    function objHasOwnProperty(obj, prop) {
        return !!obj && ObjProto.hasOwnProperty[CALL](obj, prop);
    }
    var objHasOwn = ( /*#__PURE__*/_pureAssign(( /* #__PURE__ */_pureRef(ObjClass, "hasOwn")), polyObjHasOwn));
    /*#__NO_SIDE_EFFECTS__*/
    function polyObjHasOwn(obj, prop) {
        return objHasOwnProperty(obj, prop) || !!objGetOwnPropertyDescriptor(obj, prop);
    }
    function objForEachKey(theObject, callbackfn, thisArg) {
        if (theObject && isObject(theObject)) {
            for (var prop in theObject) {
                if (objHasOwn(theObject, prop)) {
                    if (callbackfn[CALL](thisArg || theObject, prop, theObject[prop]) === -1) {
                        break;
                    }
                }
            }
        }
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _createKeyValueMap(values, keyType, valueType, completeFn) {
        var theMap = {};
        objForEachKey(values, function (key, value) {
            theMap[key] = keyType ? value : key;
            theMap[value] = valueType ? value : key;
        });
        return completeFn(theMap);
    }
    var asString = ( /* #__PURE__ */_pureAssign(StrCls));
    var ERROR_TYPE = "[object Error]";
    /*#__NO_SIDE_EFFECTS__*/
    function dumpObj(object, format) {
        var propertyValueDump = EMPTY;
        var objType = ObjProto[TO_STRING][CALL](object);
        if (objType === ERROR_TYPE) {
            object = { stack: asString(object.stack), message: asString(object.message), name: asString(object.name) };
        }
        try {
            propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? ((typeof format === "number") ? format : 4) : UNDEF_VALUE);
            propertyValueDump = (propertyValueDump && propertyValueDump.replace(/"(\w+)"\s*:\s{0,1}/g, "$1: ")) || asString(object);
        }
        catch (e) {
            propertyValueDump = " - " + dumpObj(e, format);
        }
        return objType + ": " + propertyValueDump;
    }
    function throwError(message) {
        throw new Error(message);
    }
    function throwTypeError(message) {
        throw new TypeError(message);
    }
    var _objFreeze = ( /* #__PURE__ */_pureRef(ObjClass, "freeze"));
    function _doNothing(value) {
        return value;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _getProto(value) {
        return value[__PROTO__] || NULL_VALUE;
    }
    var objAssign = ( /*#__PURE__*/_pureRef(ObjClass, "assign"));
    var objKeys = ( /*#__PURE__*/_pureRef(ObjClass, "keys"));
    function objDeepFreeze(value) {
        if (_objFreeze) {
            objForEachKey(value, function (key, value) {
                if (isArray(value) || isObject(value)) {
                    _objFreeze(value);
                }
            });
        }
        return objFreeze(value);
    }
    var objFreeze = ( /* #__PURE__*/_pureAssign(_objFreeze, _doNothing));
    var objSeal = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ObjClass, "seal")), _doNothing));
    var objGetPrototypeOf = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ObjClass, "getPrototypeOf")), _getProto));
    /*#__NO_SIDE_EFFECTS__*/
    function createEnum(values) {
        return _createKeyValueMap(values, 1 , 0 , objDeepFreeze);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function createEnumKeyMap(values) {
        return _createKeyValueMap(values, 0 , 0 , objDeepFreeze);
    }
    var _wellKnownSymbolMap = /*#__PURE__*/ createEnumKeyMap({
        asyncIterator: 0 ,
        hasInstance: 1 ,
        isConcatSpreadable: 2 ,
        iterator: 3 ,
        match: 4 ,
        matchAll: 5 ,
        replace: 6 ,
        search: 7 ,
        species: 8 ,
        split: 9 ,
        toPrimitive: 10 ,
        toStringTag: 11 ,
        unscopables: 12
    });
    var GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg";
    var _globalCfg;
    /*#__NO_SIDE_EFFECTS__*/
    function _getGlobalValue() {
        var result;
        if (typeof globalThis !== UNDEFINED) {
            result = globalThis;
        }
        if (!result && typeof self !== UNDEFINED) {
            result = self;
        }
        if (!result && typeof window !== UNDEFINED) {
            result = window;
        }
        if (!result && typeof global !== UNDEFINED) {
            result = global;
        }
        return result;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _getGlobalConfig() {
        if (!_globalCfg) {
            var gbl = safe(_getGlobalValue).v || {};
            _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};
        }
        return _globalCfg;
    }
    var _unwrapFunction = ( _unwrapFunctionWithPoly);
    /*#__NO_SIDE_EFFECTS__*/
    function _unwrapFunctionWithPoly(funcName, clsProto, polyFunc) {
        var clsFn = clsProto && clsProto[funcName];
        return function (thisArg) {
            var theFunc = (thisArg && thisArg[funcName]) || clsFn;
            if (theFunc || polyFunc) {
                var theArgs = arguments;
                return (theFunc || polyFunc).apply(thisArg, theFunc ? ArrSlice[CALL](theArgs, 1) : theArgs);
            }
            throwTypeError("\"" + asString(funcName) + "\" not defined for " + dumpObj(thisArg));
        };
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _unwrapProp(propName) {
        return function (thisArg) {
            return thisArg[propName];
        };
    }
    var mathMax = ( /*#__PURE__*/_pureRef(MathCls, "max"));
    var strSlice = ( /*#__PURE__*/_unwrapFunction("slice", StrProto));
    var strSubstring = ( /*#__PURE__*/_unwrapFunction("substring", StrProto));
    var strSubstr = ( /*#__PURE__*/_unwrapFunctionWithPoly("substr", StrProto, polyStrSubstr));
    /*#__NO_SIDE_EFFECTS__*/
    function polyStrSubstr(value, start, length) {
        if (isNullOrUndefined(value)) {
            throwTypeError("Invalid " + dumpObj(value));
        }
        if (length < 0) {
            return EMPTY;
        }
        start = start || 0;
        if (start < 0) {
            start = mathMax(start + value[LENGTH], 0);
        }
        if (isUndefined(length)) {
            return strSlice(value, start);
        }
        return strSlice(value, start, start + length);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function strLeft(value, count) {
        return strSubstring(value, 0, count);
    }
    var UNIQUE_REGISTRY_ID = "_urid";
    var _polySymbols;
    /*#__NO_SIDE_EFFECTS__*/
    function _globalSymbolRegistry() {
        if (!_polySymbols) {
            var gblCfg = _getGlobalConfig();
            _polySymbols = gblCfg.gblSym = gblCfg.gblSym || { k: {}, s: {} };
        }
        return _polySymbols;
    }
    var _wellKnownSymbolCache;
    /*#__NO_SIDE_EFFECTS__*/
    function polyNewSymbol(description) {
        var theSymbol = {
            description: asString(description),
            toString: function () { return SYMBOL + "(" + description + ")"; }
        };
        theSymbol[POLYFILL_TAG] = true;
        return theSymbol;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function polySymbolFor(key) {
        var registry = _globalSymbolRegistry();
        if (!objHasOwn(registry.k, key)) {
            var newSymbol_1 = polyNewSymbol(key);
            var regId_1 = objKeys(registry.s).length;
            newSymbol_1[UNIQUE_REGISTRY_ID] = function () { return regId_1 + "_" + newSymbol_1[TO_STRING](); };
            registry.k[key] = newSymbol_1;
            registry.s[newSymbol_1[UNIQUE_REGISTRY_ID]()] = asString(key);
        }
        return registry.k[key];
    }
    /*#__NO_SIDE_EFFECTS__*/
    function polyGetKnownSymbol(name) {
        !_wellKnownSymbolCache && (_wellKnownSymbolCache = {});
        var result;
        var knownName = _wellKnownSymbolMap[name];
        if (knownName) {
            result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || polyNewSymbol(SYMBOL + "." + knownName);
        }
        return result;
    }
    var propMap = {
        e: "enumerable",
        c: "configurable",
        v: "value",
        w: "writable",
        g: "get",
        s: "set"
    };
    /*#__NO_SIDE_EFFECTS__*/
    function _createProp(value) {
        var prop = {};
        prop[propMap["c"]] = true;
        prop[propMap["e"]] = true;
        if (value.l) {
            prop.get = function () { return value.l.v; };
            var desc = objGetOwnPropertyDescriptor(value.l, "v");
            if (desc && desc.set) {
                prop.set = function (newValue) {
                    value.l.v = newValue;
                };
            }
        }
        objForEachKey(value, function (key, value) {
            prop[propMap[key]] = isUndefined(value) ? prop[propMap[key]] : value;
        });
        return prop;
    }
    var objDefineProp = ( /*#__PURE__*/_pureRef(ObjClass, "defineProperty"));
    function objDefineAccessors(target, prop, getProp, setProp, configurable, enumerable) {
        var desc = {
            e: enumerable,
            c: configurable
        };
        if (getProp) {
            desc.g = getProp;
        }
        if (setProp) {
            desc.s = setProp;
        }
        return objDefineProp(target, prop, _createProp(desc));
    }
    function objDefine(target, key, propDesc) {
        return objDefineProp(target, key, _createProp(propDesc));
    }
    var _globalLazyTestHooks;
    function _initTestHooks() {
        _globalLazyTestHooks = _getGlobalConfig();
    }
    /*#__NO_SIDE_EFFECTS__*/
    function getLazy(cb) {
        var lazyValue = {};
        !_globalLazyTestHooks && _initTestHooks();
        lazyValue.b = _globalLazyTestHooks.lzy;
        objDefineProp(lazyValue, "v", {
            configurable: true,
            get: function () {
                var result = cb();
                if (!_globalLazyTestHooks.lzy) {
                    objDefineProp(lazyValue, "v", {
                        value: result
                    });
                }
                lazyValue.b = _globalLazyTestHooks.lzy;
                return result;
            }
        });
        return lazyValue;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function createCachedValue(value) {
        return objDefineProp({
            toJSON: function () { return value; }
        }, "v", { value: value });
    }
    var WINDOW = "window";
    var _cachedGlobal;
    function _getGlobalInstFn(getFn, theArgs) {
        var cachedValue;
        return function () {
            !_globalLazyTestHooks && _initTestHooks();
            (!cachedValue || _globalLazyTestHooks.lzy) && (cachedValue = createCachedValue(safe(getFn, theArgs).v));
            return cachedValue.v;
        };
    }
    /*#__NO_SIDE_EFFECTS__*/
    function getGlobal(useCached) {
        !_globalLazyTestHooks && _initTestHooks();
        (!_cachedGlobal || useCached === false || _globalLazyTestHooks.lzy) && (_cachedGlobal = createCachedValue(safe(_getGlobalValue).v || NULL_VALUE));
        return _cachedGlobal.v;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function getInst(name, useCached) {
        var gbl = (!_cachedGlobal || useCached === false) ? getGlobal(useCached) : _cachedGlobal.v;
        if (gbl && gbl[name]) {
            return gbl[name];
        }
        if (name === WINDOW) {
            return getWindow();
        }
        return NULL_VALUE;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function hasDocument() {
        return !!( /*#__PURE__*/getDocument());
    }
    var getDocument = ( /*#__PURE__*/_getGlobalInstFn(getInst, ["document"]));
    /*#__NO_SIDE_EFFECTS__*/
    function hasWindow() {
        return !!( /*#__PURE__*/getWindow());
    }
    var getWindow = ( /*#__PURE__*/_getGlobalInstFn(getInst, [WINDOW]));
    /*#__NO_SIDE_EFFECTS__*/
    function hasNavigator() {
        return !!( /*#__PURE__*/getNavigator());
    }
    var getNavigator = ( /*#__PURE__*/_getGlobalInstFn(getInst, ["navigator"]));
    /*#__NO_SIDE_EFFECTS__*/
    function hasHistory() {
        return !!( /*#__PURE__*/getHistory());
    }
    var getHistory = ( /*#__PURE__*/_getGlobalInstFn(getInst, ["history"]));
    var isNode = ( /*#__PURE__*/_getGlobalInstFn(function () {
        return !!( safe(function () { return (process && (process.versions || {}).node); }).v);
    }));
    var _symbol;
    var _symbolFor;
    /*#__NO_SIDE_EFFECTS__*/
    function _initSymbol() {
        _symbol = ( /*#__PURE__*/createCachedValue(safe((getInst), [SYMBOL]).v));
        return _symbol;
    }
    function _getSymbolKey(key) {
        var gblSym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());
        return (gblSym.v ? gblSym.v[key] : UNDEF_VALUE);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function hasSymbol() {
        return !!( /*#__PURE__*/getSymbol());
    }
    /*#__NO_SIDE_EFFECTS__*/
    function getSymbol() {
        !_globalLazyTestHooks && _initTestHooks();
        return ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol()).v;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function getKnownSymbol(name, noPoly) {
        var knownName = _wellKnownSymbolMap[name];
        !_globalLazyTestHooks && _initTestHooks();
        var sym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());
        return sym.v ? sym.v[knownName || name] : (!noPoly ? polyGetKnownSymbol(name) : UNDEF_VALUE);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function newSymbol(description, noPoly) {
        !_globalLazyTestHooks && _initTestHooks();
        var sym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());
        return sym.v ? sym.v(description) : (!noPoly ? polyNewSymbol(description) : NULL_VALUE);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function symbolFor(key) {
        !_globalLazyTestHooks && _initTestHooks();
        _symbolFor = ((!_globalLazyTestHooks.lzy ? _symbolFor : 0) || ( /*#__PURE__*/createCachedValue(safe((_getSymbolKey), ["for"]).v)));
        return (_symbolFor.v || polySymbolFor)(key);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isIterator(value) {
        return !!value && isFunction(value.next);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isIterable(value) {
        return !isStrictNullOrUndefined(value) && isFunction(value[getKnownSymbol(3 )]);
    }
    var _iterSymbol$1;
    function iterForOf(iter, callbackfn, thisArg) {
        if (iter) {
            if (!isIterator(iter)) {
                !_iterSymbol$1 && (_iterSymbol$1 = createCachedValue(getKnownSymbol(3 )));
                iter = iter[_iterSymbol$1.v] ? iter[_iterSymbol$1.v]() : null;
            }
            if (isIterator(iter)) {
                var err = UNDEF_VALUE;
                var iterResult = UNDEF_VALUE;
                try {
                    var count = 0;
                    while (!(iterResult = iter.next()).done) {
                        if (callbackfn[CALL](thisArg || iter, iterResult.value, count, iter) === -1) {
                            break;
                        }
                        count++;
                    }
                }
                catch (failed) {
                    err = { e: failed };
                    if (iter.throw) {
                        iterResult = NULL_VALUE;
                        iter.throw(err);
                    }
                }
                finally {
                    try {
                        if (iterResult && !iterResult.done) {
                            iter.return && iter.return(iterResult);
                        }
                    }
                    finally {
                        if (err) {
                            throw err.e;
                        }
                    }
                }
            }
        }
    }
    function fnApply(fn, thisArg, argArray) {
        return fn.apply(thisArg, argArray);
    }
    function arrAppend(target, elms) {
        if (!isUndefined(elms) && target) {
            if (isArray(elms)) {
                fnApply(target.push, target, elms);
            }
            else if (isIterator(elms) || isIterable(elms)) {
                iterForOf(elms, function (elm) {
                    target.push(elm);
                });
            }
            else {
                target.push(elms);
            }
        }
        return target;
    }
    function arrForEach(theArray, callbackfn, thisArg) {
        if (theArray) {
            var len = theArray[LENGTH] >>> 0;
            for (var idx = 0; idx < len; idx++) {
                if (idx in theArray) {
                    if (callbackfn[CALL](thisArg || theArray, theArray[idx], idx, theArray) === -1) {
                        break;
                    }
                }
            }
        }
    }
    var arrIndexOf = ( /*#__PURE__*/_unwrapFunction("indexOf", ArrProto));
    var arrMap = ( /*#__PURE__*/_unwrapFunction("map", ArrProto));
    function arrSlice(theArray, start, end) {
        return ((theArray && theArray["slice"]) || ArrSlice).apply(theArray, ArrSlice[CALL](arguments, 1));
    }
    /*#__NO_SIDE_EFFECTS__*/
    function polyArrIncludes(theArray, searchElement, fromIndex) {
        return arrIndexOf(theArray, searchElement, fromIndex) !== -1;
    }
    var arrIncludes = ( /*#__PURE__*/_unwrapFunctionWithPoly("includes", ArrProto, polyArrIncludes));
    var arrReduce = ( /*#__PURE__*/_unwrapFunction("reduce", ArrProto));
    var objCreate = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ObjClass, "create")), polyObjCreate));
    /*#__NO_SIDE_EFFECTS__*/
    function polyObjCreate(obj) {
        if (!obj) {
            return {};
        }
        var type = typeof obj;
        if (type !== OBJECT && type !== FUNCTION) {
            throwTypeError("Prototype must be an Object or function: " + dumpObj(obj));
        }
        function tempFunc() { }
        tempFunc[PROTOTYPE] = obj;
        return new tempFunc();
    }
    var _isProtoArray;
    function objSetPrototypeOf(obj, proto) {
        var fn = ObjClass["setPrototypeOf"] ||
            function (d, b) {
                var _a;
                !_isProtoArray && (_isProtoArray = createCachedValue((_a = {}, _a[__PROTO__] = [], _a) instanceof Array));
                _isProtoArray.v ? d[__PROTO__] = b : objForEachKey(b, function (key, value) { return d[key] = value; });
            };
        return fn(obj, proto);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _createCustomError(name, d, b) {
        safe(objDefine, [d, NAME, { v: name, c: true, e: false }]);
        d = objSetPrototypeOf(d, b);
        function __() {
            this[CONSTRUCTOR] = d;
            safe(objDefine, [this, NAME, { v: name, c: true, e: false }]);
        }
        d[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : (__[PROTOTYPE] = b[PROTOTYPE], new __());
        return d;
    }
    function _setName(baseClass, name) {
        name && (baseClass[NAME] = name);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function createCustomError(name, constructCb, errorBase) {
        var theBaseClass = errorBase || Error;
        var orgName = theBaseClass[PROTOTYPE][NAME];
        var captureFn = Error.captureStackTrace;
        return _createCustomError(name, function () {
            var _this = this;
            var theArgs = arguments;
            try {
                safe(_setName, [theBaseClass, name]);
                var _self = fnApply(theBaseClass, _this, ArrSlice[CALL](theArgs)) || _this;
                if (_self !== _this) {
                    var orgProto = objGetPrototypeOf(_this);
                    if (orgProto !== objGetPrototypeOf(_self)) {
                        objSetPrototypeOf(_self, orgProto);
                    }
                }
                captureFn && captureFn(_self, _this[CONSTRUCTOR]);
                constructCb && constructCb(_self, theArgs);
                return _self;
            }
            finally {
                safe(_setName, [theBaseClass, orgName]);
            }
        }, theBaseClass);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function utcNow() {
        return (Date.now || polyUtcNow)();
    }
    /*#__NO_SIDE_EFFECTS__*/
    function polyUtcNow() {
        return new Date().getTime();
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _createTrimFn(exp) {
        return function _doTrim(value) {
            if (isNullOrUndefined(value)) {
                throwTypeError("strTrim called [" + dumpObj(value) + "]");
            }
            if (value && value.replace) {
                value = value.replace(exp, EMPTY);
            }
            return value;
        };
    }
    var polyStrTrim = ( /*#__PURE__*/_createTrimFn(/^\s+|(?=\s)\s+$/g));
    var strTrim = ( /*#__PURE__*/_unwrapFunctionWithPoly("trim", StrProto, polyStrTrim));
    var _fnToString;
    var _objCtrFnString;
    var _gblWindow;
    /*#__NO_SIDE_EFFECTS__*/
    function isPlainObject(value) {
        if (!value || typeof value !== OBJECT) {
            return false;
        }
        if (!_gblWindow) {
            _gblWindow = hasWindow() ? getWindow() : true;
        }
        var result = false;
        if (value !== _gblWindow) {
            if (!_objCtrFnString) {
                _fnToString = Function[PROTOTYPE][TO_STRING];
                _objCtrFnString = _fnToString[CALL](ObjClass);
            }
            try {
                var proto = objGetPrototypeOf(value);
                result = !proto;
                if (!result) {
                    if (objHasOwnProperty(proto, CONSTRUCTOR)) {
                        proto = proto[CONSTRUCTOR];
                    }
                    result = proto && typeof proto === FUNCTION && _fnToString[CALL](proto) === _objCtrFnString;
                }
            }
            catch (ex) {
            }
        }
        return result;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _defaultDeepCopyHandler(details) {
        details.value && plainObjDeepCopyHandler(details);
        return true;
    }
    var defaultDeepCopyHandlers = [
        arrayDeepCopyHandler,
        plainObjDeepCopyHandler,
        functionDeepCopyHandler,
        dateDeepCopyHandler
    ];
    /*#__NO_SIDE_EFFECTS__*/
    function _getSetVisited(visitMap, source, newPath, cb) {
        var theEntry;
        arrForEach(visitMap, function (entry) {
            if (entry.k === source) {
                theEntry = entry;
                return -1;
            }
        });
        if (!theEntry) {
            theEntry = { k: source, v: source };
            visitMap.push(theEntry);
            cb(theEntry);
        }
        return theEntry.v;
    }
    function _deepCopy(visitMap, value, ctx, key) {
        var userHandler = ctx.handler;
        var newPath = ctx.path ? (key ? ctx.path.concat(key) : ctx.path) : [];
        var newCtx = {
            handler: ctx.handler,
            src: ctx.src,
            path: newPath
        };
        var theType = typeof value;
        var isPlain = false;
        var isPrim = false;
        if (value && theType === OBJECT) {
            isPlain = isPlainObject(value);
        }
        else {
            isPrim = value === NULL_VALUE || isPrimitiveType(theType);
        }
        var details = {
            type: theType,
            isPrim: isPrim,
            isPlain: isPlain,
            value: value,
            result: value,
            path: newPath,
            origin: ctx.src,
            copy: function (source, newKey) {
                return _deepCopy(visitMap, source, newKey ? newCtx : ctx, newKey);
            },
            copyTo: function (target, source) {
                return _copyProps(visitMap, target, source, newCtx);
            }
        };
        if (!details.isPrim) {
            return _getSetVisited(visitMap, value, newPath, function (newEntry) {
                objDefine(details, "result", {
                    g: function () {
                        return newEntry.v;
                    },
                    s: function (newValue) {
                        newEntry.v = newValue;
                    }
                });
                var idx = 0;
                var handler = userHandler;
                while (!(handler || (idx < defaultDeepCopyHandlers.length ? defaultDeepCopyHandlers[idx++] : _defaultDeepCopyHandler))[CALL](ctx, details)) {
                    handler = NULL_VALUE;
                }
            });
        }
        if (userHandler && userHandler[CALL](ctx, details)) {
            return details.result;
        }
        return value;
    }
    function _copyProps(visitMap, target, source, ctx) {
        if (!isNullOrUndefined(source)) {
            for (var key in source) {
                target[key] = _deepCopy(visitMap, source[key], ctx, key);
            }
        }
        return target;
    }
    function objCopyProps(target, source, handler) {
        var ctx = {
            handler: handler,
            src: source,
            path: []
        };
        return _copyProps([], target, source, ctx);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function objDeepCopy(source, handler) {
        var ctx = {
            handler: handler,
            src: source
        };
        return _deepCopy([], source, ctx);
    }
    function arrayDeepCopyHandler(details) {
        var value = details.value;
        if (isArray(value)) {
            var target = details.result = [];
            target.length = value.length;
            details.copyTo(target, value);
            return true;
        }
        return false;
    }
    function dateDeepCopyHandler(details) {
        var value = details.value;
        if (isDate(value)) {
            details.result = new Date(value.getTime());
            return true;
        }
        return false;
    }
    function functionDeepCopyHandler(details) {
        if (details.type === FUNCTION) {
            return true;
        }
        return false;
    }
    function plainObjDeepCopyHandler(details) {
        var value = details.value;
        if (value && details.isPlain) {
            var target = details.result = {};
            details.copyTo(target, value);
            return true;
        }
        return false;
    }
    function _doExtend(target, theArgs) {
        arrForEach(theArgs, function (theArg) {
            objCopyProps(target, theArg);
        });
        return target;
    }
    function deepExtend(target, obj1, obj2, obj3, obj4, obj5, obj6) {
        return _doExtend(objDeepCopy(target) || {}, ArrSlice[CALL](arguments));
    }
    var getLength = ( /*#__PURE__*/_unwrapProp(LENGTH));
    var _perf;
    /*#__NO_SIDE_EFFECTS__*/
    function getPerformance() {
        !_globalLazyTestHooks && _initTestHooks();
        (!_perf || _globalLazyTestHooks.lzy) && (_perf = createCachedValue(safe((getInst), ["performance"]).v));
        return _perf.v;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function perfNow() {
        var perf = getPerformance();
        if (perf && perf.now) {
            return perf.now();
        }
        return utcNow();
    }
    var strEndsWith = ( /*#__PURE__*/_unwrapFunctionWithPoly("endsWith", StrProto, polyStrEndsWith));
    /*#__NO_SIDE_EFFECTS__*/
    function polyStrEndsWith(value, searchString, length) {
        if (!isString(value)) {
            throwTypeError("'" + dumpObj(value) + "' is not a string");
        }
        var searchValue = isString(searchString) ? searchString : asString(searchString);
        var end = !isUndefined(length) && length < value[LENGTH] ? length : value[LENGTH];
        return strSubstring(value, end - searchValue[LENGTH], end) === searchValue;
    }
    var strIndexOf = ( /*#__PURE__*/_unwrapFunction("indexOf", StrProto));
    var strStartsWith = ( /*#__PURE__*/_unwrapFunctionWithPoly("startsWith", StrProto, polyStrStartsWith));
    /*#__NO_SIDE_EFFECTS__*/
    function polyStrStartsWith(value, searchString, position) {
        if (!isString(value)) {
            throwTypeError("'" + dumpObj(value) + "' is not a string");
        }
        var searchValue = isString(searchString) ? searchString : asString(searchString);
        var pos = position > 0 ? position : 0;
        return strSubstring(value, pos, pos + searchValue[LENGTH]) === searchValue;
    }
    var REF = "ref";
    var UNREF = "unref";
    var HAS_REF = "hasRef";
    var ENABLED = "enabled";
    /*#__NO_SIDE_EFFECTS__*/
    function _createTimerHandler(startTimer, refreshFn, cancelFn) {
        var ref = true;
        var timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE;
        var theTimerHandler;
        function _unref() {
            ref = false;
            timerId && timerId[UNREF] && timerId[UNREF]();
            return theTimerHandler;
        }
        function _cancel() {
            timerId && cancelFn(timerId);
            timerId = NULL_VALUE;
        }
        function _refresh() {
            timerId = refreshFn(timerId);
            if (!ref) {
                _unref();
            }
            return theTimerHandler;
        }
        function _setEnabled(value) {
            !value && timerId && _cancel();
            value && !timerId && _refresh();
        }
        theTimerHandler = {
            cancel: _cancel,
            refresh: _refresh
        };
        theTimerHandler[HAS_REF] = function () {
            if (timerId && timerId[HAS_REF]) {
                return timerId[HAS_REF]();
            }
            return ref;
        };
        theTimerHandler[REF] = function () {
            ref = true;
            timerId && timerId[REF] && timerId[REF]();
            return theTimerHandler;
        };
        theTimerHandler[UNREF] = _unref;
        theTimerHandler = objDefineProp(theTimerHandler, ENABLED, {
            get: function () { return !!timerId; },
            set: _setEnabled
        });
        return {
            h: theTimerHandler,
            dn: function () {
                timerId = NULL_VALUE;
            }
        };
    }
    function _createTimeoutWith(startTimer, overrideFn, theArgs) {
        var isArr = isArray(overrideFn);
        var len = isArr ? overrideFn.length : 0;
        var setFn = (len > 0 ? overrideFn[0] : (!isArr ? overrideFn : UNDEF_VALUE)) || setTimeout;
        var clearFn = (len > 1 ? overrideFn[1] : UNDEF_VALUE) || clearTimeout;
        var timerFn = theArgs[0];
        theArgs[0] = function () {
            handler.dn();
            fnApply(timerFn, UNDEF_VALUE, ArrSlice[CALL](arguments));
        };
        var handler = _createTimerHandler(startTimer, function (timerId) {
            if (timerId) {
                if (timerId.refresh) {
                    timerId.refresh();
                    return timerId;
                }
                fnApply(clearFn, UNDEF_VALUE, [timerId]);
            }
            return fnApply(setFn, UNDEF_VALUE, theArgs);
        }, function (timerId) {
            fnApply(clearFn, UNDEF_VALUE, [timerId]);
        });
        return handler.h;
    }
    function scheduleTimeout(callback, timeout) {
        return _createTimeoutWith(true, UNDEF_VALUE, ArrSlice[CALL](arguments));
    }
    function createTimeout(callback, timeout) {
        return _createTimeoutWith(false, UNDEF_VALUE, ArrSlice[CALL](arguments));
    }

    var strHasOwnProperty = "hasOwnProperty";
    var extendStaticsFn = function (d, b) {
        extendStaticsFn = ObjClass$1["setPrototypeOf"] ||
            ({ __proto__: [] } instanceof Array && function (d, b) {
                d.__proto__ = b;
            }) ||
            function (d, b) {
                for (var p in b) {
                    if (b[strHasOwnProperty](p)) {
                        d[p] = b[p];
                    }
                }
            };
        return extendStaticsFn(d, b);
    };
    function __extendsFn(d, b) {
        if (typeof b !== strShimFunction && b !== null) {
            throwTypeError("Class extends value " + String(b) + " is not a constructor or null");
        }
        extendStaticsFn(d, b);
        function __() {
            this.constructor = d;
        }
        d[strShimPrototype] = b === null ? objCreate(b) : (__[strShimPrototype] = b[strShimPrototype], new __());
    }
    function __spreadArrayFn(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {
            to[j] = from[i];
        }
        return to;
    }

    var _a$5;
    var Constructor = 'constructor';
    var Prototype = 'prototype';
    var strFunction = 'function';
    var DynInstFuncTable = '_dynInstFuncs';
    var DynProxyTag = '_isDynProxy';
    var DynClassName = '_dynClass';
    var DynClassNamePrefix = '_dynCls$';
    var DynInstChkTag = '_dynInstChk';
    var DynAllowInstChkTag = DynInstChkTag;
    var DynProtoDefaultOptions = '_dfOpts';
    var UnknownValue = '_unknown_';
    var str__Proto = "__proto__";
    var DynProtoBaseProto = "_dyn" + str__Proto;
    var DynProtoGlobalSettings = "__dynProto$Gbl";
    var DynProtoCurrent = "_dynInstProto";
    var strUseBaseInst = 'useBaseInst';
    var strSetInstFuncs = 'setInstFuncs';
    var Obj = Object;
    var _objGetPrototypeOf = Obj["getPrototypeOf"];
    var _objGetOwnProps = Obj["getOwnPropertyNames"];
    var _gbl = getGlobal();
    var _gblInst = _gbl[DynProtoGlobalSettings] || (_gbl[DynProtoGlobalSettings] = {
        o: (_a$5 = {},
            _a$5[strSetInstFuncs] = true,
            _a$5[strUseBaseInst] = true,
            _a$5),
        n: 1000
    });
    function _isObjectOrArrayPrototype(target) {
        return target && (target === Obj[Prototype] || target === Array[Prototype]);
    }
    function _isObjectArrayOrFunctionPrototype(target) {
        return _isObjectOrArrayPrototype(target) || target === Function[Prototype];
    }
    function _getObjProto(target) {
        var newProto;
        if (target) {
            if (_objGetPrototypeOf) {
                return _objGetPrototypeOf(target);
            }
            var curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);
            newProto = target[DynProtoBaseProto] || curProto;
            if (!objHasOwnProperty(target, DynProtoBaseProto)) {
                delete target[DynProtoCurrent];
                newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto];
                target[DynProtoCurrent] = curProto;
            }
        }
        return newProto;
    }
    function _forEachProp(target, func) {
        var props = [];
        if (_objGetOwnProps) {
            props = _objGetOwnProps(target);
        }
        else {
            for (var name_1 in target) {
                if (typeof name_1 === "string" && objHasOwnProperty(target, name_1)) {
                    props.push(name_1);
                }
            }
        }
        if (props && props.length > 0) {
            for (var lp = 0; lp < props.length; lp++) {
                func(props[lp]);
            }
        }
    }
    function _isDynamicCandidate(target, funcName, skipOwn) {
        return (funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || objHasOwnProperty(target, funcName)) && funcName !== str__Proto && funcName !== Prototype);
    }
    function _throwTypeError(message) {
        throwTypeError("DynamicProto: " + message);
    }
    function _getInstanceFuncs(thisTarget) {
        var instFuncs = objCreate(null);
        _forEachProp(thisTarget, function (name) {
            if (!instFuncs[name] && _isDynamicCandidate(thisTarget, name, false)) {
                instFuncs[name] = thisTarget[name];
            }
        });
        return instFuncs;
    }
    function _hasVisited(values, value) {
        for (var lp = values.length - 1; lp >= 0; lp--) {
            if (values[lp] === value) {
                return true;
            }
        }
        return false;
    }
    function _getBaseFuncs(classProto, thisTarget, instFuncs, useBaseInst) {
        function _instFuncProxy(target, funcHost, funcName) {
            var theFunc = funcHost[funcName];
            if (theFunc[DynProxyTag] && useBaseInst) {
                var instFuncTable = target[DynInstFuncTable] || {};
                if (instFuncTable[DynAllowInstChkTag] !== false) {
                    theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc;
                }
            }
            return function () {
                return theFunc.apply(target, arguments);
            };
        }
        var baseFuncs = objCreate(null);
        _forEachProp(instFuncs, function (name) {
            baseFuncs[name] = _instFuncProxy(thisTarget, instFuncs, name);
        });
        var baseProto = _getObjProto(classProto);
        var visited = [];
        while (baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto)) {
            _forEachProp(baseProto, function (name) {
                if (!baseFuncs[name] && _isDynamicCandidate(baseProto, name, !_objGetPrototypeOf)) {
                    baseFuncs[name] = _instFuncProxy(thisTarget, baseProto, name);
                }
            });
            visited.push(baseProto);
            baseProto = _getObjProto(baseProto);
        }
        return baseFuncs;
    }
    function _getInstFunc(target, funcName, proto, currentDynProtoProxy) {
        var instFunc = null;
        if (target && objHasOwnProperty(proto, DynClassName)) {
            var instFuncTable = target[DynInstFuncTable] || objCreate(null);
            instFunc = (instFuncTable[proto[DynClassName]] || objCreate(null))[funcName];
            if (!instFunc) {
                _throwTypeError("Missing [" + funcName + "] " + strFunction);
            }
            if (!instFunc[DynInstChkTag] && instFuncTable[DynAllowInstChkTag] !== false) {
                var canAddInst = !objHasOwnProperty(target, funcName);
                var objProto = _getObjProto(target);
                var visited = [];
                while (canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto)) {
                    var protoFunc = objProto[funcName];
                    if (protoFunc) {
                        canAddInst = (protoFunc === currentDynProtoProxy);
                        break;
                    }
                    visited.push(objProto);
                    objProto = _getObjProto(objProto);
                }
                try {
                    if (canAddInst) {
                        target[funcName] = instFunc;
                    }
                    instFunc[DynInstChkTag] = 1;
                }
                catch (e) {
                    instFuncTable[DynAllowInstChkTag] = false;
                }
            }
        }
        return instFunc;
    }
    function _getProtoFunc(funcName, proto, currentDynProtoProxy) {
        var protoFunc = proto[funcName];
        if (protoFunc === currentDynProtoProxy) {
            protoFunc = _getObjProto(proto)[funcName];
        }
        if (typeof protoFunc !== strFunction) {
            _throwTypeError("[" + funcName + "] is not a " + strFunction);
        }
        return protoFunc;
    }
    function _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {
        function _createDynamicPrototype(proto, funcName) {
            var dynProtoProxy = function () {
                var instFunc = _getInstFunc(this, funcName, proto, dynProtoProxy) || _getProtoFunc(funcName, proto, dynProtoProxy);
                return instFunc.apply(this, arguments);
            };
            dynProtoProxy[DynProxyTag] = 1;
            return dynProtoProxy;
        }
        if (!_isObjectOrArrayPrototype(proto)) {
            var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || objCreate(null);
            if (!_isObjectOrArrayPrototype(instFuncTable)) {
                var instFuncs_1 = instFuncTable[className] = (instFuncTable[className] || objCreate(null));
                if (instFuncTable[DynAllowInstChkTag] !== false) {
                    instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc;
                }
                if (!_isObjectOrArrayPrototype(instFuncs_1)) {
                    _forEachProp(target, function (name) {
                        if (_isDynamicCandidate(target, name, false) && target[name] !== baseInstFuncs[name]) {
                            instFuncs_1[name] = target[name];
                            delete target[name];
                            if (!objHasOwnProperty(proto, name) || (proto[name] && !proto[name][DynProxyTag])) {
                                proto[name] = _createDynamicPrototype(proto, name);
                            }
                        }
                    });
                }
            }
        }
    }
    function _checkPrototype(classProto, thisTarget) {
        if (_objGetPrototypeOf) {
            var visited = [];
            var thisProto = _getObjProto(thisTarget);
            while (thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto)) {
                if (thisProto === classProto) {
                    return true;
                }
                visited.push(thisProto);
                thisProto = _getObjProto(thisProto);
            }
            return false;
        }
        return true;
    }
    function _getObjName(target, unknownValue) {
        if (objHasOwnProperty(target, Prototype)) {
            return target.name || unknownValue || UnknownValue;
        }
        return (((target || {})[Constructor]) || {}).name || unknownValue || UnknownValue;
    }
    function dynamicProto(theClass, target, delegateFunc, options) {
        if (!objHasOwnProperty(theClass, Prototype)) {
            _throwTypeError("theClass is an invalid class definition.");
        }
        var classProto = theClass[Prototype];
        if (!_checkPrototype(classProto, target)) {
            _throwTypeError("[" + _getObjName(theClass) + "] not in hierarchy of [" + _getObjName(target) + "]");
        }
        var className = null;
        if (objHasOwnProperty(classProto, DynClassName)) {
            className = classProto[DynClassName];
        }
        else {
            className = DynClassNamePrefix + _getObjName(theClass, "_") + "$" + _gblInst.n;
            _gblInst.n++;
            classProto[DynClassName] = className;
        }
        var perfOptions = dynamicProto[DynProtoDefaultOptions];
        var useBaseInst = !!perfOptions[strUseBaseInst];
        if (useBaseInst && options && options[strUseBaseInst] !== undefined) {
            useBaseInst = !!options[strUseBaseInst];
        }
        var instFuncs = _getInstanceFuncs(target);
        var baseFuncs = _getBaseFuncs(classProto, target, instFuncs, useBaseInst);
        delegateFunc(target, baseFuncs);
        var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];
        if (setInstanceFunc && options) {
            setInstanceFunc = !!options[strSetInstFuncs];
        }
        _populatePrototype(classProto, className, target, instFuncs, setInstanceFunc !== false);
    }
    dynamicProto[DynProtoDefaultOptions] = _gblInst.o;

    var MinChannelPriorty = 100;

    var createEnumStyle = createEnum;

    var EventsDiscardedReason = createEnumStyle({
        Unknown: 0 ,
        NonRetryableStatus: 1 ,
        InvalidEvent: 2 ,
        SizeLimitExceeded: 3 ,
        KillSwitch: 4 ,
        QueueFull: 5
    });

    var _DYN_TO_LOWER_CASE = "toLowerCase";
    var _DYN_BLK_VAL = "blkVal";
    var _DYN_LENGTH$1 = "length";
    var _DYN_RD_ONLY = "rdOnly";
    var _DYN_NOTIFY = "notify";
    var _DYN_WARN_TO_CONSOLE = "warnToConsole";
    var _DYN_THROW_INTERNAL = "throwInternal";
    var _DYN_SET_DF = "setDf";
    var _DYN_WATCH = "watch";
    var _DYN_LOGGER$1 = "logger";
    var _DYN_APPLY = "apply";
    var _DYN_PUSH = "push";
    var _DYN_SPLICE = "splice";
    var _DYN_HDLR = "hdlr";
    var _DYN_CANCEL = "cancel";
    var _DYN_INITIALIZE$1 = "initialize";
    var _DYN_IDENTIFIER = "identifier";
    var _DYN_REMOVE_NOTIFICATION_0 = "removeNotificationListener";
    var _DYN_ADD_NOTIFICATION_LIS1 = "addNotificationListener";
    var _DYN_IS_INITIALIZED = "isInitialized";
    var _DYN_GET_NOTIFY_MGR = "getNotifyMgr";
    var _DYN_GET_PLUGIN = "getPlugin";
    var _DYN_POLL_INTERNAL_LOGS$1 = "pollInternalLogs";
    var _DYN_NAME = "name";
    var _DYN_TIME = "time";
    var _DYN_PROCESS_NEXT = "processNext";
    var _DYN_GET_PROCESS_TEL_CONT2 = "getProcessTelContext";
    var _DYN_ENABLED = "enabled";
    var _DYN_STOP_POLLING_INTERNA3 = "stopPollingInternalLogs";
    var _DYN_UNLOAD = "unload";
    var _DYN_ON_COMPLETE = "onComplete";
    var _DYN_VERSION = "version";
    var _DYN_LOGGING_LEVEL_CONSOL4 = "loggingLevelConsole";
    var _DYN_CREATE_NEW = "createNew";
    var _DYN_TEARDOWN = "teardown";
    var _DYN_MESSAGE_ID = "messageId";
    var _DYN_MESSAGE = "message";
    var _DYN_IS_ASYNC = "isAsync";
    var _DYN_DIAG_LOG = "diagLog";
    var _DYN__DO_TEARDOWN = "_doTeardown";
    var _DYN_UPDATE = "update";
    var _DYN_GET_NEXT = "getNext";
    var _DYN_SET_NEXT_PLUGIN = "setNextPlugin";
    var _DYN_PROTOCOL = "protocol";
    var _DYN_USER_AGENT = "userAgent";
    var _DYN_SPLIT = "split";
    var _DYN_NODE_TYPE = "nodeType";
    var _DYN_REPLACE = "replace";
    var _DYN_LOG_INTERNAL_MESSAGE = "logInternalMessage";
    var _DYN_TYPE = "type";
    var _DYN_HANDLER = "handler";
    var _DYN_STATUS = "status";
    var _DYN_GET_RESPONSE_HEADER = "getResponseHeader";
    var _DYN_GET_ALL_RESPONSE_HEA5 = "getAllResponseHeaders";
    var _DYN_IS_CHILD_EVT = "isChildEvt";
    var _DYN_DATA = "data";
    var _DYN_GET_CTX = "getCtx";
    var _DYN_SET_CTX = "setCtx";
    var _DYN_COMPLETE = "complete";
    var _DYN_ITEMS_RECEIVED = "itemsReceived";
    var _DYN_URL_STRING = "urlString";
    var _DYN_SEND_POST = "sendPOST";
    var _DYN_HEADERS = "headers";
    var _DYN_TIMEOUT = "timeout";
    var _DYN_SET_REQUEST_HEADER = "setRequestHeader";
    var _DYN_TRACE_ID = "traceId";
    var _DYN_SPAN_ID = "spanId";
    var _DYN_TRACE_FLAGS = "traceFlags";

    var aggregationErrorType;
    function throwAggregationError(message, sourceErrors) {
        if (!aggregationErrorType) {
            aggregationErrorType = createCustomError("AggregationError", function (self, args) {
                if (args[_DYN_LENGTH$1 ] > 1) {
                    self.errors = args[1];
                }
            });
        }
        var theMessage = message || "One or more errors occurred.";
        arrForEach(sourceErrors, function (srcError, idx) {
            theMessage += "\n".concat(idx, " > ").concat(dumpObj(srcError));
        });
        throw new aggregationErrorType(theMessage, sourceErrors || []);
    }

    /*!
     * NevWare21 - ts-async, 0.5.1
     * https://github.com/nevware21/ts-async
     * Copyright (c) NevWare21 and contributors. All rights reserved.
     * Licensed under the MIT license.
     */
    var STR_PROMISE = "Promise";
    var REJECTED = "rejected";
    function doAwaitResponse(value, cb) {
        return doAwait(value, function (value) {
            return cb ? cb({
                status: "fulfilled",
                rejected: false,
                value: value
            }) : value;
        }, function (reason) {
            return cb ? cb({
                status: REJECTED,
                rejected: true,
                reason: reason
            }) : reason;
        });
    }
    function doAwait(value, resolveFn, rejectFn, finallyFn) {
        var result = value;
        try {
            if (isPromiseLike(value)) {
                if (resolveFn || rejectFn) {
                    result = value.then(resolveFn, rejectFn);
                }
            }
            else {
                try {
                    if (resolveFn) {
                        result = resolveFn(value);
                    }
                }
                catch (err) {
                    if (rejectFn) {
                        result = rejectFn(err);
                    }
                    else {
                        throw err;
                    }
                }
            }
        }
        finally {
            if (finallyFn) {
                doFinally(result, finallyFn);
            }
        }
        return result;
    }
    function doFinally(value, finallyFn) {
        var result = value;
        if (finallyFn) {
            if (isPromiseLike(value)) {
                if (value.finally) {
                    result = value.finally(finallyFn);
                }
                else {
                    result = value.then(function (value) {
                        finallyFn();
                        return value;
                    }, function (reason) {
                        finallyFn();
                        throw reason;
                    });
                }
            }
            else {
                finallyFn();
            }
        }
        return result;
    }
    var STRING_STATES =  [
        "pending", "resolving", "resolved", REJECTED
    ];
    var DISPATCH_EVENT = "dispatchEvent";
    var _hasInitEvent;
    function _hasInitEventFn(doc) {
        var evt;
        if (doc && doc.createEvent) {
            evt = doc.createEvent("Event");
        }
        return (!!evt && evt.initEvent);
    }
    function emitEvent(target, evtName, populateEvent, useNewEvent) {
        var doc = getDocument();
        !_hasInitEvent && (_hasInitEvent = createCachedValue(!!safe(_hasInitEventFn, [doc]).v));
        var theEvt = _hasInitEvent.v ? doc.createEvent("Event") : (useNewEvent ? new Event(evtName) : {});
        populateEvent && populateEvent(theEvt);
        if (_hasInitEvent.v) {
            theEvt.initEvent(evtName, false, true);
        }
        if (theEvt && target[DISPATCH_EVENT]) {
            target[DISPATCH_EVENT](theEvt);
        }
        else {
            var handler = target["on" + evtName];
            if (handler) {
                handler(theEvt);
            }
            else {
                var theConsole = getInst("console");
                theConsole && (theConsole["error"] || theConsole["log"])(evtName, dumpObj(theEvt));
            }
        }
    }
    var NODE_UNHANDLED_REJECTION = "unhandledRejection";
    var UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();
    var _unhandledRejectionTimeout = 10;
    var _hasPromiseRejectionEvent;
    function dumpFnObj(value) {
        if (isFunction(value)) {
            return value.toString();
        }
        return dumpObj(value);
    }
    function _createPromise(newPromise, processor, executor) {
        var additionalArgs = arrSlice(arguments, 3);
        var _state = 0 ;
        var _hasResolved = false;
        var _settledValue;
        var _queue = [];
        var _handled = false;
        var _unHandledRejectionHandler = null;
        var _thePromise;
        function _then(onResolved, onRejected) {
            try {
                _handled = true;
                _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
                _unHandledRejectionHandler = null;
                var thenPromise = newPromise(function (resolve, reject) {
                    _queue.push(function () {
                        try {
                            var handler = _state === 2  ? onResolved : onRejected;
                            var value = isUndefined(handler) ? _settledValue : (isFunction(handler) ? handler(_settledValue) : handler);
                            if (isPromiseLike(value)) {
                                value.then(resolve, reject);
                            }
                            else if (handler) {
                                resolve(value);
                            }
                            else if (_state === 3 ) {
                                reject(value);
                            }
                            else {
                                resolve(value);
                            }
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                    if (_hasResolved) {
                        _processQueue();
                    }
                }, additionalArgs);
                return thenPromise;
            }
            finally {
            }
        }
        function _catch(onRejected) {
            return _then(undefined, onRejected);
        }
        function _finally(onFinally) {
            var thenFinally = onFinally;
            var catchFinally = onFinally;
            if (isFunction(onFinally)) {
                thenFinally = function (value) {
                    onFinally && onFinally();
                    return value;
                };
                catchFinally = function (reason) {
                    onFinally && onFinally();
                    throw reason;
                };
            }
            return _then(thenFinally, catchFinally);
        }
        function _strState() {
            return STRING_STATES[_state];
        }
        function _processQueue() {
            if (_queue.length > 0) {
                var pending = _queue.slice();
                _queue = [];
                _handled = true;
                _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
                _unHandledRejectionHandler = null;
                processor(pending);
            }
        }
        function _createSettleIfFn(newState, allowState) {
            return function (theValue) {
                if (_state === allowState) {
                    if (newState === 2  && isPromiseLike(theValue)) {
                        _state = 1 ;
                        theValue.then(_createSettleIfFn(2 , 1 ), _createSettleIfFn(3 , 1 ));
                        return;
                    }
                    _state = newState;
                    _hasResolved = true;
                    _settledValue = theValue;
                    _processQueue();
                    if (!_handled && newState === 3  && !_unHandledRejectionHandler) {
                        _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout);
                    }
                }
            };
        }
        function _notifyUnhandledRejection() {
            if (!_handled) {
                _handled = true;
                if (isNode()) {
                    process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);
                }
                else {
                    var gbl = getWindow() || getGlobal();
                    !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = createCachedValue(safe((getInst), [STR_PROMISE + "RejectionEvent"]).v));
                    emitEvent(gbl, UNHANDLED_REJECTION, function (theEvt) {
                        objDefine(theEvt, "promise", { g: function () { return _thePromise; } });
                        theEvt.reason = _settledValue;
                        return theEvt;
                    }, !!_hasPromiseRejectionEvent.v);
                }
            }
        }
        _thePromise = {
            then: _then,
            "catch": _catch,
            finally: _finally
        };
        objDefineProp(_thePromise, "state", {
            get: _strState
        });
        if (hasSymbol()) {
            _thePromise[getKnownSymbol(11 )] = "IPromise";
        }
        function _toString() {
            return "IPromise" + ("") + " " + _strState() + (_hasResolved ? (" - " + dumpFnObj(_settledValue)) : "") + ("");
        }
        _thePromise.toString = _toString;
        (function _initialize() {
            if (!isFunction(executor)) {
                throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpFnObj(executor));
            }
            var _rejectFn = _createSettleIfFn(3 , 0 );
            try {
                executor.call(_thePromise, _createSettleIfFn(2 , 0 ), _rejectFn);
            }
            catch (e) {
                _rejectFn(e);
            }
        })();
        return _thePromise;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _createAllPromise(newPromise) {
        return function (input) {
            var additionalArgs = arrSlice(arguments, 1);
            return newPromise(function (resolve, reject) {
                try {
                    var values_1 = [];
                    var pending_1 = 1;
                    iterForOf(input, function (item, idx) {
                        if (item) {
                            pending_1++;
                            doAwait(item, function (value) {
                                values_1[idx] = value;
                                if (--pending_1 === 0) {
                                    resolve(values_1);
                                }
                            }, reject);
                        }
                    });
                    pending_1--;
                    if (pending_1 === 0) {
                        resolve(values_1);
                    }
                }
                catch (e) {
                    reject(e);
                }
            }, additionalArgs);
        };
    }
    function syncItemProcessor(pending) {
        arrForEach(pending, function (fn) {
            try {
                fn();
            }
            catch (e) {
            }
        });
    }
    function timeoutItemProcessor(timeout) {
        var callbackTimeout = isNumber(timeout) ? timeout : 0;
        return function (pending) {
            scheduleTimeout(function () {
                syncItemProcessor(pending);
            }, callbackTimeout);
        };
    }
    function createAsyncPromise(executor, timeout) {
        return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);
    }
    var _promiseCls;
    function createNativePromise(executor, timeout) {
        !_promiseCls && (_promiseCls = createCachedValue((safe(getInst, [STR_PROMISE]).v) || null));
        var PrmCls = _promiseCls.v;
        if (!PrmCls) {
            return createAsyncPromise(executor);
        }
        if (!isFunction(executor)) {
            throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpObj(executor));
        }
        var _state = 0 ;
        function _strState() {
            return STRING_STATES[_state];
        }
        var thePromise = new PrmCls(function (resolve, reject) {
            function _resolve(value) {
                _state = 2 ;
                resolve(value);
            }
            function _reject(reason) {
                _state = 3 ;
                reject(reason);
            }
            executor(_resolve, _reject);
        });
        objDefineProp(thePromise, "state", {
            get: _strState
        });
        return thePromise;
    }
    var _promiseCreator;
    function createPromise(executor, timeout) {
        !_promiseCreator && (_promiseCreator = createCachedValue(createNativePromise));
        return _promiseCreator.v.call(this, executor, timeout);
    }
    var createAllPromise = /*#__PURE__*/ _createAllPromise(createPromise);

    var UNDEFINED_VALUE = undefined;
    var STR_EMPTY$2 = "";
    var STR_CHANNELS = "channels";
    var STR_CORE = "core";
    var STR_CREATE_PERF_MGR = "createPerfMgr";
    var STR_DISABLED = "disabled";
    var STR_EXTENSION_CONFIG = "extensionConfig";
    var STR_EXTENSIONS = "extensions";
    var STR_PROCESS_TELEMETRY = "processTelemetry";
    var STR_PRIORITY = "priority";
    var STR_EVENTS_SENT = "eventsSent";
    var STR_EVENTS_DISCARDED = "eventsDiscarded";
    var STR_EVENTS_SEND_REQUEST = "eventsSendRequest";
    var STR_PERF_EVENT = "perfEvent";
    var STR_OFFLINE_STORE = "offlineEventsStored";
    var STR_OFFLINE_SENT = "offlineBatchSent";
    var STR_OFFLINE_DROP = "offlineBatchDrop";
    var STR_GET_PERF_MGR = "getPerfMgr";
    var STR_DOMAIN = "domain";
    var STR_PATH = "path";
    var STR_NOT_DYNAMIC_ERROR = "Not dynamic - ";

    var rCamelCase = /-([a-z])/g;
    var rNormalizeInvalid = /([^\w\d_$])/g;
    var rLeadingNumeric = /^(\d+[\w\d_$])/;
    function isNotNullOrUndefined(value) {
        return !isNullOrUndefined(value);
    }
    function normalizeJsName(name) {
        var value = name;
        if (value && isString(value)) {
            value = value[_DYN_REPLACE ](rCamelCase, function (_all, letter) {
                return letter.toUpperCase();
            });
            value = value[_DYN_REPLACE ](rNormalizeInvalid, "_");
            value = value[_DYN_REPLACE ](rLeadingNumeric, function (_all, match) {
                return "_" + match;
            });
        }
        return value;
    }
    function strContains(value, search) {
        if (value && search) {
            return strIndexOf(value, search) !== -1;
        }
        return false;
    }
    function toISOString(date) {
        return date && date.toISOString() || "";
    }
    function getExceptionName(object) {
        if (isError(object)) {
            return object[_DYN_NAME ];
        }
        return STR_EMPTY$2;
    }
    function setValue(target, field, value, valChk, srcChk) {
        var theValue = value;
        if (target) {
            theValue = target[field];
            if (theValue !== value && (!srcChk || srcChk(theValue)) && (!valChk || valChk(value))) {
                theValue = value;
                target[field] = theValue;
            }
        }
        return theValue;
    }
    function getSetValue(target, field, defValue) {
        var theValue;
        if (target) {
            theValue = target[field];
            if (!theValue && isNullOrUndefined(theValue)) {
                theValue = !isUndefined(defValue) ? defValue : {};
                target[field] = theValue;
            }
        }
        else {
            theValue = !isUndefined(defValue) ? defValue : {};
        }
        return theValue;
    }
    function _createProxyFunction(source, funcName) {
        var srcFunc = null;
        var src = null;
        if (isFunction(source)) {
            srcFunc = source;
        }
        else {
            src = source;
        }
        return function () {
            var originalArguments = arguments;
            if (srcFunc) {
                src = srcFunc();
            }
            if (src) {
                return src[funcName][_DYN_APPLY ](src, originalArguments);
            }
        };
    }
    function proxyAssign(target, source, chkSet) {
        if (target && source && isObject(target) && isObject(source)) {
            var _loop_1 = function (field) {
                if (isString(field)) {
                    var value = source[field];
                    if (isFunction(value)) {
                        if (!chkSet || chkSet(field, true, source, target)) {
                            target[field] = _createProxyFunction(source, field);
                        }
                    }
                    else if (!chkSet || chkSet(field, false, source, target)) {
                        if (objHasOwn(target, field)) {
                            delete target[field];
                        }
                        objDefine(target, field, {
                            g: function () {
                                return source[field];
                            },
                            s: function (theValue) {
                                source[field] = theValue;
                            }
                        });
                    }
                }
            };
            for (var field in source) {
                _loop_1(field);
            }
        }
        return target;
    }
    function proxyFunctionAs(target, name, source, theFunc, overwriteTarget) {
        if (target && name && source) {
            if (overwriteTarget !== false || isUndefined(target[name])) {
                target[name] = _createProxyFunction(source, theFunc);
            }
        }
    }
    function proxyFunctions(target, source, functionsToProxy, overwriteTarget) {
        if (target && source && isObject(target) && isArray(functionsToProxy)) {
            arrForEach(functionsToProxy, function (theFuncName) {
                if (isString(theFuncName)) {
                    proxyFunctionAs(target, theFuncName, source, theFuncName, overwriteTarget);
                }
            });
        }
        return target;
    }
    function optimizeObject(theObject) {
        if (theObject && objAssign) {
            theObject = ObjClass$1(objAssign({}, theObject));
        }
        return theObject;
    }
    function getResponseText(xhr) {
        try {
            return xhr.responseText;
        }
        catch (e) {
        }
        return null;
    }
    function formatErrorMessageXdr(xdr, message) {
        if (xdr) {
            return "XDomainRequest,Response:" + getResponseText(xdr) || 0;
        }
        return message;
    }
    function formatErrorMessageXhr(xhr, message) {
        if (xhr) {
            return "XMLHttpRequest,Status:" + xhr[_DYN_STATUS ] + ",Response:" + getResponseText(xhr) || 0 || 0;
        }
        return message;
    }
    function prependTransports(theTransports, newTransports) {
        if (newTransports) {
            if (isNumber(newTransports)) {
                theTransports = [newTransports].concat(theTransports);
            }
            else if (isArray(newTransports)) {
                theTransports = newTransports.concat(theTransports);
            }
        }
        return theTransports;
    }
    var strDisabledPropertyName$1 = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
    var strWithCredentials$1 = "withCredentials";
    var strTimeout$1 = "timeout";
    function openXhr$1(method, urlString, withCredentials, disabled, isSync, timeout) {
        if (disabled === void 0) { disabled = false; }
        if (isSync === void 0) { isSync = false; }
        function _wrapSetXhrProp(xhr, prop, value) {
            try {
                xhr[prop] = value;
            }
            catch (e) {
            }
        }
        var xhr = new XMLHttpRequest();
        if (disabled) {
            _wrapSetXhrProp(xhr, strDisabledPropertyName$1, disabled);
        }
        if (withCredentials) {
            _wrapSetXhrProp(xhr, strWithCredentials$1, withCredentials);
        }
        xhr.open(method, urlString, !isSync);
        if (withCredentials) {
            _wrapSetXhrProp(xhr, strWithCredentials$1, withCredentials);
        }
        if (!isSync && timeout) {
            _wrapSetXhrProp(xhr, strTimeout$1, timeout);
        }
        return xhr;
    }
    function convertAllHeadersToMap(headersString) {
        var headers = {};
        if (isString(headersString)) {
            var headersArray = strTrim(headersString)[_DYN_SPLIT ](/[\r\n]+/);
            arrForEach(headersArray, function (headerEntry) {
                if (headerEntry) {
                    var idx = headerEntry.indexOf(": ");
                    if (idx !== -1) {
                        var header = strTrim(headerEntry.substring(0, idx))[_DYN_TO_LOWER_CASE ]();
                        var value = strTrim(headerEntry.substring(idx + 1));
                        headers[header] = value;
                    }
                    else {
                        headers[strTrim(headerEntry)] = 1;
                    }
                }
            });
        }
        return headers;
    }
    function _appendHeader(theHeaders, xhr, name) {
        if (!theHeaders[name] && xhr && xhr[_DYN_GET_RESPONSE_HEADER ]) {
            var value = xhr[_DYN_GET_RESPONSE_HEADER ](name);
            if (value) {
                theHeaders[name] = strTrim(value);
            }
        }
        return theHeaders;
    }
    var STR_KILL_DURATION_HEADER = "kill-duration";
    var STR_KILL_DURATION_SECONDS_HEADER = "kill-duration-seconds";
    var STR_TIME_DELTA_HEADER = "time-delta-millis";
    function _getAllResponseHeaders(xhr, isOneDs) {
        var theHeaders = {};
        if (!xhr[_DYN_GET_ALL_RESPONSE_HEA5 ]) {
            if (!!isOneDs) {
                theHeaders = _appendHeader(theHeaders, xhr, STR_TIME_DELTA_HEADER);
                theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_HEADER);
                theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_SECONDS_HEADER);
            }
        }
        else {
            theHeaders = convertAllHeadersToMap(xhr[_DYN_GET_ALL_RESPONSE_HEA5 ]());
        }
        return theHeaders;
    }

    var strDocumentMode = "documentMode";
    var strLocation = "location";
    var strConsole = "console";
    var strJSON = "JSON";
    var strCrypto = "crypto";
    var strMsCrypto = "msCrypto";
    var strReactNative = "ReactNative";
    var strMsie = "msie";
    var strTrident = "trident/";
    var strXMLHttpRequest = "XMLHttpRequest";
    var _isTrident = null;
    var _navUserAgentCheck = null;
    var _enableMocks = false;
    var _useXDomainRequest = null;
    var _beaconsSupported = null;
    function _hasProperty(theClass, property) {
        var supported = false;
        if (theClass) {
            try {
                supported = property in theClass;
                if (!supported) {
                    var proto = theClass[strShimPrototype];
                    if (proto) {
                        supported = property in proto;
                    }
                }
            }
            catch (e) {
            }
            if (!supported) {
                try {
                    var tmp = new theClass();
                    supported = !isUndefined(tmp[property]);
                }
                catch (e) {
                }
            }
        }
        return supported;
    }
    function setEnableEnvMocks(enabled) {
        _enableMocks = enabled;
    }
    function getLocation(checkForMock) {
        if (checkForMock && _enableMocks) {
            var mockLocation = getInst("__mockLocation");
            if (mockLocation) {
                return mockLocation;
            }
        }
        if (typeof location === strShimObject && location) {
            return location;
        }
        return getInst(strLocation);
    }
    function getConsole() {
        if (typeof console !== strShimUndefined) {
            return console;
        }
        return getInst(strConsole);
    }
    function hasJSON() {
        return Boolean((typeof JSON === strShimObject && JSON) || getInst(strJSON) !== null);
    }
    function getJSON() {
        if (hasJSON()) {
            return JSON || getInst(strJSON);
        }
        return null;
    }
    function getCrypto() {
        return getInst(strCrypto);
    }
    function getMsCrypto() {
        return getInst(strMsCrypto);
    }
    function isReactNative() {
        var nav = getNavigator();
        if (nav && nav.product) {
            return nav.product === strReactNative;
        }
        return false;
    }
    function isIE() {
        var nav = getNavigator();
        if (nav && (nav[_DYN_USER_AGENT ] !== _navUserAgentCheck || _isTrident === null)) {
            _navUserAgentCheck = nav[_DYN_USER_AGENT ];
            var userAgent = (_navUserAgentCheck || STR_EMPTY$2)[_DYN_TO_LOWER_CASE ]();
            _isTrident = (strContains(userAgent, strMsie) || strContains(userAgent, strTrident));
        }
        return _isTrident;
    }
    function getIEVersion(userAgentStr) {
        if (userAgentStr === void 0) { userAgentStr = null; }
        if (!userAgentStr) {
            var navigator_1 = getNavigator() || {};
            userAgentStr = navigator_1 ? (navigator_1.userAgent || STR_EMPTY$2)[_DYN_TO_LOWER_CASE ]() : STR_EMPTY$2;
        }
        var ua = (userAgentStr || STR_EMPTY$2)[_DYN_TO_LOWER_CASE ]();
        if (strContains(ua, strMsie)) {
            var doc = getDocument() || {};
            return Math.max(parseInt(ua[_DYN_SPLIT ](strMsie)[1]), (doc[strDocumentMode] || 0));
        }
        else if (strContains(ua, strTrident)) {
            var tridentVer = parseInt(ua[_DYN_SPLIT ](strTrident)[1]);
            if (tridentVer) {
                return tridentVer + 4;
            }
        }
        return null;
    }
    function isBeaconsSupported(useCached) {
        if (_beaconsSupported === null || useCached === false) {
            _beaconsSupported = hasNavigator() && Boolean(getNavigator().sendBeacon);
        }
        return _beaconsSupported;
    }
    function isFetchSupported(withKeepAlive) {
        var isSupported = false;
        try {
            isSupported = !!getInst("fetch");
            var request = getInst("Request");
            if (isSupported && withKeepAlive && request) {
                isSupported = _hasProperty(request, "keepalive");
            }
        }
        catch (e) {
        }
        return isSupported;
    }
    function useXDomainRequest() {
        if (_useXDomainRequest === null) {
            _useXDomainRequest = (typeof XDomainRequest !== strShimUndefined);
            if (_useXDomainRequest && isXhrSupported()) {
                _useXDomainRequest = _useXDomainRequest && !_hasProperty(getInst(strXMLHttpRequest), "withCredentials");
            }
        }
        return _useXDomainRequest;
    }
    function isXhrSupported() {
        var isSupported = false;
        try {
            var xmlHttpRequest = getInst(strXMLHttpRequest);
            isSupported = !!xmlHttpRequest;
        }
        catch (e) {
        }
        return isSupported;
    }
    function _getNamedValue(values, name) {
        if (values) {
            for (var i = 0; i < values[_DYN_LENGTH$1 ]; i++) {
                var value = values[i];
                if (value[_DYN_NAME ]) {
                    if (value[_DYN_NAME ] === name) {
                        return value;
                    }
                }
            }
        }
        return {};
    }
    function findMetaTag(name) {
        var doc = getDocument();
        if (doc && name) {
            return _getNamedValue(doc.querySelectorAll("meta"), name).content;
        }
        return null;
    }
    function findNamedServerTiming(name) {
        var value;
        var perf = getPerformance();
        if (perf) {
            var navPerf = perf.getEntriesByType("navigation") || [];
            value = _getNamedValue((navPerf[_DYN_LENGTH$1 ] > 0 ? navPerf[0] : {}).serverTiming, name).description;
        }
        return value;
    }

    var UInt32Mask = 0x100000000;
    var MaxUInt32 = 0xffffffff;
    var SEED1 = 123456789;
    var SEED2 = 987654321;
    var _mwcSeeded = false;
    var _mwcW = SEED1;
    var _mwcZ = SEED2;
    function _mwcSeed(seedValue) {
        if (seedValue < 0) {
            seedValue >>>= 0;
        }
        _mwcW = (SEED1 + seedValue) & MaxUInt32;
        _mwcZ = (SEED2 - seedValue) & MaxUInt32;
        _mwcSeeded = true;
    }
    function _autoSeedMwc() {
        try {
            var now = utcNow() & 0x7fffffff;
            _mwcSeed(((Math.random() * UInt32Mask) ^ now) + now);
        }
        catch (e) {
        }
    }
    function randomValue(maxValue) {
        if (maxValue > 0) {
            return Math.floor((random32() / MaxUInt32) * (maxValue + 1)) >>> 0;
        }
        return 0;
    }
    function random32(signed) {
        var value = 0;
        var c = getCrypto() || getMsCrypto();
        if (c && c.getRandomValues) {
            value = c.getRandomValues(new Uint32Array(1))[0] & MaxUInt32;
        }
        if (value === 0 && isIE()) {
            if (!_mwcSeeded) {
                _autoSeedMwc();
            }
            value = mwcRandom32() & MaxUInt32;
        }
        if (value === 0) {
            value = Math.floor((UInt32Mask * Math.random()) | 0);
        }
        if (!signed) {
            value >>>= 0;
        }
        return value;
    }
    function mwcRandom32(signed) {
        _mwcZ = (36969 * (_mwcZ & 0xFFFF) + (_mwcZ >> 16)) & MaxUInt32;
        _mwcW = (18000 * (_mwcW & 0xFFFF) + (_mwcW >> 16)) & MaxUInt32;
        var value = (((_mwcZ << 16) + (_mwcW & 0xFFFF)) >>> 0) & MaxUInt32 | 0;
        if (!signed) {
            value >>>= 0;
        }
        return value;
    }
    function newId(maxLength) {
        if (maxLength === void 0) { maxLength = 22; }
        var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var number = random32() >>> 0;
        var chars = 0;
        var result = STR_EMPTY$2;
        while (result[_DYN_LENGTH$1 ] < maxLength) {
            chars++;
            result += base64chars.charAt(number & 0x3F);
            number >>>= 6;
            if (chars === 5) {
                number = (((random32() << 2) & 0xFFFFFFFF) | (number & 0x03)) >>> 0;
                chars = 0;
            }
        }
        return result;
    }

    var version = '3.2.2';
    var instanceName = "." + newId(6);
    var _dataUid = 0;
    function _canAcceptData(target) {
        return target[_DYN_NODE_TYPE ] === 1 || target[_DYN_NODE_TYPE ] === 9 || !(+target[_DYN_NODE_TYPE ]);
    }
    function _getCache(data, target) {
        var theCache = target[data.id];
        if (!theCache) {
            theCache = {};
            try {
                if (_canAcceptData(target)) {
                    objDefine(target, data.id, {
                        e: false,
                        v: theCache
                    });
                }
            }
            catch (e) {
            }
        }
        return theCache;
    }
    function createUniqueNamespace(name, includeVersion) {
        if (includeVersion === void 0) { includeVersion = false; }
        return normalizeJsName(name + (_dataUid++) + (includeVersion ? "." + version : STR_EMPTY$2) + instanceName);
    }
    function createElmNodeData(name) {
        var data = {
            id: createUniqueNamespace("_aiData-" + (name || STR_EMPTY$2) + "." + version),
            accept: function (target) {
                return _canAcceptData(target);
            },
            get: function (target, name, defValue, addDefault) {
                var theCache = target[data.id];
                if (!theCache) {
                    if (addDefault) {
                        theCache = _getCache(data, target);
                        theCache[normalizeJsName(name)] = defValue;
                    }
                    return defValue;
                }
                return theCache[normalizeJsName(name)];
            },
            kill: function (target, name) {
                if (target && target[name]) {
                    try {
                        delete target[name];
                    }
                    catch (e) {
                    }
                }
            }
        };
        return data;
    }

    function _isConfigDefaults(value) {
        return (value && isObject(value) && (value.isVal || value.fb || objHasOwn(value, "v") || objHasOwn(value, "mrg") || objHasOwn(value, "ref") || value.set));
    }
    function _getDefault(dynamicHandler, theConfig, cfgDefaults) {
        var defValue;
        var isDefaultValid = cfgDefaults.dfVal || isDefined;
        if (theConfig && cfgDefaults.fb) {
            var fallbacks = cfgDefaults.fb;
            if (!isArray(fallbacks)) {
                fallbacks = [fallbacks];
            }
            for (var lp = 0; lp < fallbacks[_DYN_LENGTH$1 ]; lp++) {
                var fallback = fallbacks[lp];
                var fbValue = theConfig[fallback];
                if (isDefaultValid(fbValue)) {
                    defValue = fbValue;
                }
                else if (dynamicHandler) {
                    fbValue = dynamicHandler.cfg[fallback];
                    if (isDefaultValid(fbValue)) {
                        defValue = fbValue;
                    }
                    dynamicHandler.set(dynamicHandler.cfg, asString(fallback), fbValue);
                }
                if (isDefaultValid(defValue)) {
                    break;
                }
            }
        }
        if (!isDefaultValid(defValue) && isDefaultValid(cfgDefaults.v)) {
            defValue = cfgDefaults.v;
        }
        return defValue;
    }
    function _resolveDefaultValue(dynamicHandler, theConfig, cfgDefaults) {
        var theValue = cfgDefaults;
        if (cfgDefaults && _isConfigDefaults(cfgDefaults)) {
            theValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);
        }
        if (theValue) {
            if (_isConfigDefaults(theValue)) {
                theValue = _resolveDefaultValue(dynamicHandler, theConfig, theValue);
            }
            var newValue_1;
            if (isArray(theValue)) {
                newValue_1 = [];
                newValue_1[_DYN_LENGTH$1 ] = theValue[_DYN_LENGTH$1 ];
            }
            else if (isPlainObject(theValue)) {
                newValue_1 = {};
            }
            if (newValue_1) {
                objForEachKey(theValue, function (key, value) {
                    if (value && _isConfigDefaults(value)) {
                        value = _resolveDefaultValue(dynamicHandler, theConfig, value);
                    }
                    newValue_1[key] = value;
                });
                theValue = newValue_1;
            }
        }
        return theValue;
    }
    function _applyDefaultValue(dynamicHandler, theConfig, name, defaultValue) {
        var isValid;
        var setFn;
        var defValue;
        var cfgDefaults = defaultValue;
        var mergeDf;
        var reference;
        var readOnly;
        var blkDynamicValue;
        if (_isConfigDefaults(cfgDefaults)) {
            isValid = cfgDefaults.isVal;
            setFn = cfgDefaults.set;
            readOnly = cfgDefaults[_DYN_RD_ONLY ];
            blkDynamicValue = cfgDefaults[_DYN_BLK_VAL ];
            mergeDf = cfgDefaults.mrg;
            reference = cfgDefaults.ref;
            if (!reference && isUndefined(reference)) {
                reference = !!mergeDf;
            }
            defValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);
        }
        else {
            defValue = defaultValue;
        }
        if (blkDynamicValue) {
            dynamicHandler[_DYN_BLK_VAL ](theConfig, name);
        }
        var theValue;
        var usingDefault = true;
        var cfgValue = theConfig[name];
        if (cfgValue || !isNullOrUndefined(cfgValue)) {
            theValue = cfgValue;
            usingDefault = false;
            if (isValid && theValue !== defValue && !isValid(theValue)) {
                theValue = defValue;
                usingDefault = true;
            }
            if (setFn) {
                theValue = setFn(theValue, defValue, theConfig);
                usingDefault = theValue === defValue;
            }
        }
        if (!usingDefault) {
            if (isPlainObject(theValue) || isArray(defValue)) {
                if (mergeDf && defValue && (isPlainObject(defValue) || isArray(defValue))) {
                    objForEachKey(defValue, function (dfName, dfValue) {
                        _applyDefaultValue(dynamicHandler, theValue, dfName, dfValue);
                    });
                }
            }
        }
        else if (defValue) {
            theValue = _resolveDefaultValue(dynamicHandler, theConfig, defValue);
        }
        else {
            theValue = defValue;
        }
        dynamicHandler.set(theConfig, name, theValue);
        if (reference) {
            dynamicHandler.ref(theConfig, name);
        }
        if (readOnly) {
            dynamicHandler[_DYN_RD_ONLY ](theConfig, name);
        }
    }

    var CFG_HANDLER_LINK = symbolFor("[[ai_dynCfg_1]]");
    var BLOCK_DYNAMIC = symbolFor("[[ai_blkDynCfg_1]]");
    var FORCE_DYNAMIC = symbolFor("[[ai_frcDynCfg_1]]");
    function _cfgDeepCopy(source) {
        if (source) {
            var target_1;
            if (isArray(source)) {
                target_1 = [];
                target_1[_DYN_LENGTH$1 ] = source[_DYN_LENGTH$1 ];
            }
            else if (isPlainObject(source)) {
                target_1 = {};
            }
            if (target_1) {
                objForEachKey(source, function (key, value) {
                    target_1[key] = _cfgDeepCopy(value);
                });
                return target_1;
            }
        }
        return source;
    }
    function getDynamicConfigHandler(value) {
        if (value) {
            var handler = value[CFG_HANDLER_LINK] || value;
            if (handler.cfg && (handler.cfg === value || handler.cfg[CFG_HANDLER_LINK] === handler)) {
                return handler;
            }
        }
        return null;
    }
    function blockDynamicConversion(value) {
        if (value && (isPlainObject(value) || isArray(value))) {
            try {
                value[BLOCK_DYNAMIC] = true;
            }
            catch (e) {
            }
        }
        return value;
    }
    function forceDynamicConversion(value) {
        if (value) {
            try {
                value[FORCE_DYNAMIC] = true;
            }
            catch (e) {
            }
        }
        return value;
    }
    function _canMakeDynamic(getFunc, state, value) {
        var result = false;
        if (value && !getFunc[state.blkVal]) {
            result = value[FORCE_DYNAMIC];
            if (!result && !value[BLOCK_DYNAMIC]) {
                result = isPlainObject(value) || isArray(value);
            }
        }
        return result;
    }
    function throwInvalidAccess(message) {
        throwTypeError("InvalidAccess:" + message);
    }

    var arrayMethodsToPatch = [
        "push",
        "pop",
        "shift",
        "unshift",
        "splice"
    ];
    var _throwDynamicError = function (logger, name, desc, e) {
        logger && logger[_DYN_THROW_INTERNAL ](3 , 108 , "".concat(desc, " [").concat(name, "] failed - ") + dumpObj(e));
    };
    function _patchArray(state, target, name) {
        if (isArray(target)) {
            arrForEach(arrayMethodsToPatch, function (method) {
                var orgMethod = target[method];
                target[method] = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    var result = orgMethod[_DYN_APPLY ](this, args);
                    _makeDynamicObject(state, target, name, "Patching");
                    return result;
                };
            });
        }
    }
    function _getOwnPropGetter(target, name) {
        var propDesc = objGetOwnPropertyDescriptor(target, name);
        return propDesc && propDesc.get;
    }
    function _createDynamicProperty(state, theConfig, name, value) {
        var detail = {
            n: name,
            h: [],
            trk: function (handler) {
                if (handler && handler.fn) {
                    if (arrIndexOf(detail.h, handler) === -1) {
                        detail.h[_DYN_PUSH ](handler);
                    }
                    state.trk(handler, detail);
                }
            },
            clr: function (handler) {
                var idx = arrIndexOf(detail.h, handler);
                if (idx !== -1) {
                    detail.h[_DYN_SPLICE ](idx, 1);
                }
            }
        };
        var checkDynamic = true;
        var isObjectOrArray = false;
        function _getProperty() {
            if (checkDynamic) {
                isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value);
                if (value && !value[CFG_HANDLER_LINK] && isObjectOrArray) {
                    value = _makeDynamicObject(state, value, name, "Converting");
                }
                checkDynamic = false;
            }
            var activeHandler = state.act;
            if (activeHandler) {
                detail.trk(activeHandler);
            }
            return value;
        }
        _getProperty[state.prop] = {
            chng: function () {
                state.add(detail);
            }
        };
        function _setProperty(newValue) {
            if (value !== newValue) {
                if (!!_getProperty[state.ro] && !state.upd) {
                    throwInvalidAccess("[" + name + "] is read-only:" + dumpObj(theConfig));
                }
                if (checkDynamic) {
                    isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value);
                    checkDynamic = false;
                }
                var isReferenced = isObjectOrArray && _getProperty[state.rf];
                if (isObjectOrArray) {
                    if (isReferenced) {
                        objForEachKey(value, function (key) {
                            value[key] = newValue ? newValue[key] : UNDEFINED_VALUE;
                        });
                        try {
                            objForEachKey(newValue, function (key, theValue) {
                                _setDynamicProperty(state, value, key, theValue);
                            });
                            newValue = value;
                        }
                        catch (e) {
                            _throwDynamicError((state.hdlr || {})[_DYN_LOGGER$1 ], name, "Assigning", e);
                            isObjectOrArray = false;
                        }
                    }
                    else if (value && value[CFG_HANDLER_LINK]) {
                        objForEachKey(value, function (key) {
                            var getter = _getOwnPropGetter(value, key);
                            if (getter) {
                                var valueState = getter[state.prop];
                                valueState && valueState.chng();
                            }
                        });
                    }
                }
                if (newValue !== value) {
                    var newIsObjectOrArray = newValue && _canMakeDynamic(_getProperty, state, newValue);
                    if (!isReferenced && newIsObjectOrArray) {
                        newValue = _makeDynamicObject(state, newValue, name, "Converting");
                    }
                    value = newValue;
                    isObjectOrArray = newIsObjectOrArray;
                }
                state.add(detail);
            }
        }
        objDefine(theConfig, detail.n, { g: _getProperty, s: _setProperty });
    }
    function _setDynamicProperty(state, target, name, value) {
        if (target) {
            var getter = _getOwnPropGetter(target, name);
            var isDynamic = getter && !!getter[state.prop];
            if (!isDynamic) {
                _createDynamicProperty(state, target, name, value);
            }
            else {
                target[name] = value;
            }
        }
        return target;
    }
    function _setDynamicPropertyState(state, target, name, flags) {
        if (target) {
            var getter = _getOwnPropGetter(target, name);
            var isDynamic = getter && !!getter[state.prop];
            var inPlace = flags && flags[0 ];
            var rdOnly = flags && flags[1 ];
            var blkProp = flags && flags[2 ];
            if (!isDynamic) {
                if (blkProp) {
                    try {
                        blockDynamicConversion(target);
                    }
                    catch (e) {
                        _throwDynamicError((state.hdlr || {})[_DYN_LOGGER$1 ], name, "Blocking", e);
                    }
                }
                try {
                    _setDynamicProperty(state, target, name, target[name]);
                    getter = _getOwnPropGetter(target, name);
                }
                catch (e) {
                    _throwDynamicError((state.hdlr || {})[_DYN_LOGGER$1 ], name, "State", e);
                }
            }
            if (inPlace) {
                getter[state.rf] = inPlace;
            }
            if (rdOnly) {
                getter[state.ro] = rdOnly;
            }
            if (blkProp) {
                getter[state.blkVal] = true;
            }
        }
        return target;
    }
    function _makeDynamicObject(state, target, name, desc) {
        try {
            objForEachKey(target, function (key, value) {
                _setDynamicProperty(state, target, key, value);
            });
            if (!target[CFG_HANDLER_LINK]) {
                objDefineProp(target, CFG_HANDLER_LINK, {
                    get: function () {
                        return state[_DYN_HDLR ];
                    }
                });
                _patchArray(state, target, name);
            }
        }
        catch (e) {
            _throwDynamicError((state.hdlr || {})[_DYN_LOGGER$1 ], name, desc, e);
        }
        return target;
    }

    var symPrefix = "[[ai_";
    var symPostfix = "]]";
    function _createState(cfgHandler) {
        var _a;
        var dynamicPropertySymbol = newSymbol(symPrefix + "get" + cfgHandler.uid + symPostfix);
        var dynamicPropertyReadOnly = newSymbol(symPrefix + "ro" + cfgHandler.uid + symPostfix);
        var dynamicPropertyReferenced = newSymbol(symPrefix + "rf" + cfgHandler.uid + symPostfix);
        var dynamicPropertyBlockValue = newSymbol(symPrefix + "blkVal" + cfgHandler.uid + symPostfix);
        var dynamicPropertyDetail = newSymbol(symPrefix + "dtl" + cfgHandler.uid + symPostfix);
        var _waitingHandlers = null;
        var _watcherTimer = null;
        var theState;
        function _useHandler(activeHandler, callback) {
            var prevWatcher = theState.act;
            try {
                theState.act = activeHandler;
                if (activeHandler && activeHandler[dynamicPropertyDetail]) {
                    arrForEach(activeHandler[dynamicPropertyDetail], function (detail) {
                        detail.clr(activeHandler);
                    });
                    activeHandler[dynamicPropertyDetail] = [];
                }
                callback({
                    cfg: cfgHandler.cfg,
                    set: cfgHandler.set.bind(cfgHandler),
                    setDf: cfgHandler[_DYN_SET_DF ].bind(cfgHandler),
                    ref: cfgHandler.ref.bind(cfgHandler),
                    rdOnly: cfgHandler[_DYN_RD_ONLY ].bind(cfgHandler)
                });
            }
            catch (e) {
                var logger = cfgHandler[_DYN_LOGGER$1 ];
                if (logger) {
                    logger[_DYN_THROW_INTERNAL ](1 , 107 , dumpObj(e));
                }
                throw e;
            }
            finally {
                theState.act = prevWatcher || null;
            }
        }
        function _notifyWatchers() {
            if (_waitingHandlers) {
                var notifyHandlers = _waitingHandlers;
                _waitingHandlers = null;
                _watcherTimer && _watcherTimer[_DYN_CANCEL ]();
                _watcherTimer = null;
                var watcherFailures_1 = [];
                arrForEach(notifyHandlers, function (handler) {
                    if (handler) {
                        if (handler[dynamicPropertyDetail]) {
                            arrForEach(handler[dynamicPropertyDetail], function (detail) {
                                detail.clr(handler);
                            });
                            handler[dynamicPropertyDetail] = null;
                        }
                        if (handler.fn) {
                            try {
                                _useHandler(handler, handler.fn);
                            }
                            catch (e) {
                                watcherFailures_1[_DYN_PUSH ](e);
                            }
                        }
                    }
                });
                if (_waitingHandlers) {
                    try {
                        _notifyWatchers();
                    }
                    catch (e) {
                        watcherFailures_1[_DYN_PUSH ](e);
                    }
                }
                if (watcherFailures_1[_DYN_LENGTH$1 ] > 0) {
                    throwAggregationError("Watcher error(s): ", watcherFailures_1);
                }
            }
        }
        function _addWatcher(detail) {
            if (detail && detail.h[_DYN_LENGTH$1 ] > 0) {
                if (!_waitingHandlers) {
                    _waitingHandlers = [];
                }
                if (!_watcherTimer) {
                    _watcherTimer = scheduleTimeout(function () {
                        _watcherTimer = null;
                        _notifyWatchers();
                    }, 0);
                }
                for (var idx = 0; idx < detail.h[_DYN_LENGTH$1 ]; idx++) {
                    var handler = detail.h[idx];
                    if (handler && arrIndexOf(_waitingHandlers, handler) === -1) {
                        _waitingHandlers[_DYN_PUSH ](handler);
                    }
                }
            }
        }
        function _trackHandler(handler, detail) {
            if (handler) {
                var details = handler[dynamicPropertyDetail] = handler[dynamicPropertyDetail] || [];
                if (arrIndexOf(details, detail) === -1) {
                    details[_DYN_PUSH ](detail);
                }
            }
        }
        theState = (_a = {
                prop: dynamicPropertySymbol,
                ro: dynamicPropertyReadOnly,
                rf: dynamicPropertyReferenced
            },
            _a[_DYN_BLK_VAL ] = dynamicPropertyBlockValue,
            _a[_DYN_HDLR ] = cfgHandler,
            _a.add = _addWatcher,
            _a[_DYN_NOTIFY ] = _notifyWatchers,
            _a.use = _useHandler,
            _a.trk = _trackHandler,
            _a);
        return theState;
    }

    function _createAndUseHandler(state, configHandler) {
        var handler = {
            fn: configHandler,
            rm: function () {
                handler.fn = null;
                state = null;
                configHandler = null;
            }
        };
        objDefine(handler, "toJSON", { v: function () { return "WatcherHandler" + (handler.fn ? "" : "[X]"); } });
        state.use(handler, configHandler);
        return handler;
    }
    function _createDynamicHandler(logger, target, inPlace) {
        var _a;
        var dynamicHandler = getDynamicConfigHandler(target);
        if (dynamicHandler) {
            return dynamicHandler;
        }
        var uid = createUniqueNamespace("dyncfg", true);
        var newTarget = (target && inPlace !== false) ? target : _cfgDeepCopy(target);
        var theState;
        function _notifyWatchers() {
            theState[_DYN_NOTIFY ]();
        }
        function _setValue(target, name, value) {
            try {
                target = _setDynamicProperty(theState, target, name, value);
            }
            catch (e) {
                _throwDynamicError(logger, name, "Setting value", e);
            }
            return target[name];
        }
        function _watch(configHandler) {
            return _createAndUseHandler(theState, configHandler);
        }
        function _block(configHandler, allowUpdate) {
            theState.use(null, function (details) {
                var prevUpd = theState.upd;
                try {
                    if (!isUndefined(allowUpdate)) {
                        theState.upd = allowUpdate;
                    }
                    configHandler(details);
                }
                finally {
                    theState.upd = prevUpd;
                }
            });
        }
        function _ref(target, name) {
            var _a;
            return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[0 ] = true, _a))[name];
        }
        function _rdOnly(target, name) {
            var _a;
            return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[1 ] = true, _a))[name];
        }
        function _blkPropValue(target, name) {
            var _a;
            return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[2 ] = true, _a))[name];
        }
        function _applyDefaults(theConfig, defaultValues) {
            if (defaultValues) {
                objForEachKey(defaultValues, function (name, value) {
                    _applyDefaultValue(cfgHandler, theConfig, name, value);
                });
            }
            return theConfig;
        }
        var cfgHandler = (_a = {
                uid: null,
                cfg: newTarget
            },
            _a[_DYN_LOGGER$1 ] = logger,
            _a[_DYN_NOTIFY ] = _notifyWatchers,
            _a.set = _setValue,
            _a[_DYN_SET_DF ] = _applyDefaults,
            _a[_DYN_WATCH ] = _watch,
            _a.ref = _ref,
            _a[_DYN_RD_ONLY ] = _rdOnly,
            _a[_DYN_BLK_VAL ] = _blkPropValue,
            _a._block = _block,
            _a);
        objDefine(cfgHandler, "uid", {
            c: false,
            e: false,
            w: false,
            v: uid
        });
        theState = _createState(cfgHandler);
        _makeDynamicObject(theState, newTarget, "config", "Creating");
        return cfgHandler;
    }
    function _logInvalidAccess(logger, message) {
        if (logger) {
            logger[_DYN_WARN_TO_CONSOLE ](message);
            logger[_DYN_THROW_INTERNAL ](2 , 108 , message);
        }
        else {
            throwInvalidAccess(message);
        }
    }
    function createDynamicConfig(config, defaultConfig, logger, inPlace) {
        var dynamicHandler = _createDynamicHandler(logger, config || {}, inPlace);
        if (defaultConfig) {
            dynamicHandler[_DYN_SET_DF ](dynamicHandler.cfg, defaultConfig);
        }
        return dynamicHandler;
    }
    function onConfigChange(config, configHandler, logger) {
        var handler = config[CFG_HANDLER_LINK] || config;
        if (handler.cfg && (handler.cfg === config || handler.cfg[CFG_HANDLER_LINK] === handler)) {
            return handler[_DYN_WATCH ](configHandler);
        }
        _logInvalidAccess(logger, STR_NOT_DYNAMIC_ERROR + dumpObj(config));
        return createDynamicConfig(config, null, logger)[_DYN_WATCH ](configHandler);
    }

    function runTargetUnload(target, isAsync) {
        if (target && target[_DYN_UNLOAD ]) {
            return target[_DYN_UNLOAD ](isAsync);
        }
    }
    function doUnloadAll(targets, isAsync, done) {
        var result;
        if (!done) {
            result = createPromise(function (resolved) {
                done = resolved;
            });
        }
        if (targets && getLength(targets) > 0) {
            doAwaitResponse(runTargetUnload(targets[0], isAsync), function () {
                doUnloadAll(arrSlice(targets, 1), isAsync, done);
            });
        }
        else {
            done();
        }
        return result;
    }

    var ChannelControllerPriority = 500;
    var DisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";

    function cfgDfMerge(defaultValue) {
        return {
            mrg: true,
            v: defaultValue
        };
    }

    var listenerFuncs = [STR_EVENTS_SENT, STR_EVENTS_DISCARDED, STR_EVENTS_SEND_REQUEST, STR_PERF_EVENT];
    var _aiNamespace = null;
    var _debugListener;
    function _listenerProxyFunc(name, config) {
        return function () {
            var args = arguments;
            var dbgExt = getDebugExt(config);
            if (dbgExt) {
                var listener = dbgExt.listener;
                if (listener && listener[name]) {
                    listener[name][_DYN_APPLY ](listener, args);
                }
            }
        };
    }
    function _getExtensionNamespace() {
        var target = getInst("Microsoft");
        if (target) {
            _aiNamespace = target["ApplicationInsights"];
        }
        return _aiNamespace;
    }
    function getDebugExt(config) {
        var ns = _aiNamespace;
        if (!ns && config.disableDbgExt !== true) {
            ns = _aiNamespace || _getExtensionNamespace();
        }
        return ns ? ns["ChromeDbgExt"] : null;
    }
    function getDebugListener(config) {
        if (!_debugListener) {
            _debugListener = {};
            for (var lp = 0; lp < listenerFuncs[_DYN_LENGTH$1 ]; lp++) {
                _debugListener[listenerFuncs[lp]] = _listenerProxyFunc(listenerFuncs[lp], config);
            }
        }
        return _debugListener;
    }

    var _a$4;
    var STR_WARN_TO_CONSOLE = "warnToConsole";
    var AiNonUserActionablePrefix = "AI (Internal): ";
    var AiUserActionablePrefix = "AI: ";
    var AIInternalMessagePrefix = "AITR_";
    var defaultValues$2 = {
        loggingLevelConsole: 0,
        loggingLevelTelemetry: 1,
        maxMessageLimit: 25,
        enableDebug: false
    };
    var _logFuncs = (_a$4 = {},
        _a$4[0 ] = null,
        _a$4[1 ] = "errorToConsole",
        _a$4[2 ] = STR_WARN_TO_CONSOLE,
        _a$4[3 ] = "debugToConsole",
        _a$4);
    function _sanitizeDiagnosticText(text) {
        if (text) {
            return "\"" + text[_DYN_REPLACE ](/\"/g, STR_EMPTY$2) + "\"";
        }
        return STR_EMPTY$2;
    }
    function _logToConsole(func, message) {
        var theConsole = getConsole();
        if (!!theConsole) {
            var logFunc = "log";
            if (theConsole[func]) {
                logFunc = func;
            }
            if (isFunction(theConsole[logFunc])) {
                theConsole[logFunc](message);
            }
        }
    }
    var _InternalLogMessage = /** @class */ (function () {
        function _InternalLogMessage(msgId, msg, isUserAct, properties) {
            if (isUserAct === void 0) { isUserAct = false; }
            var _self = this;
            _self[_DYN_MESSAGE_ID ] = msgId;
            _self[_DYN_MESSAGE ] =
                (isUserAct ? AiUserActionablePrefix : AiNonUserActionablePrefix) +
                    msgId;
            var strProps = STR_EMPTY$2;
            if (hasJSON()) {
                strProps = getJSON().stringify(properties);
            }
            var diagnosticText = (msg ? " message:" + _sanitizeDiagnosticText(msg) : STR_EMPTY$2) +
                (properties ? " props:" + _sanitizeDiagnosticText(strProps) : STR_EMPTY$2);
            _self[_DYN_MESSAGE ] += diagnosticText;
        }
        _InternalLogMessage.dataType = "MessageData";
        return _InternalLogMessage;
    }());
    function safeGetLogger(core, config) {
        return (core || {})[_DYN_LOGGER$1 ] || new DiagnosticLogger(config);
    }
    var DiagnosticLogger = /** @class */ (function () {
        function DiagnosticLogger(config) {
            this.identifier = "DiagnosticLogger";
            this.queue = [];
            var _messageCount = 0;
            var _messageLogged = {};
            var _loggingLevelConsole;
            var _loggingLevelTelemetry;
            var _maxInternalMessageLimit;
            var _enableDebug;
            var _unloadHandler;
            dynamicProto(DiagnosticLogger, this, function (_self) {
                _unloadHandler = _setDefaultsFromConfig(config || {});
                _self.consoleLoggingLevel = function () { return _loggingLevelConsole; };
                _self[_DYN_THROW_INTERNAL ] = function (severity, msgId, msg, properties, isUserAct) {
                    if (isUserAct === void 0) { isUserAct = false; }
                    var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);
                    if (_enableDebug) {
                        throw dumpObj(message);
                    }
                    else {
                        var logFunc = _logFuncs[severity] || STR_WARN_TO_CONSOLE;
                        if (!isUndefined(message[_DYN_MESSAGE ])) {
                            if (isUserAct) {
                                var messageKey = +message[_DYN_MESSAGE_ID ];
                                if (!_messageLogged[messageKey] && _loggingLevelConsole >= severity) {
                                    _self[logFunc](message[_DYN_MESSAGE ]);
                                    _messageLogged[messageKey] = true;
                                }
                            }
                            else {
                                if (_loggingLevelConsole >= severity) {
                                    _self[logFunc](message[_DYN_MESSAGE ]);
                                }
                            }
                            _logInternalMessage(severity, message);
                        }
                        else {
                            _debugExtMsg("throw" + (severity === 1  ? "Critical" : "Warning"), message);
                        }
                    }
                };
                _self.debugToConsole = function (message) {
                    _logToConsole("debug", message);
                    _debugExtMsg("warning", message);
                };
                _self[_DYN_WARN_TO_CONSOLE ] = function (message) {
                    _logToConsole("warn", message);
                    _debugExtMsg("warning", message);
                };
                _self.errorToConsole = function (message) {
                    _logToConsole("error", message);
                    _debugExtMsg("error", message);
                };
                _self.resetInternalMessageCount = function () {
                    _messageCount = 0;
                    _messageLogged = {};
                };
                _self[_DYN_LOG_INTERNAL_MESSAGE ] = _logInternalMessage;
                _self[_DYN_UNLOAD ] = function (isAsync) {
                    _unloadHandler && _unloadHandler.rm();
                    _unloadHandler = null;
                };
                function _logInternalMessage(severity, message) {
                    if (_areInternalMessagesThrottled()) {
                        return;
                    }
                    var logMessage = true;
                    var messageKey = AIInternalMessagePrefix + message[_DYN_MESSAGE_ID ];
                    if (_messageLogged[messageKey]) {
                        logMessage = false;
                    }
                    else {
                        _messageLogged[messageKey] = true;
                    }
                    if (logMessage) {
                        if (severity <= _loggingLevelTelemetry) {
                            _self.queue[_DYN_PUSH ](message);
                            _messageCount++;
                            _debugExtMsg((severity === 1  ? "error" : "warn"), message);
                        }
                        if (_messageCount === _maxInternalMessageLimit) {
                            var throttleLimitMessage = "Internal events throttle limit per PageView reached for this app.";
                            var throttleMessage = new _InternalLogMessage(23 , throttleLimitMessage, false);
                            _self.queue[_DYN_PUSH ](throttleMessage);
                            if (severity === 1 ) {
                                _self.errorToConsole(throttleLimitMessage);
                            }
                            else {
                                _self[_DYN_WARN_TO_CONSOLE ](throttleLimitMessage);
                            }
                        }
                    }
                }
                function _setDefaultsFromConfig(config) {
                    return onConfigChange(createDynamicConfig(config, defaultValues$2, _self).cfg, function (details) {
                        var config = details.cfg;
                        _loggingLevelConsole = config[_DYN_LOGGING_LEVEL_CONSOL4 ];
                        _loggingLevelTelemetry = config.loggingLevelTelemetry;
                        _maxInternalMessageLimit = config.maxMessageLimit;
                        _enableDebug = config.enableDebug;
                    });
                }
                function _areInternalMessagesThrottled() {
                    return _messageCount >= _maxInternalMessageLimit;
                }
                function _debugExtMsg(name, data) {
                    var dbgExt = getDebugExt(config || {});
                    if (dbgExt && dbgExt[_DYN_DIAG_LOG ]) {
                        dbgExt[_DYN_DIAG_LOG ](name, data);
                    }
                }
            });
        }
        DiagnosticLogger.__ieDyn=1;
        return DiagnosticLogger;
    }());
    function _getLogger(logger) {
        return (logger || new DiagnosticLogger());
    }
    function _throwInternal(logger, severity, msgId, msg, properties, isUserAct) {
        if (isUserAct === void 0) { isUserAct = false; }
        _getLogger(logger)[_DYN_THROW_INTERNAL ](severity, msgId, msg, properties, isUserAct);
    }
    function _warnToConsole(logger, message) {
        _getLogger(logger)[_DYN_WARN_TO_CONSOLE ](message);
    }
    function _logInternalMessage(logger, severity, message) {
        _getLogger(logger)[_DYN_LOG_INTERNAL_MESSAGE ](severity, message);
    }

    var _a$3, _b;
    var strToGMTString = "toGMTString";
    var strToUTCString = "toUTCString";
    var strCookie = "cookie";
    var strExpires = "expires";
    var strIsCookieUseDisabled = "isCookieUseDisabled";
    var strDisableCookiesUsage = "disableCookiesUsage";
    var strConfigCookieMgr = "_ckMgr";
    var _supportsCookies = null;
    var _allowUaSameSite = null;
    var _parsedCookieValue = null;
    var _doc;
    var _cookieCache = {};
    var _globalCookieConfig = {};
    var rootDefaultConfig = (_a$3 = {
            cookieCfg: cfgDfMerge((_b = {},
                _b[STR_DOMAIN] = { fb: "cookieDomain", dfVal: isNotNullOrUndefined },
                _b.path = { fb: "cookiePath", dfVal: isNotNullOrUndefined },
                _b.enabled = UNDEFINED_VALUE,
                _b.ignoreCookies = UNDEFINED_VALUE,
                _b.blockedCookies = UNDEFINED_VALUE,
                _b)),
            cookieDomain: UNDEFINED_VALUE,
            cookiePath: UNDEFINED_VALUE
        },
        _a$3[strDisableCookiesUsage] = UNDEFINED_VALUE,
        _a$3);
    function _getDoc() {
        !_doc && (_doc = getLazy(function () { return getDocument(); }));
    }
    function _gblCookieMgr(config, logger) {
        var inst = createCookieMgr[strConfigCookieMgr] || _globalCookieConfig[strConfigCookieMgr];
        if (!inst) {
            inst = createCookieMgr[strConfigCookieMgr] = createCookieMgr(config, logger);
            _globalCookieConfig[strConfigCookieMgr] = inst;
        }
        return inst;
    }
    function _isMgrEnabled(cookieMgr) {
        if (cookieMgr) {
            return cookieMgr.isEnabled();
        }
        return true;
    }
    function _isIgnoredCookie(cookieMgrCfg, name) {
        if (name && cookieMgrCfg && isArray(cookieMgrCfg.ignoreCookies)) {
            return arrIndexOf(cookieMgrCfg.ignoreCookies, name) !== -1;
        }
        return false;
    }
    function _isBlockedCookie(cookieMgrCfg, name) {
        if (name && cookieMgrCfg && isArray(cookieMgrCfg.blockedCookies)) {
            if (arrIndexOf(cookieMgrCfg.blockedCookies, name) !== -1) {
                return true;
            }
        }
        return _isIgnoredCookie(cookieMgrCfg, name);
    }
    function _isCfgEnabled(rootConfig, cookieMgrConfig) {
        var isCfgEnabled = cookieMgrConfig[_DYN_ENABLED ];
        if (isNullOrUndefined(isCfgEnabled)) {
            var cookieEnabled = void 0;
            if (!isUndefined(rootConfig[strIsCookieUseDisabled])) {
                cookieEnabled = !rootConfig[strIsCookieUseDisabled];
            }
            if (!isUndefined(rootConfig[strDisableCookiesUsage])) {
                cookieEnabled = !rootConfig[strDisableCookiesUsage];
            }
            isCfgEnabled = cookieEnabled;
        }
        return isCfgEnabled;
    }
    function safeGetCookieMgr(core, config) {
        var cookieMgr;
        if (core) {
            cookieMgr = core.getCookieMgr();
        }
        else if (config) {
            var cookieCfg = config.cookieCfg;
            if (cookieCfg && cookieCfg[strConfigCookieMgr]) {
                cookieMgr = cookieCfg[strConfigCookieMgr];
            }
            else {
                cookieMgr = createCookieMgr(config);
            }
        }
        if (!cookieMgr) {
            cookieMgr = _gblCookieMgr(config, (core || {})[_DYN_LOGGER$1 ]);
        }
        return cookieMgr;
    }
    function createCookieMgr(rootConfig, logger) {
        var _a;
        var cookieMgrConfig;
        var _path;
        var _domain;
        var unloadHandler;
        var _enabled;
        var _getCookieFn;
        var _setCookieFn;
        var _delCookieFn;
        rootConfig = createDynamicConfig(rootConfig || _globalCookieConfig, null, logger).cfg;
        unloadHandler = onConfigChange(rootConfig, function (details) {
            details[_DYN_SET_DF ](details.cfg, rootDefaultConfig);
            cookieMgrConfig = details.ref(details.cfg, "cookieCfg");
            _path = cookieMgrConfig[STR_PATH ] || "/";
            _domain = cookieMgrConfig[STR_DOMAIN ];
            _enabled = _isCfgEnabled(rootConfig, cookieMgrConfig) !== false;
            _getCookieFn = cookieMgrConfig.getCookie || _getCookieValue;
            _setCookieFn = cookieMgrConfig.setCookie || _setCookieValue;
            _delCookieFn = cookieMgrConfig.delCookie || _setCookieValue;
        }, logger);
        var cookieMgr = (_a = {
                isEnabled: function () {
                    var enabled = _isCfgEnabled(rootConfig, cookieMgrConfig) !== false && _enabled && areCookiesSupported(logger);
                    var gblManager = _globalCookieConfig[strConfigCookieMgr];
                    if (enabled && gblManager && cookieMgr !== gblManager) {
                        enabled = _isMgrEnabled(gblManager);
                    }
                    return enabled;
                },
                setEnabled: function (value) {
                    _enabled = value !== false;
                    cookieMgrConfig[_DYN_ENABLED ] = value;
                },
                set: function (name, value, maxAgeSec, domain, path) {
                    var result = false;
                    if (_isMgrEnabled(cookieMgr) && !_isBlockedCookie(cookieMgrConfig, name)) {
                        var values = {};
                        var theValue = strTrim(value || STR_EMPTY$2);
                        var idx = strIndexOf(theValue, ";");
                        if (idx !== -1) {
                            theValue = strTrim(strLeft(value, idx));
                            values = _extractParts(strSubstring(value, idx + 1));
                        }
                        setValue(values, STR_DOMAIN, domain || _domain, isTruthy, isUndefined);
                        if (!isNullOrUndefined(maxAgeSec)) {
                            var _isIE = isIE();
                            if (isUndefined(values[strExpires])) {
                                var nowMs = utcNow();
                                var expireMs = nowMs + (maxAgeSec * 1000);
                                if (expireMs > 0) {
                                    var expiry = new Date();
                                    expiry.setTime(expireMs);
                                    setValue(values, strExpires, _formatDate(expiry, !_isIE ? strToUTCString : strToGMTString) || _formatDate(expiry, _isIE ? strToGMTString : strToUTCString) || STR_EMPTY$2, isTruthy);
                                }
                            }
                            if (!_isIE) {
                                setValue(values, "max-age", STR_EMPTY$2 + maxAgeSec, null, isUndefined);
                            }
                        }
                        var location_1 = getLocation();
                        if (location_1 && location_1[_DYN_PROTOCOL ] === "https:") {
                            setValue(values, "secure", null, null, isUndefined);
                            if (_allowUaSameSite === null) {
                                _allowUaSameSite = !uaDisallowsSameSiteNone((getNavigator() || {})[_DYN_USER_AGENT ]);
                            }
                            if (_allowUaSameSite) {
                                setValue(values, "SameSite", "None", null, isUndefined);
                            }
                        }
                        setValue(values, STR_PATH, path || _path, null, isUndefined);
                        _setCookieFn(name, _formatCookieValue(theValue, values));
                        result = true;
                    }
                    return result;
                },
                get: function (name) {
                    var value = STR_EMPTY$2;
                    if (_isMgrEnabled(cookieMgr) && !_isIgnoredCookie(cookieMgrConfig, name)) {
                        value = _getCookieFn(name);
                    }
                    return value;
                },
                del: function (name, path) {
                    var result = false;
                    if (_isMgrEnabled(cookieMgr)) {
                        result = cookieMgr.purge(name, path);
                    }
                    return result;
                },
                purge: function (name, path) {
                    var _a;
                    var result = false;
                    if (areCookiesSupported(logger)) {
                        var values = (_a = {},
                            _a[STR_PATH] = path ? path : "/",
                            _a[strExpires] = "Thu, 01 Jan 1970 00:00:01 GMT",
                            _a);
                        if (!isIE()) {
                            values["max-age"] = "0";
                        }
                        _delCookieFn(name, _formatCookieValue(STR_EMPTY$2, values));
                        result = true;
                    }
                    return result;
                }
            },
            _a[_DYN_UNLOAD ] = function (isAsync) {
                unloadHandler && unloadHandler.rm();
                unloadHandler = null;
            },
            _a);
        cookieMgr[strConfigCookieMgr] = cookieMgr;
        return cookieMgr;
    }
    function areCookiesSupported(logger) {
        if (_supportsCookies === null) {
            _supportsCookies = false;
            !_doc && _getDoc();
            try {
                var doc = _doc.v || {};
                _supportsCookies = doc[strCookie] !== undefined;
            }
            catch (e) {
                _throwInternal(logger, 2 , 68 , "Cannot access document.cookie - " + getExceptionName(e), { exception: dumpObj(e) });
            }
        }
        return _supportsCookies;
    }
    function _extractParts(theValue) {
        var values = {};
        if (theValue && theValue[_DYN_LENGTH$1 ]) {
            var parts = strTrim(theValue)[_DYN_SPLIT ](";");
            arrForEach(parts, function (thePart) {
                thePart = strTrim(thePart || STR_EMPTY$2);
                if (thePart) {
                    var idx = strIndexOf(thePart, "=");
                    if (idx === -1) {
                        values[thePart] = null;
                    }
                    else {
                        values[strTrim(strLeft(thePart, idx))] = strTrim(strSubstring(thePart, idx + 1));
                    }
                }
            });
        }
        return values;
    }
    function _formatDate(theDate, func) {
        if (isFunction(theDate[func])) {
            return theDate[func]();
        }
        return null;
    }
    function _formatCookieValue(value, values) {
        var cookieValue = value || STR_EMPTY$2;
        objForEachKey(values, function (name, theValue) {
            cookieValue += "; " + name + (!isNullOrUndefined(theValue) ? "=" + theValue : STR_EMPTY$2);
        });
        return cookieValue;
    }
    function _getCookieValue(name) {
        var cookieValue = STR_EMPTY$2;
        !_doc && _getDoc();
        if (_doc.v) {
            var theCookie = _doc.v[strCookie] || STR_EMPTY$2;
            if (_parsedCookieValue !== theCookie) {
                _cookieCache = _extractParts(theCookie);
                _parsedCookieValue = theCookie;
            }
            cookieValue = strTrim(_cookieCache[name] || STR_EMPTY$2);
        }
        return cookieValue;
    }
    function _setCookieValue(name, cookieValue) {
        !_doc && _getDoc();
        if (_doc.v) {
            _doc.v[strCookie] = name + "=" + cookieValue;
        }
    }
    function uaDisallowsSameSiteNone(userAgent) {
        if (!isString(userAgent)) {
            return false;
        }
        if (strContains(userAgent, "CPU iPhone OS 12") || strContains(userAgent, "iPad; CPU OS 12")) {
            return true;
        }
        if (strContains(userAgent, "Macintosh; Intel Mac OS X 10_14") && strContains(userAgent, "Version/") && strContains(userAgent, "Safari")) {
            return true;
        }
        if (strContains(userAgent, "Macintosh; Intel Mac OS X 10_14") && strEndsWith(userAgent, "AppleWebKit/605.1.15 (KHTML, like Gecko)")) {
            return true;
        }
        if (strContains(userAgent, "Chrome/5") || strContains(userAgent, "Chrome/6")) {
            return true;
        }
        if (strContains(userAgent, "UnrealEngine") && !strContains(userAgent, "Chrome")) {
            return true;
        }
        if (strContains(userAgent, "UCBrowser/12") || strContains(userAgent, "UCBrowser/11")) {
            return true;
        }
        return false;
    }

    var defaultValues$1 = {
        perfEvtsSendAll: false
    };
    function _runScheduledListeners(asyncNotifications) {
        asyncNotifications.h = null;
        var callbacks = asyncNotifications.cb;
        asyncNotifications.cb = [];
        arrForEach(callbacks, function (cb) {
            safe(cb.fn, [cb.arg]);
        });
    }
    function _runListeners(listeners, name, asyncNotifications, callback) {
        arrForEach(listeners, function (listener) {
            if (listener && listener[name]) {
                if (asyncNotifications) {
                    asyncNotifications.cb[_DYN_PUSH ]({
                        fn: callback,
                        arg: listener
                    });
                    asyncNotifications.h = asyncNotifications.h || scheduleTimeout(_runScheduledListeners, 0, asyncNotifications);
                }
                else {
                    safe(callback, [listener]);
                }
            }
        });
    }
    var NotificationManager = /** @class */ (function () {
        function NotificationManager(config) {
            this.listeners = [];
            var perfEvtsSendAll;
            var unloadHandler;
            var _listeners = [];
            var _asyncNotifications = {
                h: null,
                cb: []
            };
            var cfgHandler = createDynamicConfig(config, defaultValues$1);
            unloadHandler = cfgHandler[_DYN_WATCH ](function (details) {
                perfEvtsSendAll = !!details.cfg.perfEvtsSendAll;
            });
            dynamicProto(NotificationManager, this, function (_self) {
                objDefine(_self, "listeners", {
                    g: function () { return _listeners; }
                });
                _self[_DYN_ADD_NOTIFICATION_LIS1 ] = function (listener) {
                    _listeners[_DYN_PUSH ](listener);
                };
                _self[_DYN_REMOVE_NOTIFICATION_0 ] = function (listener) {
                    var index = arrIndexOf(_listeners, listener);
                    while (index > -1) {
                        _listeners[_DYN_SPLICE ](index, 1);
                        index = arrIndexOf(_listeners, listener);
                    }
                };
                _self[STR_EVENTS_SENT ] = function (events) {
                    _runListeners(_listeners, STR_EVENTS_SENT, _asyncNotifications, function (listener) {
                        listener[STR_EVENTS_SENT ](events);
                    });
                };
                _self[STR_EVENTS_DISCARDED ] = function (events, reason) {
                    _runListeners(_listeners, STR_EVENTS_DISCARDED, _asyncNotifications, function (listener) {
                        listener[STR_EVENTS_DISCARDED ](events, reason);
                    });
                };
                _self[STR_EVENTS_SEND_REQUEST ] = function (sendReason, isAsync) {
                    _runListeners(_listeners, STR_EVENTS_SEND_REQUEST, isAsync ? _asyncNotifications : null, function (listener) {
                        listener[STR_EVENTS_SEND_REQUEST ](sendReason, isAsync);
                    });
                };
                _self[STR_PERF_EVENT ] = function (perfEvent) {
                    if (perfEvent) {
                        if (perfEvtsSendAll || !perfEvent[_DYN_IS_CHILD_EVT ]()) {
                            _runListeners(_listeners, STR_PERF_EVENT, null, function (listener) {
                                if (perfEvent[_DYN_IS_ASYNC ]) {
                                    scheduleTimeout(function () { return listener[STR_PERF_EVENT ](perfEvent); }, 0);
                                }
                                else {
                                    listener[STR_PERF_EVENT ](perfEvent);
                                }
                            });
                        }
                    }
                };
                _self[STR_OFFLINE_STORE ] = function (events) {
                    if (events && events[_DYN_LENGTH$1 ]) {
                        _runListeners(_listeners, STR_OFFLINE_STORE, _asyncNotifications, function (listener) {
                            listener[STR_OFFLINE_STORE ](events);
                        });
                    }
                };
                _self[STR_OFFLINE_SENT ] = function (batch) {
                    if (batch && batch[_DYN_DATA ]) {
                        _runListeners(_listeners, STR_OFFLINE_SENT, _asyncNotifications, function (listener) {
                            listener[STR_OFFLINE_SENT ](batch);
                        });
                    }
                };
                _self[STR_OFFLINE_DROP ] = function (cnt, reason) {
                    if (cnt > 0) {
                        var rn_1 = reason || 0;
                        _runListeners(_listeners, STR_OFFLINE_DROP, _asyncNotifications, function (listener) {
                            listener[STR_OFFLINE_DROP ](cnt, rn_1);
                        });
                    }
                };
                _self[_DYN_UNLOAD ] = function (isAsync) {
                    var _finishUnload = function () {
                        unloadHandler && unloadHandler.rm();
                        unloadHandler = null;
                        _listeners = [];
                        _asyncNotifications.h && _asyncNotifications.h[_DYN_CANCEL ]();
                        _asyncNotifications.h = null;
                        _asyncNotifications.cb = [];
                    };
                    var waiting;
                    _runListeners(_listeners, "unload", null, function (listener) {
                        var asyncUnload = listener[_DYN_UNLOAD ](isAsync);
                        if (asyncUnload) {
                            if (!waiting) {
                                waiting = [];
                            }
                            waiting[_DYN_PUSH ](asyncUnload);
                        }
                    });
                    if (waiting) {
                        return createPromise(function (resolve) {
                            return doAwaitResponse(createAllPromise(waiting), function () {
                                _finishUnload();
                                resolve();
                            });
                        });
                    }
                    else {
                        _finishUnload();
                    }
                };
            });
        }
        NotificationManager.__ieDyn=1;
        return NotificationManager;
    }());

    var strExecutionContextKey = "ctx";
    var strParentContextKey = "ParentContextKey";
    var strChildrenContextKey = "ChildrenContextKey";
    var _defaultPerfManager = null;
    var PerfEvent = /** @class */ (function () {
        function PerfEvent(name, payloadDetails, isAsync) {
            var _self = this;
            _self.start = utcNow();
            _self[_DYN_NAME ] = name;
            _self[_DYN_IS_ASYNC ] = isAsync;
            _self[_DYN_IS_CHILD_EVT ] = function () { return false; };
            if (isFunction(payloadDetails)) {
                var theDetails_1;
                objDefine(_self, "payload", {
                    g: function () {
                        if (!theDetails_1 && isFunction(payloadDetails)) {
                            theDetails_1 = payloadDetails();
                            payloadDetails = null;
                        }
                        return theDetails_1;
                    }
                });
            }
            _self[_DYN_GET_CTX ] = function (key) {
                if (key) {
                    if (key === PerfEvent[strParentContextKey] || key === PerfEvent[strChildrenContextKey]) {
                        return _self[key];
                    }
                    return (_self[strExecutionContextKey] || {})[key];
                }
                return null;
            };
            _self[_DYN_SET_CTX ] = function (key, value) {
                if (key) {
                    if (key === PerfEvent[strParentContextKey]) {
                        if (!_self[key]) {
                            _self[_DYN_IS_CHILD_EVT ] = function () { return true; };
                        }
                        _self[key] = value;
                    }
                    else if (key === PerfEvent[strChildrenContextKey]) {
                        _self[key] = value;
                    }
                    else {
                        var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};
                        ctx[key] = value;
                    }
                }
            };
            _self[_DYN_COMPLETE ] = function () {
                var childTime = 0;
                var childEvts = _self[_DYN_GET_CTX ](PerfEvent[strChildrenContextKey]);
                if (isArray(childEvts)) {
                    for (var lp = 0; lp < childEvts[_DYN_LENGTH$1 ]; lp++) {
                        var childEvt = childEvts[lp];
                        if (childEvt) {
                            childTime += childEvt[_DYN_TIME ];
                        }
                    }
                }
                _self[_DYN_TIME ] = utcNow() - _self.start;
                _self.exTime = _self[_DYN_TIME ] - childTime;
                _self[_DYN_COMPLETE ] = function () { };
            };
        }
        PerfEvent.ParentContextKey = "parent";
        PerfEvent.ChildrenContextKey = "childEvts";
        return PerfEvent;
    }());
    var PerfManager = /** @class */ (function () {
        function PerfManager(manager) {
            this.ctx = {};
            dynamicProto(PerfManager, this, function (_self) {
                _self.create = function (src, payloadDetails, isAsync) {
                    return new PerfEvent(src, payloadDetails, isAsync);
                };
                _self.fire = function (perfEvent) {
                    if (perfEvent) {
                        perfEvent[_DYN_COMPLETE ]();
                        if (manager && isFunction(manager[STR_PERF_EVENT ])) {
                            manager[STR_PERF_EVENT ](perfEvent);
                        }
                    }
                };
                _self[_DYN_SET_CTX ] = function (key, value) {
                    if (key) {
                        var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};
                        ctx[key] = value;
                    }
                };
                _self[_DYN_GET_CTX ] = function (key) {
                    return (_self[strExecutionContextKey] || {})[key];
                };
            });
        }
        PerfManager.__ieDyn=1;
        return PerfManager;
    }());
    var doPerfActiveKey = "CoreUtils.doPerf";
    function doPerf(mgrSource, getSource, func, details, isAsync) {
        if (mgrSource) {
            var perfMgr = mgrSource;
            if (perfMgr[STR_GET_PERF_MGR]) {
                perfMgr = perfMgr[STR_GET_PERF_MGR]();
            }
            if (perfMgr) {
                var perfEvt = void 0;
                var currentActive = perfMgr[_DYN_GET_CTX ](doPerfActiveKey);
                try {
                    perfEvt = perfMgr.create(getSource(), details, isAsync);
                    if (perfEvt) {
                        if (currentActive && perfEvt[_DYN_SET_CTX ]) {
                            perfEvt[_DYN_SET_CTX ](PerfEvent[strParentContextKey], currentActive);
                            if (currentActive[_DYN_GET_CTX ] && currentActive[_DYN_SET_CTX ]) {
                                var children = currentActive[_DYN_GET_CTX ](PerfEvent[strChildrenContextKey]);
                                if (!children) {
                                    children = [];
                                    currentActive[_DYN_SET_CTX ](PerfEvent[strChildrenContextKey], children);
                                }
                                children[_DYN_PUSH ](perfEvt);
                            }
                        }
                        perfMgr[_DYN_SET_CTX ](doPerfActiveKey, perfEvt);
                        return func(perfEvt);
                    }
                }
                catch (ex) {
                    if (perfEvt && perfEvt[_DYN_SET_CTX ]) {
                        perfEvt[_DYN_SET_CTX ]("exception", ex);
                    }
                }
                finally {
                    if (perfEvt) {
                        perfMgr.fire(perfEvt);
                    }
                    perfMgr[_DYN_SET_CTX ](doPerfActiveKey, currentActive);
                }
            }
        }
        return func();
    }
    function getGblPerfMgr() {
        return _defaultPerfManager;
    }

    function newGuid() {
        var uuid = generateW3CId();
        return strSubstring(uuid, 0, 8) + "-" + strSubstring(uuid, 8, 12) + "-" + strSubstring(uuid, 12, 16) + "-" + strSubstring(uuid, 16, 20) + "-" + strSubstring(uuid, 20);
    }
    function generateW3CId() {
        var hexValues = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
        var oct = STR_EMPTY$2, tmp;
        for (var a = 0; a < 4; a++) {
            tmp = random32();
            oct +=
                hexValues[tmp & 0xF] +
                    hexValues[tmp >> 4 & 0xF] +
                    hexValues[tmp >> 8 & 0xF] +
                    hexValues[tmp >> 12 & 0xF] +
                    hexValues[tmp >> 16 & 0xF] +
                    hexValues[tmp >> 20 & 0xF] +
                    hexValues[tmp >> 24 & 0xF] +
                    hexValues[tmp >> 28 & 0xF];
        }
        var clockSequenceHi = hexValues[8 + (random32() & 0x03) | 0];
        return strSubstr(oct, 0, 8) + strSubstr(oct, 9, 4) + "4" + strSubstr(oct, 13, 3) + clockSequenceHi + strSubstr(oct, 16, 3) + strSubstr(oct, 19, 12);
    }

    var TRACE_PARENT_REGEX = /^([\da-f]{2})-([\da-f]{32})-([\da-f]{16})-([\da-f]{2})(-[^\s]{1,64})?$/i;
    var DEFAULT_VERSION = "00";
    var INVALID_VERSION = "ff";
    var INVALID_TRACE_ID = "00000000000000000000000000000000";
    var INVALID_SPAN_ID = "0000000000000000";
    var SAMPLED_FLAG = 0x01;
    function _isValid(value, len, invalidValue) {
        if (value && value[_DYN_LENGTH$1 ] === len && value !== invalidValue) {
            return !!value.match(/^[\da-f]*$/i);
        }
        return false;
    }
    function _formatValue(value, len, defValue) {
        if (_isValid(value, len)) {
            return value;
        }
        return defValue;
    }
    function _formatFlags(value) {
        if (isNaN(value) || value < 0 || value > 255) {
            value = 0x01;
        }
        var result = value.toString(16);
        while (result[_DYN_LENGTH$1 ] < 2) {
            result = "0" + result;
        }
        return result;
    }
    function createTraceParent(traceId, spanId, flags, version) {
        var _a;
        return _a = {},
            _a[_DYN_VERSION ] = _isValid(version, 2, INVALID_VERSION) ? version : DEFAULT_VERSION,
            _a[_DYN_TRACE_ID ] = isValidTraceId(traceId) ? traceId : generateW3CId(),
            _a[_DYN_SPAN_ID ] = isValidSpanId(spanId) ? spanId : strLeft(generateW3CId(), 16),
            _a.traceFlags = flags >= 0 && flags <= 0xFF ? flags : 1,
            _a;
    }
    function parseTraceParent(value, selectIdx) {
        var _a;
        if (!value) {
            return null;
        }
        if (isArray(value)) {
            value = value[0] || "";
        }
        if (!value || !isString(value) || value[_DYN_LENGTH$1 ] > 8192) {
            return null;
        }
        if (value.indexOf(",") !== -1) {
            var values = value[_DYN_SPLIT ](",");
            value = values[selectIdx > 0 && values[_DYN_LENGTH$1 ] > selectIdx ? selectIdx : 0];
        }
        var match = TRACE_PARENT_REGEX.exec(strTrim(value));
        if (!match ||
            match[1] === INVALID_VERSION ||
            match[2] === INVALID_TRACE_ID ||
            match[3] === INVALID_SPAN_ID) {
            return null;
        }
        return _a = {
                version: (match[1] || STR_EMPTY$2)[_DYN_TO_LOWER_CASE ](),
                traceId: (match[2] || STR_EMPTY$2)[_DYN_TO_LOWER_CASE ](),
                spanId: (match[3] || STR_EMPTY$2)[_DYN_TO_LOWER_CASE ]()
            },
            _a[_DYN_TRACE_FLAGS ] = parseInt(match[4], 16),
            _a;
    }
    function isValidTraceId(value) {
        return _isValid(value, 32, INVALID_TRACE_ID);
    }
    function isValidSpanId(value) {
        return _isValid(value, 16, INVALID_SPAN_ID);
    }
    function isValidTraceParent(value) {
        if (!value ||
            !_isValid(value[_DYN_VERSION ], 2, INVALID_VERSION) ||
            !_isValid(value[_DYN_TRACE_ID ], 32, INVALID_TRACE_ID) ||
            !_isValid(value[_DYN_SPAN_ID ], 16, INVALID_SPAN_ID) ||
            !_isValid(_formatFlags(value[_DYN_TRACE_FLAGS ]), 2)) {
            return false;
        }
        return true;
    }
    function isSampledFlag(value) {
        if (isValidTraceParent(value)) {
            return (value[_DYN_TRACE_FLAGS ] & SAMPLED_FLAG) === SAMPLED_FLAG;
        }
        return false;
    }
    function formatTraceParent(value) {
        if (value) {
            var flags = _formatFlags(value[_DYN_TRACE_FLAGS ]);
            if (!_isValid(flags, 2)) {
                flags = "01";
            }
            var version = value[_DYN_VERSION ] || DEFAULT_VERSION;
            if (version !== "00" && version !== "ff") {
                version = DEFAULT_VERSION;
            }
            return "".concat(version.toLowerCase(), "-").concat(_formatValue(value.traceId, 32, INVALID_TRACE_ID).toLowerCase(), "-").concat(_formatValue(value.spanId, 16, INVALID_SPAN_ID).toLowerCase(), "-").concat(flags.toLowerCase());
        }
        return "";
    }
    function findW3cTraceParent(selectIdx) {
        var name = "traceparent";
        var traceParent = parseTraceParent(findMetaTag(name), selectIdx);
        if (!traceParent) {
            traceParent = parseTraceParent(findNamedServerTiming(name), selectIdx);
        }
        return traceParent;
    }

    var pluginStateData = createElmNodeData("plugin");
    function _getPluginState(plugin) {
        return pluginStateData.get(plugin, "state", {}, true);
    }
    function initializePlugins(processContext, extensions) {
        var initPlugins = [];
        var lastPlugin = null;
        var proxy = processContext[_DYN_GET_NEXT ]();
        var pluginState;
        while (proxy) {
            var thePlugin = proxy[_DYN_GET_PLUGIN ]();
            if (thePlugin) {
                if (lastPlugin && lastPlugin[_DYN_SET_NEXT_PLUGIN ] && thePlugin[STR_PROCESS_TELEMETRY ]) {
                    lastPlugin[_DYN_SET_NEXT_PLUGIN ](thePlugin);
                }
                pluginState = _getPluginState(thePlugin);
                var isInitialized = !!pluginState[_DYN_IS_INITIALIZED ];
                if (thePlugin[_DYN_IS_INITIALIZED ]) {
                    isInitialized = thePlugin[_DYN_IS_INITIALIZED ]();
                }
                if (!isInitialized) {
                    initPlugins[_DYN_PUSH ](thePlugin);
                }
                lastPlugin = thePlugin;
                proxy = proxy[_DYN_GET_NEXT ]();
            }
        }
        arrForEach(initPlugins, function (thePlugin) {
            var core = processContext[STR_CORE ]();
            thePlugin[_DYN_INITIALIZE$1 ](processContext.getCfg(), core, extensions, processContext[_DYN_GET_NEXT ]());
            pluginState = _getPluginState(thePlugin);
            if (!thePlugin[STR_CORE] && !pluginState[STR_CORE]) {
                pluginState[STR_CORE] = core;
            }
            pluginState[_DYN_IS_INITIALIZED ] = true;
            delete pluginState[_DYN_TEARDOWN ];
        });
    }
    function sortPlugins(plugins) {
        return plugins.sort(function (extA, extB) {
            var result = 0;
            if (extB) {
                var bHasProcess = extB[STR_PROCESS_TELEMETRY];
                if (extA[STR_PROCESS_TELEMETRY]) {
                    result = bHasProcess ? extA[STR_PRIORITY] - extB[STR_PRIORITY] : 1;
                }
                else if (bHasProcess) {
                    result = -1;
                }
            }
            else {
                result = extA ? 1 : -1;
            }
            return result;
        });
    }
    function createDistributedTraceContext(parentCtx) {
        var trace = {};
        return {
            getName: function () {
                return trace[_DYN_NAME ];
            },
            setName: function (newValue) {
                parentCtx && parentCtx.setName(newValue);
                trace[_DYN_NAME ] = newValue;
            },
            getTraceId: function () {
                return trace[_DYN_TRACE_ID ];
            },
            setTraceId: function (newValue) {
                parentCtx && parentCtx.setTraceId(newValue);
                if (isValidTraceId(newValue)) {
                    trace[_DYN_TRACE_ID ] = newValue;
                }
            },
            getSpanId: function () {
                return trace[_DYN_SPAN_ID ];
            },
            setSpanId: function (newValue) {
                parentCtx && parentCtx.setSpanId(newValue);
                if (isValidSpanId(newValue)) {
                    trace[_DYN_SPAN_ID ] = newValue;
                }
            },
            getTraceFlags: function () {
                return trace[_DYN_TRACE_FLAGS ];
            },
            setTraceFlags: function (newTraceFlags) {
                parentCtx && parentCtx.setTraceFlags(newTraceFlags);
                trace[_DYN_TRACE_FLAGS ] = newTraceFlags;
            }
        };
    }

    var strTelemetryPluginChain = "TelemetryPluginChain";
    var strHasRunFlags = "_hasRun";
    var strGetTelCtx = "_getTelCtx";
    var _chainId = 0;
    function _getNextProxyStart(proxy, core, startAt) {
        while (proxy) {
            if (proxy[_DYN_GET_PLUGIN ]() === startAt) {
                return proxy;
            }
            proxy = proxy[_DYN_GET_NEXT ]();
        }
        return createTelemetryProxyChain([startAt], core.config || {}, core);
    }
    function _createInternalContext(telemetryChain, dynamicHandler, core, startAt) {
        var _nextProxy = null;
        var _onComplete = [];
        if (!dynamicHandler) {
            dynamicHandler = createDynamicConfig({}, null, core[_DYN_LOGGER$1 ]);
        }
        if (startAt !== null) {
            _nextProxy = startAt ? _getNextProxyStart(telemetryChain, core, startAt) : telemetryChain;
        }
        var context = {
            _next: _moveNext,
            ctx: {
                core: function () {
                    return core;
                },
                diagLog: function () {
                    return safeGetLogger(core, dynamicHandler.cfg);
                },
                getCfg: function () {
                    return dynamicHandler.cfg;
                },
                getExtCfg: _resolveExtCfg,
                getConfig: _getConfig,
                hasNext: function () {
                    return !!_nextProxy;
                },
                getNext: function () {
                    return _nextProxy;
                },
                setNext: function (nextPlugin) {
                    _nextProxy = nextPlugin;
                },
                iterate: _iterateChain,
                onComplete: _addOnComplete
            }
        };
        function _addOnComplete(onComplete, that) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            if (onComplete) {
                _onComplete[_DYN_PUSH ]({
                    func: onComplete,
                    self: !isUndefined(that) ? that : context.ctx,
                    args: args
                });
            }
        }
        function _moveNext() {
            var nextProxy = _nextProxy;
            _nextProxy = nextProxy ? nextProxy[_DYN_GET_NEXT ]() : null;
            if (!nextProxy) {
                var onComplete = _onComplete;
                if (onComplete && onComplete[_DYN_LENGTH$1 ] > 0) {
                    arrForEach(onComplete, function (completeDetails) {
                        try {
                            completeDetails.func.call(completeDetails.self, completeDetails.args);
                        }
                        catch (e) {
                            _throwInternal(core[_DYN_LOGGER$1 ], 2 , 73 , "Unexpected Exception during onComplete - " + dumpObj(e));
                        }
                    });
                    _onComplete = [];
                }
            }
            return nextProxy;
        }
        function _getExtCfg(identifier, createIfMissing) {
            var idCfg = null;
            var cfg = dynamicHandler.cfg;
            if (cfg && identifier) {
                var extCfg = cfg[STR_EXTENSION_CONFIG ];
                if (!extCfg && createIfMissing) {
                    extCfg = {};
                }
                cfg[STR_EXTENSION_CONFIG] = extCfg;
                extCfg = dynamicHandler.ref(cfg, STR_EXTENSION_CONFIG);
                if (extCfg) {
                    idCfg = extCfg[identifier];
                    if (!idCfg && createIfMissing) {
                        idCfg = {};
                    }
                    extCfg[identifier] = idCfg;
                    idCfg = dynamicHandler.ref(extCfg, identifier);
                }
            }
            return idCfg;
        }
        function _resolveExtCfg(identifier, defaultValues) {
            var newConfig = _getExtCfg(identifier, true);
            if (defaultValues) {
                objForEachKey(defaultValues, function (field, defaultValue) {
                    if (isNullOrUndefined(newConfig[field])) {
                        var cfgValue = dynamicHandler.cfg[field];
                        if (cfgValue || !isNullOrUndefined(cfgValue)) {
                            newConfig[field] = cfgValue;
                        }
                    }
                    _applyDefaultValue(dynamicHandler, newConfig, field, defaultValue);
                });
            }
            return dynamicHandler[_DYN_SET_DF ](newConfig, defaultValues);
        }
        function _getConfig(identifier, field, defaultValue) {
            if (defaultValue === void 0) { defaultValue = false; }
            var theValue;
            var extConfig = _getExtCfg(identifier, false);
            var rootConfig = dynamicHandler.cfg;
            if (extConfig && (extConfig[field] || !isNullOrUndefined(extConfig[field]))) {
                theValue = extConfig[field];
            }
            else if (rootConfig[field] || !isNullOrUndefined(rootConfig[field])) {
                theValue = rootConfig[field];
            }
            return (theValue || !isNullOrUndefined(theValue)) ? theValue : defaultValue;
        }
        function _iterateChain(cb) {
            var nextPlugin;
            while (!!(nextPlugin = context._next())) {
                var plugin = nextPlugin[_DYN_GET_PLUGIN ]();
                if (plugin) {
                    cb(plugin);
                }
            }
        }
        return context;
    }
    function createProcessTelemetryContext(telemetryChain, cfg, core, startAt) {
        var config = createDynamicConfig(cfg);
        var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
        var context = internalContext.ctx;
        function _processNext(env) {
            var nextPlugin = internalContext._next();
            if (nextPlugin) {
                nextPlugin[STR_PROCESS_TELEMETRY ](env, context);
            }
            return !nextPlugin;
        }
        function _createNew(plugins, startAt) {
            if (plugins === void 0) { plugins = null; }
            if (isArray(plugins)) {
                plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt);
            }
            return createProcessTelemetryContext(plugins || context[_DYN_GET_NEXT ](), config.cfg, core, startAt);
        }
        context[_DYN_PROCESS_NEXT ] = _processNext;
        context[_DYN_CREATE_NEW ] = _createNew;
        return context;
    }
    function createProcessTelemetryUnloadContext(telemetryChain, core, startAt) {
        var config = createDynamicConfig(core.config);
        var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
        var context = internalContext.ctx;
        function _processNext(unloadState) {
            var nextPlugin = internalContext._next();
            nextPlugin && nextPlugin[_DYN_UNLOAD ](context, unloadState);
            return !nextPlugin;
        }
        function _createNew(plugins, startAt) {
            if (plugins === void 0) { plugins = null; }
            if (isArray(plugins)) {
                plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt);
            }
            return createProcessTelemetryUnloadContext(plugins || context[_DYN_GET_NEXT ](), core, startAt);
        }
        context[_DYN_PROCESS_NEXT ] = _processNext;
        context[_DYN_CREATE_NEW ] = _createNew;
        return context;
    }
    function createProcessTelemetryUpdateContext(telemetryChain, core, startAt) {
        var config = createDynamicConfig(core.config);
        var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
        var context = internalContext.ctx;
        function _processNext(updateState) {
            return context.iterate(function (plugin) {
                if (isFunction(plugin[_DYN_UPDATE ])) {
                    plugin[_DYN_UPDATE ](context, updateState);
                }
            });
        }
        function _createNew(plugins, startAt) {
            if (plugins === void 0) { plugins = null; }
            if (isArray(plugins)) {
                plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt);
            }
            return createProcessTelemetryUpdateContext(plugins || context[_DYN_GET_NEXT ](), core, startAt);
        }
        context[_DYN_PROCESS_NEXT ] = _processNext;
        context[_DYN_CREATE_NEW ] = _createNew;
        return context;
    }
    function createTelemetryProxyChain(plugins, config, core, startAt) {
        var firstProxy = null;
        var add = startAt ? false : true;
        if (isArray(plugins) && plugins[_DYN_LENGTH$1 ] > 0) {
            var lastProxy_1 = null;
            arrForEach(plugins, function (thePlugin) {
                if (!add && startAt === thePlugin) {
                    add = true;
                }
                if (add && thePlugin && isFunction(thePlugin[STR_PROCESS_TELEMETRY ])) {
                    var newProxy = createTelemetryPluginProxy(thePlugin, config, core);
                    if (!firstProxy) {
                        firstProxy = newProxy;
                    }
                    if (lastProxy_1) {
                        lastProxy_1._setNext(newProxy);
                    }
                    lastProxy_1 = newProxy;
                }
            });
        }
        if (startAt && !firstProxy) {
            return createTelemetryProxyChain([startAt], config, core);
        }
        return firstProxy;
    }
    function createTelemetryPluginProxy(plugin, config, core) {
        var nextProxy = null;
        var hasProcessTelemetry = isFunction(plugin[STR_PROCESS_TELEMETRY ]);
        var hasSetNext = isFunction(plugin[_DYN_SET_NEXT_PLUGIN ]);
        var chainId;
        if (plugin) {
            chainId = plugin[_DYN_IDENTIFIER ] + "-" + plugin[STR_PRIORITY ] + "-" + _chainId++;
        }
        else {
            chainId = "Unknown-0-" + _chainId++;
        }
        var proxyChain = {
            getPlugin: function () {
                return plugin;
            },
            getNext: function () {
                return nextProxy;
            },
            processTelemetry: _processTelemetry,
            unload: _unloadPlugin,
            update: _updatePlugin,
            _id: chainId,
            _setNext: function (nextPlugin) {
                nextProxy = nextPlugin;
            }
        };
        function _getTelCtx() {
            var itemCtx;
            if (plugin && isFunction(plugin[strGetTelCtx])) {
                itemCtx = plugin[strGetTelCtx]();
            }
            if (!itemCtx) {
                itemCtx = createProcessTelemetryContext(proxyChain, config, core);
            }
            return itemCtx;
        }
        function _processChain(itemCtx, processPluginFn, name, details, isAsync) {
            var hasRun = false;
            var identifier = plugin ? plugin[_DYN_IDENTIFIER ] : strTelemetryPluginChain;
            var hasRunContext = itemCtx[strHasRunFlags];
            if (!hasRunContext) {
                hasRunContext = itemCtx[strHasRunFlags] = {};
            }
            itemCtx.setNext(nextProxy);
            if (plugin) {
                doPerf(itemCtx[STR_CORE ](), function () { return identifier + ":" + name; }, function () {
                    hasRunContext[chainId] = true;
                    try {
                        var nextId = nextProxy ? nextProxy._id : STR_EMPTY$2;
                        if (nextId) {
                            hasRunContext[nextId] = false;
                        }
                        hasRun = processPluginFn(itemCtx);
                    }
                    catch (error) {
                        var hasNextRun = nextProxy ? hasRunContext[nextProxy._id] : true;
                        if (hasNextRun) {
                            hasRun = true;
                        }
                        if (!nextProxy || !hasNextRun) {
                            _throwInternal(itemCtx[_DYN_DIAG_LOG ](), 1 , 73 , "Plugin [" + identifier + "] failed during " + name + " - " + dumpObj(error) + ", run flags: " + dumpObj(hasRunContext));
                        }
                    }
                }, details, isAsync);
            }
            return hasRun;
        }
        function _processTelemetry(env, itemCtx) {
            itemCtx = itemCtx || _getTelCtx();
            function _callProcessTelemetry(itemCtx) {
                if (!plugin || !hasProcessTelemetry) {
                    return false;
                }
                var pluginState = _getPluginState(plugin);
                if (pluginState[_DYN_TEARDOWN ] || pluginState[STR_DISABLED]) {
                    return false;
                }
                if (hasSetNext) {
                    plugin[_DYN_SET_NEXT_PLUGIN ](nextProxy);
                }
                plugin[STR_PROCESS_TELEMETRY ](env, itemCtx);
                return true;
            }
            if (!_processChain(itemCtx, _callProcessTelemetry, "processTelemetry", function () { return ({ item: env }); }, !(env.sync))) {
                itemCtx[_DYN_PROCESS_NEXT ](env);
            }
        }
        function _unloadPlugin(unloadCtx, unloadState) {
            function _callTeardown() {
                var hasRun = false;
                if (plugin) {
                    var pluginState = _getPluginState(plugin);
                    var pluginCore = plugin[STR_CORE] || pluginState[STR_CORE ];
                    if (plugin && (!pluginCore || pluginCore === unloadCtx.core()) && !pluginState[_DYN_TEARDOWN ]) {
                        pluginState[STR_CORE ] = null;
                        pluginState[_DYN_TEARDOWN ] = true;
                        pluginState[_DYN_IS_INITIALIZED ] = false;
                        if (plugin[_DYN_TEARDOWN ] && plugin[_DYN_TEARDOWN ](unloadCtx, unloadState) === true) {
                            hasRun = true;
                        }
                    }
                }
                return hasRun;
            }
            if (!_processChain(unloadCtx, _callTeardown, "unload", function () { }, unloadState[_DYN_IS_ASYNC ])) {
                unloadCtx[_DYN_PROCESS_NEXT ](unloadState);
            }
        }
        function _updatePlugin(updateCtx, updateState) {
            function _callUpdate() {
                var hasRun = false;
                if (plugin) {
                    var pluginState = _getPluginState(plugin);
                    var pluginCore = plugin[STR_CORE] || pluginState[STR_CORE ];
                    if (plugin && (!pluginCore || pluginCore === updateCtx.core()) && !pluginState[_DYN_TEARDOWN ]) {
                        if (plugin[_DYN_UPDATE ] && plugin[_DYN_UPDATE ](updateCtx, updateState) === true) {
                            hasRun = true;
                        }
                    }
                }
                return hasRun;
            }
            if (!_processChain(updateCtx, _callUpdate, "update", function () { }, false)) {
                updateCtx[_DYN_PROCESS_NEXT ](updateState);
            }
        }
        return objFreeze(proxyChain);
    }
    var ProcessTelemetryContext = /** @class */ (function () {
        function ProcessTelemetryContext(pluginChain, config, core, startAt) {
            var _self = this;
            var context = createProcessTelemetryContext(pluginChain, config, core, startAt);
            proxyFunctions(_self, context, objKeys(context));
        }
        return ProcessTelemetryContext;
    }());

    function createUnloadHandlerContainer() {
        var handlers = [];
        function _addHandler(handler) {
            if (handler) {
                handlers[_DYN_PUSH ](handler);
            }
        }
        function _runHandlers(unloadCtx, unloadState) {
            arrForEach(handlers, function (handler) {
                try {
                    handler(unloadCtx, unloadState);
                }
                catch (e) {
                    _throwInternal(unloadCtx[_DYN_DIAG_LOG ](), 2 , 73 , "Unexpected error calling unload handler - " + dumpObj(e));
                }
            });
            handlers = [];
        }
        return {
            add: _addHandler,
            run: _runHandlers
        };
    }

    var _maxHooks;
    var _hookAddMonitor;
    function _testHookMaxUnloadHooksCb(maxHooks, addMonitor) {
        _maxHooks = maxHooks;
        _hookAddMonitor = addMonitor;
    }
    function createUnloadHookContainer() {
        var _hooks = [];
        function _doUnload(logger) {
            var oldHooks = _hooks;
            _hooks = [];
            arrForEach(oldHooks, function (fn) {
                try {
                    (fn.rm || fn.remove).call(fn);
                }
                catch (e) {
                    _throwInternal(logger, 2 , 73 , "Unloading:" + dumpObj(e));
                }
            });
            if (_maxHooks && oldHooks[_DYN_LENGTH$1 ] > _maxHooks) {
                _hookAddMonitor ? _hookAddMonitor("doUnload", oldHooks) : _throwInternal(null, 1 , 48 , "Max unload hooks exceeded. An excessive number of unload hooks has been detected.");
            }
        }
        function _addHook(hooks) {
            if (hooks) {
                arrAppend(_hooks, hooks);
                if (_maxHooks && _hooks[_DYN_LENGTH$1 ] > _maxHooks) {
                    _hookAddMonitor ? _hookAddMonitor("Add", _hooks) : _throwInternal(null, 1 , 48 , "Max unload hooks exceeded. An excessive number of unload hooks has been detected.");
                }
            }
        }
        return {
            run: _doUnload,
            add: _addHook
        };
    }

    var _a$2;
    var strGetPlugin = "getPlugin";
    var defaultValues = (_a$2 = {},
        _a$2[STR_EXTENSION_CONFIG] = { isVal: isNotNullOrUndefined, v: {} },
        _a$2);
    var BaseTelemetryPlugin = /** @class */ (function () {
        function BaseTelemetryPlugin() {
            var _self = this;
            var _isinitialized;
            var _rootCtx;
            var _nextPlugin;
            var _unloadHandlerContainer;
            var _hookContainer;
            _initDefaults();
            dynamicProto(BaseTelemetryPlugin, _self, function (_self) {
                _self[_DYN_INITIALIZE$1 ] = function (config, core, extensions, pluginChain) {
                    _setDefaults(config, core, pluginChain);
                    _isinitialized = true;
                };
                _self[_DYN_TEARDOWN ] = function (unloadCtx, unloadState) {
                    var _a;
                    var core = _self[STR_CORE ];
                    if (!core || (unloadCtx && core !== unloadCtx[STR_CORE ]())) {
                        return;
                    }
                    var result;
                    var unloadDone = false;
                    var theUnloadCtx = unloadCtx || createProcessTelemetryUnloadContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);
                    var theUnloadState = unloadState || (_a = {
                            reason: 0
                        },
                        _a[_DYN_IS_ASYNC ] = false,
                        _a);
                    function _unloadCallback() {
                        if (!unloadDone) {
                            unloadDone = true;
                            _unloadHandlerContainer.run(theUnloadCtx, unloadState);
                            _hookContainer.run(theUnloadCtx[_DYN_DIAG_LOG ]());
                            if (result === true) {
                                theUnloadCtx[_DYN_PROCESS_NEXT ](theUnloadState);
                            }
                            _initDefaults();
                        }
                    }
                    if (!_self[_DYN__DO_TEARDOWN ] || _self[_DYN__DO_TEARDOWN ](theUnloadCtx, theUnloadState, _unloadCallback) !== true) {
                        _unloadCallback();
                    }
                    else {
                        result = true;
                    }
                    return result;
                };
                _self[_DYN_UPDATE ] = function (updateCtx, updateState) {
                    var core = _self[STR_CORE ];
                    if (!core || (updateCtx && core !== updateCtx[STR_CORE ]())) {
                        return;
                    }
                    var result;
                    var updateDone = false;
                    var theUpdateCtx = updateCtx || createProcessTelemetryUpdateContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);
                    var theUpdateState = updateState || {
                        reason: 0
                    };
                    function _updateCallback() {
                        if (!updateDone) {
                            updateDone = true;
                            _setDefaults(theUpdateCtx.getCfg(), theUpdateCtx.core(), theUpdateCtx[_DYN_GET_NEXT ]());
                        }
                    }
                    if (!_self._doUpdate || _self._doUpdate(theUpdateCtx, theUpdateState, _updateCallback) !== true) {
                        _updateCallback();
                    }
                    else {
                        result = true;
                    }
                    return result;
                };
                proxyFunctionAs(_self, "_addUnloadCb", function () { return _unloadHandlerContainer; }, "add");
                proxyFunctionAs(_self, "_addHook", function () { return _hookContainer; }, "add");
                objDefine(_self, "_unloadHooks", { g: function () { return _hookContainer; } });
            });
            _self[_DYN_DIAG_LOG ] = function (itemCtx) {
                return _getTelCtx(itemCtx)[_DYN_DIAG_LOG ]();
            };
            _self[_DYN_IS_INITIALIZED ] = function () {
                return _isinitialized;
            };
            _self.setInitialized = function (isInitialized) {
                _isinitialized = isInitialized;
            };
            _self[_DYN_SET_NEXT_PLUGIN ] = function (next) {
                _nextPlugin = next;
            };
            _self[_DYN_PROCESS_NEXT ] = function (env, itemCtx) {
                if (itemCtx) {
                    itemCtx[_DYN_PROCESS_NEXT ](env);
                }
                else if (_nextPlugin && isFunction(_nextPlugin[STR_PROCESS_TELEMETRY ])) {
                    _nextPlugin[STR_PROCESS_TELEMETRY ](env, null);
                }
            };
            _self._getTelCtx = _getTelCtx;
            function _getTelCtx(currentCtx) {
                if (currentCtx === void 0) { currentCtx = null; }
                var itemCtx = currentCtx;
                if (!itemCtx) {
                    var rootCtx = _rootCtx || createProcessTelemetryContext(null, {}, _self[STR_CORE ]);
                    if (_nextPlugin && _nextPlugin[strGetPlugin]) {
                        itemCtx = rootCtx[_DYN_CREATE_NEW ](null, _nextPlugin[strGetPlugin]);
                    }
                    else {
                        itemCtx = rootCtx[_DYN_CREATE_NEW ](null, _nextPlugin);
                    }
                }
                return itemCtx;
            }
            function _setDefaults(config, core, pluginChain) {
                createDynamicConfig(config, defaultValues, safeGetLogger(core));
                if (!pluginChain && core) {
                    pluginChain = core[_DYN_GET_PROCESS_TEL_CONT2 ]()[_DYN_GET_NEXT ]();
                }
                var nextPlugin = _nextPlugin;
                if (_nextPlugin && _nextPlugin[strGetPlugin]) {
                    nextPlugin = _nextPlugin[strGetPlugin]();
                }
                _self[STR_CORE ] = core;
                _rootCtx = createProcessTelemetryContext(pluginChain, config, core, nextPlugin);
            }
            function _initDefaults() {
                _isinitialized = false;
                _self[STR_CORE ] = null;
                _rootCtx = null;
                _nextPlugin = null;
                _hookContainer = createUnloadHookContainer();
                _unloadHandlerContainer = createUnloadHandlerContainer();
            }
        }
        BaseTelemetryPlugin.__ieDyn=1;
        return BaseTelemetryPlugin;
    }());

    function _addInitializer(_initializers, id, telemetryInitializer) {
        var theInitializer = {
            id: id,
            fn: telemetryInitializer
        };
        arrAppend(_initializers, theInitializer);
        var handler = {
            remove: function () {
                arrForEach(_initializers, function (initializer, idx) {
                    if (initializer.id === theInitializer.id) {
                        _initializers[_DYN_SPLICE ](idx, 1);
                        return -1;
                    }
                });
            }
        };
        return handler;
    }
    function _runInitializers(_initializers, item, logger) {
        var doNotSendItem = false;
        var telemetryInitializersCount = _initializers[_DYN_LENGTH$1 ];
        for (var i = 0; i < telemetryInitializersCount; ++i) {
            var telemetryInitializer = _initializers[i];
            if (telemetryInitializer) {
                try {
                    if (telemetryInitializer.fn[_DYN_APPLY ](null, [item]) === false) {
                        doNotSendItem = true;
                        break;
                    }
                }
                catch (e) {
                    _throwInternal(logger, 2 , 64 , "Telemetry initializer failed: " + getExceptionName(e), { exception: dumpObj(e) }, true);
                }
            }
        }
        return !doNotSendItem;
    }
    var TelemetryInitializerPlugin = /** @class */ (function (_super) {
        __extendsFn(TelemetryInitializerPlugin, _super);
        function TelemetryInitializerPlugin() {
            var _this = _super.call(this) || this;
            _this.identifier = "TelemetryInitializerPlugin";
            _this.priority = 199;
            var _id;
            var _initializers;
            _initDefaults();
            dynamicProto(TelemetryInitializerPlugin, _this, function (_self, _base) {
                _self.addTelemetryInitializer = function (telemetryInitializer) {
                    return _addInitializer(_initializers, _id++, telemetryInitializer);
                };
                _self[STR_PROCESS_TELEMETRY ] = function (item, itemCtx) {
                    if (_runInitializers(_initializers, item, itemCtx ? itemCtx[_DYN_DIAG_LOG ]() : _self[_DYN_DIAG_LOG ]())) {
                        _self[_DYN_PROCESS_NEXT ](item, itemCtx);
                    }
                };
                _self[_DYN__DO_TEARDOWN ] = function () {
                    _initDefaults();
                };
            });
            function _initDefaults() {
                _id = 0;
                _initializers = [];
            }
            return _this;
        }
        TelemetryInitializerPlugin.__ieDyn=1;
        return TelemetryInitializerPlugin;
    }(BaseTelemetryPlugin));

    var _a$1;
    var strValidationError = "Plugins must provide initialize method";
    var strNotificationManager = "_notificationManager";
    var strSdkUnloadingError = "SDK is still unloading...";
    var strSdkNotInitialized = "SDK is not initialized";
    var defaultConfig$1 = objDeepFreeze((_a$1 = {
            cookieCfg: {}
        },
        _a$1[STR_EXTENSIONS] = { rdOnly: true, ref: true, v: [] },
        _a$1[STR_CHANNELS] = { rdOnly: true, ref: true, v: [] },
        _a$1[STR_EXTENSION_CONFIG] = { ref: true, v: {} },
        _a$1[STR_CREATE_PERF_MGR] = UNDEFINED_VALUE,
        _a$1.loggingLevelConsole = 0 ,
        _a$1.diagnosticLogInterval = UNDEFINED_VALUE,
        _a$1));
    function _createPerfManager(core, notificationMgr) {
        return new PerfManager(notificationMgr);
    }
    function _validateExtensions(logger, channelPriority, allExtensions) {
        var _a;
        var coreExtensions = [];
        var channels = [];
        var extPriorities = {};
        arrForEach(allExtensions, function (ext) {
            if (isNullOrUndefined(ext) || isNullOrUndefined(ext[_DYN_INITIALIZE$1 ])) {
                throwError(strValidationError);
            }
            var extPriority = ext[STR_PRIORITY ];
            var identifier = ext[_DYN_IDENTIFIER ];
            if (ext && extPriority) {
                if (!isNullOrUndefined(extPriorities[extPriority])) {
                    _warnToConsole(logger, "Two extensions have same priority #" + extPriority + " - " + extPriorities[extPriority] + ", " + identifier);
                }
                else {
                    extPriorities[extPriority] = identifier;
                }
            }
            if (!extPriority || extPriority < channelPriority) {
                coreExtensions[_DYN_PUSH ](ext);
            }
            else {
                channels[_DYN_PUSH ](ext);
            }
        });
        return _a = {},
            _a[STR_CORE ] = coreExtensions,
            _a[STR_CHANNELS ] = channels,
            _a;
    }
    function _isPluginPresent(thePlugin, plugins) {
        var exists = false;
        arrForEach(plugins, function (plugin) {
            if (plugin === thePlugin) {
                exists = true;
                return -1;
            }
        });
        return exists;
    }
    function _deepMergeConfig(details, target, newValues, merge) {
        if (newValues) {
            objForEachKey(newValues, function (key, value) {
                if (merge) {
                    if (isPlainObject(value) && isPlainObject(target[key])) {
                        _deepMergeConfig(details, target[key], value, merge);
                    }
                }
                if (merge && isPlainObject(value) && isPlainObject(target[key])) {
                    _deepMergeConfig(details, target[key], value, merge);
                }
                else {
                    details.set(target, key, value);
                }
            });
        }
    }
    function _findWatcher(listeners, newWatcher) {
        var theListener = null;
        var idx = -1;
        arrForEach(listeners, function (listener, lp) {
            if (listener.w === newWatcher) {
                theListener = listener;
                idx = lp;
                return -1;
            }
        });
        return { i: idx, l: theListener };
    }
    function _addDelayedCfgListener(listeners, newWatcher) {
        var theListener = _findWatcher(listeners, newWatcher).l;
        if (!theListener) {
            theListener = {
                w: newWatcher,
                rm: function () {
                    var fnd = _findWatcher(listeners, newWatcher);
                    if (fnd.i !== -1) {
                        listeners[_DYN_SPLICE ](fnd.i, 1);
                    }
                }
            };
            listeners[_DYN_PUSH ](theListener);
        }
        return theListener;
    }
    function _registerDelayedCfgListener(config, listeners, logger) {
        arrForEach(listeners, function (listener) {
            var unloadHdl = onConfigChange(config, listener.w, logger);
            delete listener.w;
            listener.rm = function () {
                unloadHdl.rm();
            };
        });
    }
    function _initDebugListener(configHandler, unloadContainer, notificationManager, debugListener) {
        unloadContainer.add(configHandler[_DYN_WATCH ](function (details) {
            var disableDbgExt = details.cfg.disableDbgExt;
            if (disableDbgExt === true && debugListener) {
                notificationManager[_DYN_REMOVE_NOTIFICATION_0 ](debugListener);
                debugListener = null;
            }
            if (notificationManager && !debugListener && disableDbgExt !== true) {
                debugListener = getDebugListener(details.cfg);
                notificationManager[_DYN_ADD_NOTIFICATION_LIS1 ](debugListener);
            }
        }));
        return debugListener;
    }
    function _createUnloadHook(unloadHook) {
        return objDefine({
            rm: function () {
                unloadHook.rm();
            }
        }, "toJSON", { v: function () { return "aicore::onCfgChange<" + JSON.stringify(unloadHook) + ">"; } });
    }
    var AppInsightsCore$1 = /** @class */ (function () {
        function AppInsightsCore() {
            var _configHandler;
            var _isInitialized;
            var _logger;
            var _eventQueue;
            var _notificationManager;
            var _perfManager;
            var _cfgPerfManager;
            var _cookieManager;
            var _pluginChain;
            var _configExtensions;
            var _channelConfig;
            var _channels;
            var _isUnloading;
            var _telemetryInitializerPlugin;
            var _internalLogsEventName;
            var _evtNamespace;
            var _unloadHandlers;
            var _hookContainer;
            var _debugListener;
            var _traceCtx;
            var _instrumentationKey;
            var _cfgListeners;
            var _extensions;
            var _pluginVersionStringArr;
            var _pluginVersionString;
            var _internalLogPoller;
            var _internalLogPollerListening;
            var _forceStopInternalLogPoller;
            dynamicProto(AppInsightsCore, this, function (_self) {
                _initDefaults();
                _self["_getDbgPlgTargets"] = function () {
                    return [_extensions];
                };
                _self[_DYN_IS_INITIALIZED ] = function () { return _isInitialized; };
                _self[_DYN_INITIALIZE$1 ] = function (config, extensions, logger, notificationManager) {
                    if (_isUnloading) {
                        throwError(strSdkUnloadingError);
                    }
                    if (_self[_DYN_IS_INITIALIZED ]()) {
                        throwError("Core cannot be initialized more than once");
                    }
                    _configHandler = createDynamicConfig(config, defaultConfig$1, logger || _self[_DYN_LOGGER$1 ], false);
                    config = _configHandler.cfg;
                    _addUnloadHook(_configHandler[_DYN_WATCH ](function (details) {
                        _instrumentationKey = details.cfg.instrumentationKey;
                        var extCfg = details.ref(details.cfg, STR_EXTENSION_CONFIG);
                        objForEachKey(extCfg, function (key) {
                            details.ref(extCfg, key);
                        });
                        if (isNullOrUndefined(_instrumentationKey)) {
                            throwError("Please provide instrumentation key");
                        }
                    }));
                    _notificationManager = notificationManager;
                    _debugListener = _initDebugListener(_configHandler, _hookContainer, _notificationManager && _self[_DYN_GET_NOTIFY_MGR ](), _debugListener);
                    _initPerfManager();
                    _self[_DYN_LOGGER$1 ] = logger;
                    var cfgExtensions = config[STR_EXTENSIONS ];
                    _configExtensions = [];
                    _configExtensions[_DYN_PUSH ].apply(_configExtensions, __spreadArrayFn(__spreadArrayFn([], extensions, false), cfgExtensions));
                    _channelConfig = config[STR_CHANNELS ];
                    _initPluginChain(null);
                    if (!_channels || _channels[_DYN_LENGTH$1 ] === 0) {
                        throwError("No " + STR_CHANNELS + " available");
                    }
                    if (_channelConfig && _channelConfig[_DYN_LENGTH$1 ] > 1) {
                        var teeController = _self[_DYN_GET_PLUGIN ]("TeeChannelController");
                        if (!teeController || !teeController.plugin) {
                            _throwInternal(_logger, 1 , 28 , "TeeChannel required");
                        }
                    }
                    _registerDelayedCfgListener(config, _cfgListeners, _logger);
                    _cfgListeners = null;
                    _isInitialized = true;
                    _self.releaseQueue();
                    _self[_DYN_POLL_INTERNAL_LOGS$1 ]();
                };
                _self.getChannels = function () {
                    var controls = [];
                    if (_channels) {
                        arrForEach(_channels, function (channel) {
                            controls[_DYN_PUSH ](channel);
                        });
                    }
                    return objFreeze(controls);
                };
                _self.track = function (telemetryItem) {
                    doPerf(_self[STR_GET_PERF_MGR ](), function () { return "AppInsightsCore:track"; }, function () {
                        if (telemetryItem === null) {
                            _notifyInvalidEvent(telemetryItem);
                            throwError("Invalid telemetry item");
                        }
                        if (!telemetryItem[_DYN_NAME ] && isNullOrUndefined(telemetryItem[_DYN_NAME ])) {
                            _notifyInvalidEvent(telemetryItem);
                            throwError("telemetry name required");
                        }
                        telemetryItem.iKey = telemetryItem.iKey || _instrumentationKey;
                        telemetryItem[_DYN_TIME ] = telemetryItem[_DYN_TIME ] || toISOString(new Date());
                        telemetryItem.ver = telemetryItem.ver || "4.0";
                        if (!_isUnloading && _self[_DYN_IS_INITIALIZED ]()) {
                            _createTelCtx()[_DYN_PROCESS_NEXT ](telemetryItem);
                        }
                        else {
                            _eventQueue[_DYN_PUSH ](telemetryItem);
                        }
                    }, function () { return ({ item: telemetryItem }); }, !(telemetryItem.sync));
                };
                _self[_DYN_GET_PROCESS_TEL_CONT2 ] = _createTelCtx;
                _self[_DYN_GET_NOTIFY_MGR ] = function () {
                    if (!_notificationManager) {
                        _notificationManager = new NotificationManager(_configHandler.cfg);
                        _self[strNotificationManager] = _notificationManager;
                    }
                    return _notificationManager;
                };
                _self[_DYN_ADD_NOTIFICATION_LIS1 ] = function (listener) {
                    _self.getNotifyMgr()[_DYN_ADD_NOTIFICATION_LIS1 ](listener);
                };
                _self[_DYN_REMOVE_NOTIFICATION_0 ] = function (listener) {
                    if (_notificationManager) {
                        _notificationManager[_DYN_REMOVE_NOTIFICATION_0 ](listener);
                    }
                };
                _self.getCookieMgr = function () {
                    if (!_cookieManager) {
                        _cookieManager = createCookieMgr(_configHandler.cfg, _self[_DYN_LOGGER$1 ]);
                    }
                    return _cookieManager;
                };
                _self.setCookieMgr = function (cookieMgr) {
                    if (_cookieManager !== cookieMgr) {
                        runTargetUnload(_cookieManager, false);
                        _cookieManager = cookieMgr;
                    }
                };
                _self[STR_GET_PERF_MGR ] = function () {
                    return _perfManager || _cfgPerfManager || getGblPerfMgr();
                };
                _self.setPerfMgr = function (perfMgr) {
                    _perfManager = perfMgr;
                };
                _self.eventCnt = function () {
                    return _eventQueue[_DYN_LENGTH$1 ];
                };
                _self.releaseQueue = function () {
                    if (_isInitialized && _eventQueue[_DYN_LENGTH$1 ] > 0) {
                        var eventQueue = _eventQueue;
                        _eventQueue = [];
                        arrForEach(eventQueue, function (event) {
                            _createTelCtx()[_DYN_PROCESS_NEXT ](event);
                        });
                    }
                };
                _self[_DYN_POLL_INTERNAL_LOGS$1 ] = function (eventName) {
                    _internalLogsEventName = eventName || null;
                    _forceStopInternalLogPoller = false;
                    _internalLogPoller && _internalLogPoller[_DYN_CANCEL ]();
                    return _startLogPoller(true);
                };
                function _startLogPoller(alwaysStart) {
                    if ((!_internalLogPoller || !_internalLogPoller[_DYN_ENABLED ]) && !_forceStopInternalLogPoller) {
                        var shouldStart = alwaysStart || (_logger && _logger.queue[_DYN_LENGTH$1 ] > 0);
                        if (shouldStart) {
                            if (!_internalLogPollerListening) {
                                _internalLogPollerListening = true;
                                _addUnloadHook(_configHandler[_DYN_WATCH ](function (details) {
                                    var interval = details.cfg.diagnosticLogInterval;
                                    if (!interval || !(interval > 0)) {
                                        interval = 10000;
                                    }
                                    var isRunning = false;
                                    if (_internalLogPoller) {
                                        isRunning = _internalLogPoller[_DYN_ENABLED ];
                                        _internalLogPoller[_DYN_CANCEL ]();
                                    }
                                    _internalLogPoller = createTimeout(_flushInternalLogs, interval);
                                    _internalLogPoller.unref();
                                    _internalLogPoller[_DYN_ENABLED ] = isRunning;
                                }));
                            }
                            _internalLogPoller[_DYN_ENABLED ] = true;
                        }
                    }
                    return _internalLogPoller;
                }
                _self[_DYN_STOP_POLLING_INTERNA3 ] = function () {
                    _forceStopInternalLogPoller = true;
                    _internalLogPoller && _internalLogPoller[_DYN_CANCEL ]();
                    _flushInternalLogs();
                };
                proxyFunctions(_self, function () { return _telemetryInitializerPlugin; }, ["addTelemetryInitializer"]);
                _self[_DYN_UNLOAD ] = function (isAsync, unloadComplete, cbTimeout) {
                    var _a;
                    if (isAsync === void 0) { isAsync = true; }
                    if (!_isInitialized) {
                        throwError(strSdkNotInitialized);
                    }
                    if (_isUnloading) {
                        throwError(strSdkUnloadingError);
                    }
                    var unloadState = (_a = {
                            reason: 50
                        },
                        _a[_DYN_IS_ASYNC ] = isAsync,
                        _a.flushComplete = false,
                        _a);
                    var result;
                    if (isAsync && !unloadComplete) {
                        result = createPromise(function (resolve) {
                            unloadComplete = resolve;
                        });
                    }
                    var processUnloadCtx = createProcessTelemetryUnloadContext(_getPluginChain(), _self);
                    processUnloadCtx[_DYN_ON_COMPLETE ](function () {
                        _hookContainer.run(_self[_DYN_LOGGER$1 ]);
                        doUnloadAll([_cookieManager, _notificationManager, _logger], isAsync, function () {
                            _initDefaults();
                            unloadComplete && unloadComplete(unloadState);
                        });
                    }, _self);
                    function _doUnload(flushComplete) {
                        unloadState.flushComplete = flushComplete;
                        _isUnloading = true;
                        _unloadHandlers.run(processUnloadCtx, unloadState);
                        _self[_DYN_STOP_POLLING_INTERNA3 ]();
                        processUnloadCtx[_DYN_PROCESS_NEXT ](unloadState);
                    }
                    _flushInternalLogs();
                    if (!_flushChannels(isAsync, _doUnload, 6 , cbTimeout)) ;
                    return result;
                };
                _self[_DYN_GET_PLUGIN ] = _getPlugin;
                _self.addPlugin = function (plugin, replaceExisting, isAsync, addCb) {
                    if (!plugin) {
                        addCb && addCb(false);
                        _logOrThrowError(strValidationError);
                        return;
                    }
                    var existingPlugin = _getPlugin(plugin[_DYN_IDENTIFIER ]);
                    if (existingPlugin && !replaceExisting) {
                        addCb && addCb(false);
                        _logOrThrowError("Plugin [" + plugin[_DYN_IDENTIFIER ] + "] is already loaded!");
                        return;
                    }
                    var updateState = {
                        reason: 16
                    };
                    function _addPlugin(removed) {
                        _configExtensions[_DYN_PUSH ](plugin);
                        updateState.added = [plugin];
                        _initPluginChain(updateState);
                        addCb && addCb(true);
                    }
                    if (existingPlugin) {
                        var removedPlugins_1 = [existingPlugin.plugin];
                        var unloadState = {
                            reason: 2 ,
                            isAsync: !!isAsync
                        };
                        _removePlugins(removedPlugins_1, unloadState, function (removed) {
                            if (!removed) {
                                addCb && addCb(false);
                            }
                            else {
                                updateState.removed = removedPlugins_1;
                                updateState.reason |= 32 ;
                                _addPlugin();
                            }
                        });
                    }
                    else {
                        _addPlugin();
                    }
                };
                _self.updateCfg = function (newConfig, mergeExisting) {
                    if (mergeExisting === void 0) { mergeExisting = true; }
                    var updateState;
                    if (_self[_DYN_IS_INITIALIZED ]()) {
                        updateState = {
                            reason: 1 ,
                            cfg: _configHandler.cfg,
                            oldCfg: deepExtend({}, _configHandler.cfg),
                            newConfig: deepExtend({}, newConfig),
                            merge: mergeExisting
                        };
                        newConfig = updateState.newConfig;
                        var cfg = _configHandler.cfg;
                        newConfig[STR_EXTENSIONS ] = cfg[STR_EXTENSIONS ];
                        newConfig[STR_CHANNELS ] = cfg[STR_CHANNELS ];
                    }
                    _configHandler._block(function (details) {
                        var theConfig = details.cfg;
                        _deepMergeConfig(details, theConfig, newConfig, mergeExisting);
                        if (!mergeExisting) {
                            objForEachKey(theConfig, function (key) {
                                if (!objHasOwn(newConfig, key)) {
                                    details.set(theConfig, key, UNDEFINED_VALUE);
                                }
                            });
                        }
                        details[_DYN_SET_DF ](theConfig, defaultConfig$1);
                    }, true);
                    _configHandler[_DYN_NOTIFY ]();
                    if (updateState) {
                        _doUpdate(updateState);
                    }
                };
                _self.evtNamespace = function () {
                    return _evtNamespace;
                };
                _self.flush = _flushChannels;
                _self.getTraceCtx = function (createNew) {
                    if (!_traceCtx) {
                        _traceCtx = createDistributedTraceContext();
                    }
                    return _traceCtx;
                };
                _self.setTraceCtx = function (traceCtx) {
                    _traceCtx = traceCtx || null;
                };
                _self.addUnloadHook = _addUnloadHook;
                proxyFunctionAs(_self, "addUnloadCb", function () { return _unloadHandlers; }, "add");
                _self.onCfgChange = function (handler) {
                    var unloadHook;
                    if (!_isInitialized) {
                        unloadHook = _addDelayedCfgListener(_cfgListeners, handler);
                    }
                    else {
                        unloadHook = onConfigChange(_configHandler.cfg, handler, _self[_DYN_LOGGER$1 ]);
                    }
                    return _createUnloadHook(unloadHook);
                };
                _self.getWParam = function () {
                    return (hasDocument() || !!_configHandler.cfg.enableWParam) ? 0 : -1;
                };
                function _setPluginVersions() {
                    var thePlugins = {};
                    _pluginVersionStringArr = [];
                    var _addPluginVersions = function (plugins) {
                        if (plugins) {
                            arrForEach(plugins, function (plugin) {
                                if (plugin[_DYN_IDENTIFIER ] && plugin[_DYN_VERSION ] && !thePlugins[plugin.identifier]) {
                                    var ver = plugin[_DYN_IDENTIFIER ] + "=" + plugin[_DYN_VERSION ];
                                    _pluginVersionStringArr[_DYN_PUSH ](ver);
                                    thePlugins[plugin.identifier] = plugin;
                                }
                            });
                        }
                    };
                    _addPluginVersions(_channels);
                    if (_channelConfig) {
                        arrForEach(_channelConfig, function (channels) {
                            _addPluginVersions(channels);
                        });
                    }
                    _addPluginVersions(_configExtensions);
                }
                function _initDefaults() {
                    _isInitialized = false;
                    _configHandler = createDynamicConfig({}, defaultConfig$1, _self[_DYN_LOGGER$1 ]);
                    _configHandler.cfg[_DYN_LOGGING_LEVEL_CONSOL4 ] = 1 ;
                    objDefine(_self, "config", {
                        g: function () { return _configHandler.cfg; },
                        s: function (newValue) {
                            _self.updateCfg(newValue, false);
                        }
                    });
                    objDefine(_self, "pluginVersionStringArr", {
                        g: function () {
                            if (!_pluginVersionStringArr) {
                                _setPluginVersions();
                            }
                            return _pluginVersionStringArr;
                        }
                    });
                    objDefine(_self, "pluginVersionString", {
                        g: function () {
                            if (!_pluginVersionString) {
                                if (!_pluginVersionStringArr) {
                                    _setPluginVersions();
                                }
                                _pluginVersionString = _pluginVersionStringArr.join(";");
                            }
                            return _pluginVersionString || STR_EMPTY$2;
                        }
                    });
                    objDefine(_self, "logger", {
                        g: function () {
                            if (!_logger) {
                                _logger = new DiagnosticLogger(_configHandler.cfg);
                                _configHandler[_DYN_LOGGER$1 ] = _logger;
                            }
                            return _logger;
                        },
                        s: function (newLogger) {
                            _configHandler[_DYN_LOGGER$1 ] = newLogger;
                            if (_logger !== newLogger) {
                                runTargetUnload(_logger, false);
                                _logger = newLogger;
                            }
                        }
                    });
                    _self[_DYN_LOGGER$1 ] = new DiagnosticLogger(_configHandler.cfg);
                    _extensions = [];
                    var cfgExtensions = _self.config[STR_EXTENSIONS ] || [];
                    cfgExtensions.splice(0, cfgExtensions[_DYN_LENGTH$1 ]);
                    arrAppend(cfgExtensions, _extensions);
                    _telemetryInitializerPlugin = new TelemetryInitializerPlugin();
                    _eventQueue = [];
                    runTargetUnload(_notificationManager, false);
                    _notificationManager = null;
                    _perfManager = null;
                    _cfgPerfManager = null;
                    runTargetUnload(_cookieManager, false);
                    _cookieManager = null;
                    _pluginChain = null;
                    _configExtensions = [];
                    _channelConfig = null;
                    _channels = null;
                    _isUnloading = false;
                    _internalLogsEventName = null;
                    _evtNamespace = createUniqueNamespace("AIBaseCore", true);
                    _unloadHandlers = createUnloadHandlerContainer();
                    _traceCtx = null;
                    _instrumentationKey = null;
                    _hookContainer = createUnloadHookContainer();
                    _cfgListeners = [];
                    _pluginVersionString = null;
                    _pluginVersionStringArr = null;
                    _forceStopInternalLogPoller = false;
                    _internalLogPoller = null;
                    _internalLogPollerListening = false;
                }
                function _createTelCtx() {
                    var theCtx = createProcessTelemetryContext(_getPluginChain(), _configHandler.cfg, _self);
                    theCtx[_DYN_ON_COMPLETE ](_startLogPoller);
                    return theCtx;
                }
                function _initPluginChain(updateState) {
                    var theExtensions = _validateExtensions(_self[_DYN_LOGGER$1 ], ChannelControllerPriority, _configExtensions);
                    _pluginChain = null;
                    _pluginVersionString = null;
                    _pluginVersionStringArr = null;
                    _channels = (_channelConfig || [])[0] || [];
                    _channels = sortPlugins(arrAppend(_channels, theExtensions[STR_CHANNELS ]));
                    var allExtensions = arrAppend(sortPlugins(theExtensions[STR_CORE ]), _channels);
                    _extensions = objFreeze(allExtensions);
                    var cfgExtensions = _self.config[STR_EXTENSIONS ] || [];
                    cfgExtensions.splice(0, cfgExtensions[_DYN_LENGTH$1 ]);
                    arrAppend(cfgExtensions, _extensions);
                    var rootCtx = _createTelCtx();
                    if (_channels && _channels[_DYN_LENGTH$1 ] > 0) {
                        initializePlugins(rootCtx[_DYN_CREATE_NEW ](_channels), allExtensions);
                    }
                    initializePlugins(rootCtx, allExtensions);
                    if (updateState) {
                        _doUpdate(updateState);
                    }
                }
                function _getPlugin(pluginIdentifier) {
                    var theExt = null;
                    var thePlugin = null;
                    var channelHosts = [];
                    arrForEach(_extensions, function (ext) {
                        if (ext[_DYN_IDENTIFIER ] === pluginIdentifier && ext !== _telemetryInitializerPlugin) {
                            thePlugin = ext;
                            return -1;
                        }
                        if (ext.getChannel) {
                            channelHosts[_DYN_PUSH ](ext);
                        }
                    });
                    if (!thePlugin && channelHosts[_DYN_LENGTH$1 ] > 0) {
                        arrForEach(channelHosts, function (host) {
                            thePlugin = host.getChannel(pluginIdentifier);
                            if (!thePlugin) {
                                return -1;
                            }
                        });
                    }
                    if (thePlugin) {
                        theExt = {
                            plugin: thePlugin,
                            setEnabled: function (enabled) {
                                _getPluginState(thePlugin)[STR_DISABLED] = !enabled;
                            },
                            isEnabled: function () {
                                var pluginState = _getPluginState(thePlugin);
                                return !pluginState[_DYN_TEARDOWN ] && !pluginState[STR_DISABLED];
                            },
                            remove: function (isAsync, removeCb) {
                                var _a;
                                if (isAsync === void 0) { isAsync = true; }
                                var pluginsToRemove = [thePlugin];
                                var unloadState = (_a = {
                                        reason: 1
                                    },
                                    _a[_DYN_IS_ASYNC ] = isAsync,
                                    _a);
                                _removePlugins(pluginsToRemove, unloadState, function (removed) {
                                    if (removed) {
                                        _initPluginChain({
                                            reason: 32 ,
                                            removed: pluginsToRemove
                                        });
                                    }
                                    removeCb && removeCb(removed);
                                });
                            }
                        };
                    }
                    return theExt;
                }
                function _getPluginChain() {
                    if (!_pluginChain) {
                        var extensions = (_extensions || []).slice();
                        if (arrIndexOf(extensions, _telemetryInitializerPlugin) === -1) {
                            extensions[_DYN_PUSH ](_telemetryInitializerPlugin);
                        }
                        _pluginChain = createTelemetryProxyChain(sortPlugins(extensions), _configHandler.cfg, _self);
                    }
                    return _pluginChain;
                }
                function _removePlugins(thePlugins, unloadState, removeComplete) {
                    if (thePlugins && thePlugins[_DYN_LENGTH$1 ] > 0) {
                        var unloadChain = createTelemetryProxyChain(thePlugins, _configHandler.cfg, _self);
                        var unloadCtx = createProcessTelemetryUnloadContext(unloadChain, _self);
                        unloadCtx[_DYN_ON_COMPLETE ](function () {
                            var removed = false;
                            var newConfigExtensions = [];
                            arrForEach(_configExtensions, function (plugin, idx) {
                                if (!_isPluginPresent(plugin, thePlugins)) {
                                    newConfigExtensions[_DYN_PUSH ](plugin);
                                }
                                else {
                                    removed = true;
                                }
                            });
                            _configExtensions = newConfigExtensions;
                            _pluginVersionString = null;
                            _pluginVersionStringArr = null;
                            var newChannelConfig = [];
                            if (_channelConfig) {
                                arrForEach(_channelConfig, function (queue, idx) {
                                    var newQueue = [];
                                    arrForEach(queue, function (channel) {
                                        if (!_isPluginPresent(channel, thePlugins)) {
                                            newQueue[_DYN_PUSH ](channel);
                                        }
                                        else {
                                            removed = true;
                                        }
                                    });
                                    newChannelConfig[_DYN_PUSH ](newQueue);
                                });
                                _channelConfig = newChannelConfig;
                            }
                            removeComplete && removeComplete(removed);
                            _startLogPoller();
                        });
                        unloadCtx[_DYN_PROCESS_NEXT ](unloadState);
                    }
                    else {
                        removeComplete(false);
                    }
                }
                function _flushInternalLogs() {
                    if (_logger && _logger.queue) {
                        var queue = _logger.queue.slice(0);
                        _logger.queue[_DYN_LENGTH$1 ] = 0;
                        arrForEach(queue, function (logMessage) {
                            var _a;
                            var item = (_a = {},
                                _a[_DYN_NAME ] = _internalLogsEventName ? _internalLogsEventName : "InternalMessageId: " + logMessage[_DYN_MESSAGE_ID ],
                                _a.iKey = _instrumentationKey,
                                _a[_DYN_TIME ] = toISOString(new Date()),
                                _a.baseType = _InternalLogMessage.dataType,
                                _a.baseData = { message: logMessage[_DYN_MESSAGE ] },
                                _a);
                            _self.track(item);
                        });
                    }
                }
                function _flushChannels(isAsync, callBack, sendReason, cbTimeout) {
                    var waiting = 1;
                    var doneIterating = false;
                    var cbTimer = null;
                    cbTimeout = cbTimeout || 5000;
                    function doCallback() {
                        waiting--;
                        if (doneIterating && waiting === 0) {
                            cbTimer && cbTimer[_DYN_CANCEL ]();
                            cbTimer = null;
                            callBack && callBack(doneIterating);
                            callBack = null;
                        }
                    }
                    if (_channels && _channels[_DYN_LENGTH$1 ] > 0) {
                        var flushCtx = _createTelCtx()[_DYN_CREATE_NEW ](_channels);
                        flushCtx.iterate(function (plugin) {
                            if (plugin.flush) {
                                waiting++;
                                var handled_1 = false;
                                if (!plugin.flush(isAsync, function () {
                                    handled_1 = true;
                                    doCallback();
                                }, sendReason)) {
                                    if (!handled_1) {
                                        if (isAsync && cbTimer == null) {
                                            cbTimer = scheduleTimeout(function () {
                                                cbTimer = null;
                                                doCallback();
                                            }, cbTimeout);
                                        }
                                        else {
                                            doCallback();
                                        }
                                    }
                                }
                            }
                        });
                    }
                    doneIterating = true;
                    doCallback();
                    return true;
                }
                function _initPerfManager() {
                    var prevCfgPerfMgr;
                    _addUnloadHook(_configHandler[_DYN_WATCH ](function (details) {
                        var enablePerfMgr = details.cfg.enablePerfMgr;
                        if (enablePerfMgr) {
                            var createPerfMgr = details.cfg[STR_CREATE_PERF_MGR ];
                            if (prevCfgPerfMgr !== createPerfMgr) {
                                if (!createPerfMgr) {
                                    createPerfMgr = _createPerfManager;
                                }
                                getSetValue(details.cfg, STR_CREATE_PERF_MGR, createPerfMgr);
                                prevCfgPerfMgr = createPerfMgr;
                                _cfgPerfManager = null;
                            }
                            if (!_perfManager && !_cfgPerfManager && isFunction(createPerfMgr)) {
                                _cfgPerfManager = createPerfMgr(_self, _self[_DYN_GET_NOTIFY_MGR ]());
                            }
                        }
                        else {
                            _cfgPerfManager = null;
                            prevCfgPerfMgr = null;
                        }
                    }));
                }
                function _doUpdate(updateState) {
                    var updateCtx = createProcessTelemetryUpdateContext(_getPluginChain(), _self);
                    updateCtx[_DYN_ON_COMPLETE ](_startLogPoller);
                    if (!_self._updateHook || _self._updateHook(updateCtx, updateState) !== true) {
                        updateCtx[_DYN_PROCESS_NEXT ](updateState);
                    }
                }
                function _logOrThrowError(message) {
                    var logger = _self[_DYN_LOGGER$1 ];
                    if (logger) {
                        _throwInternal(logger, 2 , 73 , message);
                        _startLogPoller();
                    }
                    else {
                        throwError(message);
                    }
                }
                function _notifyInvalidEvent(telemetryItem) {
                    var manager = _self[_DYN_GET_NOTIFY_MGR ]();
                    if (manager) {
                        manager[STR_EVENTS_DISCARDED ]([telemetryItem], 2 );
                    }
                }
                function _addUnloadHook(hooks) {
                    _hookContainer.add(hooks);
                }
            });
        }
        AppInsightsCore.__ieDyn=1;
        return AppInsightsCore;
    }());

    function parseResponse(response, diagLog) {
        try {
            if (response && response !== "") {
                var result = getJSON().parse(response);
                if (result && result[_DYN_ITEMS_RECEIVED ] && result[_DYN_ITEMS_RECEIVED ] >= result.itemsAccepted &&
                    result.itemsReceived - result.itemsAccepted === result.errors[_DYN_LENGTH$1 ]) {
                    return result;
                }
            }
        }
        catch (e) {
            _throwInternal(diagLog, 1 , 43 , "Cannot parse the response. " + (e[_DYN_NAME ] || dumpObj(e)), {
                response: response
            });
        }
        return null;
    }

    var STR_EMPTY$1 = "";
    var STR_NO_RESPONSE_BODY = "NoResponseBody";
    var _noResponseQs = "&" + STR_NO_RESPONSE_BODY + "=true";
    var STR_POST_METHOD = "POST";
    var SenderPostManager = /** @class */ (function () {
        function SenderPostManager() {
            var _syncFetchPayload = 0;
            var _enableSendPromise;
            var _isInitialized;
            var _diagLog;
            var _isOneDs;
            var _onCompleteFuncs;
            var _disableCredentials;
            var _fallbackInst;
            var _disableXhr;
            var _disableBeacon;
            var _disableBeaconSync;
            var _disableFetchKeepAlive;
            var _addNoResponse;
            var _timeoutWrapper;
            dynamicProto(SenderPostManager, this, function (_self, _base) {
                var _sendCredentials = true;
                _initDefaults();
                _self[_DYN_INITIALIZE$1 ] = function (config, diagLog) {
                    _diagLog = diagLog;
                    if (_isInitialized) {
                        _throwInternal(_diagLog, 1 , 28 , "Sender is already initialized");
                    }
                    _self.SetConfig(config);
                    _isInitialized = true;
                };
                _self["_getDbgPlgTargets"] = function () {
                    return [_isInitialized, _isOneDs, _disableCredentials, _enableSendPromise];
                };
                _self.SetConfig = function (config) {
                    try {
                        _onCompleteFuncs = config.senderOnCompleteCallBack || {};
                        _disableCredentials = !!config.disableCredentials;
                        _isOneDs = !!config.isOneDs;
                        _enableSendPromise = !!config.enableSendPromise;
                        _disableXhr = !!config.disableXhr;
                        _disableBeacon = !!config.disableBeacon;
                        _disableBeaconSync = !!config.disableBeaconSync;
                        _timeoutWrapper = config.timeWrapper;
                        _addNoResponse = !!config.addNoResponse;
                        _disableFetchKeepAlive = !!config.disableFetchKeepAlive;
                        _fallbackInst = { sendPOST: _xhrSender };
                        if (!_isOneDs) {
                            _sendCredentials = false;
                        }
                        if (_disableCredentials) {
                            var location_1 = getLocation();
                            if (location_1 && location_1.protocol && location_1.protocol[_DYN_TO_LOWER_CASE ]() === "file:") {
                                _sendCredentials = false;
                            }
                        }
                        return true;
                    }
                    catch (e) {
                    }
                    return false;
                };
                _self.getSyncFetchPayload = function () {
                    return _syncFetchPayload;
                };
                _self.getSenderInst = function (transports, sync) {
                    if (transports && transports[_DYN_LENGTH$1 ]) {
                        return _getSenderInterface(transports, sync);
                    }
                    return null;
                };
                _self.getFallbackInst = function () {
                    return _fallbackInst;
                };
                _self[_DYN__DO_TEARDOWN ] = function (unloadCtx, unloadState) {
                    _initDefaults();
                };
                function _onSuccess(res, onComplete) {
                    _doOnComplete(onComplete, 200, {}, res);
                }
                function _onError(message, onComplete) {
                    _throwInternal(_diagLog, 2 , 26 , "Failed to send telemetry.", { message: message });
                    _doOnComplete(onComplete, 400, {});
                }
                function _onNoPayloadUrl(onComplete) {
                    _onError("No endpoint url is provided for the batch", onComplete);
                }
                function _getSenderInterface(transports, syncSupport) {
                    var _a;
                    var transportType = 0 ;
                    var sendPostFunc = null;
                    var lp = 0;
                    while (sendPostFunc == null && lp < transports[_DYN_LENGTH$1 ]) {
                        transportType = transports[lp];
                        if (!_disableXhr && transportType === 1 ) {
                            if (useXDomainRequest()) {
                                sendPostFunc = _xdrSender;
                            }
                            else if (isXhrSupported()) {
                                sendPostFunc = _xhrSender;
                            }
                        }
                        else if (transportType === 2  && isFetchSupported(syncSupport) && (!syncSupport || !_disableFetchKeepAlive)) {
                            sendPostFunc = _doFetchSender;
                        }
                        else if (transportType === 3  && isBeaconsSupported() && (syncSupport ? !_disableBeaconSync : !_disableBeacon)) {
                            sendPostFunc = _beaconSender;
                        }
                        lp++;
                    }
                    if (sendPostFunc) {
                        return _a = {
                                _transport: transportType,
                                _isSync: syncSupport
                            },
                            _a[_DYN_SEND_POST ] = sendPostFunc,
                            _a;
                    }
                    return null;
                }
                function _doOnComplete(oncomplete, status, headers, response) {
                    try {
                        oncomplete && oncomplete(status, headers, response);
                    }
                    catch (e) {
                    }
                }
                function _doBeaconSend(payload, oncomplete) {
                    var nav = getNavigator();
                    var url = payload[_DYN_URL_STRING ];
                    if (!url) {
                        _onNoPayloadUrl(oncomplete);
                        return true;
                    }
                    url = payload[_DYN_URL_STRING ] + (_addNoResponse ? _noResponseQs : STR_EMPTY$1);
                    var data = payload[_DYN_DATA ];
                    var plainTextBatch = _isOneDs ? data : new Blob([data], { type: "text/plain;charset=UTF-8" });
                    var queued = nav.sendBeacon(url, plainTextBatch);
                    return queued;
                }
                function _beaconSender(payload, oncomplete, sync) {
                    var data = payload[_DYN_DATA ];
                    try {
                        if (data) {
                            if (!_doBeaconSend(payload, oncomplete)) {
                                var onRetry = _onCompleteFuncs && _onCompleteFuncs.beaconOnRetry;
                                if (onRetry && isFunction(onRetry)) {
                                    onRetry(payload, oncomplete, _doBeaconSend);
                                }
                                else {
                                    _fallbackInst && _fallbackInst[_DYN_SEND_POST ](payload, oncomplete, true);
                                    _throwInternal(_diagLog, 2 , 40 , ". " + "Failed to send telemetry with Beacon API, retried with normal sender.");
                                }
                            }
                            else {
                                _onSuccess(STR_EMPTY$1, oncomplete);
                            }
                        }
                    }
                    catch (e) {
                        _isOneDs && _warnToConsole(_diagLog, "Failed to send telemetry using sendBeacon API. Ex:" + dumpObj(e));
                        _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, STR_EMPTY$1);
                    }
                    return;
                }
                function _xhrSender(payload, oncomplete, sync) {
                    var thePromise;
                    var resolveFunc;
                    var rejectFunc;
                    var headers = payload[_DYN_HEADERS ] || {};
                    if (!sync && _enableSendPromise) {
                        thePromise = createPromise(function (resolve, reject) {
                            resolveFunc = resolve;
                            rejectFunc = reject;
                        });
                    }
                    if (_isOneDs && sync && payload.disableXhrSync) {
                        sync = false;
                    }
                    var endPointUrl = payload[_DYN_URL_STRING ];
                    if (!endPointUrl) {
                        _onNoPayloadUrl(oncomplete);
                        resolveFunc && resolveFunc(false);
                        return;
                    }
                    var xhr = openXhr$1(STR_POST_METHOD, endPointUrl, _sendCredentials, true, sync, payload[_DYN_TIMEOUT ]);
                    if (!_isOneDs) {
                        xhr[_DYN_SET_REQUEST_HEADER ]("Content-type", "application/json");
                    }
                    arrForEach(objKeys(headers), function (headerName) {
                        xhr[_DYN_SET_REQUEST_HEADER ](headerName, headers[headerName]);
                    });
                    xhr.onreadystatechange = function () {
                        if (!_isOneDs) {
                            _doOnReadyFunc(xhr);
                            if (xhr.readyState === 4) {
                                resolveFunc && resolveFunc(true);
                            }
                        }
                    };
                    xhr.onload = function () {
                        if (_isOneDs) {
                            _doOnReadyFunc(xhr);
                        }
                    };
                    function _doOnReadyFunc(xhr) {
                        var onReadyFunc = _onCompleteFuncs && _onCompleteFuncs.xhrOnComplete;
                        var onReadyFuncExist = onReadyFunc && isFunction(onReadyFunc);
                        if (onReadyFuncExist) {
                            onReadyFunc(xhr, oncomplete, payload);
                        }
                        else {
                            var response = getResponseText(xhr);
                            _doOnComplete(oncomplete, xhr[_DYN_STATUS ], _getAllResponseHeaders(xhr, _isOneDs), response);
                        }
                    }
                    xhr.onerror = function (event) {
                        _doOnComplete(oncomplete, _isOneDs ? xhr[_DYN_STATUS ] : 400, _getAllResponseHeaders(xhr, _isOneDs), _isOneDs ? STR_EMPTY$1 : formatErrorMessageXhr(xhr));
                        rejectFunc && rejectFunc(event);
                    };
                    xhr.ontimeout = function () {
                        _doOnComplete(oncomplete, _isOneDs ? xhr[_DYN_STATUS ] : 500, _getAllResponseHeaders(xhr, _isOneDs), _isOneDs ? STR_EMPTY$1 : formatErrorMessageXhr(xhr));
                        resolveFunc && resolveFunc(false);
                    };
                    xhr.send(payload[_DYN_DATA ]);
                    return thePromise;
                }
                function _doFetchSender(payload, oncomplete, sync) {
                    var _a;
                    var endPointUrl = payload[_DYN_URL_STRING ];
                    var batch = payload[_DYN_DATA ];
                    var plainTextBatch = _isOneDs ? batch : new Blob([batch], { type: "application/json" });
                    var thePromise;
                    var resolveFunc;
                    var rejectFunc;
                    var requestHeaders = new Headers();
                    var batchLength = batch[_DYN_LENGTH$1 ];
                    var ignoreResponse = false;
                    var responseHandled = false;
                    var headers = payload[_DYN_HEADERS ] || {};
                    var init = (_a = {
                            method: STR_POST_METHOD,
                            body: plainTextBatch
                        },
                        _a[DisabledPropertyName] = true
                    ,
                        _a);
                    if (payload.headers && objKeys(payload.headers)[_DYN_LENGTH$1 ] > 0) {
                        arrForEach(objKeys(headers), function (headerName) {
                            requestHeaders.append(headerName, headers[headerName]);
                        });
                        init[_DYN_HEADERS ] = requestHeaders;
                    }
                    if (_sendCredentials && _isOneDs) {
                        init.credentials = "include";
                    }
                    if (sync) {
                        init.keepalive = true;
                        _syncFetchPayload += batchLength;
                        if (_isOneDs) {
                            if (payload["_sendReason"] === 2 ) {
                                ignoreResponse = true;
                                if (_addNoResponse) {
                                    endPointUrl += _noResponseQs;
                                }
                            }
                        }
                        else {
                            ignoreResponse = true;
                        }
                    }
                    var request = new Request(endPointUrl, init);
                    try {
                        request[DisabledPropertyName] = true;
                    }
                    catch (e) {
                    }
                    if (!sync && _enableSendPromise) {
                        thePromise = createPromise(function (resolve, reject) {
                            resolveFunc = resolve;
                            rejectFunc = reject;
                        });
                    }
                    if (!endPointUrl) {
                        _onNoPayloadUrl(oncomplete);
                        resolveFunc && resolveFunc(false);
                        return;
                    }
                    function _handleError(res) {
                        _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, _isOneDs ? STR_EMPTY$1 : res);
                    }
                    function _onFetchComplete(response, payload, value) {
                        var status = response[_DYN_STATUS ];
                        var onCompleteFunc = _onCompleteFuncs.fetchOnComplete;
                        if (onCompleteFunc && isFunction(onCompleteFunc)) {
                            onCompleteFunc(response, oncomplete, value || STR_EMPTY$1, payload);
                        }
                        else {
                            _doOnComplete(oncomplete, status, {}, value || STR_EMPTY$1);
                        }
                    }
                    try {
                        doAwaitResponse(fetch(_isOneDs ? endPointUrl : request, _isOneDs ? init : null), function (result) {
                            if (sync) {
                                _syncFetchPayload -= batchLength;
                                batchLength = 0;
                            }
                            if (!responseHandled) {
                                responseHandled = true;
                                if (!result.rejected) {
                                    var response_1 = result.value;
                                    try {
                                        if (!_isOneDs && !response_1.ok) {
                                            _handleError(response_1.statusText);
                                            resolveFunc && resolveFunc(false);
                                        }
                                        else {
                                            if (_isOneDs && !response_1.body) {
                                                _onFetchComplete(response_1, null, STR_EMPTY$1);
                                                resolveFunc && resolveFunc(true);
                                            }
                                            else {
                                                doAwaitResponse(response_1.text(), function (resp) {
                                                    _onFetchComplete(response_1, payload, resp.value);
                                                    resolveFunc && resolveFunc(true);
                                                });
                                            }
                                        }
                                    }
                                    catch (e) {
                                        _handleError(dumpObj(e));
                                        rejectFunc && rejectFunc(e);
                                    }
                                }
                                else {
                                    _handleError(result.reason && result.reason[_DYN_MESSAGE ]);
                                    rejectFunc && rejectFunc(result.reason);
                                }
                            }
                        });
                    }
                    catch (e) {
                        if (!responseHandled) {
                            _handleError(dumpObj(e));
                            rejectFunc && rejectFunc(e);
                        }
                    }
                    if (ignoreResponse && !responseHandled) {
                        responseHandled = true;
                        _doOnComplete(oncomplete, 200, {});
                        resolveFunc && resolveFunc(true);
                    }
                    if (_isOneDs && !responseHandled && payload[_DYN_TIMEOUT ] > 0) {
                        _timeoutWrapper && _timeoutWrapper.set(function () {
                            if (!responseHandled) {
                                responseHandled = true;
                                _doOnComplete(oncomplete, 500, {});
                                resolveFunc && resolveFunc(true);
                            }
                        }, payload[_DYN_TIMEOUT ]);
                    }
                    return thePromise;
                }
                function _xdrSender(payload, oncomplete, sync) {
                    var _window = getWindow();
                    var xdr = new XDomainRequest();
                    var data = payload[_DYN_DATA ];
                    xdr.onload = function () {
                        var response = getResponseText(xdr);
                        var onloadFunc = _onCompleteFuncs && _onCompleteFuncs.xdrOnComplete;
                        if (onloadFunc && isFunction(onloadFunc)) {
                            onloadFunc(xdr, oncomplete, payload);
                        }
                        else {
                            _doOnComplete(oncomplete, 200, {}, response);
                        }
                    };
                    xdr.onerror = function () {
                        _doOnComplete(oncomplete, 400, {}, _isOneDs ? STR_EMPTY$1 : formatErrorMessageXdr(xdr));
                    };
                    xdr.ontimeout = function () {
                        _doOnComplete(oncomplete, 500, {});
                    };
                    xdr.onprogress = function () { };
                    var hostingProtocol = _window && _window.location && _window.location[_DYN_PROTOCOL ] || "";
                    var endpoint = payload[_DYN_URL_STRING ];
                    if (!endpoint) {
                        _onNoPayloadUrl(oncomplete);
                        return;
                    }
                    if (!_isOneDs && endpoint.lastIndexOf(hostingProtocol, 0) !== 0) {
                        var msg = "Cannot send XDomain request. The endpoint URL protocol doesn't match the hosting page protocol.";
                        _throwInternal(_diagLog, 2 , 40 , ". " + msg);
                        _onError(msg, oncomplete);
                        return;
                    }
                    var endpointUrl = _isOneDs ? endpoint : endpoint[_DYN_REPLACE ](/^(https?:)/, "");
                    xdr.open(STR_POST_METHOD, endpointUrl);
                    if (payload[_DYN_TIMEOUT ]) {
                        xdr[_DYN_TIMEOUT ] = payload[_DYN_TIMEOUT ];
                    }
                    xdr.send(data);
                    if (_isOneDs && sync) {
                        _timeoutWrapper && _timeoutWrapper.set(function () {
                            xdr.send(data);
                        }, 0);
                    }
                    else {
                        xdr.send(data);
                    }
                }
                function _initDefaults() {
                    _syncFetchPayload = 0;
                    _isInitialized = false;
                    _enableSendPromise = false;
                    _diagLog = null;
                    _isOneDs = null;
                    _onCompleteFuncs = null;
                    _disableCredentials = null;
                    _fallbackInst = null;
                    _disableXhr = false;
                    _disableBeacon = false;
                    _disableBeaconSync = false;
                    _disableFetchKeepAlive = false;
                    _addNoResponse = false;
                    _timeoutWrapper = null;
                }
            });
        }
        SenderPostManager.__ieDyn=1;
        return SenderPostManager;
    }());

    var strOnPrefix = "on";
    var strAttachEvent = "attachEvent";
    var strAddEventHelper = "addEventListener";
    var strDetachEvent = "detachEvent";
    var strRemoveEventListener = "removeEventListener";
    var strEvents = "events";
    var strVisibilityChangeEvt = "visibilitychange";
    var strPageHide = "pagehide";
    var strPageShow = "pageshow";
    var strUnload = "unload";
    var strBeforeUnload = "beforeunload";
    var strPageHideNamespace = createUniqueNamespace("aiEvtPageHide");
    var strPageShowNamespace = createUniqueNamespace("aiEvtPageShow");
    var rRemoveEmptyNs = /\.[\.]+/g;
    var rRemoveTrailingEmptyNs = /[\.]+$/;
    var _guid = 1;
    var elmNodeData = createElmNodeData("events");
    var eventNamespace = /^([^.]*)(?:\.(.+)|)/;
    function _normalizeNamespace(name) {
        if (name && name[_DYN_REPLACE ]) {
            return name[_DYN_REPLACE ](/^[\s\.]+|(?=[\s\.])[\.\s]+$/g, STR_EMPTY$2);
        }
        return name;
    }
    function _getEvtNamespace(eventName, evtNamespace) {
        var _a;
        if (evtNamespace) {
            var theNamespace_1 = STR_EMPTY$2;
            if (isArray(evtNamespace)) {
                theNamespace_1 = STR_EMPTY$2;
                arrForEach(evtNamespace, function (name) {
                    name = _normalizeNamespace(name);
                    if (name) {
                        if (name[0] !== ".") {
                            name = "." + name;
                        }
                        theNamespace_1 += name;
                    }
                });
            }
            else {
                theNamespace_1 = _normalizeNamespace(evtNamespace);
            }
            if (theNamespace_1) {
                if (theNamespace_1[0] !== ".") {
                    theNamespace_1 = "." + theNamespace_1;
                }
                eventName = (eventName || STR_EMPTY$2) + theNamespace_1;
            }
        }
        var parsedEvent = (eventNamespace.exec(eventName || STR_EMPTY$2) || []);
        return _a = {},
            _a[_DYN_TYPE ] = parsedEvent[1],
            _a.ns = ((parsedEvent[2] || STR_EMPTY$2).replace(rRemoveEmptyNs, ".").replace(rRemoveTrailingEmptyNs, STR_EMPTY$2)[_DYN_SPLIT ](".").sort()).join("."),
            _a;
    }
    function __getRegisteredEvents(target, eventName, evtNamespace) {
        var theEvents = [];
        var eventCache = elmNodeData.get(target, strEvents, {}, false);
        var evtName = _getEvtNamespace(eventName, evtNamespace);
        objForEachKey(eventCache, function (evtType, registeredEvents) {
            arrForEach(registeredEvents, function (value) {
                var _a;
                if (!evtName[_DYN_TYPE ] || evtName[_DYN_TYPE ] === value.evtName[_DYN_TYPE ]) {
                    if (!evtName.ns || evtName.ns === evtName.ns) {
                        theEvents[_DYN_PUSH ]((_a = {},
                            _a[_DYN_NAME ] = value.evtName[_DYN_TYPE ] + (value.evtName.ns ? "." + value.evtName.ns : STR_EMPTY$2),
                            _a.handler = value[_DYN_HANDLER ],
                            _a));
                    }
                }
            });
        });
        return theEvents;
    }
    function _getRegisteredEvents(target, evtName, addDefault) {
        if (addDefault === void 0) { addDefault = true; }
        var aiEvts = elmNodeData.get(target, strEvents, {}, addDefault);
        var registeredEvents = aiEvts[evtName];
        if (!registeredEvents) {
            registeredEvents = aiEvts[evtName] = [];
        }
        return registeredEvents;
    }
    function _doDetach(obj, evtName, handlerRef, useCapture) {
        if (obj && evtName && evtName[_DYN_TYPE ]) {
            if (obj[strRemoveEventListener]) {
                obj[strRemoveEventListener](evtName[_DYN_TYPE ], handlerRef, useCapture);
            }
            else if (obj[strDetachEvent]) {
                obj[strDetachEvent](strOnPrefix + evtName[_DYN_TYPE ], handlerRef);
            }
        }
    }
    function _doAttach(obj, evtName, handlerRef, useCapture) {
        var result = false;
        if (obj && evtName && evtName[_DYN_TYPE ] && handlerRef) {
            if (obj[strAddEventHelper]) {
                obj[strAddEventHelper](evtName[_DYN_TYPE ], handlerRef, useCapture);
                result = true;
            }
            else if (obj[strAttachEvent]) {
                obj[strAttachEvent](strOnPrefix + evtName[_DYN_TYPE ], handlerRef);
                result = true;
            }
        }
        return result;
    }
    function _doUnregister(target, events, evtName, unRegFn) {
        var idx = events[_DYN_LENGTH$1 ];
        while (idx--) {
            var theEvent = events[idx];
            if (theEvent) {
                if (!evtName.ns || evtName.ns === theEvent.evtName.ns) {
                    if (!unRegFn || unRegFn(theEvent)) {
                        _doDetach(target, theEvent.evtName, theEvent[_DYN_HANDLER ], theEvent.capture);
                        events[_DYN_SPLICE ](idx, 1);
                    }
                }
            }
        }
    }
    function _unregisterEvents(target, evtName, unRegFn) {
        if (evtName[_DYN_TYPE ]) {
            _doUnregister(target, _getRegisteredEvents(target, evtName[_DYN_TYPE ]), evtName, unRegFn);
        }
        else {
            var eventCache = elmNodeData.get(target, strEvents, {});
            objForEachKey(eventCache, function (evtType, events) {
                _doUnregister(target, events, evtName, unRegFn);
            });
            if (objKeys(eventCache)[_DYN_LENGTH$1 ] === 0) {
                elmNodeData.kill(target, strEvents);
            }
        }
    }
    function mergeEvtNamespace(theNamespace, namespaces) {
        var newNamespaces;
        if (namespaces) {
            if (isArray(namespaces)) {
                newNamespaces = [theNamespace].concat(namespaces);
            }
            else {
                newNamespaces = [theNamespace, namespaces];
            }
            newNamespaces = (_getEvtNamespace("xx", newNamespaces).ns)[_DYN_SPLIT ](".");
        }
        else {
            newNamespaces = theNamespace;
        }
        return newNamespaces;
    }
    function eventOn(target, eventName, handlerRef, evtNamespace, useCapture) {
        var _a;
        if (useCapture === void 0) { useCapture = false; }
        var result = false;
        if (target) {
            try {
                var evtName = _getEvtNamespace(eventName, evtNamespace);
                result = _doAttach(target, evtName, handlerRef, useCapture);
                if (result && elmNodeData.accept(target)) {
                    var registeredEvent = (_a = {
                            guid: _guid++,
                            evtName: evtName
                        },
                        _a[_DYN_HANDLER ] = handlerRef,
                        _a.capture = useCapture,
                        _a);
                    _getRegisteredEvents(target, evtName.type)[_DYN_PUSH ](registeredEvent);
                }
            }
            catch (e) {
            }
        }
        return result;
    }
    function eventOff(target, eventName, handlerRef, evtNamespace, useCapture) {
        if (useCapture === void 0) { useCapture = false; }
        if (target) {
            try {
                var evtName_1 = _getEvtNamespace(eventName, evtNamespace);
                var found_1 = false;
                _unregisterEvents(target, evtName_1, function (regEvent) {
                    if ((evtName_1.ns && !handlerRef) || regEvent[_DYN_HANDLER ] === handlerRef) {
                        found_1 = true;
                        return true;
                    }
                    return false;
                });
                if (!found_1) {
                    _doDetach(target, evtName_1, handlerRef, useCapture);
                }
            }
            catch (e) {
            }
        }
    }
    function attachEvent(obj, eventNameWithoutOn, handlerRef, useCapture) {
        if (useCapture === void 0) { useCapture = false; }
        return eventOn(obj, eventNameWithoutOn, handlerRef, null, useCapture);
    }
    function detachEvent(obj, eventNameWithoutOn, handlerRef, useCapture) {
        if (useCapture === void 0) { useCapture = false; }
        eventOff(obj, eventNameWithoutOn, handlerRef, null, useCapture);
    }
    function addEventHandler(eventName, callback, evtNamespace) {
        var result = false;
        var w = getWindow();
        if (w) {
            result = eventOn(w, eventName, callback, evtNamespace);
            result = eventOn(w["body"], eventName, callback, evtNamespace) || result;
        }
        var doc = getDocument();
        if (doc) {
            result = eventOn(doc, eventName, callback, evtNamespace) || result;
        }
        return result;
    }
    function removeEventHandler(eventName, callback, evtNamespace) {
        var w = getWindow();
        if (w) {
            eventOff(w, eventName, callback, evtNamespace);
            eventOff(w["body"], eventName, callback, evtNamespace);
        }
        var doc = getDocument();
        if (doc) {
            eventOff(doc, eventName, callback, evtNamespace);
        }
    }
    function _addEventListeners(events, listener, excludeEvents, evtNamespace) {
        var added = false;
        if (listener && events && events[_DYN_LENGTH$1 ] > 0) {
            arrForEach(events, function (name) {
                if (name) {
                    if (!excludeEvents || arrIndexOf(excludeEvents, name) === -1) {
                        added = addEventHandler(name, listener, evtNamespace) || added;
                    }
                }
            });
        }
        return added;
    }
    function addEventListeners(events, listener, excludeEvents, evtNamespace) {
        var added = false;
        if (listener && events && isArray(events)) {
            added = _addEventListeners(events, listener, excludeEvents, evtNamespace);
            if (!added && excludeEvents && excludeEvents[_DYN_LENGTH$1 ] > 0) {
                added = _addEventListeners(events, listener, null, evtNamespace);
            }
        }
        return added;
    }
    function removeEventListeners(events, listener, evtNamespace) {
        if (events && isArray(events)) {
            arrForEach(events, function (name) {
                if (name) {
                    removeEventHandler(name, listener, evtNamespace);
                }
            });
        }
    }
    function addPageUnloadEventListener(listener, excludeEvents, evtNamespace) {
        return addEventListeners([strBeforeUnload, strUnload, strPageHide], listener, excludeEvents, evtNamespace);
    }
    function removePageUnloadEventListener(listener, evtNamespace) {
        removeEventListeners([strBeforeUnload, strUnload, strPageHide], listener, evtNamespace);
    }
    function addPageHideEventListener(listener, excludeEvents, evtNamespace) {
        function _handlePageVisibility(evt) {
            var doc = getDocument();
            if (listener && doc && doc.visibilityState === "hidden") {
                listener(evt);
            }
        }
        var newNamespaces = mergeEvtNamespace(strPageHideNamespace, evtNamespace);
        var pageUnloadAdded = _addEventListeners([strPageHide], listener, excludeEvents, newNamespaces);
        if (!excludeEvents || arrIndexOf(excludeEvents, strVisibilityChangeEvt) === -1) {
            pageUnloadAdded = _addEventListeners([strVisibilityChangeEvt], _handlePageVisibility, excludeEvents, newNamespaces) || pageUnloadAdded;
        }
        if (!pageUnloadAdded && excludeEvents) {
            pageUnloadAdded = addPageHideEventListener(listener, null, evtNamespace);
        }
        return pageUnloadAdded;
    }
    function removePageHideEventListener(listener, evtNamespace) {
        var newNamespaces = mergeEvtNamespace(strPageHideNamespace, evtNamespace);
        removeEventListeners([strPageHide], listener, newNamespaces);
        removeEventListeners([strVisibilityChangeEvt], null, newNamespaces);
    }
    function addPageShowEventListener(listener, excludeEvents, evtNamespace) {
        function _handlePageVisibility(evt) {
            var doc = getDocument();
            if (listener && doc && doc.visibilityState === "visible") {
                listener(evt);
            }
        }
        var newNamespaces = mergeEvtNamespace(strPageShowNamespace, evtNamespace);
        var pageShowAdded = _addEventListeners([strPageShow], listener, excludeEvents, newNamespaces);
        pageShowAdded = _addEventListeners([strVisibilityChangeEvt], _handlePageVisibility, excludeEvents, newNamespaces) || pageShowAdded;
        if (!pageShowAdded && excludeEvents) {
            pageShowAdded = addPageShowEventListener(listener, null, evtNamespace);
        }
        return pageShowAdded;
    }
    function removePageShowEventListener(listener, evtNamespace) {
        var newNamespaces = mergeEvtNamespace(strPageShowNamespace, evtNamespace);
        removeEventListeners([strPageShow], listener, newNamespaces);
        removeEventListeners([strVisibilityChangeEvt], null, newNamespaces);
    }

    var LoggingSeverity = createEnumStyle({
        DISABLED: 0 ,
        CRITICAL: 1 ,
        WARNING: 2 ,
        DEBUG: 3
    });

    var STR_EMPTY = "";
    var STR_DEFAULT_ENDPOINT_URL = "https://browser.events.data.microsoft.com/OneCollector/1.0/";
    var STR_VERSION = "version";
    var STR_PROPERTIES = "properties";

    var _DYN_INITIALIZE = "initialize";
    var _DYN_LOGGER = "logger";
    var _DYN_INDEX_OF = "indexOf";
    var _DYN_TIMINGS = "timings";
    var _DYN_POLL_INTERNAL_LOGS = "pollInternalLogs";
    var _DYN_VALUE = "value";
    var _DYN_KIND = "kind";
    var _DYN_LENGTH = "length";
    var _DYN_PROCESS_TELEMETRY_ST0 = "processTelemetryStart";
    var _DYN_HANDLE_FIELD = "handleField";
    var _DYN_RM_SANITIZER = "rmSanitizer";
    var _DYN_RM_FIELD_SANITIZER = "rmFieldSanitizer";
    var _DYN_CAN_HANDLE = "canHandle";

    var _a;
    var Version = '4.2.2';
    var FullVersionString = "1DS-Web-JS-" + Version;
    var ObjHasOwnProperty = ObjProto$1.hasOwnProperty;
    var strDisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
    var strWithCredentials = "withCredentials";
    var strTimeout = "timeout";
    var _fieldTypeEventPropMap = (_a = {},
        _a[0 ] = 0 ,
        _a[2 ] = 6 ,
        _a[1 ] = 1 ,
        _a[3 ] = 7 ,
        _a[4096  | 2 ] = 6 ,
        _a[4096  | 1 ] = 1 ,
        _a[4096  | 3 ] = 7 ,
        _a);
    var uInt8ArraySupported = null;
    var isDocumentObjectAvailable = hasDocument();
    var isWindowObjectAvailable = hasWindow();
    function isValueAssigned(value) {
        return !(value === STR_EMPTY || isNullOrUndefined(value));
    }
    function getTenantId(apiKey) {
        if (apiKey) {
            var indexTenantId = strIndexOf(apiKey, "-");
            if (indexTenantId > -1) {
                return strLeft(apiKey, indexTenantId);
            }
        }
        return STR_EMPTY;
    }
    function isUint8ArrayAvailable() {
        if (uInt8ArraySupported === null) {
            uInt8ArraySupported = !isUndefined(Uint8Array) && !isSafariOrFirefox() && !isReactNative();
        }
        return uInt8ArraySupported;
    }
    function isLatency(value) {
        if (value && isNumber(value) && value >= 1  && value <= 4 ) {
            return true;
        }
        return false;
    }
    function sanitizeProperty(name, property, stringifyObjects) {
        if ((!property && !isValueAssigned(property)) || typeof name !== "string") {
            return null;
        }
        var propType = typeof property;
        if (propType === "string" || propType === "number" || propType === "boolean" || isArray(property)) {
            property = { value: property };
        }
        else if (propType === "object" && !ObjHasOwnProperty.call(property, "value")) {
            property = { value: stringifyObjects ? JSON.stringify(property) : property };
        }
        else if (isNullOrUndefined(property[_DYN_VALUE ])
            || property[_DYN_VALUE ] === STR_EMPTY || (!isString(property[_DYN_VALUE ])
            && !isNumber(property[_DYN_VALUE ]) && !isBoolean(property[_DYN_VALUE ])
            && !isArray(property[_DYN_VALUE ]))) {
            return null;
        }
        if (isArray(property[_DYN_VALUE ]) &&
            !isArrayValid(property[_DYN_VALUE ])) {
            return null;
        }
        if (!isNullOrUndefined(property[_DYN_KIND ])) {
            if (isArray(property[_DYN_VALUE ]) || !isValueKind(property[_DYN_KIND ])) {
                return null;
            }
            property[_DYN_VALUE ] = property[_DYN_VALUE ].toString();
        }
        return property;
    }
    function getCommonSchemaMetaData(value, kind, type) {
        var encodedTypeValue = -1;
        if (!isUndefined(value)) {
            if (kind > 0) {
                if (kind === 32 ) {
                    encodedTypeValue = (1 << 13);
                }
                else if (kind <= 13) {
                    encodedTypeValue = (kind << 5);
                }
            }
            if (isDataType(type)) {
                if (encodedTypeValue === -1) {
                    encodedTypeValue = 0;
                }
                encodedTypeValue |= type;
            }
            else {
                var propType = _fieldTypeEventPropMap[getFieldValueType(value)] || -1;
                if (encodedTypeValue !== -1 && propType !== -1) {
                    encodedTypeValue |= propType;
                }
                else if (propType === 6 ) {
                    encodedTypeValue = propType;
                }
            }
        }
        return encodedTypeValue;
    }
    function getCookieValue(cookieMgr, name, decode) {
        if (decode === void 0) { decode = true; }
        var cookieValue;
        if (cookieMgr) {
            cookieValue = cookieMgr.get(name);
            if (decode && cookieValue && decodeURIComponent) {
                cookieValue = decodeURIComponent(cookieValue);
            }
        }
        return cookieValue || STR_EMPTY;
    }
    function createGuid(style) {
        if (style === void 0) { style = "D" ; }
        var theGuid = newGuid();
        if (style === "B" ) {
            theGuid = "{" + theGuid + "}";
        }
        else if (style === "P" ) {
            theGuid = "(" + theGuid + ")";
        }
        else if (style === "N" ) {
            theGuid = theGuid.replace(/-/g, STR_EMPTY);
        }
        return theGuid;
    }
    function extend(obj, obj2, obj3, obj4, obj5) {
        var extended = {};
        var deep = false;
        var i = 0;
        var length = arguments[_DYN_LENGTH ];
        var theArgs = arguments;
        if (isBoolean(theArgs[0])) {
            deep = theArgs[0];
            i++;
        }
        for (; i < length; i++) {
            var obj = theArgs[i];
            objForEachKey(obj, function (prop, value) {
                if (deep && value && isObject(value)) {
                    if (isArray(value)) {
                        extended[prop] = extended[prop] || [];
                        arrForEach(value, function (arrayValue, arrayIndex) {
                            if (arrayValue && isObject(arrayValue)) {
                                extended[prop][arrayIndex] = extend(true, extended[prop][arrayIndex], arrayValue);
                            }
                            else {
                                extended[prop][arrayIndex] = arrayValue;
                            }
                        });
                    }
                    else {
                        extended[prop] = extend(true, extended[prop], value);
                    }
                }
                else {
                    extended[prop] = value;
                }
            });
        }
        return extended;
    }
    var getTime = perfNow;
    function isValueKind(value) {
        if (value === 0  || ((value > 0  && value <= 13 ) || value === 32 )) {
            return true;
        }
        return false;
    }
    function isDataType(value) {
        if (value >= 0 && value <= 9) {
            return true;
        }
        return false;
    }
    function isSafariOrFirefox() {
        var nav = getNavigator();
        if (!isUndefined(nav) && nav.userAgent) {
            var ua = nav.userAgent.toLowerCase();
            if ((ua[_DYN_INDEX_OF ]("safari") >= 0 || ua[_DYN_INDEX_OF ]("firefox") >= 0) && ua[_DYN_INDEX_OF ]("chrome") < 0) {
                return true;
            }
        }
        return false;
    }
    function isArrayValid(value) {
        return value[_DYN_LENGTH ] > 0;
    }
    function setProcessTelemetryTimings(event, identifier) {
        var evt = event;
        evt[_DYN_TIMINGS ] = evt[_DYN_TIMINGS ] || {};
        evt[_DYN_TIMINGS ][_DYN_PROCESS_TELEMETRY_ST0 ] = evt[_DYN_TIMINGS ][_DYN_PROCESS_TELEMETRY_ST0 ] || {};
        evt[_DYN_TIMINGS ][_DYN_PROCESS_TELEMETRY_ST0 ][identifier] = getTime();
    }
    function getFieldValueType(value) {
        var theType = 0 ;
        if (value !== null && value !== undefined) {
            var objType = typeof value;
            if (objType === "string") {
                theType = 1 ;
            }
            else if (objType === "number") {
                theType = 2 ;
            }
            else if (objType === "boolean") {
                theType = 3 ;
            }
            else if (objType === strShimObject) {
                theType = 4 ;
                if (isArray(value)) {
                    theType = 4096 ;
                    if (value[_DYN_LENGTH ] > 0) {
                        theType |= getFieldValueType(value[0]);
                    }
                }
                else if (ObjHasOwnProperty.call(value, "value")) {
                    theType = 8192  | getFieldValueType(value[_DYN_VALUE ]);
                }
            }
        }
        return theType;
    }
    function isChromium() {
        return !!getInst("chrome");
    }
    function openXhr(method, urlString, withCredentials, disabled, isSync, timeout) {
        if (disabled === void 0) { disabled = false; }
        if (isSync === void 0) { isSync = false; }
        function _wrapSetXhrProp(xhr, prop, value) {
            try {
                xhr[prop] = value;
            }
            catch (e) {
            }
        }
        var xhr = new XMLHttpRequest();
        if (disabled) {
            _wrapSetXhrProp(xhr, strDisabledPropertyName, disabled);
        }
        if (withCredentials) {
            _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
        }
        xhr.open(method, urlString, !isSync);
        if (withCredentials) {
            _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
        }
        if (!isSync && timeout) {
            _wrapSetXhrProp(xhr, strTimeout, timeout);
        }
        return xhr;
    }
    function isGreaterThanZero(value) {
        return value > 0;
    }

    var defaultConfig = objDeepFreeze({
        endpointUrl: STR_DEFAULT_ENDPOINT_URL,
        propertyStorageOverride: { isVal: _chkPropOverride }
    });
    function _chkPropOverride(propertyStorageOverride) {
        if (propertyStorageOverride && (!propertyStorageOverride.getProperty || !propertyStorageOverride.setProperty)) {
            throwError("Invalid property storage override passed.");
        }
        return true;
    }
    var AppInsightsCore = /** @class */ (function (_super) {
        __extendsFn(AppInsightsCore, _super);
        function AppInsightsCore() {
            var _this = _super.call(this) || this;
            dynamicProto(AppInsightsCore, _this, function (_self, _base) {
                _self[_DYN_INITIALIZE ] = function (config, extensions, logger, notificationManager) {
                    doPerf(_self, function () { return "AppInsightsCore.initialize"; }, function () {
                        try {
                            _base[_DYN_INITIALIZE ](createDynamicConfig(config, defaultConfig, logger || _self[_DYN_LOGGER ], false).cfg, extensions, logger, notificationManager);
                        }
                        catch (e) {
                            var logger_1 = _self[_DYN_LOGGER ];
                            var message = dumpObj(e);
                            if (message[_DYN_INDEX_OF ]("channels") !== -1) {
                                message += "\n - Channels must be provided through config.channels only!";
                            }
                            _throwInternal(logger_1, 1 , 514 , "SDK Initialization Failed - no telemetry will be sent: " + message);
                        }
                    }, function () { return ({ config: config, extensions: extensions, logger: logger, notificationManager: notificationManager }); });
                };
                _self.track = function (item) {
                    doPerf(_self, function () { return "AppInsightsCore.track"; }, function () {
                        var telemetryItem = item;
                        if (telemetryItem) {
                            telemetryItem[_DYN_TIMINGS ] = telemetryItem[_DYN_TIMINGS ] || {};
                            telemetryItem[_DYN_TIMINGS ].trackStart = getTime();
                            if (!isLatency(telemetryItem.latency)) {
                                telemetryItem.latency = 1 ;
                            }
                            var itemExt = telemetryItem.ext = telemetryItem.ext || {};
                            itemExt.sdk = itemExt.sdk || {};
                            itemExt.sdk.ver = FullVersionString;
                            var baseData = telemetryItem.baseData = telemetryItem.baseData || {};
                            baseData[STR_PROPERTIES ] = baseData[STR_PROPERTIES ] || {};
                            var itemProperties = baseData[STR_PROPERTIES ];
                            itemProperties[STR_VERSION] = itemProperties[STR_VERSION] || _self.pluginVersionString || STR_EMPTY;
                        }
                        _base.track(telemetryItem);
                    }, function () { return ({ item: item }); }, !(item.sync));
                };
                _self[_DYN_POLL_INTERNAL_LOGS ] = function (eventName) {
                    return _base[_DYN_POLL_INTERNAL_LOGS ](eventName || "InternalLog");
                };
            });
            return _this;
        }
        AppInsightsCore.__ieDyn=1;
        return AppInsightsCore;
    }(AppInsightsCore$1));

    var ValueKind = createEnumStyle({
        NotSet: 0 ,
        Pii_DistinguishedName: 1 ,
        Pii_GenericData: 2 ,
        Pii_IPV4Address: 3 ,
        Pii_IPv6Address: 4 ,
        Pii_MailSubject: 5 ,
        Pii_PhoneNumber: 6 ,
        Pii_QueryString: 7 ,
        Pii_SipAddress: 8 ,
        Pii_SmtpAddress: 9 ,
        Pii_Identity: 10 ,
        Pii_Uri: 11 ,
        Pii_Fqdn: 12 ,
        Pii_IPV4AddressLegacy: 13 ,
        Pii_IPv6ScrubLastHextets: 14 ,
        Pii_DropValue: 15 ,
        CustomerContent_GenericContent: 32
    });
    var EventLatency = createEnumStyle({
        Normal: 1 ,
        CostDeferred: 2 ,
        RealTime: 3 ,
        Immediate: 4
    });
    var EventPropertyType = createEnumStyle({
        Unspecified: 0 ,
        String: 1 ,
        Int32: 2 ,
        UInt32: 3 ,
        Int64: 4 ,
        UInt64: 5 ,
        Double: 6 ,
        Bool: 7 ,
        Guid: 8 ,
        DateTime: 9
    });
    var EventPersistence = createEnumStyle({
        Normal: 1 ,
        Critical: 2
    });
    var TraceLevel = createEnumStyle({
        NONE: 0 ,
        ERROR: 1 ,
        WARNING: 2 ,
        INFORMATION: 3
    });

    var ValueSanitizer = /** @class */ (function () {
        function ValueSanitizer(fieldSanitizerProvider) {
            var _self = this;
            var _sanitizerMap = {};
            var _sanitizers = [];
            var _fieldSanitizers = [];
            if (fieldSanitizerProvider) {
                _fieldSanitizers.push(fieldSanitizerProvider);
            }
            function _getFieldSanitizer(path, name) {
                var result;
                var fieldLookup = _sanitizerMap[path];
                if (fieldLookup) {
                    result = fieldLookup[name];
                }
                if (!result && result !== null) {
                    if (isString(path) && isString(name)) {
                        if (_fieldSanitizers[_DYN_LENGTH ] > 0) {
                            for (var lp = 0; lp < _fieldSanitizers[_DYN_LENGTH ]; lp++) {
                                if (_fieldSanitizers[lp][_DYN_HANDLE_FIELD ](path, name)) {
                                    result = {
                                        canHandle: true,
                                        fieldHandler: _fieldSanitizers[lp]
                                    };
                                    break;
                                }
                            }
                        }
                        else if (_sanitizers[_DYN_LENGTH ] === 0) {
                            result = {
                                canHandle: true
                            };
                        }
                    }
                    if (!result && result !== null) {
                        result = null;
                        for (var lp = 0; lp < _sanitizers[_DYN_LENGTH ]; lp++) {
                            if (_sanitizers[lp][_DYN_HANDLE_FIELD ](path, name)) {
                                result = {
                                    canHandle: true,
                                    handler: _sanitizers[lp],
                                    fieldHandler: null
                                };
                                break;
                            }
                        }
                    }
                    if (!fieldLookup) {
                        fieldLookup = _sanitizerMap[path] = {};
                    }
                    fieldLookup[name] = result;
                }
                return result;
            }
            _self.clearCache = function () {
                _sanitizerMap = {};
            };
            _self.addSanitizer = function (newSanitizer) {
                if (newSanitizer) {
                    if (!arrIncludes(_sanitizers, newSanitizer)) {
                        _sanitizers.push(newSanitizer);
                    }
                    _sanitizerMap = {};
                }
            };
            _self.addFieldSanitizer = function (fieldSanitizer) {
                if (fieldSanitizer) {
                    if (!arrIncludes(_fieldSanitizers, fieldSanitizer)) {
                        _fieldSanitizers.push(fieldSanitizer);
                    }
                    _sanitizerMap = {};
                }
            };
            _self[_DYN_RM_SANITIZER ] = function (theSanitizer) {
                if (theSanitizer) {
                    var idx = arrIndexOf(_sanitizers, theSanitizer);
                    if (idx !== -1) {
                        _sanitizers.splice(idx, 1);
                        _sanitizerMap = {};
                    }
                    arrForEach(_sanitizers, function (sanitizer) {
                        sanitizer && sanitizer[_DYN_RM_SANITIZER ] && sanitizer[_DYN_RM_SANITIZER ](theSanitizer);
                    });
                }
            };
            _self[_DYN_RM_FIELD_SANITIZER ] = function (theFieldSanitizer) {
                if (theFieldSanitizer) {
                    var idx = arrIndexOf(_fieldSanitizers, theFieldSanitizer);
                    if (idx !== -1) {
                        _fieldSanitizers.splice(idx, 1);
                        _sanitizerMap = {};
                    }
                    arrForEach(_sanitizers, function (sanitizer) {
                        sanitizer && sanitizer[_DYN_RM_FIELD_SANITIZER ] && sanitizer[_DYN_RM_FIELD_SANITIZER ](theFieldSanitizer);
                    });
                }
            };
            _self.isEmpty = function () {
                return (getLength(_sanitizers) + getLength(_fieldSanitizers)) === 0;
            };
            _self[_DYN_HANDLE_FIELD ] = function (path, name) {
                var mapValue = _getFieldSanitizer(path, name);
                return mapValue ? mapValue[_DYN_CAN_HANDLE ] : false;
            };
            _self[_DYN_VALUE ] = function (path, name, value, stringifyObjects) {
                var mapValue = _getFieldSanitizer(path, name);
                if (mapValue && mapValue[_DYN_CAN_HANDLE ]) {
                    if (!mapValue || !mapValue[_DYN_CAN_HANDLE ]) {
                        return null;
                    }
                    if (mapValue.handler) {
                        return mapValue.handler[_DYN_VALUE ](path, name, value, stringifyObjects);
                    }
                    if (!isString(name) || isNullOrUndefined(value) || value === STR_EMPTY) {
                        return null;
                    }
                    var property = null;
                    var fieldType = getFieldValueType(value);
                    if ((fieldType & 8192 ) === 8192 ) {
                        var subType = fieldType & ~8192 ;
                        property = value;
                        if (!isValueAssigned(property[_DYN_VALUE ]) ||
                            (subType !== 1  &&
                                subType !== 2  &&
                                subType !== 3  &&
                                (subType & 4096 ) !== 4096 )) {
                            return null;
                        }
                    }
                    else if (fieldType === 1  ||
                        fieldType === 2  ||
                        fieldType === 3  ||
                        (fieldType & 4096 ) === 4096 ) {
                        property = _convertToProperty(path, name, value);
                    }
                    else if (fieldType === 4 ) {
                        property = _convertToProperty(path, name, !!stringifyObjects ? JSON.stringify(value) : value);
                    }
                    if (property) {
                        return _handleProperty(mapValue, path, name, fieldType, property, stringifyObjects);
                    }
                }
                return null;
            };
            _self.property = function (path, name, property, stringifyObjects) {
                var mapValue = _getFieldSanitizer(path, name);
                if (!mapValue || !mapValue[_DYN_CAN_HANDLE ]) {
                    return null;
                }
                if (!isString(name) || isNullOrUndefined(property) || !isValueAssigned(property[_DYN_VALUE ])) {
                    return null;
                }
                var fieldType = getFieldValueType(property[_DYN_VALUE ]);
                if (fieldType === 0 ) {
                    return null;
                }
                return _handleProperty(mapValue, path, name, fieldType, property, stringifyObjects);
            };
            function _handleProperty(mapValue, path, name, fieldType, property, stringifyObjects) {
                if (mapValue.handler) {
                    return mapValue.handler.property(path, name, property, stringifyObjects);
                }
                if (!isNullOrUndefined(property[_DYN_KIND ])) {
                    if ((fieldType & 4096 ) === 4096  || !isValueKind(property[_DYN_KIND ])) {
                        return null;
                    }
                    property[_DYN_VALUE ] = property[_DYN_VALUE ].toString();
                }
                return _callFieldSanitizer(mapValue.fieldHandler, path, name, fieldType, property);
            }
            function _convertToProperty(path, name, value) {
                if (isValueAssigned(value)) {
                    return { value: value };
                }
                return null;
            }
            function _callFieldSanitizer(fieldProvider, path, name, theType, property) {
                if (property && fieldProvider) {
                    var sanitizer = fieldProvider.getSanitizer(path, name, theType, property[_DYN_KIND ], property.propertyType);
                    if (sanitizer) {
                        if (theType === 4 ) {
                            var newValue_1 = {};
                            var propValue = property[_DYN_VALUE ];
                            objForEachKey(propValue, function (propKey, theValue) {
                                var newPath = path + "." + name;
                                if (isValueAssigned(theValue)) {
                                    var newProp = _convertToProperty(newPath, propKey, theValue);
                                    newProp = _callFieldSanitizer(fieldProvider, newPath, propKey, getFieldValueType(theValue), newProp);
                                    if (newProp) {
                                        newValue_1[propKey] = newProp[_DYN_VALUE ];
                                    }
                                }
                            });
                            property[_DYN_VALUE ] = newValue_1;
                        }
                        else {
                            var details = {
                                path: path,
                                name: name,
                                type: theType,
                                prop: property,
                                sanitizer: _self
                            };
                            property = sanitizer.call(_self, details);
                        }
                    }
                }
                return property;
            }
        }
        ValueSanitizer.getFieldType = getFieldValueType;
        return ValueSanitizer;
    }());

    exports.AppInsightsCore = AppInsightsCore;
    exports.BaseTelemetryPlugin = BaseTelemetryPlugin;
    exports.DiagnosticLogger = DiagnosticLogger;
    exports.EventLatency = EventLatency;
    exports.EventPersistence = EventPersistence;
    exports.EventPropertyType = EventPropertyType;
    exports.EventsDiscardedReason = EventsDiscardedReason;
    exports.FullVersionString = FullVersionString;
    exports.InternalAppInsightsCore = AppInsightsCore$1;
    exports.LoggingSeverity = LoggingSeverity;
    exports.MinChannelPriorty = MinChannelPriorty;
    exports.NotificationManager = NotificationManager;
    exports.PerfEvent = PerfEvent;
    exports.PerfManager = PerfManager;
    exports.ProcessTelemetryContext = ProcessTelemetryContext;
    exports.SenderPostManager = SenderPostManager;
    exports.TraceLevel = TraceLevel;
    exports.Undefined = strShimUndefined;
    exports.ValueKind = ValueKind;
    exports.ValueSanitizer = ValueSanitizer;
    exports.Version = Version;
    exports._InternalLogMessage = _InternalLogMessage;
    exports.__getRegisteredEvents = __getRegisteredEvents;
    exports._appendHeader = _appendHeader;
    exports._getAllResponseHeaders = _getAllResponseHeaders;
    exports._logInternalMessage = _logInternalMessage;
    exports._testHookMaxUnloadHooksCb = _testHookMaxUnloadHooksCb;
    exports._throwInternal = _throwInternal;
    exports._warnToConsole = _warnToConsole;
    exports.addEventHandler = addEventHandler;
    exports.addEventListeners = addEventListeners;
    exports.addPageHideEventListener = addPageHideEventListener;
    exports.addPageShowEventListener = addPageShowEventListener;
    exports.addPageUnloadEventListener = addPageUnloadEventListener;
    exports.areCookiesSupported = areCookiesSupported;
    exports.arrForEach = arrForEach;
    exports.arrIndexOf = arrIndexOf;
    exports.arrMap = arrMap;
    exports.arrReduce = arrReduce;
    exports.attachEvent = attachEvent;
    exports.blockDynamicConversion = blockDynamicConversion;
    exports.convertAllHeadersToMap = convertAllHeadersToMap;
    exports.cookieAvailable = areCookiesSupported;
    exports.createCookieMgr = createCookieMgr;
    exports.createDynamicConfig = createDynamicConfig;
    exports.createEnumStyle = createEnumStyle;
    exports.createGuid = createGuid;
    exports.createProcessTelemetryContext = createProcessTelemetryContext;
    exports.createTraceParent = createTraceParent;
    exports.createUniqueNamespace = createUniqueNamespace;
    exports.createUnloadHandlerContainer = createUnloadHandlerContainer;
    exports.dateNow = utcNow;
    exports.detachEvent = detachEvent;
    exports.disallowsSameSiteNone = uaDisallowsSameSiteNone;
    exports.doPerf = doPerf;
    exports.dumpObj = dumpObj;
    exports.eventOff = eventOff;
    exports.eventOn = eventOn;
    exports.extend = extend;
    exports.findW3cTraceParent = findW3cTraceParent;
    exports.forceDynamicConversion = forceDynamicConversion;
    exports.formatErrorMessageXdr = formatErrorMessageXdr;
    exports.formatErrorMessageXhr = formatErrorMessageXhr;
    exports.formatTraceParent = formatTraceParent;
    exports.generateW3CId = generateW3CId;
    exports.getCommonSchemaMetaData = getCommonSchemaMetaData;
    exports.getConsole = getConsole;
    exports.getCookieValue = getCookieValue;
    exports.getCrypto = getCrypto;
    exports.getDocument = getDocument;
    exports.getDynamicConfigHandler = getDynamicConfigHandler;
    exports.getExceptionName = getExceptionName;
    exports.getFieldValueType = getFieldValueType;
    exports.getGlobal = getGlobal;
    exports.getGlobalInst = getInst;
    exports.getHistory = getHistory;
    exports.getIEVersion = getIEVersion;
    exports.getISOString = toISOString;
    exports.getJSON = getJSON;
    exports.getLocation = getLocation;
    exports.getMsCrypto = getMsCrypto;
    exports.getNavigator = getNavigator;
    exports.getPerformance = getPerformance;
    exports.getResponseText = getResponseText;
    exports.getSetValue = getSetValue;
    exports.getTenantId = getTenantId;
    exports.getTime = getTime;
    exports.getWindow = getWindow;
    exports.hasDocument = hasDocument;
    exports.hasHistory = hasHistory;
    exports.hasJSON = hasJSON;
    exports.hasNavigator = hasNavigator;
    exports.hasOwnProperty = objHasOwnProperty;
    exports.hasWindow = hasWindow;
    exports.isArray = isArray;
    exports.isArrayValid = isArrayValid;
    exports.isBeaconsSupported = isBeaconsSupported;
    exports.isBoolean = isBoolean;
    exports.isChromium = isChromium;
    exports.isDate = isDate;
    exports.isDocumentObjectAvailable = isDocumentObjectAvailable;
    exports.isError = isError;
    exports.isFetchSupported = isFetchSupported;
    exports.isFunction = isFunction;
    exports.isGreaterThanZero = isGreaterThanZero;
    exports.isIE = isIE;
    exports.isLatency = isLatency;
    exports.isNotTruthy = isNotTruthy;
    exports.isNullOrUndefined = isNullOrUndefined;
    exports.isNumber = isNumber;
    exports.isObject = isObject;
    exports.isReactNative = isReactNative;
    exports.isSampledFlag = isSampledFlag;
    exports.isString = isString;
    exports.isTruthy = isTruthy;
    exports.isTypeof = isTypeof;
    exports.isUint8ArrayAvailable = isUint8ArrayAvailable;
    exports.isUndefined = isUndefined;
    exports.isValidSpanId = isValidSpanId;
    exports.isValidTraceId = isValidTraceId;
    exports.isValidTraceParent = isValidTraceParent;
    exports.isValueAssigned = isValueAssigned;
    exports.isValueKind = isValueKind;
    exports.isWindowObjectAvailable = isWindowObjectAvailable;
    exports.isXhrSupported = isXhrSupported;
    exports.mergeEvtNamespace = mergeEvtNamespace;
    exports.newGuid = newGuid;
    exports.newId = newId;
    exports.normalizeJsName = normalizeJsName;
    exports.objDefineAccessors = objDefineAccessors;
    exports.objForEachKey = objForEachKey;
    exports.objFreeze = objFreeze;
    exports.objKeys = objKeys;
    exports.objSeal = objSeal;
    exports.onConfigChange = onConfigChange;
    exports.openXhr = openXhr;
    exports.optimizeObject = optimizeObject;
    exports.parseResponse = parseResponse;
    exports.parseTraceParent = parseTraceParent;
    exports.perfNow = perfNow;
    exports.prependTransports = prependTransports;
    exports.proxyAssign = proxyAssign;
    exports.proxyFunctionAs = proxyFunctionAs;
    exports.proxyFunctions = proxyFunctions;
    exports.random32 = random32;
    exports.randomValue = randomValue;
    exports.removeEventHandler = removeEventHandler;
    exports.removeEventListeners = removeEventListeners;
    exports.removePageHideEventListener = removePageHideEventListener;
    exports.removePageShowEventListener = removePageShowEventListener;
    exports.removePageUnloadEventListener = removePageUnloadEventListener;
    exports.safeGetCookieMgr = safeGetCookieMgr;
    exports.safeGetLogger = safeGetLogger;
    exports.sanitizeProperty = sanitizeProperty;
    exports.setEnableEnvMocks = setEnableEnvMocks;
    exports.setProcessTelemetryTimings = setProcessTelemetryTimings;
    exports.setValue = setValue;
    exports.strContains = strContains;
    exports.strEndsWith = strEndsWith;
    exports.strFunction = strShimFunction;
    exports.strObject = strShimObject;
    exports.strPrototype = strShimPrototype;
    exports.strStartsWith = strStartsWith;
    exports.strTrim = strTrim;
    exports.strUndefined = strShimUndefined;
    exports.throwError = throwError;
    exports.toISOString = toISOString;
    exports.useXDomainRequest = useXDomainRequest;

}));
//# sourceMappingURL=ms.core.js.map


/***/ }),

/***/ 879:
/***/ (function(__unused_webpack_module, exports) {

/*!
 * 1DS JS SDK POST plugin, 4.2.2
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
(function (global, factory) {
     true ? factory(exports) :
    0;
})(this, (function (exports) { 'use strict';

    var RT_PROFILE = "REAL_TIME";
    var NRT_PROFILE = "NEAR_REAL_TIME";
    var BE_PROFILE = "BEST_EFFORT";

    var strShimFunction = "function";
    var strShimObject = "object";
    var strShimUndefined = "undefined";
    var strShimPrototype = "prototype";
    var ObjClass$1 = Object;
    var ObjProto$1 = ObjClass$1[strShimPrototype];

    /*! https://github.com/nevware21/ts-utils v0.11.2 */
    /*#__NO_SIDE_EFFECTS__*/
    function _pureAssign(func1, func2) {
        return func1 || func2;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _pureRef(value, name) {
        return value[name];
    }
    var UNDEF_VALUE = undefined;
    var NULL_VALUE = null;
    var EMPTY = "";
    var FUNCTION = "function";
    var OBJECT = "object";
    var PROTOTYPE = "prototype";
    var __PROTO__ = "__proto__";
    var UNDEFINED = "undefined";
    var CONSTRUCTOR = "constructor";
    var SYMBOL = "Symbol";
    var POLYFILL_TAG = "_polyfill";
    var LENGTH = "length";
    var NAME = "name";
    var CALL = "call";
    var TO_STRING = "toString";
    var ObjClass = ( /*#__PURE__*/_pureAssign(Object));
    var ObjProto = ( /*#__PURE__*/_pureRef(ObjClass, PROTOTYPE));
    var StrCls = ( /*#__PURE__*/_pureAssign(String));
    var StrProto = ( /*#__PURE__*/_pureRef(StrCls, PROTOTYPE));
    var MathCls = ( /*#__PURE__*/_pureAssign(Math));
    var ArrCls = ( /*#__PURE__*/_pureAssign(Array));
    var ArrProto = ( /*#__PURE__*/_pureRef(ArrCls, PROTOTYPE));
    var ArrSlice = ( /*#__PURE__*/_pureRef(ArrProto, "slice"));
    function safe(func, argArray) {
        try {
            return {
                v: func.apply(this, argArray)
            };
        }
        catch (e) {
            return { e: e };
        }
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _createIs(theType) {
        return function (value) {
            return typeof value === theType;
        };
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isUndefined(value) {
        return typeof value === UNDEFINED || value === UNDEFINED;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isNullOrUndefined(value) {
        return value === NULL_VALUE || isUndefined(value);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isStrictNullOrUndefined(value) {
        return value === NULL_VALUE || !isDefined(value);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isDefined(arg) {
        return !!arg || arg !== UNDEF_VALUE;
    }
    var isString = ( /*#__PURE__*/_createIs("string"));
    var isFunction = ( /*#__PURE__*/_createIs(FUNCTION));
    /*#__NO_SIDE_EFFECTS__*/
    function isObject(value) {
        if (!value && isNullOrUndefined(value)) {
            return false;
        }
        return !!value && typeof value === OBJECT;
    }
    var isArray = ( /* #__PURE__*/_pureRef(ArrCls, "isArray"));
    var isNumber = ( /*#__PURE__*/_createIs("number"));
    var isBoolean = ( /*#__PURE__*/_createIs("boolean"));
    /*#__NO_SIDE_EFFECTS__*/
    function isPromiseLike(value) {
        return !!(value && value.then && isFunction(value.then));
    }
    var objGetOwnPropertyDescriptor = ( /* #__PURE__ */_pureRef(ObjClass, "getOwnPropertyDescriptor"));
    /*#__NO_SIDE_EFFECTS__*/
    function objHasOwnProperty(obj, prop) {
        return !!obj && ObjProto.hasOwnProperty[CALL](obj, prop);
    }
    var objHasOwn = ( /*#__PURE__*/_pureAssign(( /* #__PURE__ */_pureRef(ObjClass, "hasOwn")), polyObjHasOwn));
    /*#__NO_SIDE_EFFECTS__*/
    function polyObjHasOwn(obj, prop) {
        return objHasOwnProperty(obj, prop) || !!objGetOwnPropertyDescriptor(obj, prop);
    }
    function objForEachKey(theObject, callbackfn, thisArg) {
        if (theObject && isObject(theObject)) {
            for (var prop in theObject) {
                if (objHasOwn(theObject, prop)) {
                    if (callbackfn[CALL](thisArg || theObject, prop, theObject[prop]) === -1) {
                        break;
                    }
                }
            }
        }
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _createKeyValueMap(values, keyType, valueType, completeFn) {
        var theMap = {};
        objForEachKey(values, function (key, value) {
            theMap[key] = keyType ? value : key;
            theMap[value] = valueType ? value : key;
        });
        return completeFn(theMap);
    }
    var asString = ( /* #__PURE__ */_pureAssign(StrCls));
    var ERROR_TYPE = "[object Error]";
    /*#__NO_SIDE_EFFECTS__*/
    function dumpObj(object, format) {
        var propertyValueDump = EMPTY;
        var objType = ObjProto[TO_STRING][CALL](object);
        if (objType === ERROR_TYPE) {
            object = { stack: asString(object.stack), message: asString(object.message), name: asString(object.name) };
        }
        try {
            propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? ((typeof format === "number") ? format : 4) : UNDEF_VALUE);
            propertyValueDump = (propertyValueDump && propertyValueDump.replace(/"(\w+)"\s*:\s{0,1}/g, "$1: ")) || asString(object);
        }
        catch (e) {
            propertyValueDump = " - " + dumpObj(e, format);
        }
        return objType + ": " + propertyValueDump;
    }
    function throwTypeError(message) {
        throw new TypeError(message);
    }
    var _objFreeze = ( /* #__PURE__ */_pureRef(ObjClass, "freeze"));
    function _doNothing(value) {
        return value;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _getProto(value) {
        return value[__PROTO__] || NULL_VALUE;
    }
    var objAssign = ( /*#__PURE__*/_pureRef(ObjClass, "assign"));
    var objKeys = ( /*#__PURE__*/_pureRef(ObjClass, "keys"));
    function objDeepFreeze(value) {
        if (_objFreeze) {
            objForEachKey(value, function (key, value) {
                if (isArray(value) || isObject(value)) {
                    _objFreeze(value);
                }
            });
        }
        return objFreeze(value);
    }
    var objFreeze = ( /* #__PURE__*/_pureAssign(_objFreeze, _doNothing));
    var objGetPrototypeOf = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ObjClass, "getPrototypeOf")), _getProto));
    /*#__NO_SIDE_EFFECTS__*/
    function createEnum(values) {
        return _createKeyValueMap(values, 1 , 0 , objDeepFreeze);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function createEnumKeyMap(values) {
        return _createKeyValueMap(values, 0 , 0 , objDeepFreeze);
    }
    var _wellKnownSymbolMap = /*#__PURE__*/ createEnumKeyMap({
        asyncIterator: 0 ,
        hasInstance: 1 ,
        isConcatSpreadable: 2 ,
        iterator: 3 ,
        match: 4 ,
        matchAll: 5 ,
        replace: 6 ,
        search: 7 ,
        species: 8 ,
        split: 9 ,
        toPrimitive: 10 ,
        toStringTag: 11 ,
        unscopables: 12
    });
    var GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg";
    var _globalCfg;
    /*#__NO_SIDE_EFFECTS__*/
    function _getGlobalValue() {
        var result;
        if (typeof globalThis !== UNDEFINED) {
            result = globalThis;
        }
        if (!result && typeof self !== UNDEFINED) {
            result = self;
        }
        if (!result && typeof window !== UNDEFINED) {
            result = window;
        }
        if (!result && typeof global !== UNDEFINED) {
            result = global;
        }
        return result;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _getGlobalConfig() {
        if (!_globalCfg) {
            var gbl = safe(_getGlobalValue).v || {};
            _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};
        }
        return _globalCfg;
    }
    var _unwrapFunction = ( _unwrapFunctionWithPoly);
    /*#__NO_SIDE_EFFECTS__*/
    function _unwrapFunctionWithPoly(funcName, clsProto, polyFunc) {
        var clsFn = clsProto && clsProto[funcName];
        return function (thisArg) {
            var theFunc = (thisArg && thisArg[funcName]) || clsFn;
            if (theFunc || polyFunc) {
                var theArgs = arguments;
                return (theFunc || polyFunc).apply(thisArg, theFunc ? ArrSlice[CALL](theArgs, 1) : theArgs);
            }
            throwTypeError("\"" + asString(funcName) + "\" not defined for " + dumpObj(thisArg));
        };
    }
    var mathMax = ( /*#__PURE__*/_pureRef(MathCls, "max"));
    var strSlice = ( /*#__PURE__*/_unwrapFunction("slice", StrProto));
    var strSubstring = ( /*#__PURE__*/_unwrapFunction("substring", StrProto));
    var strSubstr = ( /*#__PURE__*/_unwrapFunctionWithPoly("substr", StrProto, polyStrSubstr));
    /*#__NO_SIDE_EFFECTS__*/
    function polyStrSubstr(value, start, length) {
        if (isNullOrUndefined(value)) {
            throwTypeError("Invalid " + dumpObj(value));
        }
        if (length < 0) {
            return EMPTY;
        }
        start = start || 0;
        if (start < 0) {
            start = mathMax(start + value[LENGTH], 0);
        }
        if (isUndefined(length)) {
            return strSlice(value, start);
        }
        return strSlice(value, start, start + length);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function strLeft(value, count) {
        return strSubstring(value, 0, count);
    }
    var UNIQUE_REGISTRY_ID = "_urid";
    var _polySymbols;
    /*#__NO_SIDE_EFFECTS__*/
    function _globalSymbolRegistry() {
        if (!_polySymbols) {
            var gblCfg = _getGlobalConfig();
            _polySymbols = gblCfg.gblSym = gblCfg.gblSym || { k: {}, s: {} };
        }
        return _polySymbols;
    }
    var _wellKnownSymbolCache;
    /*#__NO_SIDE_EFFECTS__*/
    function polyNewSymbol(description) {
        var theSymbol = {
            description: asString(description),
            toString: function () { return SYMBOL + "(" + description + ")"; }
        };
        theSymbol[POLYFILL_TAG] = true;
        return theSymbol;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function polySymbolFor(key) {
        var registry = _globalSymbolRegistry();
        if (!objHasOwn(registry.k, key)) {
            var newSymbol_1 = polyNewSymbol(key);
            var regId_1 = objKeys(registry.s).length;
            newSymbol_1[UNIQUE_REGISTRY_ID] = function () { return regId_1 + "_" + newSymbol_1[TO_STRING](); };
            registry.k[key] = newSymbol_1;
            registry.s[newSymbol_1[UNIQUE_REGISTRY_ID]()] = asString(key);
        }
        return registry.k[key];
    }
    /*#__NO_SIDE_EFFECTS__*/
    function polyGetKnownSymbol(name) {
        !_wellKnownSymbolCache && (_wellKnownSymbolCache = {});
        var result;
        var knownName = _wellKnownSymbolMap[name];
        if (knownName) {
            result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || polyNewSymbol(SYMBOL + "." + knownName);
        }
        return result;
    }
    var propMap = {
        e: "enumerable",
        c: "configurable",
        v: "value",
        w: "writable",
        g: "get",
        s: "set"
    };
    /*#__NO_SIDE_EFFECTS__*/
    function _createProp(value) {
        var prop = {};
        prop[propMap["c"]] = true;
        prop[propMap["e"]] = true;
        if (value.l) {
            prop.get = function () { return value.l.v; };
            var desc = objGetOwnPropertyDescriptor(value.l, "v");
            if (desc && desc.set) {
                prop.set = function (newValue) {
                    value.l.v = newValue;
                };
            }
        }
        objForEachKey(value, function (key, value) {
            prop[propMap[key]] = isUndefined(value) ? prop[propMap[key]] : value;
        });
        return prop;
    }
    var objDefineProp = ( /*#__PURE__*/_pureRef(ObjClass, "defineProperty"));
    function objDefine(target, key, propDesc) {
        return objDefineProp(target, key, _createProp(propDesc));
    }
    var _globalLazyTestHooks;
    function _initTestHooks() {
        _globalLazyTestHooks = _getGlobalConfig();
    }
    /*#__NO_SIDE_EFFECTS__*/
    function createCachedValue(value) {
        return objDefineProp({
            toJSON: function () { return value; }
        }, "v", { value: value });
    }
    var WINDOW = "window";
    var _cachedGlobal;
    function _getGlobalInstFn(getFn, theArgs) {
        var cachedValue;
        return function () {
            !_globalLazyTestHooks && _initTestHooks();
            (!cachedValue || _globalLazyTestHooks.lzy) && (cachedValue = createCachedValue(safe(getFn, theArgs).v));
            return cachedValue.v;
        };
    }
    /*#__NO_SIDE_EFFECTS__*/
    function getGlobal(useCached) {
        !_globalLazyTestHooks && _initTestHooks();
        (!_cachedGlobal || useCached === false || _globalLazyTestHooks.lzy) && (_cachedGlobal = createCachedValue(safe(_getGlobalValue).v || NULL_VALUE));
        return _cachedGlobal.v;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function getInst(name, useCached) {
        var gbl = (!_cachedGlobal || useCached === false) ? getGlobal(useCached) : _cachedGlobal.v;
        if (gbl && gbl[name]) {
            return gbl[name];
        }
        if (name === WINDOW) {
            return getWindow();
        }
        return NULL_VALUE;
    }
    var getDocument = ( /*#__PURE__*/_getGlobalInstFn(getInst, ["document"]));
    /*#__NO_SIDE_EFFECTS__*/
    function hasWindow() {
        return !!( /*#__PURE__*/getWindow());
    }
    var getWindow = ( /*#__PURE__*/_getGlobalInstFn(getInst, [WINDOW]));
    /*#__NO_SIDE_EFFECTS__*/
    function hasNavigator() {
        return !!( /*#__PURE__*/getNavigator());
    }
    var getNavigator = ( /*#__PURE__*/_getGlobalInstFn(getInst, ["navigator"]));
    var isNode = ( /*#__PURE__*/_getGlobalInstFn(function () {
        return !!( safe(function () { return (process && (process.versions || {}).node); }).v);
    }));
    var _symbol;
    var _symbolFor;
    /*#__NO_SIDE_EFFECTS__*/
    function _initSymbol() {
        _symbol = ( /*#__PURE__*/createCachedValue(safe((getInst), [SYMBOL]).v));
        return _symbol;
    }
    function _getSymbolKey(key) {
        var gblSym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());
        return (gblSym.v ? gblSym.v[key] : UNDEF_VALUE);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function hasSymbol() {
        return !!( /*#__PURE__*/getSymbol());
    }
    /*#__NO_SIDE_EFFECTS__*/
    function getSymbol() {
        !_globalLazyTestHooks && _initTestHooks();
        return ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol()).v;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function getKnownSymbol(name, noPoly) {
        var knownName = _wellKnownSymbolMap[name];
        !_globalLazyTestHooks && _initTestHooks();
        var sym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());
        return sym.v ? sym.v[knownName || name] : (!noPoly ? polyGetKnownSymbol(name) : UNDEF_VALUE);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function newSymbol(description, noPoly) {
        !_globalLazyTestHooks && _initTestHooks();
        var sym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());
        return sym.v ? sym.v(description) : (!noPoly ? polyNewSymbol(description) : NULL_VALUE);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function symbolFor(key) {
        !_globalLazyTestHooks && _initTestHooks();
        _symbolFor = ((!_globalLazyTestHooks.lzy ? _symbolFor : 0) || ( /*#__PURE__*/createCachedValue(safe((_getSymbolKey), ["for"]).v)));
        return (_symbolFor.v || polySymbolFor)(key);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isIterator(value) {
        return !!value && isFunction(value.next);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isIterable(value) {
        return !isStrictNullOrUndefined(value) && isFunction(value[getKnownSymbol(3 )]);
    }
    var _iterSymbol$1;
    function iterForOf(iter, callbackfn, thisArg) {
        if (iter) {
            if (!isIterator(iter)) {
                !_iterSymbol$1 && (_iterSymbol$1 = createCachedValue(getKnownSymbol(3 )));
                iter = iter[_iterSymbol$1.v] ? iter[_iterSymbol$1.v]() : null;
            }
            if (isIterator(iter)) {
                var err = UNDEF_VALUE;
                var iterResult = UNDEF_VALUE;
                try {
                    var count = 0;
                    while (!(iterResult = iter.next()).done) {
                        if (callbackfn[CALL](thisArg || iter, iterResult.value, count, iter) === -1) {
                            break;
                        }
                        count++;
                    }
                }
                catch (failed) {
                    err = { e: failed };
                    if (iter.throw) {
                        iterResult = NULL_VALUE;
                        iter.throw(err);
                    }
                }
                finally {
                    try {
                        if (iterResult && !iterResult.done) {
                            iter.return && iter.return(iterResult);
                        }
                    }
                    finally {
                        if (err) {
                            throw err.e;
                        }
                    }
                }
            }
        }
    }
    function fnApply(fn, thisArg, argArray) {
        return fn.apply(thisArg, argArray);
    }
    function arrAppend(target, elms) {
        if (!isUndefined(elms) && target) {
            if (isArray(elms)) {
                fnApply(target.push, target, elms);
            }
            else if (isIterator(elms) || isIterable(elms)) {
                iterForOf(elms, function (elm) {
                    target.push(elm);
                });
            }
            else {
                target.push(elms);
            }
        }
        return target;
    }
    function arrForEach(theArray, callbackfn, thisArg) {
        if (theArray) {
            var len = theArray[LENGTH] >>> 0;
            for (var idx = 0; idx < len; idx++) {
                if (idx in theArray) {
                    if (callbackfn[CALL](thisArg || theArray, theArray[idx], idx, theArray) === -1) {
                        break;
                    }
                }
            }
        }
    }
    var arrIndexOf = ( /*#__PURE__*/_unwrapFunction("indexOf", ArrProto));
    function arrSlice(theArray, start, end) {
        return ((theArray && theArray["slice"]) || ArrSlice).apply(theArray, ArrSlice[CALL](arguments, 1));
    }
    var objCreate = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ObjClass, "create")), polyObjCreate));
    /*#__NO_SIDE_EFFECTS__*/
    function polyObjCreate(obj) {
        if (!obj) {
            return {};
        }
        var type = typeof obj;
        if (type !== OBJECT && type !== FUNCTION) {
            throwTypeError("Prototype must be an Object or function: " + dumpObj(obj));
        }
        function tempFunc() { }
        tempFunc[PROTOTYPE] = obj;
        return new tempFunc();
    }
    var _isProtoArray;
    function objSetPrototypeOf(obj, proto) {
        var fn = ObjClass["setPrototypeOf"] ||
            function (d, b) {
                var _a;
                !_isProtoArray && (_isProtoArray = createCachedValue((_a = {}, _a[__PROTO__] = [], _a) instanceof Array));
                _isProtoArray.v ? d[__PROTO__] = b : objForEachKey(b, function (key, value) { return d[key] = value; });
            };
        return fn(obj, proto);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _createCustomError(name, d, b) {
        safe(objDefine, [d, NAME, { v: name, c: true, e: false }]);
        d = objSetPrototypeOf(d, b);
        function __() {
            this[CONSTRUCTOR] = d;
            safe(objDefine, [this, NAME, { v: name, c: true, e: false }]);
        }
        d[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : (__[PROTOTYPE] = b[PROTOTYPE], new __());
        return d;
    }
    function _setName(baseClass, name) {
        name && (baseClass[NAME] = name);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function createCustomError(name, constructCb, errorBase) {
        var theBaseClass = errorBase || Error;
        var orgName = theBaseClass[PROTOTYPE][NAME];
        var captureFn = Error.captureStackTrace;
        return _createCustomError(name, function () {
            var _this = this;
            var theArgs = arguments;
            try {
                safe(_setName, [theBaseClass, name]);
                var _self = fnApply(theBaseClass, _this, ArrSlice[CALL](theArgs)) || _this;
                if (_self !== _this) {
                    var orgProto = objGetPrototypeOf(_this);
                    if (orgProto !== objGetPrototypeOf(_self)) {
                        objSetPrototypeOf(_self, orgProto);
                    }
                }
                captureFn && captureFn(_self, _this[CONSTRUCTOR]);
                constructCb && constructCb(_self, theArgs);
                return _self;
            }
            finally {
                safe(_setName, [theBaseClass, orgName]);
            }
        }, theBaseClass);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function utcNow() {
        return (Date.now || polyUtcNow)();
    }
    /*#__NO_SIDE_EFFECTS__*/
    function polyUtcNow() {
        return new Date().getTime();
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _createTrimFn(exp) {
        return function _doTrim(value) {
            if (isNullOrUndefined(value)) {
                throwTypeError("strTrim called [" + dumpObj(value) + "]");
            }
            if (value && value.replace) {
                value = value.replace(exp, EMPTY);
            }
            return value;
        };
    }
    var polyStrTrim = ( /*#__PURE__*/_createTrimFn(/^\s+|(?=\s)\s+$/g));
    var strTrim = ( /*#__PURE__*/_unwrapFunctionWithPoly("trim", StrProto, polyStrTrim));
    var _fnToString;
    var _objCtrFnString;
    var _gblWindow;
    /*#__NO_SIDE_EFFECTS__*/
    function isPlainObject(value) {
        if (!value || typeof value !== OBJECT) {
            return false;
        }
        if (!_gblWindow) {
            _gblWindow = hasWindow() ? getWindow() : true;
        }
        var result = false;
        if (value !== _gblWindow) {
            if (!_objCtrFnString) {
                _fnToString = Function[PROTOTYPE][TO_STRING];
                _objCtrFnString = _fnToString[CALL](ObjClass);
            }
            try {
                var proto = objGetPrototypeOf(value);
                result = !proto;
                if (!result) {
                    if (objHasOwnProperty(proto, CONSTRUCTOR)) {
                        proto = proto[CONSTRUCTOR];
                    }
                    result = proto && typeof proto === FUNCTION && _fnToString[CALL](proto) === _objCtrFnString;
                }
            }
            catch (ex) {
            }
        }
        return result;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function perfNow() {
        return utcNow();
    }
    var strIndexOf = ( /*#__PURE__*/_unwrapFunction("indexOf", StrProto));
    var strStartsWith = ( /*#__PURE__*/_unwrapFunctionWithPoly("startsWith", StrProto, polyStrStartsWith));
    /*#__NO_SIDE_EFFECTS__*/
    function polyStrStartsWith(value, searchString, position) {
        if (!isString(value)) {
            throwTypeError("'" + dumpObj(value) + "' is not a string");
        }
        var searchValue = isString(searchString) ? searchString : asString(searchString);
        var pos = position > 0 ? position : 0;
        return strSubstring(value, pos, pos + searchValue[LENGTH]) === searchValue;
    }
    var REF = "ref";
    var UNREF = "unref";
    var HAS_REF = "hasRef";
    var ENABLED = "enabled";
    /*#__NO_SIDE_EFFECTS__*/
    function _createTimerHandler(startTimer, refreshFn, cancelFn) {
        var ref = true;
        var timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE;
        var theTimerHandler;
        function _unref() {
            ref = false;
            timerId && timerId[UNREF] && timerId[UNREF]();
            return theTimerHandler;
        }
        function _cancel() {
            timerId && cancelFn(timerId);
            timerId = NULL_VALUE;
        }
        function _refresh() {
            timerId = refreshFn(timerId);
            if (!ref) {
                _unref();
            }
            return theTimerHandler;
        }
        function _setEnabled(value) {
            !value && timerId && _cancel();
            value && !timerId && _refresh();
        }
        theTimerHandler = {
            cancel: _cancel,
            refresh: _refresh
        };
        theTimerHandler[HAS_REF] = function () {
            if (timerId && timerId[HAS_REF]) {
                return timerId[HAS_REF]();
            }
            return ref;
        };
        theTimerHandler[REF] = function () {
            ref = true;
            timerId && timerId[REF] && timerId[REF]();
            return theTimerHandler;
        };
        theTimerHandler[UNREF] = _unref;
        theTimerHandler = objDefineProp(theTimerHandler, ENABLED, {
            get: function () { return !!timerId; },
            set: _setEnabled
        });
        return {
            h: theTimerHandler,
            dn: function () {
                timerId = NULL_VALUE;
            }
        };
    }
    function _createTimeoutWith(startTimer, overrideFn, theArgs) {
        var isArr = isArray(overrideFn);
        var len = isArr ? overrideFn.length : 0;
        var setFn = (len > 0 ? overrideFn[0] : (!isArr ? overrideFn : UNDEF_VALUE)) || setTimeout;
        var clearFn = (len > 1 ? overrideFn[1] : UNDEF_VALUE) || clearTimeout;
        var timerFn = theArgs[0];
        theArgs[0] = function () {
            handler.dn();
            fnApply(timerFn, UNDEF_VALUE, ArrSlice[CALL](arguments));
        };
        var handler = _createTimerHandler(startTimer, function (timerId) {
            if (timerId) {
                if (timerId.refresh) {
                    timerId.refresh();
                    return timerId;
                }
                fnApply(clearFn, UNDEF_VALUE, [timerId]);
            }
            return fnApply(setFn, UNDEF_VALUE, theArgs);
        }, function (timerId) {
            fnApply(clearFn, UNDEF_VALUE, [timerId]);
        });
        return handler.h;
    }
    function scheduleTimeout(callback, timeout) {
        return _createTimeoutWith(true, UNDEF_VALUE, ArrSlice[CALL](arguments));
    }
    function scheduleTimeoutWith(overrideFn, callback, timeout) {
        return _createTimeoutWith(true, overrideFn, ArrSlice[CALL](arguments, 1));
    }

    var strHasOwnProperty = "hasOwnProperty";
    var extendStaticsFn = function (d, b) {
        extendStaticsFn = ObjClass$1["setPrototypeOf"] ||
            ({ __proto__: [] } instanceof Array && function (d, b) {
                d.__proto__ = b;
            }) ||
            function (d, b) {
                for (var p in b) {
                    if (b[strHasOwnProperty](p)) {
                        d[p] = b[p];
                    }
                }
            };
        return extendStaticsFn(d, b);
    };
    function __extendsFn(d, b) {
        if (typeof b !== strShimFunction && b !== null) {
            throwTypeError("Class extends value " + String(b) + " is not a constructor or null");
        }
        extendStaticsFn(d, b);
        function __() {
            this.constructor = d;
        }
        d[strShimPrototype] = b === null ? objCreate(b) : (__[strShimPrototype] = b[strShimPrototype], new __());
    }

    var _a$4;
    var Constructor = 'constructor';
    var Prototype = 'prototype';
    var strFunction = 'function';
    var DynInstFuncTable = '_dynInstFuncs';
    var DynProxyTag = '_isDynProxy';
    var DynClassName = '_dynClass';
    var DynClassNamePrefix = '_dynCls$';
    var DynInstChkTag = '_dynInstChk';
    var DynAllowInstChkTag = DynInstChkTag;
    var DynProtoDefaultOptions = '_dfOpts';
    var UnknownValue = '_unknown_';
    var str__Proto = "__proto__";
    var DynProtoBaseProto = "_dyn" + str__Proto;
    var DynProtoGlobalSettings = "__dynProto$Gbl";
    var DynProtoCurrent = "_dynInstProto";
    var strUseBaseInst = 'useBaseInst';
    var strSetInstFuncs = 'setInstFuncs';
    var Obj = Object;
    var _objGetPrototypeOf = Obj["getPrototypeOf"];
    var _objGetOwnProps = Obj["getOwnPropertyNames"];
    var _gbl = getGlobal();
    var _gblInst = _gbl[DynProtoGlobalSettings] || (_gbl[DynProtoGlobalSettings] = {
        o: (_a$4 = {},
            _a$4[strSetInstFuncs] = true,
            _a$4[strUseBaseInst] = true,
            _a$4),
        n: 1000
    });
    function _isObjectOrArrayPrototype(target) {
        return target && (target === Obj[Prototype] || target === Array[Prototype]);
    }
    function _isObjectArrayOrFunctionPrototype(target) {
        return _isObjectOrArrayPrototype(target) || target === Function[Prototype];
    }
    function _getObjProto(target) {
        var newProto;
        if (target) {
            if (_objGetPrototypeOf) {
                return _objGetPrototypeOf(target);
            }
            var curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);
            newProto = target[DynProtoBaseProto] || curProto;
            if (!objHasOwnProperty(target, DynProtoBaseProto)) {
                delete target[DynProtoCurrent];
                newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto];
                target[DynProtoCurrent] = curProto;
            }
        }
        return newProto;
    }
    function _forEachProp(target, func) {
        var props = [];
        if (_objGetOwnProps) {
            props = _objGetOwnProps(target);
        }
        else {
            for (var name_1 in target) {
                if (typeof name_1 === "string" && objHasOwnProperty(target, name_1)) {
                    props.push(name_1);
                }
            }
        }
        if (props && props.length > 0) {
            for (var lp = 0; lp < props.length; lp++) {
                func(props[lp]);
            }
        }
    }
    function _isDynamicCandidate(target, funcName, skipOwn) {
        return (funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || objHasOwnProperty(target, funcName)) && funcName !== str__Proto && funcName !== Prototype);
    }
    function _throwTypeError(message) {
        throwTypeError("DynamicProto: " + message);
    }
    function _getInstanceFuncs(thisTarget) {
        var instFuncs = objCreate(null);
        _forEachProp(thisTarget, function (name) {
            if (!instFuncs[name] && _isDynamicCandidate(thisTarget, name, false)) {
                instFuncs[name] = thisTarget[name];
            }
        });
        return instFuncs;
    }
    function _hasVisited(values, value) {
        for (var lp = values.length - 1; lp >= 0; lp--) {
            if (values[lp] === value) {
                return true;
            }
        }
        return false;
    }
    function _getBaseFuncs(classProto, thisTarget, instFuncs, useBaseInst) {
        function _instFuncProxy(target, funcHost, funcName) {
            var theFunc = funcHost[funcName];
            if (theFunc[DynProxyTag] && useBaseInst) {
                var instFuncTable = target[DynInstFuncTable] || {};
                if (instFuncTable[DynAllowInstChkTag] !== false) {
                    theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc;
                }
            }
            return function () {
                return theFunc.apply(target, arguments);
            };
        }
        var baseFuncs = objCreate(null);
        _forEachProp(instFuncs, function (name) {
            baseFuncs[name] = _instFuncProxy(thisTarget, instFuncs, name);
        });
        var baseProto = _getObjProto(classProto);
        var visited = [];
        while (baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto)) {
            _forEachProp(baseProto, function (name) {
                if (!baseFuncs[name] && _isDynamicCandidate(baseProto, name, !_objGetPrototypeOf)) {
                    baseFuncs[name] = _instFuncProxy(thisTarget, baseProto, name);
                }
            });
            visited.push(baseProto);
            baseProto = _getObjProto(baseProto);
        }
        return baseFuncs;
    }
    function _getInstFunc(target, funcName, proto, currentDynProtoProxy) {
        var instFunc = null;
        if (target && objHasOwnProperty(proto, DynClassName)) {
            var instFuncTable = target[DynInstFuncTable] || objCreate(null);
            instFunc = (instFuncTable[proto[DynClassName]] || objCreate(null))[funcName];
            if (!instFunc) {
                _throwTypeError("Missing [" + funcName + "] " + strFunction);
            }
            if (!instFunc[DynInstChkTag] && instFuncTable[DynAllowInstChkTag] !== false) {
                var canAddInst = !objHasOwnProperty(target, funcName);
                var objProto = _getObjProto(target);
                var visited = [];
                while (canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto)) {
                    var protoFunc = objProto[funcName];
                    if (protoFunc) {
                        canAddInst = (protoFunc === currentDynProtoProxy);
                        break;
                    }
                    visited.push(objProto);
                    objProto = _getObjProto(objProto);
                }
                try {
                    if (canAddInst) {
                        target[funcName] = instFunc;
                    }
                    instFunc[DynInstChkTag] = 1;
                }
                catch (e) {
                    instFuncTable[DynAllowInstChkTag] = false;
                }
            }
        }
        return instFunc;
    }
    function _getProtoFunc(funcName, proto, currentDynProtoProxy) {
        var protoFunc = proto[funcName];
        if (protoFunc === currentDynProtoProxy) {
            protoFunc = _getObjProto(proto)[funcName];
        }
        if (typeof protoFunc !== strFunction) {
            _throwTypeError("[" + funcName + "] is not a " + strFunction);
        }
        return protoFunc;
    }
    function _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {
        function _createDynamicPrototype(proto, funcName) {
            var dynProtoProxy = function () {
                var instFunc = _getInstFunc(this, funcName, proto, dynProtoProxy) || _getProtoFunc(funcName, proto, dynProtoProxy);
                return instFunc.apply(this, arguments);
            };
            dynProtoProxy[DynProxyTag] = 1;
            return dynProtoProxy;
        }
        if (!_isObjectOrArrayPrototype(proto)) {
            var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || objCreate(null);
            if (!_isObjectOrArrayPrototype(instFuncTable)) {
                var instFuncs_1 = instFuncTable[className] = (instFuncTable[className] || objCreate(null));
                if (instFuncTable[DynAllowInstChkTag] !== false) {
                    instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc;
                }
                if (!_isObjectOrArrayPrototype(instFuncs_1)) {
                    _forEachProp(target, function (name) {
                        if (_isDynamicCandidate(target, name, false) && target[name] !== baseInstFuncs[name]) {
                            instFuncs_1[name] = target[name];
                            delete target[name];
                            if (!objHasOwnProperty(proto, name) || (proto[name] && !proto[name][DynProxyTag])) {
                                proto[name] = _createDynamicPrototype(proto, name);
                            }
                        }
                    });
                }
            }
        }
    }
    function _checkPrototype(classProto, thisTarget) {
        if (_objGetPrototypeOf) {
            var visited = [];
            var thisProto = _getObjProto(thisTarget);
            while (thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto)) {
                if (thisProto === classProto) {
                    return true;
                }
                visited.push(thisProto);
                thisProto = _getObjProto(thisProto);
            }
            return false;
        }
        return true;
    }
    function _getObjName(target, unknownValue) {
        if (objHasOwnProperty(target, Prototype)) {
            return target.name || unknownValue || UnknownValue;
        }
        return (((target || {})[Constructor]) || {}).name || unknownValue || UnknownValue;
    }
    function dynamicProto(theClass, target, delegateFunc, options) {
        if (!objHasOwnProperty(theClass, Prototype)) {
            _throwTypeError("theClass is an invalid class definition.");
        }
        var classProto = theClass[Prototype];
        if (!_checkPrototype(classProto, target)) {
            _throwTypeError("[" + _getObjName(theClass) + "] not in hierarchy of [" + _getObjName(target) + "]");
        }
        var className = null;
        if (objHasOwnProperty(classProto, DynClassName)) {
            className = classProto[DynClassName];
        }
        else {
            className = DynClassNamePrefix + _getObjName(theClass, "_") + "$" + _gblInst.n;
            _gblInst.n++;
            classProto[DynClassName] = className;
        }
        var perfOptions = dynamicProto[DynProtoDefaultOptions];
        var useBaseInst = !!perfOptions[strUseBaseInst];
        if (useBaseInst && options && options[strUseBaseInst] !== undefined) {
            useBaseInst = !!options[strUseBaseInst];
        }
        var instFuncs = _getInstanceFuncs(target);
        var baseFuncs = _getBaseFuncs(classProto, target, instFuncs, useBaseInst);
        delegateFunc(target, baseFuncs);
        var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];
        if (setInstanceFunc && options) {
            setInstanceFunc = !!options[strSetInstFuncs];
        }
        _populatePrototype(classProto, className, target, instFuncs, setInstanceFunc !== false);
    }
    dynamicProto[DynProtoDefaultOptions] = _gblInst.o;

    var createEnumStyle = createEnum;

    var EventsDiscardedReason = createEnumStyle({
        Unknown: 0 ,
        NonRetryableStatus: 1 ,
        InvalidEvent: 2 ,
        SizeLimitExceeded: 3 ,
        KillSwitch: 4 ,
        QueueFull: 5
    });

    var _DYN_TO_LOWER_CASE$1 = "toLowerCase";
    var _DYN_BLK_VAL = "blkVal";
    var _DYN_LENGTH$2 = "length";
    var _DYN_RD_ONLY = "rdOnly";
    var _DYN_NOTIFY = "notify";
    var _DYN_WARN_TO_CONSOLE = "warnToConsole";
    var _DYN_THROW_INTERNAL = "throwInternal";
    var _DYN_SET_DF = "setDf";
    var _DYN_WATCH = "watch";
    var _DYN_LOGGER = "logger";
    var _DYN_APPLY = "apply";
    var _DYN_PUSH$1 = "push";
    var _DYN_SPLICE$1 = "splice";
    var _DYN_HDLR = "hdlr";
    var _DYN_CANCEL = "cancel";
    var _DYN_INITIALIZE$1 = "initialize";
    var _DYN_IDENTIFIER$1 = "identifier";
    var _DYN_IS_INITIALIZED = "isInitialized";
    var _DYN_GET_PLUGIN = "getPlugin";
    var _DYN_NAME = "name";
    var _DYN_TIME = "time";
    var _DYN_PROCESS_NEXT = "processNext";
    var _DYN_GET_PROCESS_TEL_CONT2 = "getProcessTelContext";
    var _DYN_UNLOAD = "unload";
    var _DYN_LOGGING_LEVEL_CONSOL4 = "loggingLevelConsole";
    var _DYN_CREATE_NEW = "createNew";
    var _DYN_TEARDOWN = "teardown";
    var _DYN_MESSAGE_ID = "messageId";
    var _DYN_MESSAGE = "message";
    var _DYN_IS_ASYNC = "isAsync";
    var _DYN_DIAG_LOG = "diagLog";
    var _DYN__DO_TEARDOWN = "_doTeardown";
    var _DYN_UPDATE = "update";
    var _DYN_GET_NEXT = "getNext";
    var _DYN_SET_NEXT_PLUGIN = "setNextPlugin";
    var _DYN_PROTOCOL = "protocol";
    var _DYN_USER_AGENT = "userAgent";
    var _DYN_SPLIT$1 = "split";
    var _DYN_NODE_TYPE = "nodeType";
    var _DYN_REPLACE = "replace";
    var _DYN_LOG_INTERNAL_MESSAGE = "logInternalMessage";
    var _DYN_TYPE = "type";
    var _DYN_HANDLER = "handler";
    var _DYN_STATUS = "status";
    var _DYN_GET_RESPONSE_HEADER = "getResponseHeader";
    var _DYN_GET_ALL_RESPONSE_HEA5 = "getAllResponseHeaders";
    var _DYN_IS_CHILD_EVT = "isChildEvt";
    var _DYN_DATA$1 = "data";
    var _DYN_GET_CTX = "getCtx";
    var _DYN_SET_CTX = "setCtx";
    var _DYN_COMPLETE = "complete";
    var _DYN_URL_STRING$1 = "urlString";
    var _DYN_SEND_POST = "sendPOST";
    var _DYN_HEADERS$1 = "headers";
    var _DYN_TIMEOUT$1 = "timeout";
    var _DYN_SET_REQUEST_HEADER = "setRequestHeader";

    var aggregationErrorType;
    function throwAggregationError(message, sourceErrors) {
        if (!aggregationErrorType) {
            aggregationErrorType = createCustomError("AggregationError", function (self, args) {
                if (args[_DYN_LENGTH$2 ] > 1) {
                    self.errors = args[1];
                }
            });
        }
        var theMessage = message || "One or more errors occurred.";
        arrForEach(sourceErrors, function (srcError, idx) {
            theMessage += "\n".concat(idx, " > ").concat(dumpObj(srcError));
        });
        throw new aggregationErrorType(theMessage, sourceErrors || []);
    }

    /*!
     * NevWare21 - ts-async, 0.5.1
     * https://github.com/nevware21/ts-async
     * Copyright (c) NevWare21 and contributors. All rights reserved.
     * Licensed under the MIT license.
     */
    var STR_PROMISE = "Promise";
    var REJECTED = "rejected";
    function doAwaitResponse(value, cb) {
        return doAwait(value, function (value) {
            return cb ? cb({
                status: "fulfilled",
                rejected: false,
                value: value
            }) : value;
        }, function (reason) {
            return cb ? cb({
                status: REJECTED,
                rejected: true,
                reason: reason
            }) : reason;
        });
    }
    function doAwait(value, resolveFn, rejectFn, finallyFn) {
        var result = value;
        try {
            if (isPromiseLike(value)) {
                if (resolveFn || rejectFn) {
                    result = value.then(resolveFn, rejectFn);
                }
            }
            else {
                try {
                    if (resolveFn) {
                        result = resolveFn(value);
                    }
                }
                catch (err) {
                    if (rejectFn) {
                        result = rejectFn(err);
                    }
                    else {
                        throw err;
                    }
                }
            }
        }
        finally {
            if (finallyFn) {
                doFinally(result, finallyFn);
            }
        }
        return result;
    }
    function doFinally(value, finallyFn) {
        var result = value;
        if (finallyFn) {
            if (isPromiseLike(value)) {
                if (value.finally) {
                    result = value.finally(finallyFn);
                }
                else {
                    result = value.then(function (value) {
                        finallyFn();
                        return value;
                    }, function (reason) {
                        finallyFn();
                        throw reason;
                    });
                }
            }
            else {
                finallyFn();
            }
        }
        return result;
    }
    var STRING_STATES =  [
        "pending", "resolving", "resolved", REJECTED
    ];
    var DISPATCH_EVENT = "dispatchEvent";
    var _hasInitEvent;
    function _hasInitEventFn(doc) {
        var evt;
        if (doc && doc.createEvent) {
            evt = doc.createEvent("Event");
        }
        return (!!evt && evt.initEvent);
    }
    function emitEvent(target, evtName, populateEvent, useNewEvent) {
        var doc = getDocument();
        !_hasInitEvent && (_hasInitEvent = createCachedValue(!!safe(_hasInitEventFn, [doc]).v));
        var theEvt = _hasInitEvent.v ? doc.createEvent("Event") : (useNewEvent ? new Event(evtName) : {});
        populateEvent && populateEvent(theEvt);
        if (_hasInitEvent.v) {
            theEvt.initEvent(evtName, false, true);
        }
        if (theEvt && target[DISPATCH_EVENT]) {
            target[DISPATCH_EVENT](theEvt);
        }
        else {
            var handler = target["on" + evtName];
            if (handler) {
                handler(theEvt);
            }
            else {
                var theConsole = getInst("console");
                theConsole && (theConsole["error"] || theConsole["log"])(evtName, dumpObj(theEvt));
            }
        }
    }
    var NODE_UNHANDLED_REJECTION = "unhandledRejection";
    var UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();
    var _unhandledRejectionTimeout = 10;
    var _hasPromiseRejectionEvent;
    function dumpFnObj(value) {
        if (isFunction(value)) {
            return value.toString();
        }
        return dumpObj(value);
    }
    function _createPromise(newPromise, processor, executor) {
        var additionalArgs = arrSlice(arguments, 3);
        var _state = 0 ;
        var _hasResolved = false;
        var _settledValue;
        var _queue = [];
        var _handled = false;
        var _unHandledRejectionHandler = null;
        var _thePromise;
        function _then(onResolved, onRejected) {
            try {
                _handled = true;
                _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
                _unHandledRejectionHandler = null;
                var thenPromise = newPromise(function (resolve, reject) {
                    _queue.push(function () {
                        try {
                            var handler = _state === 2  ? onResolved : onRejected;
                            var value = isUndefined(handler) ? _settledValue : (isFunction(handler) ? handler(_settledValue) : handler);
                            if (isPromiseLike(value)) {
                                value.then(resolve, reject);
                            }
                            else if (handler) {
                                resolve(value);
                            }
                            else if (_state === 3 ) {
                                reject(value);
                            }
                            else {
                                resolve(value);
                            }
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                    if (_hasResolved) {
                        _processQueue();
                    }
                }, additionalArgs);
                return thenPromise;
            }
            finally {
            }
        }
        function _catch(onRejected) {
            return _then(undefined, onRejected);
        }
        function _finally(onFinally) {
            var thenFinally = onFinally;
            var catchFinally = onFinally;
            if (isFunction(onFinally)) {
                thenFinally = function (value) {
                    onFinally && onFinally();
                    return value;
                };
                catchFinally = function (reason) {
                    onFinally && onFinally();
                    throw reason;
                };
            }
            return _then(thenFinally, catchFinally);
        }
        function _strState() {
            return STRING_STATES[_state];
        }
        function _processQueue() {
            if (_queue.length > 0) {
                var pending = _queue.slice();
                _queue = [];
                _handled = true;
                _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
                _unHandledRejectionHandler = null;
                processor(pending);
            }
        }
        function _createSettleIfFn(newState, allowState) {
            return function (theValue) {
                if (_state === allowState) {
                    if (newState === 2  && isPromiseLike(theValue)) {
                        _state = 1 ;
                        theValue.then(_createSettleIfFn(2 , 1 ), _createSettleIfFn(3 , 1 ));
                        return;
                    }
                    _state = newState;
                    _hasResolved = true;
                    _settledValue = theValue;
                    _processQueue();
                    if (!_handled && newState === 3  && !_unHandledRejectionHandler) {
                        _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout);
                    }
                }
            };
        }
        function _notifyUnhandledRejection() {
            if (!_handled) {
                _handled = true;
                if (isNode()) {
                    process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);
                }
                else {
                    var gbl = getWindow() || getGlobal();
                    !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = createCachedValue(safe((getInst), [STR_PROMISE + "RejectionEvent"]).v));
                    emitEvent(gbl, UNHANDLED_REJECTION, function (theEvt) {
                        objDefine(theEvt, "promise", { g: function () { return _thePromise; } });
                        theEvt.reason = _settledValue;
                        return theEvt;
                    }, !!_hasPromiseRejectionEvent.v);
                }
            }
        }
        _thePromise = {
            then: _then,
            "catch": _catch,
            finally: _finally
        };
        objDefineProp(_thePromise, "state", {
            get: _strState
        });
        if (hasSymbol()) {
            _thePromise[getKnownSymbol(11 )] = "IPromise";
        }
        function _toString() {
            return "IPromise" + ("") + " " + _strState() + (_hasResolved ? (" - " + dumpFnObj(_settledValue)) : "") + ("");
        }
        _thePromise.toString = _toString;
        (function _initialize() {
            if (!isFunction(executor)) {
                throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpFnObj(executor));
            }
            var _rejectFn = _createSettleIfFn(3 , 0 );
            try {
                executor.call(_thePromise, _createSettleIfFn(2 , 0 ), _rejectFn);
            }
            catch (e) {
                _rejectFn(e);
            }
        })();
        return _thePromise;
    }
    function syncItemProcessor(pending) {
        arrForEach(pending, function (fn) {
            try {
                fn();
            }
            catch (e) {
            }
        });
    }
    function timeoutItemProcessor(timeout) {
        var callbackTimeout = isNumber(timeout) ? timeout : 0;
        return function (pending) {
            scheduleTimeout(function () {
                syncItemProcessor(pending);
            }, callbackTimeout);
        };
    }
    function createAsyncPromise(executor, timeout) {
        return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);
    }
    var _promiseCls;
    function createNativePromise(executor, timeout) {
        !_promiseCls && (_promiseCls = createCachedValue((safe(getInst, [STR_PROMISE]).v) || null));
        var PrmCls = _promiseCls.v;
        if (!PrmCls) {
            return createAsyncPromise(executor);
        }
        if (!isFunction(executor)) {
            throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpObj(executor));
        }
        var _state = 0 ;
        function _strState() {
            return STRING_STATES[_state];
        }
        var thePromise = new PrmCls(function (resolve, reject) {
            function _resolve(value) {
                _state = 2 ;
                resolve(value);
            }
            function _reject(reason) {
                _state = 3 ;
                reject(reason);
            }
            executor(_resolve, _reject);
        });
        objDefineProp(thePromise, "state", {
            get: _strState
        });
        return thePromise;
    }
    var _promiseCreator;
    function createPromise(executor, timeout) {
        !_promiseCreator && (_promiseCreator = createCachedValue(createNativePromise));
        return _promiseCreator.v.call(this, executor, timeout);
    }

    var UNDEFINED_VALUE = undefined;
    var STR_EMPTY$3 = "";
    var STR_CORE = "core";
    var STR_DISABLED = "disabled";
    var STR_EXTENSION_CONFIG = "extensionConfig";
    var STR_PROCESS_TELEMETRY = "processTelemetry";
    var STR_PRIORITY = "priority";
    var STR_GET_PERF_MGR = "getPerfMgr";
    var STR_NOT_DYNAMIC_ERROR = "Not dynamic - ";

    var rCamelCase = /-([a-z])/g;
    var rNormalizeInvalid = /([^\w\d_$])/g;
    var rLeadingNumeric = /^(\d+[\w\d_$])/;
    function isNotNullOrUndefined(value) {
        return !isNullOrUndefined(value);
    }
    function normalizeJsName(name) {
        var value = name;
        if (value && isString(value)) {
            value = value[_DYN_REPLACE ](rCamelCase, function (_all, letter) {
                return letter.toUpperCase();
            });
            value = value[_DYN_REPLACE ](rNormalizeInvalid, "_");
            value = value[_DYN_REPLACE ](rLeadingNumeric, function (_all, match) {
                return "_" + match;
            });
        }
        return value;
    }
    function strContains(value, search) {
        if (value && search) {
            return strIndexOf(value, search) !== -1;
        }
        return false;
    }
    function _createProxyFunction(source, funcName) {
        var srcFunc = null;
        var src = null;
        if (isFunction(source)) {
            srcFunc = source;
        }
        else {
            src = source;
        }
        return function () {
            var originalArguments = arguments;
            if (srcFunc) {
                src = srcFunc();
            }
            if (src) {
                return src[funcName][_DYN_APPLY ](src, originalArguments);
            }
        };
    }
    function proxyFunctionAs(target, name, source, theFunc, overwriteTarget) {
        if (target && name && source) {
            if (overwriteTarget !== false || isUndefined(target[name])) {
                target[name] = _createProxyFunction(source, theFunc);
            }
        }
    }
    function proxyFunctions(target, source, functionsToProxy, overwriteTarget) {
        if (target && source && isObject(target) && isArray(functionsToProxy)) {
            arrForEach(functionsToProxy, function (theFuncName) {
                if (isString(theFuncName)) {
                    proxyFunctionAs(target, theFuncName, source, theFuncName, overwriteTarget);
                }
            });
        }
        return target;
    }
    function optimizeObject(theObject) {
        if (theObject && objAssign) {
            theObject = ObjClass$1(objAssign({}, theObject));
        }
        return theObject;
    }
    function getResponseText(xhr) {
        try {
            return xhr.responseText;
        }
        catch (e) {
        }
        return null;
    }
    function formatErrorMessageXdr(xdr, message) {
        if (xdr) {
            return "XDomainRequest,Response:" + getResponseText(xdr) || 0;
        }
        return message;
    }
    function formatErrorMessageXhr(xhr, message) {
        if (xhr) {
            return "XMLHttpRequest,Status:" + xhr[_DYN_STATUS ] + ",Response:" + getResponseText(xhr) || 0 || 0;
        }
        return message;
    }
    function prependTransports(theTransports, newTransports) {
        if (newTransports) {
            if (isNumber(newTransports)) {
                theTransports = [newTransports].concat(theTransports);
            }
            else if (isArray(newTransports)) {
                theTransports = newTransports.concat(theTransports);
            }
        }
        return theTransports;
    }
    var strDisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
    var strWithCredentials = "withCredentials";
    var strTimeout = "timeout";
    function openXhr(method, urlString, withCredentials, disabled, isSync, timeout) {
        if (disabled === void 0) { disabled = false; }
        if (isSync === void 0) { isSync = false; }
        function _wrapSetXhrProp(xhr, prop, value) {
            try {
                xhr[prop] = value;
            }
            catch (e) {
            }
        }
        var xhr = new XMLHttpRequest();
        if (disabled) {
            _wrapSetXhrProp(xhr, strDisabledPropertyName, disabled);
        }
        if (withCredentials) {
            _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
        }
        xhr.open(method, urlString, !isSync);
        if (withCredentials) {
            _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
        }
        if (!isSync && timeout) {
            _wrapSetXhrProp(xhr, strTimeout, timeout);
        }
        return xhr;
    }
    function convertAllHeadersToMap(headersString) {
        var headers = {};
        if (isString(headersString)) {
            var headersArray = strTrim(headersString)[_DYN_SPLIT$1 ](/[\r\n]+/);
            arrForEach(headersArray, function (headerEntry) {
                if (headerEntry) {
                    var idx = headerEntry.indexOf(": ");
                    if (idx !== -1) {
                        var header = strTrim(headerEntry.substring(0, idx))[_DYN_TO_LOWER_CASE$1 ]();
                        var value = strTrim(headerEntry.substring(idx + 1));
                        headers[header] = value;
                    }
                    else {
                        headers[strTrim(headerEntry)] = 1;
                    }
                }
            });
        }
        return headers;
    }
    function _appendHeader(theHeaders, xhr, name) {
        if (!theHeaders[name] && xhr && xhr[_DYN_GET_RESPONSE_HEADER ]) {
            var value = xhr[_DYN_GET_RESPONSE_HEADER ](name);
            if (value) {
                theHeaders[name] = strTrim(value);
            }
        }
        return theHeaders;
    }
    var STR_KILL_DURATION_HEADER$1 = "kill-duration";
    var STR_KILL_DURATION_SECONDS_HEADER = "kill-duration-seconds";
    var STR_TIME_DELTA_HEADER$1 = "time-delta-millis";
    function _getAllResponseHeaders(xhr, isOneDs) {
        var theHeaders = {};
        if (!xhr[_DYN_GET_ALL_RESPONSE_HEA5 ]) {
            if (!!isOneDs) {
                theHeaders = _appendHeader(theHeaders, xhr, STR_TIME_DELTA_HEADER$1);
                theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_HEADER$1);
                theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_SECONDS_HEADER);
            }
        }
        else {
            theHeaders = convertAllHeadersToMap(xhr[_DYN_GET_ALL_RESPONSE_HEA5 ]());
        }
        return theHeaders;
    }

    var strLocation = "location";
    var strConsole = "console";
    var strJSON = "JSON";
    var strCrypto = "crypto";
    var strMsCrypto = "msCrypto";
    var strReactNative = "ReactNative";
    var strMsie = "msie";
    var strTrident = "trident/";
    var strXMLHttpRequest = "XMLHttpRequest";
    var _isTrident = null;
    var _navUserAgentCheck = null;
    var _enableMocks = false;
    var _useXDomainRequest = null;
    var _beaconsSupported = null;
    function _hasProperty(theClass, property) {
        var supported = false;
        if (theClass) {
            try {
                supported = property in theClass;
                if (!supported) {
                    var proto = theClass[strShimPrototype];
                    if (proto) {
                        supported = property in proto;
                    }
                }
            }
            catch (e) {
            }
            if (!supported) {
                try {
                    var tmp = new theClass();
                    supported = !isUndefined(tmp[property]);
                }
                catch (e) {
                }
            }
        }
        return supported;
    }
    function getLocation(checkForMock) {
        if (checkForMock && _enableMocks) {
            var mockLocation = getInst("__mockLocation");
            if (mockLocation) {
                return mockLocation;
            }
        }
        if (typeof location === strShimObject && location) {
            return location;
        }
        return getInst(strLocation);
    }
    function getConsole() {
        if (typeof console !== strShimUndefined) {
            return console;
        }
        return getInst(strConsole);
    }
    function hasJSON() {
        return Boolean((typeof JSON === strShimObject && JSON) || getInst(strJSON) !== null);
    }
    function getJSON() {
        if (hasJSON()) {
            return JSON || getInst(strJSON);
        }
        return null;
    }
    function getCrypto() {
        return getInst(strCrypto);
    }
    function getMsCrypto() {
        return getInst(strMsCrypto);
    }
    function isReactNative() {
        var nav = getNavigator();
        if (nav && nav.product) {
            return nav.product === strReactNative;
        }
        return false;
    }
    function isIE() {
        var nav = getNavigator();
        if (nav && (nav[_DYN_USER_AGENT ] !== _navUserAgentCheck || _isTrident === null)) {
            _navUserAgentCheck = nav[_DYN_USER_AGENT ];
            var userAgent = (_navUserAgentCheck || STR_EMPTY$3)[_DYN_TO_LOWER_CASE$1 ]();
            _isTrident = (strContains(userAgent, strMsie) || strContains(userAgent, strTrident));
        }
        return _isTrident;
    }
    function isBeaconsSupported(useCached) {
        if (_beaconsSupported === null || useCached === false) {
            _beaconsSupported = hasNavigator() && Boolean(getNavigator().sendBeacon);
        }
        return _beaconsSupported;
    }
    function isFetchSupported(withKeepAlive) {
        var isSupported = false;
        try {
            isSupported = !!getInst("fetch");
            var request = getInst("Request");
            if (isSupported && withKeepAlive && request) {
                isSupported = _hasProperty(request, "keepalive");
            }
        }
        catch (e) {
        }
        return isSupported;
    }
    function useXDomainRequest() {
        if (_useXDomainRequest === null) {
            _useXDomainRequest = (typeof XDomainRequest !== strShimUndefined);
            if (_useXDomainRequest && isXhrSupported()) {
                _useXDomainRequest = _useXDomainRequest && !_hasProperty(getInst(strXMLHttpRequest), "withCredentials");
            }
        }
        return _useXDomainRequest;
    }
    function isXhrSupported() {
        var isSupported = false;
        try {
            var xmlHttpRequest = getInst(strXMLHttpRequest);
            isSupported = !!xmlHttpRequest;
        }
        catch (e) {
        }
        return isSupported;
    }

    var UInt32Mask = 0x100000000;
    var MaxUInt32 = 0xffffffff;
    var SEED1 = 123456789;
    var SEED2 = 987654321;
    var _mwcSeeded = false;
    var _mwcW = SEED1;
    var _mwcZ = SEED2;
    function _mwcSeed(seedValue) {
        if (seedValue < 0) {
            seedValue >>>= 0;
        }
        _mwcW = (SEED1 + seedValue) & MaxUInt32;
        _mwcZ = (SEED2 - seedValue) & MaxUInt32;
        _mwcSeeded = true;
    }
    function _autoSeedMwc() {
        try {
            var now = utcNow() & 0x7fffffff;
            _mwcSeed(((Math.random() * UInt32Mask) ^ now) + now);
        }
        catch (e) {
        }
    }
    function random32(signed) {
        var value = 0;
        var c = getCrypto() || getMsCrypto();
        if (c && c.getRandomValues) {
            value = c.getRandomValues(new Uint32Array(1))[0] & MaxUInt32;
        }
        if (value === 0 && isIE()) {
            if (!_mwcSeeded) {
                _autoSeedMwc();
            }
            value = mwcRandom32() & MaxUInt32;
        }
        if (value === 0) {
            value = Math.floor((UInt32Mask * Math.random()) | 0);
        }
        if (!signed) {
            value >>>= 0;
        }
        return value;
    }
    function mwcRandom32(signed) {
        _mwcZ = (36969 * (_mwcZ & 0xFFFF) + (_mwcZ >> 16)) & MaxUInt32;
        _mwcW = (18000 * (_mwcW & 0xFFFF) + (_mwcW >> 16)) & MaxUInt32;
        var value = (((_mwcZ << 16) + (_mwcW & 0xFFFF)) >>> 0) & MaxUInt32 | 0;
        if (!signed) {
            value >>>= 0;
        }
        return value;
    }
    function newId(maxLength) {
        if (maxLength === void 0) { maxLength = 22; }
        var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var number = random32() >>> 0;
        var chars = 0;
        var result = STR_EMPTY$3;
        while (result[_DYN_LENGTH$2 ] < maxLength) {
            chars++;
            result += base64chars.charAt(number & 0x3F);
            number >>>= 6;
            if (chars === 5) {
                number = (((random32() << 2) & 0xFFFFFFFF) | (number & 0x03)) >>> 0;
                chars = 0;
            }
        }
        return result;
    }

    var version = '3.2.2';
    var instanceName = "." + newId(6);
    var _dataUid = 0;
    function _canAcceptData(target) {
        return target[_DYN_NODE_TYPE ] === 1 || target[_DYN_NODE_TYPE ] === 9 || !(+target[_DYN_NODE_TYPE ]);
    }
    function _getCache(data, target) {
        var theCache = target[data.id];
        if (!theCache) {
            theCache = {};
            try {
                if (_canAcceptData(target)) {
                    objDefine(target, data.id, {
                        e: false,
                        v: theCache
                    });
                }
            }
            catch (e) {
            }
        }
        return theCache;
    }
    function createUniqueNamespace(name, includeVersion) {
        if (includeVersion === void 0) { includeVersion = false; }
        return normalizeJsName(name + (_dataUid++) + (includeVersion ? "." + version : STR_EMPTY$3) + instanceName);
    }
    function createElmNodeData(name) {
        var data = {
            id: createUniqueNamespace("_aiData-" + (name || STR_EMPTY$3) + "." + version),
            accept: function (target) {
                return _canAcceptData(target);
            },
            get: function (target, name, defValue, addDefault) {
                var theCache = target[data.id];
                if (!theCache) {
                    if (addDefault) {
                        theCache = _getCache(data, target);
                        theCache[normalizeJsName(name)] = defValue;
                    }
                    return defValue;
                }
                return theCache[normalizeJsName(name)];
            },
            kill: function (target, name) {
                if (target && target[name]) {
                    try {
                        delete target[name];
                    }
                    catch (e) {
                    }
                }
            }
        };
        return data;
    }

    function _isConfigDefaults(value) {
        return (value && isObject(value) && (value.isVal || value.fb || objHasOwn(value, "v") || objHasOwn(value, "mrg") || objHasOwn(value, "ref") || value.set));
    }
    function _getDefault(dynamicHandler, theConfig, cfgDefaults) {
        var defValue;
        var isDefaultValid = cfgDefaults.dfVal || isDefined;
        if (theConfig && cfgDefaults.fb) {
            var fallbacks = cfgDefaults.fb;
            if (!isArray(fallbacks)) {
                fallbacks = [fallbacks];
            }
            for (var lp = 0; lp < fallbacks[_DYN_LENGTH$2 ]; lp++) {
                var fallback = fallbacks[lp];
                var fbValue = theConfig[fallback];
                if (isDefaultValid(fbValue)) {
                    defValue = fbValue;
                }
                else if (dynamicHandler) {
                    fbValue = dynamicHandler.cfg[fallback];
                    if (isDefaultValid(fbValue)) {
                        defValue = fbValue;
                    }
                    dynamicHandler.set(dynamicHandler.cfg, asString(fallback), fbValue);
                }
                if (isDefaultValid(defValue)) {
                    break;
                }
            }
        }
        if (!isDefaultValid(defValue) && isDefaultValid(cfgDefaults.v)) {
            defValue = cfgDefaults.v;
        }
        return defValue;
    }
    function _resolveDefaultValue(dynamicHandler, theConfig, cfgDefaults) {
        var theValue = cfgDefaults;
        if (cfgDefaults && _isConfigDefaults(cfgDefaults)) {
            theValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);
        }
        if (theValue) {
            if (_isConfigDefaults(theValue)) {
                theValue = _resolveDefaultValue(dynamicHandler, theConfig, theValue);
            }
            var newValue_1;
            if (isArray(theValue)) {
                newValue_1 = [];
                newValue_1[_DYN_LENGTH$2 ] = theValue[_DYN_LENGTH$2 ];
            }
            else if (isPlainObject(theValue)) {
                newValue_1 = {};
            }
            if (newValue_1) {
                objForEachKey(theValue, function (key, value) {
                    if (value && _isConfigDefaults(value)) {
                        value = _resolveDefaultValue(dynamicHandler, theConfig, value);
                    }
                    newValue_1[key] = value;
                });
                theValue = newValue_1;
            }
        }
        return theValue;
    }
    function _applyDefaultValue(dynamicHandler, theConfig, name, defaultValue) {
        var isValid;
        var setFn;
        var defValue;
        var cfgDefaults = defaultValue;
        var mergeDf;
        var reference;
        var readOnly;
        var blkDynamicValue;
        if (_isConfigDefaults(cfgDefaults)) {
            isValid = cfgDefaults.isVal;
            setFn = cfgDefaults.set;
            readOnly = cfgDefaults[_DYN_RD_ONLY ];
            blkDynamicValue = cfgDefaults[_DYN_BLK_VAL ];
            mergeDf = cfgDefaults.mrg;
            reference = cfgDefaults.ref;
            if (!reference && isUndefined(reference)) {
                reference = !!mergeDf;
            }
            defValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);
        }
        else {
            defValue = defaultValue;
        }
        if (blkDynamicValue) {
            dynamicHandler[_DYN_BLK_VAL ](theConfig, name);
        }
        var theValue;
        var usingDefault = true;
        var cfgValue = theConfig[name];
        if (cfgValue || !isNullOrUndefined(cfgValue)) {
            theValue = cfgValue;
            usingDefault = false;
            if (isValid && theValue !== defValue && !isValid(theValue)) {
                theValue = defValue;
                usingDefault = true;
            }
            if (setFn) {
                theValue = setFn(theValue, defValue, theConfig);
                usingDefault = theValue === defValue;
            }
        }
        if (!usingDefault) {
            if (isPlainObject(theValue) || isArray(defValue)) {
                if (mergeDf && defValue && (isPlainObject(defValue) || isArray(defValue))) {
                    objForEachKey(defValue, function (dfName, dfValue) {
                        _applyDefaultValue(dynamicHandler, theValue, dfName, dfValue);
                    });
                }
            }
        }
        else if (defValue) {
            theValue = _resolveDefaultValue(dynamicHandler, theConfig, defValue);
        }
        else {
            theValue = defValue;
        }
        dynamicHandler.set(theConfig, name, theValue);
        if (reference) {
            dynamicHandler.ref(theConfig, name);
        }
        if (readOnly) {
            dynamicHandler[_DYN_RD_ONLY ](theConfig, name);
        }
    }

    var CFG_HANDLER_LINK = symbolFor("[[ai_dynCfg_1]]");
    var BLOCK_DYNAMIC = symbolFor("[[ai_blkDynCfg_1]]");
    var FORCE_DYNAMIC = symbolFor("[[ai_frcDynCfg_1]]");
    function _cfgDeepCopy(source) {
        if (source) {
            var target_1;
            if (isArray(source)) {
                target_1 = [];
                target_1[_DYN_LENGTH$2 ] = source[_DYN_LENGTH$2 ];
            }
            else if (isPlainObject(source)) {
                target_1 = {};
            }
            if (target_1) {
                objForEachKey(source, function (key, value) {
                    target_1[key] = _cfgDeepCopy(value);
                });
                return target_1;
            }
        }
        return source;
    }
    function getDynamicConfigHandler(value) {
        if (value) {
            var handler = value[CFG_HANDLER_LINK] || value;
            if (handler.cfg && (handler.cfg === value || handler.cfg[CFG_HANDLER_LINK] === handler)) {
                return handler;
            }
        }
        return null;
    }
    function blockDynamicConversion(value) {
        if (value && (isPlainObject(value) || isArray(value))) {
            try {
                value[BLOCK_DYNAMIC] = true;
            }
            catch (e) {
            }
        }
        return value;
    }
    function _canMakeDynamic(getFunc, state, value) {
        var result = false;
        if (value && !getFunc[state.blkVal]) {
            result = value[FORCE_DYNAMIC];
            if (!result && !value[BLOCK_DYNAMIC]) {
                result = isPlainObject(value) || isArray(value);
            }
        }
        return result;
    }
    function throwInvalidAccess(message) {
        throwTypeError("InvalidAccess:" + message);
    }

    var arrayMethodsToPatch = [
        "push",
        "pop",
        "shift",
        "unshift",
        "splice"
    ];
    var _throwDynamicError = function (logger, name, desc, e) {
        logger && logger[_DYN_THROW_INTERNAL ](3 , 108 , "".concat(desc, " [").concat(name, "] failed - ") + dumpObj(e));
    };
    function _patchArray(state, target, name) {
        if (isArray(target)) {
            arrForEach(arrayMethodsToPatch, function (method) {
                var orgMethod = target[method];
                target[method] = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    var result = orgMethod[_DYN_APPLY ](this, args);
                    _makeDynamicObject(state, target, name, "Patching");
                    return result;
                };
            });
        }
    }
    function _getOwnPropGetter(target, name) {
        var propDesc = objGetOwnPropertyDescriptor(target, name);
        return propDesc && propDesc.get;
    }
    function _createDynamicProperty(state, theConfig, name, value) {
        var detail = {
            n: name,
            h: [],
            trk: function (handler) {
                if (handler && handler.fn) {
                    if (arrIndexOf(detail.h, handler) === -1) {
                        detail.h[_DYN_PUSH$1 ](handler);
                    }
                    state.trk(handler, detail);
                }
            },
            clr: function (handler) {
                var idx = arrIndexOf(detail.h, handler);
                if (idx !== -1) {
                    detail.h[_DYN_SPLICE$1 ](idx, 1);
                }
            }
        };
        var checkDynamic = true;
        var isObjectOrArray = false;
        function _getProperty() {
            if (checkDynamic) {
                isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value);
                if (value && !value[CFG_HANDLER_LINK] && isObjectOrArray) {
                    value = _makeDynamicObject(state, value, name, "Converting");
                }
                checkDynamic = false;
            }
            var activeHandler = state.act;
            if (activeHandler) {
                detail.trk(activeHandler);
            }
            return value;
        }
        _getProperty[state.prop] = {
            chng: function () {
                state.add(detail);
            }
        };
        function _setProperty(newValue) {
            if (value !== newValue) {
                if (!!_getProperty[state.ro] && !state.upd) {
                    throwInvalidAccess("[" + name + "] is read-only:" + dumpObj(theConfig));
                }
                if (checkDynamic) {
                    isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value);
                    checkDynamic = false;
                }
                var isReferenced = isObjectOrArray && _getProperty[state.rf];
                if (isObjectOrArray) {
                    if (isReferenced) {
                        objForEachKey(value, function (key) {
                            value[key] = newValue ? newValue[key] : UNDEFINED_VALUE;
                        });
                        try {
                            objForEachKey(newValue, function (key, theValue) {
                                _setDynamicProperty(state, value, key, theValue);
                            });
                            newValue = value;
                        }
                        catch (e) {
                            _throwDynamicError((state.hdlr || {})[_DYN_LOGGER ], name, "Assigning", e);
                            isObjectOrArray = false;
                        }
                    }
                    else if (value && value[CFG_HANDLER_LINK]) {
                        objForEachKey(value, function (key) {
                            var getter = _getOwnPropGetter(value, key);
                            if (getter) {
                                var valueState = getter[state.prop];
                                valueState && valueState.chng();
                            }
                        });
                    }
                }
                if (newValue !== value) {
                    var newIsObjectOrArray = newValue && _canMakeDynamic(_getProperty, state, newValue);
                    if (!isReferenced && newIsObjectOrArray) {
                        newValue = _makeDynamicObject(state, newValue, name, "Converting");
                    }
                    value = newValue;
                    isObjectOrArray = newIsObjectOrArray;
                }
                state.add(detail);
            }
        }
        objDefine(theConfig, detail.n, { g: _getProperty, s: _setProperty });
    }
    function _setDynamicProperty(state, target, name, value) {
        if (target) {
            var getter = _getOwnPropGetter(target, name);
            var isDynamic = getter && !!getter[state.prop];
            if (!isDynamic) {
                _createDynamicProperty(state, target, name, value);
            }
            else {
                target[name] = value;
            }
        }
        return target;
    }
    function _setDynamicPropertyState(state, target, name, flags) {
        if (target) {
            var getter = _getOwnPropGetter(target, name);
            var isDynamic = getter && !!getter[state.prop];
            var inPlace = flags && flags[0 ];
            var rdOnly = flags && flags[1 ];
            var blkProp = flags && flags[2 ];
            if (!isDynamic) {
                if (blkProp) {
                    try {
                        blockDynamicConversion(target);
                    }
                    catch (e) {
                        _throwDynamicError((state.hdlr || {})[_DYN_LOGGER ], name, "Blocking", e);
                    }
                }
                try {
                    _setDynamicProperty(state, target, name, target[name]);
                    getter = _getOwnPropGetter(target, name);
                }
                catch (e) {
                    _throwDynamicError((state.hdlr || {})[_DYN_LOGGER ], name, "State", e);
                }
            }
            if (inPlace) {
                getter[state.rf] = inPlace;
            }
            if (rdOnly) {
                getter[state.ro] = rdOnly;
            }
            if (blkProp) {
                getter[state.blkVal] = true;
            }
        }
        return target;
    }
    function _makeDynamicObject(state, target, name, desc) {
        try {
            objForEachKey(target, function (key, value) {
                _setDynamicProperty(state, target, key, value);
            });
            if (!target[CFG_HANDLER_LINK]) {
                objDefineProp(target, CFG_HANDLER_LINK, {
                    get: function () {
                        return state[_DYN_HDLR ];
                    }
                });
                _patchArray(state, target, name);
            }
        }
        catch (e) {
            _throwDynamicError((state.hdlr || {})[_DYN_LOGGER ], name, desc, e);
        }
        return target;
    }

    var symPrefix = "[[ai_";
    var symPostfix = "]]";
    function _createState(cfgHandler) {
        var _a;
        var dynamicPropertySymbol = newSymbol(symPrefix + "get" + cfgHandler.uid + symPostfix);
        var dynamicPropertyReadOnly = newSymbol(symPrefix + "ro" + cfgHandler.uid + symPostfix);
        var dynamicPropertyReferenced = newSymbol(symPrefix + "rf" + cfgHandler.uid + symPostfix);
        var dynamicPropertyBlockValue = newSymbol(symPrefix + "blkVal" + cfgHandler.uid + symPostfix);
        var dynamicPropertyDetail = newSymbol(symPrefix + "dtl" + cfgHandler.uid + symPostfix);
        var _waitingHandlers = null;
        var _watcherTimer = null;
        var theState;
        function _useHandler(activeHandler, callback) {
            var prevWatcher = theState.act;
            try {
                theState.act = activeHandler;
                if (activeHandler && activeHandler[dynamicPropertyDetail]) {
                    arrForEach(activeHandler[dynamicPropertyDetail], function (detail) {
                        detail.clr(activeHandler);
                    });
                    activeHandler[dynamicPropertyDetail] = [];
                }
                callback({
                    cfg: cfgHandler.cfg,
                    set: cfgHandler.set.bind(cfgHandler),
                    setDf: cfgHandler[_DYN_SET_DF ].bind(cfgHandler),
                    ref: cfgHandler.ref.bind(cfgHandler),
                    rdOnly: cfgHandler[_DYN_RD_ONLY ].bind(cfgHandler)
                });
            }
            catch (e) {
                var logger = cfgHandler[_DYN_LOGGER ];
                if (logger) {
                    logger[_DYN_THROW_INTERNAL ](1 , 107 , dumpObj(e));
                }
                throw e;
            }
            finally {
                theState.act = prevWatcher || null;
            }
        }
        function _notifyWatchers() {
            if (_waitingHandlers) {
                var notifyHandlers = _waitingHandlers;
                _waitingHandlers = null;
                _watcherTimer && _watcherTimer[_DYN_CANCEL ]();
                _watcherTimer = null;
                var watcherFailures_1 = [];
                arrForEach(notifyHandlers, function (handler) {
                    if (handler) {
                        if (handler[dynamicPropertyDetail]) {
                            arrForEach(handler[dynamicPropertyDetail], function (detail) {
                                detail.clr(handler);
                            });
                            handler[dynamicPropertyDetail] = null;
                        }
                        if (handler.fn) {
                            try {
                                _useHandler(handler, handler.fn);
                            }
                            catch (e) {
                                watcherFailures_1[_DYN_PUSH$1 ](e);
                            }
                        }
                    }
                });
                if (_waitingHandlers) {
                    try {
                        _notifyWatchers();
                    }
                    catch (e) {
                        watcherFailures_1[_DYN_PUSH$1 ](e);
                    }
                }
                if (watcherFailures_1[_DYN_LENGTH$2 ] > 0) {
                    throwAggregationError("Watcher error(s): ", watcherFailures_1);
                }
            }
        }
        function _addWatcher(detail) {
            if (detail && detail.h[_DYN_LENGTH$2 ] > 0) {
                if (!_waitingHandlers) {
                    _waitingHandlers = [];
                }
                if (!_watcherTimer) {
                    _watcherTimer = scheduleTimeout(function () {
                        _watcherTimer = null;
                        _notifyWatchers();
                    }, 0);
                }
                for (var idx = 0; idx < detail.h[_DYN_LENGTH$2 ]; idx++) {
                    var handler = detail.h[idx];
                    if (handler && arrIndexOf(_waitingHandlers, handler) === -1) {
                        _waitingHandlers[_DYN_PUSH$1 ](handler);
                    }
                }
            }
        }
        function _trackHandler(handler, detail) {
            if (handler) {
                var details = handler[dynamicPropertyDetail] = handler[dynamicPropertyDetail] || [];
                if (arrIndexOf(details, detail) === -1) {
                    details[_DYN_PUSH$1 ](detail);
                }
            }
        }
        theState = (_a = {
                prop: dynamicPropertySymbol,
                ro: dynamicPropertyReadOnly,
                rf: dynamicPropertyReferenced
            },
            _a[_DYN_BLK_VAL ] = dynamicPropertyBlockValue,
            _a[_DYN_HDLR ] = cfgHandler,
            _a.add = _addWatcher,
            _a[_DYN_NOTIFY ] = _notifyWatchers,
            _a.use = _useHandler,
            _a.trk = _trackHandler,
            _a);
        return theState;
    }

    function _createAndUseHandler(state, configHandler) {
        var handler = {
            fn: configHandler,
            rm: function () {
                handler.fn = null;
                state = null;
                configHandler = null;
            }
        };
        objDefine(handler, "toJSON", { v: function () { return "WatcherHandler" + (handler.fn ? "" : "[X]"); } });
        state.use(handler, configHandler);
        return handler;
    }
    function _createDynamicHandler(logger, target, inPlace) {
        var _a;
        var dynamicHandler = getDynamicConfigHandler(target);
        if (dynamicHandler) {
            return dynamicHandler;
        }
        var uid = createUniqueNamespace("dyncfg", true);
        var newTarget = (target && inPlace !== false) ? target : _cfgDeepCopy(target);
        var theState;
        function _notifyWatchers() {
            theState[_DYN_NOTIFY ]();
        }
        function _setValue(target, name, value) {
            try {
                target = _setDynamicProperty(theState, target, name, value);
            }
            catch (e) {
                _throwDynamicError(logger, name, "Setting value", e);
            }
            return target[name];
        }
        function _watch(configHandler) {
            return _createAndUseHandler(theState, configHandler);
        }
        function _block(configHandler, allowUpdate) {
            theState.use(null, function (details) {
                var prevUpd = theState.upd;
                try {
                    if (!isUndefined(allowUpdate)) {
                        theState.upd = allowUpdate;
                    }
                    configHandler(details);
                }
                finally {
                    theState.upd = prevUpd;
                }
            });
        }
        function _ref(target, name) {
            var _a;
            return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[0 ] = true, _a))[name];
        }
        function _rdOnly(target, name) {
            var _a;
            return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[1 ] = true, _a))[name];
        }
        function _blkPropValue(target, name) {
            var _a;
            return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[2 ] = true, _a))[name];
        }
        function _applyDefaults(theConfig, defaultValues) {
            if (defaultValues) {
                objForEachKey(defaultValues, function (name, value) {
                    _applyDefaultValue(cfgHandler, theConfig, name, value);
                });
            }
            return theConfig;
        }
        var cfgHandler = (_a = {
                uid: null,
                cfg: newTarget
            },
            _a[_DYN_LOGGER ] = logger,
            _a[_DYN_NOTIFY ] = _notifyWatchers,
            _a.set = _setValue,
            _a[_DYN_SET_DF ] = _applyDefaults,
            _a[_DYN_WATCH ] = _watch,
            _a.ref = _ref,
            _a[_DYN_RD_ONLY ] = _rdOnly,
            _a[_DYN_BLK_VAL ] = _blkPropValue,
            _a._block = _block,
            _a);
        objDefine(cfgHandler, "uid", {
            c: false,
            e: false,
            w: false,
            v: uid
        });
        theState = _createState(cfgHandler);
        _makeDynamicObject(theState, newTarget, "config", "Creating");
        return cfgHandler;
    }
    function _logInvalidAccess(logger, message) {
        if (logger) {
            logger[_DYN_WARN_TO_CONSOLE ](message);
            logger[_DYN_THROW_INTERNAL ](2 , 108 , message);
        }
        else {
            throwInvalidAccess(message);
        }
    }
    function createDynamicConfig(config, defaultConfig, logger, inPlace) {
        var dynamicHandler = _createDynamicHandler(logger, config || {}, inPlace);
        if (defaultConfig) {
            dynamicHandler[_DYN_SET_DF ](dynamicHandler.cfg, defaultConfig);
        }
        return dynamicHandler;
    }
    function onConfigChange(config, configHandler, logger) {
        var handler = config[CFG_HANDLER_LINK] || config;
        if (handler.cfg && (handler.cfg === config || handler.cfg[CFG_HANDLER_LINK] === handler)) {
            return handler[_DYN_WATCH ](configHandler);
        }
        _logInvalidAccess(logger, STR_NOT_DYNAMIC_ERROR + dumpObj(config));
        return createDynamicConfig(config, null, logger)[_DYN_WATCH ](configHandler);
    }

    var DisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";

    var _aiNamespace = null;
    function _getExtensionNamespace() {
        var target = getInst("Microsoft");
        if (target) {
            _aiNamespace = target["ApplicationInsights"];
        }
        return _aiNamespace;
    }
    function getDebugExt(config) {
        var ns = _aiNamespace;
        if (!ns && config.disableDbgExt !== true) {
            ns = _aiNamespace || _getExtensionNamespace();
        }
        return ns ? ns["ChromeDbgExt"] : null;
    }

    var _a$3;
    var STR_WARN_TO_CONSOLE = "warnToConsole";
    var AiNonUserActionablePrefix = "AI (Internal): ";
    var AiUserActionablePrefix = "AI: ";
    var AIInternalMessagePrefix = "AITR_";
    var defaultValues$1 = {
        loggingLevelConsole: 0,
        loggingLevelTelemetry: 1,
        maxMessageLimit: 25,
        enableDebug: false
    };
    var _logFuncs = (_a$3 = {},
        _a$3[0 ] = null,
        _a$3[1 ] = "errorToConsole",
        _a$3[2 ] = STR_WARN_TO_CONSOLE,
        _a$3[3 ] = "debugToConsole",
        _a$3);
    function _sanitizeDiagnosticText(text) {
        if (text) {
            return "\"" + text[_DYN_REPLACE ](/\"/g, STR_EMPTY$3) + "\"";
        }
        return STR_EMPTY$3;
    }
    function _logToConsole(func, message) {
        var theConsole = getConsole();
        if (!!theConsole) {
            var logFunc = "log";
            if (theConsole[func]) {
                logFunc = func;
            }
            if (isFunction(theConsole[logFunc])) {
                theConsole[logFunc](message);
            }
        }
    }
    var _InternalLogMessage = /** @class */ (function () {
        function _InternalLogMessage(msgId, msg, isUserAct, properties) {
            if (isUserAct === void 0) { isUserAct = false; }
            var _self = this;
            _self[_DYN_MESSAGE_ID ] = msgId;
            _self[_DYN_MESSAGE ] =
                (isUserAct ? AiUserActionablePrefix : AiNonUserActionablePrefix) +
                    msgId;
            var strProps = STR_EMPTY$3;
            if (hasJSON()) {
                strProps = getJSON().stringify(properties);
            }
            var diagnosticText = (msg ? " message:" + _sanitizeDiagnosticText(msg) : STR_EMPTY$3) +
                (properties ? " props:" + _sanitizeDiagnosticText(strProps) : STR_EMPTY$3);
            _self[_DYN_MESSAGE ] += diagnosticText;
        }
        _InternalLogMessage.dataType = "MessageData";
        return _InternalLogMessage;
    }());
    function safeGetLogger(core, config) {
        return (core || {})[_DYN_LOGGER ] || new DiagnosticLogger(config);
    }
    var DiagnosticLogger = /** @class */ (function () {
        function DiagnosticLogger(config) {
            this.identifier = "DiagnosticLogger";
            this.queue = [];
            var _messageCount = 0;
            var _messageLogged = {};
            var _loggingLevelConsole;
            var _loggingLevelTelemetry;
            var _maxInternalMessageLimit;
            var _enableDebug;
            var _unloadHandler;
            dynamicProto(DiagnosticLogger, this, function (_self) {
                _unloadHandler = _setDefaultsFromConfig(config || {});
                _self.consoleLoggingLevel = function () { return _loggingLevelConsole; };
                _self[_DYN_THROW_INTERNAL ] = function (severity, msgId, msg, properties, isUserAct) {
                    if (isUserAct === void 0) { isUserAct = false; }
                    var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);
                    if (_enableDebug) {
                        throw dumpObj(message);
                    }
                    else {
                        var logFunc = _logFuncs[severity] || STR_WARN_TO_CONSOLE;
                        if (!isUndefined(message[_DYN_MESSAGE ])) {
                            if (isUserAct) {
                                var messageKey = +message[_DYN_MESSAGE_ID ];
                                if (!_messageLogged[messageKey] && _loggingLevelConsole >= severity) {
                                    _self[logFunc](message[_DYN_MESSAGE ]);
                                    _messageLogged[messageKey] = true;
                                }
                            }
                            else {
                                if (_loggingLevelConsole >= severity) {
                                    _self[logFunc](message[_DYN_MESSAGE ]);
                                }
                            }
                            _logInternalMessage(severity, message);
                        }
                        else {
                            _debugExtMsg("throw" + (severity === 1  ? "Critical" : "Warning"), message);
                        }
                    }
                };
                _self.debugToConsole = function (message) {
                    _logToConsole("debug", message);
                    _debugExtMsg("warning", message);
                };
                _self[_DYN_WARN_TO_CONSOLE ] = function (message) {
                    _logToConsole("warn", message);
                    _debugExtMsg("warning", message);
                };
                _self.errorToConsole = function (message) {
                    _logToConsole("error", message);
                    _debugExtMsg("error", message);
                };
                _self.resetInternalMessageCount = function () {
                    _messageCount = 0;
                    _messageLogged = {};
                };
                _self[_DYN_LOG_INTERNAL_MESSAGE ] = _logInternalMessage;
                _self[_DYN_UNLOAD ] = function (isAsync) {
                    _unloadHandler && _unloadHandler.rm();
                    _unloadHandler = null;
                };
                function _logInternalMessage(severity, message) {
                    if (_areInternalMessagesThrottled()) {
                        return;
                    }
                    var logMessage = true;
                    var messageKey = AIInternalMessagePrefix + message[_DYN_MESSAGE_ID ];
                    if (_messageLogged[messageKey]) {
                        logMessage = false;
                    }
                    else {
                        _messageLogged[messageKey] = true;
                    }
                    if (logMessage) {
                        if (severity <= _loggingLevelTelemetry) {
                            _self.queue[_DYN_PUSH$1 ](message);
                            _messageCount++;
                            _debugExtMsg((severity === 1  ? "error" : "warn"), message);
                        }
                        if (_messageCount === _maxInternalMessageLimit) {
                            var throttleLimitMessage = "Internal events throttle limit per PageView reached for this app.";
                            var throttleMessage = new _InternalLogMessage(23 , throttleLimitMessage, false);
                            _self.queue[_DYN_PUSH$1 ](throttleMessage);
                            if (severity === 1 ) {
                                _self.errorToConsole(throttleLimitMessage);
                            }
                            else {
                                _self[_DYN_WARN_TO_CONSOLE ](throttleLimitMessage);
                            }
                        }
                    }
                }
                function _setDefaultsFromConfig(config) {
                    return onConfigChange(createDynamicConfig(config, defaultValues$1, _self).cfg, function (details) {
                        var config = details.cfg;
                        _loggingLevelConsole = config[_DYN_LOGGING_LEVEL_CONSOL4 ];
                        _loggingLevelTelemetry = config.loggingLevelTelemetry;
                        _maxInternalMessageLimit = config.maxMessageLimit;
                        _enableDebug = config.enableDebug;
                    });
                }
                function _areInternalMessagesThrottled() {
                    return _messageCount >= _maxInternalMessageLimit;
                }
                function _debugExtMsg(name, data) {
                    var dbgExt = getDebugExt(config || {});
                    if (dbgExt && dbgExt[_DYN_DIAG_LOG ]) {
                        dbgExt[_DYN_DIAG_LOG ](name, data);
                    }
                }
            });
        }
        DiagnosticLogger.__ieDyn=1;
        return DiagnosticLogger;
    }());
    function _getLogger(logger) {
        return (logger || new DiagnosticLogger());
    }
    function _throwInternal(logger, severity, msgId, msg, properties, isUserAct) {
        if (isUserAct === void 0) { isUserAct = false; }
        _getLogger(logger)[_DYN_THROW_INTERNAL ](severity, msgId, msg, properties, isUserAct);
    }
    function _warnToConsole(logger, message) {
        _getLogger(logger)[_DYN_WARN_TO_CONSOLE ](message);
    }

    var strExecutionContextKey = "ctx";
    var strParentContextKey = "ParentContextKey";
    var strChildrenContextKey = "ChildrenContextKey";
    var PerfEvent = /** @class */ (function () {
        function PerfEvent(name, payloadDetails, isAsync) {
            var _self = this;
            _self.start = utcNow();
            _self[_DYN_NAME ] = name;
            _self[_DYN_IS_ASYNC ] = isAsync;
            _self[_DYN_IS_CHILD_EVT ] = function () { return false; };
            if (isFunction(payloadDetails)) {
                var theDetails_1;
                objDefine(_self, "payload", {
                    g: function () {
                        if (!theDetails_1 && isFunction(payloadDetails)) {
                            theDetails_1 = payloadDetails();
                            payloadDetails = null;
                        }
                        return theDetails_1;
                    }
                });
            }
            _self[_DYN_GET_CTX ] = function (key) {
                if (key) {
                    if (key === PerfEvent[strParentContextKey] || key === PerfEvent[strChildrenContextKey]) {
                        return _self[key];
                    }
                    return (_self[strExecutionContextKey] || {})[key];
                }
                return null;
            };
            _self[_DYN_SET_CTX ] = function (key, value) {
                if (key) {
                    if (key === PerfEvent[strParentContextKey]) {
                        if (!_self[key]) {
                            _self[_DYN_IS_CHILD_EVT ] = function () { return true; };
                        }
                        _self[key] = value;
                    }
                    else if (key === PerfEvent[strChildrenContextKey]) {
                        _self[key] = value;
                    }
                    else {
                        var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};
                        ctx[key] = value;
                    }
                }
            };
            _self[_DYN_COMPLETE ] = function () {
                var childTime = 0;
                var childEvts = _self[_DYN_GET_CTX ](PerfEvent[strChildrenContextKey]);
                if (isArray(childEvts)) {
                    for (var lp = 0; lp < childEvts[_DYN_LENGTH$2 ]; lp++) {
                        var childEvt = childEvts[lp];
                        if (childEvt) {
                            childTime += childEvt[_DYN_TIME ];
                        }
                    }
                }
                _self[_DYN_TIME ] = utcNow() - _self.start;
                _self.exTime = _self[_DYN_TIME ] - childTime;
                _self[_DYN_COMPLETE ] = function () { };
            };
        }
        PerfEvent.ParentContextKey = "parent";
        PerfEvent.ChildrenContextKey = "childEvts";
        return PerfEvent;
    }());
    var doPerfActiveKey = "CoreUtils.doPerf";
    function doPerf(mgrSource, getSource, func, details, isAsync) {
        if (mgrSource) {
            var perfMgr = mgrSource;
            if (perfMgr[STR_GET_PERF_MGR]) {
                perfMgr = perfMgr[STR_GET_PERF_MGR]();
            }
            if (perfMgr) {
                var perfEvt = void 0;
                var currentActive = perfMgr[_DYN_GET_CTX ](doPerfActiveKey);
                try {
                    perfEvt = perfMgr.create(getSource(), details, isAsync);
                    if (perfEvt) {
                        if (currentActive && perfEvt[_DYN_SET_CTX ]) {
                            perfEvt[_DYN_SET_CTX ](PerfEvent[strParentContextKey], currentActive);
                            if (currentActive[_DYN_GET_CTX ] && currentActive[_DYN_SET_CTX ]) {
                                var children = currentActive[_DYN_GET_CTX ](PerfEvent[strChildrenContextKey]);
                                if (!children) {
                                    children = [];
                                    currentActive[_DYN_SET_CTX ](PerfEvent[strChildrenContextKey], children);
                                }
                                children[_DYN_PUSH$1 ](perfEvt);
                            }
                        }
                        perfMgr[_DYN_SET_CTX ](doPerfActiveKey, perfEvt);
                        return func(perfEvt);
                    }
                }
                catch (ex) {
                    if (perfEvt && perfEvt[_DYN_SET_CTX ]) {
                        perfEvt[_DYN_SET_CTX ]("exception", ex);
                    }
                }
                finally {
                    if (perfEvt) {
                        perfMgr.fire(perfEvt);
                    }
                    perfMgr[_DYN_SET_CTX ](doPerfActiveKey, currentActive);
                }
            }
        }
        return func();
    }

    var pluginStateData = createElmNodeData("plugin");
    function _getPluginState(plugin) {
        return pluginStateData.get(plugin, "state", {}, true);
    }

    var strTelemetryPluginChain = "TelemetryPluginChain";
    var strHasRunFlags = "_hasRun";
    var strGetTelCtx = "_getTelCtx";
    var _chainId = 0;
    function _getNextProxyStart(proxy, core, startAt) {
        while (proxy) {
            if (proxy[_DYN_GET_PLUGIN ]() === startAt) {
                return proxy;
            }
            proxy = proxy[_DYN_GET_NEXT ]();
        }
        return createTelemetryProxyChain([startAt], core.config || {}, core);
    }
    function _createInternalContext(telemetryChain, dynamicHandler, core, startAt) {
        var _nextProxy = null;
        var _onComplete = [];
        if (!dynamicHandler) {
            dynamicHandler = createDynamicConfig({}, null, core[_DYN_LOGGER ]);
        }
        if (startAt !== null) {
            _nextProxy = startAt ? _getNextProxyStart(telemetryChain, core, startAt) : telemetryChain;
        }
        var context = {
            _next: _moveNext,
            ctx: {
                core: function () {
                    return core;
                },
                diagLog: function () {
                    return safeGetLogger(core, dynamicHandler.cfg);
                },
                getCfg: function () {
                    return dynamicHandler.cfg;
                },
                getExtCfg: _resolveExtCfg,
                getConfig: _getConfig,
                hasNext: function () {
                    return !!_nextProxy;
                },
                getNext: function () {
                    return _nextProxy;
                },
                setNext: function (nextPlugin) {
                    _nextProxy = nextPlugin;
                },
                iterate: _iterateChain,
                onComplete: _addOnComplete
            }
        };
        function _addOnComplete(onComplete, that) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            if (onComplete) {
                _onComplete[_DYN_PUSH$1 ]({
                    func: onComplete,
                    self: !isUndefined(that) ? that : context.ctx,
                    args: args
                });
            }
        }
        function _moveNext() {
            var nextProxy = _nextProxy;
            _nextProxy = nextProxy ? nextProxy[_DYN_GET_NEXT ]() : null;
            if (!nextProxy) {
                var onComplete = _onComplete;
                if (onComplete && onComplete[_DYN_LENGTH$2 ] > 0) {
                    arrForEach(onComplete, function (completeDetails) {
                        try {
                            completeDetails.func.call(completeDetails.self, completeDetails.args);
                        }
                        catch (e) {
                            _throwInternal(core[_DYN_LOGGER ], 2 , 73 , "Unexpected Exception during onComplete - " + dumpObj(e));
                        }
                    });
                    _onComplete = [];
                }
            }
            return nextProxy;
        }
        function _getExtCfg(identifier, createIfMissing) {
            var idCfg = null;
            var cfg = dynamicHandler.cfg;
            if (cfg && identifier) {
                var extCfg = cfg[STR_EXTENSION_CONFIG ];
                if (!extCfg && createIfMissing) {
                    extCfg = {};
                }
                cfg[STR_EXTENSION_CONFIG] = extCfg;
                extCfg = dynamicHandler.ref(cfg, STR_EXTENSION_CONFIG);
                if (extCfg) {
                    idCfg = extCfg[identifier];
                    if (!idCfg && createIfMissing) {
                        idCfg = {};
                    }
                    extCfg[identifier] = idCfg;
                    idCfg = dynamicHandler.ref(extCfg, identifier);
                }
            }
            return idCfg;
        }
        function _resolveExtCfg(identifier, defaultValues) {
            var newConfig = _getExtCfg(identifier, true);
            if (defaultValues) {
                objForEachKey(defaultValues, function (field, defaultValue) {
                    if (isNullOrUndefined(newConfig[field])) {
                        var cfgValue = dynamicHandler.cfg[field];
                        if (cfgValue || !isNullOrUndefined(cfgValue)) {
                            newConfig[field] = cfgValue;
                        }
                    }
                    _applyDefaultValue(dynamicHandler, newConfig, field, defaultValue);
                });
            }
            return dynamicHandler[_DYN_SET_DF ](newConfig, defaultValues);
        }
        function _getConfig(identifier, field, defaultValue) {
            if (defaultValue === void 0) { defaultValue = false; }
            var theValue;
            var extConfig = _getExtCfg(identifier, false);
            var rootConfig = dynamicHandler.cfg;
            if (extConfig && (extConfig[field] || !isNullOrUndefined(extConfig[field]))) {
                theValue = extConfig[field];
            }
            else if (rootConfig[field] || !isNullOrUndefined(rootConfig[field])) {
                theValue = rootConfig[field];
            }
            return (theValue || !isNullOrUndefined(theValue)) ? theValue : defaultValue;
        }
        function _iterateChain(cb) {
            var nextPlugin;
            while (!!(nextPlugin = context._next())) {
                var plugin = nextPlugin[_DYN_GET_PLUGIN ]();
                if (plugin) {
                    cb(plugin);
                }
            }
        }
        return context;
    }
    function createProcessTelemetryContext(telemetryChain, cfg, core, startAt) {
        var config = createDynamicConfig(cfg);
        var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
        var context = internalContext.ctx;
        function _processNext(env) {
            var nextPlugin = internalContext._next();
            if (nextPlugin) {
                nextPlugin[STR_PROCESS_TELEMETRY ](env, context);
            }
            return !nextPlugin;
        }
        function _createNew(plugins, startAt) {
            if (plugins === void 0) { plugins = null; }
            if (isArray(plugins)) {
                plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt);
            }
            return createProcessTelemetryContext(plugins || context[_DYN_GET_NEXT ](), config.cfg, core, startAt);
        }
        context[_DYN_PROCESS_NEXT ] = _processNext;
        context[_DYN_CREATE_NEW ] = _createNew;
        return context;
    }
    function createProcessTelemetryUnloadContext(telemetryChain, core, startAt) {
        var config = createDynamicConfig(core.config);
        var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
        var context = internalContext.ctx;
        function _processNext(unloadState) {
            var nextPlugin = internalContext._next();
            nextPlugin && nextPlugin[_DYN_UNLOAD ](context, unloadState);
            return !nextPlugin;
        }
        function _createNew(plugins, startAt) {
            if (plugins === void 0) { plugins = null; }
            if (isArray(plugins)) {
                plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt);
            }
            return createProcessTelemetryUnloadContext(plugins || context[_DYN_GET_NEXT ](), core, startAt);
        }
        context[_DYN_PROCESS_NEXT ] = _processNext;
        context[_DYN_CREATE_NEW ] = _createNew;
        return context;
    }
    function createProcessTelemetryUpdateContext(telemetryChain, core, startAt) {
        var config = createDynamicConfig(core.config);
        var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
        var context = internalContext.ctx;
        function _processNext(updateState) {
            return context.iterate(function (plugin) {
                if (isFunction(plugin[_DYN_UPDATE ])) {
                    plugin[_DYN_UPDATE ](context, updateState);
                }
            });
        }
        function _createNew(plugins, startAt) {
            if (plugins === void 0) { plugins = null; }
            if (isArray(plugins)) {
                plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt);
            }
            return createProcessTelemetryUpdateContext(plugins || context[_DYN_GET_NEXT ](), core, startAt);
        }
        context[_DYN_PROCESS_NEXT ] = _processNext;
        context[_DYN_CREATE_NEW ] = _createNew;
        return context;
    }
    function createTelemetryProxyChain(plugins, config, core, startAt) {
        var firstProxy = null;
        var add = startAt ? false : true;
        if (isArray(plugins) && plugins[_DYN_LENGTH$2 ] > 0) {
            var lastProxy_1 = null;
            arrForEach(plugins, function (thePlugin) {
                if (!add && startAt === thePlugin) {
                    add = true;
                }
                if (add && thePlugin && isFunction(thePlugin[STR_PROCESS_TELEMETRY ])) {
                    var newProxy = createTelemetryPluginProxy(thePlugin, config, core);
                    if (!firstProxy) {
                        firstProxy = newProxy;
                    }
                    if (lastProxy_1) {
                        lastProxy_1._setNext(newProxy);
                    }
                    lastProxy_1 = newProxy;
                }
            });
        }
        if (startAt && !firstProxy) {
            return createTelemetryProxyChain([startAt], config, core);
        }
        return firstProxy;
    }
    function createTelemetryPluginProxy(plugin, config, core) {
        var nextProxy = null;
        var hasProcessTelemetry = isFunction(plugin[STR_PROCESS_TELEMETRY ]);
        var hasSetNext = isFunction(plugin[_DYN_SET_NEXT_PLUGIN ]);
        var chainId;
        if (plugin) {
            chainId = plugin[_DYN_IDENTIFIER$1 ] + "-" + plugin[STR_PRIORITY ] + "-" + _chainId++;
        }
        else {
            chainId = "Unknown-0-" + _chainId++;
        }
        var proxyChain = {
            getPlugin: function () {
                return plugin;
            },
            getNext: function () {
                return nextProxy;
            },
            processTelemetry: _processTelemetry,
            unload: _unloadPlugin,
            update: _updatePlugin,
            _id: chainId,
            _setNext: function (nextPlugin) {
                nextProxy = nextPlugin;
            }
        };
        function _getTelCtx() {
            var itemCtx;
            if (plugin && isFunction(plugin[strGetTelCtx])) {
                itemCtx = plugin[strGetTelCtx]();
            }
            if (!itemCtx) {
                itemCtx = createProcessTelemetryContext(proxyChain, config, core);
            }
            return itemCtx;
        }
        function _processChain(itemCtx, processPluginFn, name, details, isAsync) {
            var hasRun = false;
            var identifier = plugin ? plugin[_DYN_IDENTIFIER$1 ] : strTelemetryPluginChain;
            var hasRunContext = itemCtx[strHasRunFlags];
            if (!hasRunContext) {
                hasRunContext = itemCtx[strHasRunFlags] = {};
            }
            itemCtx.setNext(nextProxy);
            if (plugin) {
                doPerf(itemCtx[STR_CORE ](), function () { return identifier + ":" + name; }, function () {
                    hasRunContext[chainId] = true;
                    try {
                        var nextId = nextProxy ? nextProxy._id : STR_EMPTY$3;
                        if (nextId) {
                            hasRunContext[nextId] = false;
                        }
                        hasRun = processPluginFn(itemCtx);
                    }
                    catch (error) {
                        var hasNextRun = nextProxy ? hasRunContext[nextProxy._id] : true;
                        if (hasNextRun) {
                            hasRun = true;
                        }
                        if (!nextProxy || !hasNextRun) {
                            _throwInternal(itemCtx[_DYN_DIAG_LOG ](), 1 , 73 , "Plugin [" + identifier + "] failed during " + name + " - " + dumpObj(error) + ", run flags: " + dumpObj(hasRunContext));
                        }
                    }
                }, details, isAsync);
            }
            return hasRun;
        }
        function _processTelemetry(env, itemCtx) {
            itemCtx = itemCtx || _getTelCtx();
            function _callProcessTelemetry(itemCtx) {
                if (!plugin || !hasProcessTelemetry) {
                    return false;
                }
                var pluginState = _getPluginState(plugin);
                if (pluginState[_DYN_TEARDOWN ] || pluginState[STR_DISABLED]) {
                    return false;
                }
                if (hasSetNext) {
                    plugin[_DYN_SET_NEXT_PLUGIN ](nextProxy);
                }
                plugin[STR_PROCESS_TELEMETRY ](env, itemCtx);
                return true;
            }
            if (!_processChain(itemCtx, _callProcessTelemetry, "processTelemetry", function () { return ({ item: env }); }, !(env.sync))) {
                itemCtx[_DYN_PROCESS_NEXT ](env);
            }
        }
        function _unloadPlugin(unloadCtx, unloadState) {
            function _callTeardown() {
                var hasRun = false;
                if (plugin) {
                    var pluginState = _getPluginState(plugin);
                    var pluginCore = plugin[STR_CORE] || pluginState[STR_CORE ];
                    if (plugin && (!pluginCore || pluginCore === unloadCtx.core()) && !pluginState[_DYN_TEARDOWN ]) {
                        pluginState[STR_CORE ] = null;
                        pluginState[_DYN_TEARDOWN ] = true;
                        pluginState[_DYN_IS_INITIALIZED ] = false;
                        if (plugin[_DYN_TEARDOWN ] && plugin[_DYN_TEARDOWN ](unloadCtx, unloadState) === true) {
                            hasRun = true;
                        }
                    }
                }
                return hasRun;
            }
            if (!_processChain(unloadCtx, _callTeardown, "unload", function () { }, unloadState[_DYN_IS_ASYNC ])) {
                unloadCtx[_DYN_PROCESS_NEXT ](unloadState);
            }
        }
        function _updatePlugin(updateCtx, updateState) {
            function _callUpdate() {
                var hasRun = false;
                if (plugin) {
                    var pluginState = _getPluginState(plugin);
                    var pluginCore = plugin[STR_CORE] || pluginState[STR_CORE ];
                    if (plugin && (!pluginCore || pluginCore === updateCtx.core()) && !pluginState[_DYN_TEARDOWN ]) {
                        if (plugin[_DYN_UPDATE ] && plugin[_DYN_UPDATE ](updateCtx, updateState) === true) {
                            hasRun = true;
                        }
                    }
                }
                return hasRun;
            }
            if (!_processChain(updateCtx, _callUpdate, "update", function () { }, false)) {
                updateCtx[_DYN_PROCESS_NEXT ](updateState);
            }
        }
        return objFreeze(proxyChain);
    }

    function createUnloadHandlerContainer() {
        var handlers = [];
        function _addHandler(handler) {
            if (handler) {
                handlers[_DYN_PUSH$1 ](handler);
            }
        }
        function _runHandlers(unloadCtx, unloadState) {
            arrForEach(handlers, function (handler) {
                try {
                    handler(unloadCtx, unloadState);
                }
                catch (e) {
                    _throwInternal(unloadCtx[_DYN_DIAG_LOG ](), 2 , 73 , "Unexpected error calling unload handler - " + dumpObj(e));
                }
            });
            handlers = [];
        }
        return {
            add: _addHandler,
            run: _runHandlers
        };
    }

    function createUnloadHookContainer() {
        var _hooks = [];
        function _doUnload(logger) {
            var oldHooks = _hooks;
            _hooks = [];
            arrForEach(oldHooks, function (fn) {
                try {
                    (fn.rm || fn.remove).call(fn);
                }
                catch (e) {
                    _throwInternal(logger, 2 , 73 , "Unloading:" + dumpObj(e));
                }
            });
        }
        function _addHook(hooks) {
            if (hooks) {
                arrAppend(_hooks, hooks);
            }
        }
        return {
            run: _doUnload,
            add: _addHook
        };
    }

    var _a$2;
    var strGetPlugin = "getPlugin";
    var defaultValues = (_a$2 = {},
        _a$2[STR_EXTENSION_CONFIG] = { isVal: isNotNullOrUndefined, v: {} },
        _a$2);
    var BaseTelemetryPlugin = /** @class */ (function () {
        function BaseTelemetryPlugin() {
            var _self = this;
            var _isinitialized;
            var _rootCtx;
            var _nextPlugin;
            var _unloadHandlerContainer;
            var _hookContainer;
            _initDefaults();
            dynamicProto(BaseTelemetryPlugin, _self, function (_self) {
                _self[_DYN_INITIALIZE$1 ] = function (config, core, extensions, pluginChain) {
                    _setDefaults(config, core, pluginChain);
                    _isinitialized = true;
                };
                _self[_DYN_TEARDOWN ] = function (unloadCtx, unloadState) {
                    var _a;
                    var core = _self[STR_CORE ];
                    if (!core || (unloadCtx && core !== unloadCtx[STR_CORE ]())) {
                        return;
                    }
                    var result;
                    var unloadDone = false;
                    var theUnloadCtx = unloadCtx || createProcessTelemetryUnloadContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);
                    var theUnloadState = unloadState || (_a = {
                            reason: 0
                        },
                        _a[_DYN_IS_ASYNC ] = false,
                        _a);
                    function _unloadCallback() {
                        if (!unloadDone) {
                            unloadDone = true;
                            _unloadHandlerContainer.run(theUnloadCtx, unloadState);
                            _hookContainer.run(theUnloadCtx[_DYN_DIAG_LOG ]());
                            if (result === true) {
                                theUnloadCtx[_DYN_PROCESS_NEXT ](theUnloadState);
                            }
                            _initDefaults();
                        }
                    }
                    if (!_self[_DYN__DO_TEARDOWN ] || _self[_DYN__DO_TEARDOWN ](theUnloadCtx, theUnloadState, _unloadCallback) !== true) {
                        _unloadCallback();
                    }
                    else {
                        result = true;
                    }
                    return result;
                };
                _self[_DYN_UPDATE ] = function (updateCtx, updateState) {
                    var core = _self[STR_CORE ];
                    if (!core || (updateCtx && core !== updateCtx[STR_CORE ]())) {
                        return;
                    }
                    var result;
                    var updateDone = false;
                    var theUpdateCtx = updateCtx || createProcessTelemetryUpdateContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);
                    var theUpdateState = updateState || {
                        reason: 0
                    };
                    function _updateCallback() {
                        if (!updateDone) {
                            updateDone = true;
                            _setDefaults(theUpdateCtx.getCfg(), theUpdateCtx.core(), theUpdateCtx[_DYN_GET_NEXT ]());
                        }
                    }
                    if (!_self._doUpdate || _self._doUpdate(theUpdateCtx, theUpdateState, _updateCallback) !== true) {
                        _updateCallback();
                    }
                    else {
                        result = true;
                    }
                    return result;
                };
                proxyFunctionAs(_self, "_addUnloadCb", function () { return _unloadHandlerContainer; }, "add");
                proxyFunctionAs(_self, "_addHook", function () { return _hookContainer; }, "add");
                objDefine(_self, "_unloadHooks", { g: function () { return _hookContainer; } });
            });
            _self[_DYN_DIAG_LOG ] = function (itemCtx) {
                return _getTelCtx(itemCtx)[_DYN_DIAG_LOG ]();
            };
            _self[_DYN_IS_INITIALIZED ] = function () {
                return _isinitialized;
            };
            _self.setInitialized = function (isInitialized) {
                _isinitialized = isInitialized;
            };
            _self[_DYN_SET_NEXT_PLUGIN ] = function (next) {
                _nextPlugin = next;
            };
            _self[_DYN_PROCESS_NEXT ] = function (env, itemCtx) {
                if (itemCtx) {
                    itemCtx[_DYN_PROCESS_NEXT ](env);
                }
                else if (_nextPlugin && isFunction(_nextPlugin[STR_PROCESS_TELEMETRY ])) {
                    _nextPlugin[STR_PROCESS_TELEMETRY ](env, null);
                }
            };
            _self._getTelCtx = _getTelCtx;
            function _getTelCtx(currentCtx) {
                if (currentCtx === void 0) { currentCtx = null; }
                var itemCtx = currentCtx;
                if (!itemCtx) {
                    var rootCtx = _rootCtx || createProcessTelemetryContext(null, {}, _self[STR_CORE ]);
                    if (_nextPlugin && _nextPlugin[strGetPlugin]) {
                        itemCtx = rootCtx[_DYN_CREATE_NEW ](null, _nextPlugin[strGetPlugin]);
                    }
                    else {
                        itemCtx = rootCtx[_DYN_CREATE_NEW ](null, _nextPlugin);
                    }
                }
                return itemCtx;
            }
            function _setDefaults(config, core, pluginChain) {
                createDynamicConfig(config, defaultValues, safeGetLogger(core));
                if (!pluginChain && core) {
                    pluginChain = core[_DYN_GET_PROCESS_TEL_CONT2 ]()[_DYN_GET_NEXT ]();
                }
                var nextPlugin = _nextPlugin;
                if (_nextPlugin && _nextPlugin[strGetPlugin]) {
                    nextPlugin = _nextPlugin[strGetPlugin]();
                }
                _self[STR_CORE ] = core;
                _rootCtx = createProcessTelemetryContext(pluginChain, config, core, nextPlugin);
            }
            function _initDefaults() {
                _isinitialized = false;
                _self[STR_CORE ] = null;
                _rootCtx = null;
                _nextPlugin = null;
                _hookContainer = createUnloadHookContainer();
                _unloadHandlerContainer = createUnloadHandlerContainer();
            }
        }
        BaseTelemetryPlugin.__ieDyn=1;
        return BaseTelemetryPlugin;
    }());

    var STR_EMPTY$2 = "";
    var STR_NO_RESPONSE_BODY$1 = "NoResponseBody";
    var _noResponseQs$1 = "&" + STR_NO_RESPONSE_BODY$1 + "=true";
    var STR_POST_METHOD = "POST";
    var SenderPostManager = /** @class */ (function () {
        function SenderPostManager() {
            var _syncFetchPayload = 0;
            var _enableSendPromise;
            var _isInitialized;
            var _diagLog;
            var _isOneDs;
            var _onCompleteFuncs;
            var _disableCredentials;
            var _fallbackInst;
            var _disableXhr;
            var _disableBeacon;
            var _disableBeaconSync;
            var _disableFetchKeepAlive;
            var _addNoResponse;
            var _timeoutWrapper;
            dynamicProto(SenderPostManager, this, function (_self, _base) {
                var _sendCredentials = true;
                _initDefaults();
                _self[_DYN_INITIALIZE$1 ] = function (config, diagLog) {
                    _diagLog = diagLog;
                    if (_isInitialized) {
                        _throwInternal(_diagLog, 1 , 28 , "Sender is already initialized");
                    }
                    _self.SetConfig(config);
                    _isInitialized = true;
                };
                _self["_getDbgPlgTargets"] = function () {
                    return [_isInitialized, _isOneDs, _disableCredentials, _enableSendPromise];
                };
                _self.SetConfig = function (config) {
                    try {
                        _onCompleteFuncs = config.senderOnCompleteCallBack || {};
                        _disableCredentials = !!config.disableCredentials;
                        _isOneDs = !!config.isOneDs;
                        _enableSendPromise = !!config.enableSendPromise;
                        _disableXhr = !!config.disableXhr;
                        _disableBeacon = !!config.disableBeacon;
                        _disableBeaconSync = !!config.disableBeaconSync;
                        _timeoutWrapper = config.timeWrapper;
                        _addNoResponse = !!config.addNoResponse;
                        _disableFetchKeepAlive = !!config.disableFetchKeepAlive;
                        _fallbackInst = { sendPOST: _xhrSender };
                        if (!_isOneDs) {
                            _sendCredentials = false;
                        }
                        if (_disableCredentials) {
                            var location_1 = getLocation();
                            if (location_1 && location_1.protocol && location_1.protocol[_DYN_TO_LOWER_CASE$1 ]() === "file:") {
                                _sendCredentials = false;
                            }
                        }
                        return true;
                    }
                    catch (e) {
                    }
                    return false;
                };
                _self.getSyncFetchPayload = function () {
                    return _syncFetchPayload;
                };
                _self.getSenderInst = function (transports, sync) {
                    if (transports && transports[_DYN_LENGTH$2 ]) {
                        return _getSenderInterface(transports, sync);
                    }
                    return null;
                };
                _self.getFallbackInst = function () {
                    return _fallbackInst;
                };
                _self[_DYN__DO_TEARDOWN ] = function (unloadCtx, unloadState) {
                    _initDefaults();
                };
                function _onSuccess(res, onComplete) {
                    _doOnComplete(onComplete, 200, {}, res);
                }
                function _onError(message, onComplete) {
                    _throwInternal(_diagLog, 2 , 26 , "Failed to send telemetry.", { message: message });
                    _doOnComplete(onComplete, 400, {});
                }
                function _onNoPayloadUrl(onComplete) {
                    _onError("No endpoint url is provided for the batch", onComplete);
                }
                function _getSenderInterface(transports, syncSupport) {
                    var _a;
                    var transportType = 0 ;
                    var sendPostFunc = null;
                    var lp = 0;
                    while (sendPostFunc == null && lp < transports[_DYN_LENGTH$2 ]) {
                        transportType = transports[lp];
                        if (!_disableXhr && transportType === 1 ) {
                            if (useXDomainRequest()) {
                                sendPostFunc = _xdrSender;
                            }
                            else if (isXhrSupported()) {
                                sendPostFunc = _xhrSender;
                            }
                        }
                        else if (transportType === 2  && isFetchSupported(syncSupport) && (!syncSupport || !_disableFetchKeepAlive)) {
                            sendPostFunc = _doFetchSender;
                        }
                        else if (transportType === 3  && isBeaconsSupported() && (syncSupport ? !_disableBeaconSync : !_disableBeacon)) {
                            sendPostFunc = _beaconSender;
                        }
                        lp++;
                    }
                    if (sendPostFunc) {
                        return _a = {
                                _transport: transportType,
                                _isSync: syncSupport
                            },
                            _a[_DYN_SEND_POST ] = sendPostFunc,
                            _a;
                    }
                    return null;
                }
                function _doOnComplete(oncomplete, status, headers, response) {
                    try {
                        oncomplete && oncomplete(status, headers, response);
                    }
                    catch (e) {
                    }
                }
                function _doBeaconSend(payload, oncomplete) {
                    var nav = getNavigator();
                    var url = payload[_DYN_URL_STRING$1 ];
                    if (!url) {
                        _onNoPayloadUrl(oncomplete);
                        return true;
                    }
                    url = payload[_DYN_URL_STRING$1 ] + (_addNoResponse ? _noResponseQs$1 : STR_EMPTY$2);
                    var data = payload[_DYN_DATA$1 ];
                    var plainTextBatch = _isOneDs ? data : new Blob([data], { type: "text/plain;charset=UTF-8" });
                    var queued = nav.sendBeacon(url, plainTextBatch);
                    return queued;
                }
                function _beaconSender(payload, oncomplete, sync) {
                    var data = payload[_DYN_DATA$1 ];
                    try {
                        if (data) {
                            if (!_doBeaconSend(payload, oncomplete)) {
                                var onRetry = _onCompleteFuncs && _onCompleteFuncs.beaconOnRetry;
                                if (onRetry && isFunction(onRetry)) {
                                    onRetry(payload, oncomplete, _doBeaconSend);
                                }
                                else {
                                    _fallbackInst && _fallbackInst[_DYN_SEND_POST ](payload, oncomplete, true);
                                    _throwInternal(_diagLog, 2 , 40 , ". " + "Failed to send telemetry with Beacon API, retried with normal sender.");
                                }
                            }
                            else {
                                _onSuccess(STR_EMPTY$2, oncomplete);
                            }
                        }
                    }
                    catch (e) {
                        _isOneDs && _warnToConsole(_diagLog, "Failed to send telemetry using sendBeacon API. Ex:" + dumpObj(e));
                        _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, STR_EMPTY$2);
                    }
                    return;
                }
                function _xhrSender(payload, oncomplete, sync) {
                    var thePromise;
                    var resolveFunc;
                    var rejectFunc;
                    var headers = payload[_DYN_HEADERS$1 ] || {};
                    if (!sync && _enableSendPromise) {
                        thePromise = createPromise(function (resolve, reject) {
                            resolveFunc = resolve;
                            rejectFunc = reject;
                        });
                    }
                    if (_isOneDs && sync && payload.disableXhrSync) {
                        sync = false;
                    }
                    var endPointUrl = payload[_DYN_URL_STRING$1 ];
                    if (!endPointUrl) {
                        _onNoPayloadUrl(oncomplete);
                        resolveFunc && resolveFunc(false);
                        return;
                    }
                    var xhr = openXhr(STR_POST_METHOD, endPointUrl, _sendCredentials, true, sync, payload[_DYN_TIMEOUT$1 ]);
                    if (!_isOneDs) {
                        xhr[_DYN_SET_REQUEST_HEADER ]("Content-type", "application/json");
                    }
                    arrForEach(objKeys(headers), function (headerName) {
                        xhr[_DYN_SET_REQUEST_HEADER ](headerName, headers[headerName]);
                    });
                    xhr.onreadystatechange = function () {
                        if (!_isOneDs) {
                            _doOnReadyFunc(xhr);
                            if (xhr.readyState === 4) {
                                resolveFunc && resolveFunc(true);
                            }
                        }
                    };
                    xhr.onload = function () {
                        if (_isOneDs) {
                            _doOnReadyFunc(xhr);
                        }
                    };
                    function _doOnReadyFunc(xhr) {
                        var onReadyFunc = _onCompleteFuncs && _onCompleteFuncs.xhrOnComplete;
                        var onReadyFuncExist = onReadyFunc && isFunction(onReadyFunc);
                        if (onReadyFuncExist) {
                            onReadyFunc(xhr, oncomplete, payload);
                        }
                        else {
                            var response = getResponseText(xhr);
                            _doOnComplete(oncomplete, xhr[_DYN_STATUS ], _getAllResponseHeaders(xhr, _isOneDs), response);
                        }
                    }
                    xhr.onerror = function (event) {
                        _doOnComplete(oncomplete, _isOneDs ? xhr[_DYN_STATUS ] : 400, _getAllResponseHeaders(xhr, _isOneDs), _isOneDs ? STR_EMPTY$2 : formatErrorMessageXhr(xhr));
                        rejectFunc && rejectFunc(event);
                    };
                    xhr.ontimeout = function () {
                        _doOnComplete(oncomplete, _isOneDs ? xhr[_DYN_STATUS ] : 500, _getAllResponseHeaders(xhr, _isOneDs), _isOneDs ? STR_EMPTY$2 : formatErrorMessageXhr(xhr));
                        resolveFunc && resolveFunc(false);
                    };
                    xhr.send(payload[_DYN_DATA$1 ]);
                    return thePromise;
                }
                function _doFetchSender(payload, oncomplete, sync) {
                    var _a;
                    var endPointUrl = payload[_DYN_URL_STRING$1 ];
                    var batch = payload[_DYN_DATA$1 ];
                    var plainTextBatch = _isOneDs ? batch : new Blob([batch], { type: "application/json" });
                    var thePromise;
                    var resolveFunc;
                    var rejectFunc;
                    var requestHeaders = new Headers();
                    var batchLength = batch[_DYN_LENGTH$2 ];
                    var ignoreResponse = false;
                    var responseHandled = false;
                    var headers = payload[_DYN_HEADERS$1 ] || {};
                    var init = (_a = {
                            method: STR_POST_METHOD,
                            body: plainTextBatch
                        },
                        _a[DisabledPropertyName] = true
                    ,
                        _a);
                    if (payload.headers && objKeys(payload.headers)[_DYN_LENGTH$2 ] > 0) {
                        arrForEach(objKeys(headers), function (headerName) {
                            requestHeaders.append(headerName, headers[headerName]);
                        });
                        init[_DYN_HEADERS$1 ] = requestHeaders;
                    }
                    if (_sendCredentials && _isOneDs) {
                        init.credentials = "include";
                    }
                    if (sync) {
                        init.keepalive = true;
                        _syncFetchPayload += batchLength;
                        if (_isOneDs) {
                            if (payload["_sendReason"] === 2 ) {
                                ignoreResponse = true;
                                if (_addNoResponse) {
                                    endPointUrl += _noResponseQs$1;
                                }
                            }
                        }
                        else {
                            ignoreResponse = true;
                        }
                    }
                    var request = new Request(endPointUrl, init);
                    try {
                        request[DisabledPropertyName] = true;
                    }
                    catch (e) {
                    }
                    if (!sync && _enableSendPromise) {
                        thePromise = createPromise(function (resolve, reject) {
                            resolveFunc = resolve;
                            rejectFunc = reject;
                        });
                    }
                    if (!endPointUrl) {
                        _onNoPayloadUrl(oncomplete);
                        resolveFunc && resolveFunc(false);
                        return;
                    }
                    function _handleError(res) {
                        _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, _isOneDs ? STR_EMPTY$2 : res);
                    }
                    function _onFetchComplete(response, payload, value) {
                        var status = response[_DYN_STATUS ];
                        var onCompleteFunc = _onCompleteFuncs.fetchOnComplete;
                        if (onCompleteFunc && isFunction(onCompleteFunc)) {
                            onCompleteFunc(response, oncomplete, value || STR_EMPTY$2, payload);
                        }
                        else {
                            _doOnComplete(oncomplete, status, {}, value || STR_EMPTY$2);
                        }
                    }
                    try {
                        doAwaitResponse(fetch(_isOneDs ? endPointUrl : request, _isOneDs ? init : null), function (result) {
                            if (sync) {
                                _syncFetchPayload -= batchLength;
                                batchLength = 0;
                            }
                            if (!responseHandled) {
                                responseHandled = true;
                                if (!result.rejected) {
                                    var response_1 = result.value;
                                    try {
                                        if (!_isOneDs && !response_1.ok) {
                                            _handleError(response_1.statusText);
                                            resolveFunc && resolveFunc(false);
                                        }
                                        else {
                                            if (_isOneDs && !response_1.body) {
                                                _onFetchComplete(response_1, null, STR_EMPTY$2);
                                                resolveFunc && resolveFunc(true);
                                            }
                                            else {
                                                doAwaitResponse(response_1.text(), function (resp) {
                                                    _onFetchComplete(response_1, payload, resp.value);
                                                    resolveFunc && resolveFunc(true);
                                                });
                                            }
                                        }
                                    }
                                    catch (e) {
                                        _handleError(dumpObj(e));
                                        rejectFunc && rejectFunc(e);
                                    }
                                }
                                else {
                                    _handleError(result.reason && result.reason[_DYN_MESSAGE ]);
                                    rejectFunc && rejectFunc(result.reason);
                                }
                            }
                        });
                    }
                    catch (e) {
                        if (!responseHandled) {
                            _handleError(dumpObj(e));
                            rejectFunc && rejectFunc(e);
                        }
                    }
                    if (ignoreResponse && !responseHandled) {
                        responseHandled = true;
                        _doOnComplete(oncomplete, 200, {});
                        resolveFunc && resolveFunc(true);
                    }
                    if (_isOneDs && !responseHandled && payload[_DYN_TIMEOUT$1 ] > 0) {
                        _timeoutWrapper && _timeoutWrapper.set(function () {
                            if (!responseHandled) {
                                responseHandled = true;
                                _doOnComplete(oncomplete, 500, {});
                                resolveFunc && resolveFunc(true);
                            }
                        }, payload[_DYN_TIMEOUT$1 ]);
                    }
                    return thePromise;
                }
                function _xdrSender(payload, oncomplete, sync) {
                    var _window = getWindow();
                    var xdr = new XDomainRequest();
                    var data = payload[_DYN_DATA$1 ];
                    xdr.onload = function () {
                        var response = getResponseText(xdr);
                        var onloadFunc = _onCompleteFuncs && _onCompleteFuncs.xdrOnComplete;
                        if (onloadFunc && isFunction(onloadFunc)) {
                            onloadFunc(xdr, oncomplete, payload);
                        }
                        else {
                            _doOnComplete(oncomplete, 200, {}, response);
                        }
                    };
                    xdr.onerror = function () {
                        _doOnComplete(oncomplete, 400, {}, _isOneDs ? STR_EMPTY$2 : formatErrorMessageXdr(xdr));
                    };
                    xdr.ontimeout = function () {
                        _doOnComplete(oncomplete, 500, {});
                    };
                    xdr.onprogress = function () { };
                    var hostingProtocol = _window && _window.location && _window.location[_DYN_PROTOCOL ] || "";
                    var endpoint = payload[_DYN_URL_STRING$1 ];
                    if (!endpoint) {
                        _onNoPayloadUrl(oncomplete);
                        return;
                    }
                    if (!_isOneDs && endpoint.lastIndexOf(hostingProtocol, 0) !== 0) {
                        var msg = "Cannot send XDomain request. The endpoint URL protocol doesn't match the hosting page protocol.";
                        _throwInternal(_diagLog, 2 , 40 , ". " + msg);
                        _onError(msg, oncomplete);
                        return;
                    }
                    var endpointUrl = _isOneDs ? endpoint : endpoint[_DYN_REPLACE ](/^(https?:)/, "");
                    xdr.open(STR_POST_METHOD, endpointUrl);
                    if (payload[_DYN_TIMEOUT$1 ]) {
                        xdr[_DYN_TIMEOUT$1 ] = payload[_DYN_TIMEOUT$1 ];
                    }
                    xdr.send(data);
                    if (_isOneDs && sync) {
                        _timeoutWrapper && _timeoutWrapper.set(function () {
                            xdr.send(data);
                        }, 0);
                    }
                    else {
                        xdr.send(data);
                    }
                }
                function _initDefaults() {
                    _syncFetchPayload = 0;
                    _isInitialized = false;
                    _enableSendPromise = false;
                    _diagLog = null;
                    _isOneDs = null;
                    _onCompleteFuncs = null;
                    _disableCredentials = null;
                    _fallbackInst = null;
                    _disableXhr = false;
                    _disableBeacon = false;
                    _disableBeaconSync = false;
                    _disableFetchKeepAlive = false;
                    _addNoResponse = false;
                    _timeoutWrapper = null;
                }
            });
        }
        SenderPostManager.__ieDyn=1;
        return SenderPostManager;
    }());

    var strOnPrefix = "on";
    var strAttachEvent = "attachEvent";
    var strAddEventHelper = "addEventListener";
    var strDetachEvent = "detachEvent";
    var strRemoveEventListener = "removeEventListener";
    var strEvents = "events";
    var strVisibilityChangeEvt = "visibilitychange";
    var strPageHide = "pagehide";
    var strPageShow = "pageshow";
    var strUnload = "unload";
    var strBeforeUnload = "beforeunload";
    var strPageHideNamespace = createUniqueNamespace("aiEvtPageHide");
    var strPageShowNamespace = createUniqueNamespace("aiEvtPageShow");
    var rRemoveEmptyNs = /\.[\.]+/g;
    var rRemoveTrailingEmptyNs = /[\.]+$/;
    var _guid = 1;
    var elmNodeData = createElmNodeData("events");
    var eventNamespace = /^([^.]*)(?:\.(.+)|)/;
    function _normalizeNamespace(name) {
        if (name && name[_DYN_REPLACE ]) {
            return name[_DYN_REPLACE ](/^[\s\.]+|(?=[\s\.])[\.\s]+$/g, STR_EMPTY$3);
        }
        return name;
    }
    function _getEvtNamespace(eventName, evtNamespace) {
        var _a;
        if (evtNamespace) {
            var theNamespace_1 = STR_EMPTY$3;
            if (isArray(evtNamespace)) {
                theNamespace_1 = STR_EMPTY$3;
                arrForEach(evtNamespace, function (name) {
                    name = _normalizeNamespace(name);
                    if (name) {
                        if (name[0] !== ".") {
                            name = "." + name;
                        }
                        theNamespace_1 += name;
                    }
                });
            }
            else {
                theNamespace_1 = _normalizeNamespace(evtNamespace);
            }
            if (theNamespace_1) {
                if (theNamespace_1[0] !== ".") {
                    theNamespace_1 = "." + theNamespace_1;
                }
                eventName = (eventName || STR_EMPTY$3) + theNamespace_1;
            }
        }
        var parsedEvent = (eventNamespace.exec(eventName || STR_EMPTY$3) || []);
        return _a = {},
            _a[_DYN_TYPE ] = parsedEvent[1],
            _a.ns = ((parsedEvent[2] || STR_EMPTY$3).replace(rRemoveEmptyNs, ".").replace(rRemoveTrailingEmptyNs, STR_EMPTY$3)[_DYN_SPLIT$1 ](".").sort()).join("."),
            _a;
    }
    function _getRegisteredEvents(target, evtName, addDefault) {
        if (addDefault === void 0) { addDefault = true; }
        var aiEvts = elmNodeData.get(target, strEvents, {}, addDefault);
        var registeredEvents = aiEvts[evtName];
        if (!registeredEvents) {
            registeredEvents = aiEvts[evtName] = [];
        }
        return registeredEvents;
    }
    function _doDetach(obj, evtName, handlerRef, useCapture) {
        if (obj && evtName && evtName[_DYN_TYPE ]) {
            if (obj[strRemoveEventListener]) {
                obj[strRemoveEventListener](evtName[_DYN_TYPE ], handlerRef, useCapture);
            }
            else if (obj[strDetachEvent]) {
                obj[strDetachEvent](strOnPrefix + evtName[_DYN_TYPE ], handlerRef);
            }
        }
    }
    function _doAttach(obj, evtName, handlerRef, useCapture) {
        var result = false;
        if (obj && evtName && evtName[_DYN_TYPE ] && handlerRef) {
            if (obj[strAddEventHelper]) {
                obj[strAddEventHelper](evtName[_DYN_TYPE ], handlerRef, useCapture);
                result = true;
            }
            else if (obj[strAttachEvent]) {
                obj[strAttachEvent](strOnPrefix + evtName[_DYN_TYPE ], handlerRef);
                result = true;
            }
        }
        return result;
    }
    function _doUnregister(target, events, evtName, unRegFn) {
        var idx = events[_DYN_LENGTH$2 ];
        while (idx--) {
            var theEvent = events[idx];
            if (theEvent) {
                if (!evtName.ns || evtName.ns === theEvent.evtName.ns) {
                    if (!unRegFn || unRegFn(theEvent)) {
                        _doDetach(target, theEvent.evtName, theEvent[_DYN_HANDLER ], theEvent.capture);
                        events[_DYN_SPLICE$1 ](idx, 1);
                    }
                }
            }
        }
    }
    function _unregisterEvents(target, evtName, unRegFn) {
        if (evtName[_DYN_TYPE ]) {
            _doUnregister(target, _getRegisteredEvents(target, evtName[_DYN_TYPE ]), evtName, unRegFn);
        }
        else {
            var eventCache = elmNodeData.get(target, strEvents, {});
            objForEachKey(eventCache, function (evtType, events) {
                _doUnregister(target, events, evtName, unRegFn);
            });
            if (objKeys(eventCache)[_DYN_LENGTH$2 ] === 0) {
                elmNodeData.kill(target, strEvents);
            }
        }
    }
    function mergeEvtNamespace(theNamespace, namespaces) {
        var newNamespaces;
        if (namespaces) {
            if (isArray(namespaces)) {
                newNamespaces = [theNamespace].concat(namespaces);
            }
            else {
                newNamespaces = [theNamespace, namespaces];
            }
            newNamespaces = (_getEvtNamespace("xx", newNamespaces).ns)[_DYN_SPLIT$1 ](".");
        }
        else {
            newNamespaces = theNamespace;
        }
        return newNamespaces;
    }
    function eventOn(target, eventName, handlerRef, evtNamespace, useCapture) {
        var _a;
        if (useCapture === void 0) { useCapture = false; }
        var result = false;
        if (target) {
            try {
                var evtName = _getEvtNamespace(eventName, evtNamespace);
                result = _doAttach(target, evtName, handlerRef, useCapture);
                if (result && elmNodeData.accept(target)) {
                    var registeredEvent = (_a = {
                            guid: _guid++,
                            evtName: evtName
                        },
                        _a[_DYN_HANDLER ] = handlerRef,
                        _a.capture = useCapture,
                        _a);
                    _getRegisteredEvents(target, evtName.type)[_DYN_PUSH$1 ](registeredEvent);
                }
            }
            catch (e) {
            }
        }
        return result;
    }
    function eventOff(target, eventName, handlerRef, evtNamespace, useCapture) {
        if (useCapture === void 0) { useCapture = false; }
        if (target) {
            try {
                var evtName_1 = _getEvtNamespace(eventName, evtNamespace);
                var found_1 = false;
                _unregisterEvents(target, evtName_1, function (regEvent) {
                    if ((evtName_1.ns && !handlerRef) || regEvent[_DYN_HANDLER ] === handlerRef) {
                        found_1 = true;
                        return true;
                    }
                    return false;
                });
                if (!found_1) {
                    _doDetach(target, evtName_1, handlerRef, useCapture);
                }
            }
            catch (e) {
            }
        }
    }
    function addEventHandler(eventName, callback, evtNamespace) {
        var result = false;
        var w = getWindow();
        if (w) {
            result = eventOn(w, eventName, callback, evtNamespace);
            result = eventOn(w["body"], eventName, callback, evtNamespace) || result;
        }
        var doc = getDocument();
        if (doc) {
            result = eventOn(doc, eventName, callback, evtNamespace) || result;
        }
        return result;
    }
    function removeEventHandler(eventName, callback, evtNamespace) {
        var w = getWindow();
        if (w) {
            eventOff(w, eventName, callback, evtNamespace);
            eventOff(w["body"], eventName, callback, evtNamespace);
        }
        var doc = getDocument();
        if (doc) {
            eventOff(doc, eventName, callback, evtNamespace);
        }
    }
    function _addEventListeners(events, listener, excludeEvents, evtNamespace) {
        var added = false;
        if (listener && events && events[_DYN_LENGTH$2 ] > 0) {
            arrForEach(events, function (name) {
                if (name) {
                    if (!excludeEvents || arrIndexOf(excludeEvents, name) === -1) {
                        added = addEventHandler(name, listener, evtNamespace) || added;
                    }
                }
            });
        }
        return added;
    }
    function addEventListeners(events, listener, excludeEvents, evtNamespace) {
        var added = false;
        if (listener && events && isArray(events)) {
            added = _addEventListeners(events, listener, excludeEvents, evtNamespace);
            if (!added && excludeEvents && excludeEvents[_DYN_LENGTH$2 ] > 0) {
                added = _addEventListeners(events, listener, null, evtNamespace);
            }
        }
        return added;
    }
    function removeEventListeners(events, listener, evtNamespace) {
        if (events && isArray(events)) {
            arrForEach(events, function (name) {
                if (name) {
                    removeEventHandler(name, listener, evtNamespace);
                }
            });
        }
    }
    function addPageUnloadEventListener(listener, excludeEvents, evtNamespace) {
        return addEventListeners([strBeforeUnload, strUnload, strPageHide], listener, excludeEvents, evtNamespace);
    }
    function removePageUnloadEventListener(listener, evtNamespace) {
        removeEventListeners([strBeforeUnload, strUnload, strPageHide], listener, evtNamespace);
    }
    function addPageHideEventListener(listener, excludeEvents, evtNamespace) {
        function _handlePageVisibility(evt) {
            var doc = getDocument();
            if (listener && doc && doc.visibilityState === "hidden") {
                listener(evt);
            }
        }
        var newNamespaces = mergeEvtNamespace(strPageHideNamespace, evtNamespace);
        var pageUnloadAdded = _addEventListeners([strPageHide], listener, excludeEvents, newNamespaces);
        if (!excludeEvents || arrIndexOf(excludeEvents, strVisibilityChangeEvt) === -1) {
            pageUnloadAdded = _addEventListeners([strVisibilityChangeEvt], _handlePageVisibility, excludeEvents, newNamespaces) || pageUnloadAdded;
        }
        if (!pageUnloadAdded && excludeEvents) {
            pageUnloadAdded = addPageHideEventListener(listener, null, evtNamespace);
        }
        return pageUnloadAdded;
    }
    function removePageHideEventListener(listener, evtNamespace) {
        var newNamespaces = mergeEvtNamespace(strPageHideNamespace, evtNamespace);
        removeEventListeners([strPageHide], listener, newNamespaces);
        removeEventListeners([strVisibilityChangeEvt], null, newNamespaces);
    }
    function addPageShowEventListener(listener, excludeEvents, evtNamespace) {
        function _handlePageVisibility(evt) {
            var doc = getDocument();
            if (listener && doc && doc.visibilityState === "visible") {
                listener(evt);
            }
        }
        var newNamespaces = mergeEvtNamespace(strPageShowNamespace, evtNamespace);
        var pageShowAdded = _addEventListeners([strPageShow], listener, excludeEvents, newNamespaces);
        pageShowAdded = _addEventListeners([strVisibilityChangeEvt], _handlePageVisibility, excludeEvents, newNamespaces) || pageShowAdded;
        if (!pageShowAdded && excludeEvents) {
            pageShowAdded = addPageShowEventListener(listener, null, evtNamespace);
        }
        return pageShowAdded;
    }
    function removePageShowEventListener(listener, evtNamespace) {
        var newNamespaces = mergeEvtNamespace(strPageShowNamespace, evtNamespace);
        removeEventListeners([strPageShow], listener, newNamespaces);
        removeEventListeners([strVisibilityChangeEvt], null, newNamespaces);
    }

    var STR_EMPTY$1 = "";

    var _DYN_TIMINGS$1 = "timings";
    var _DYN_VALUE = "value";
    var _DYN_KIND = "kind";
    var _DYN_LENGTH$1 = "length";
    var _DYN_PROCESS_TELEMETRY_ST0 = "processTelemetryStart";

    var _a$1;
    var Version = '4.2.2';
    var FullVersionString = "1DS-Web-JS-" + Version;
    var ObjHasOwnProperty = ObjProto$1.hasOwnProperty;
    var _fieldTypeEventPropMap = (_a$1 = {},
        _a$1[0 ] = 0 ,
        _a$1[2 ] = 6 ,
        _a$1[1 ] = 1 ,
        _a$1[3 ] = 7 ,
        _a$1[4096  | 2 ] = 6 ,
        _a$1[4096  | 1 ] = 1 ,
        _a$1[4096  | 3 ] = 7 ,
        _a$1);
    function isValueAssigned(value) {
        return !(value === STR_EMPTY$1 || isNullOrUndefined(value));
    }
    function getTenantId(apiKey) {
        if (apiKey) {
            var indexTenantId = strIndexOf(apiKey, "-");
            if (indexTenantId > -1) {
                return strLeft(apiKey, indexTenantId);
            }
        }
        return STR_EMPTY$1;
    }
    function sanitizeProperty(name, property, stringifyObjects) {
        if ((!property && !isValueAssigned(property)) || typeof name !== "string") {
            return null;
        }
        var propType = typeof property;
        if (propType === "string" || propType === "number" || propType === "boolean" || isArray(property)) {
            property = { value: property };
        }
        else if (propType === "object" && !ObjHasOwnProperty.call(property, "value")) {
            property = { value: stringifyObjects ? JSON.stringify(property) : property };
        }
        else if (isNullOrUndefined(property[_DYN_VALUE ])
            || property[_DYN_VALUE ] === STR_EMPTY$1 || (!isString(property[_DYN_VALUE ])
            && !isNumber(property[_DYN_VALUE ]) && !isBoolean(property[_DYN_VALUE ])
            && !isArray(property[_DYN_VALUE ]))) {
            return null;
        }
        if (isArray(property[_DYN_VALUE ]) &&
            !isArrayValid(property[_DYN_VALUE ])) {
            return null;
        }
        if (!isNullOrUndefined(property[_DYN_KIND ])) {
            if (isArray(property[_DYN_VALUE ]) || !isValueKind(property[_DYN_KIND ])) {
                return null;
            }
            property[_DYN_VALUE ] = property[_DYN_VALUE ].toString();
        }
        return property;
    }
    function getCommonSchemaMetaData(value, kind, type) {
        var encodedTypeValue = -1;
        if (!isUndefined(value)) {
            if (kind > 0) {
                if (kind === 32 ) {
                    encodedTypeValue = (1 << 13);
                }
                else if (kind <= 13) {
                    encodedTypeValue = (kind << 5);
                }
            }
            if (isDataType(type)) {
                if (encodedTypeValue === -1) {
                    encodedTypeValue = 0;
                }
                encodedTypeValue |= type;
            }
            else {
                var propType = _fieldTypeEventPropMap[getFieldValueType(value)] || -1;
                if (encodedTypeValue !== -1 && propType !== -1) {
                    encodedTypeValue |= propType;
                }
                else if (propType === 6 ) {
                    encodedTypeValue = propType;
                }
            }
        }
        return encodedTypeValue;
    }
    function extend(obj, obj2, obj3, obj4, obj5) {
        var extended = {};
        var deep = false;
        var i = 0;
        var length = arguments[_DYN_LENGTH$1 ];
        var theArgs = arguments;
        if (isBoolean(theArgs[0])) {
            deep = theArgs[0];
            i++;
        }
        for (; i < length; i++) {
            var obj = theArgs[i];
            objForEachKey(obj, function (prop, value) {
                if (deep && value && isObject(value)) {
                    if (isArray(value)) {
                        extended[prop] = extended[prop] || [];
                        arrForEach(value, function (arrayValue, arrayIndex) {
                            if (arrayValue && isObject(arrayValue)) {
                                extended[prop][arrayIndex] = extend(true, extended[prop][arrayIndex], arrayValue);
                            }
                            else {
                                extended[prop][arrayIndex] = arrayValue;
                            }
                        });
                    }
                    else {
                        extended[prop] = extend(true, extended[prop], value);
                    }
                }
                else {
                    extended[prop] = value;
                }
            });
        }
        return extended;
    }
    var getTime = perfNow;
    function isValueKind(value) {
        if (value === 0  || ((value > 0  && value <= 13 ) || value === 32 )) {
            return true;
        }
        return false;
    }
    function isDataType(value) {
        if (value >= 0 && value <= 9) {
            return true;
        }
        return false;
    }
    function isArrayValid(value) {
        return value[_DYN_LENGTH$1 ] > 0;
    }
    function setProcessTelemetryTimings(event, identifier) {
        var evt = event;
        evt[_DYN_TIMINGS$1 ] = evt[_DYN_TIMINGS$1 ] || {};
        evt[_DYN_TIMINGS$1 ][_DYN_PROCESS_TELEMETRY_ST0 ] = evt[_DYN_TIMINGS$1 ][_DYN_PROCESS_TELEMETRY_ST0 ] || {};
        evt[_DYN_TIMINGS$1 ][_DYN_PROCESS_TELEMETRY_ST0 ][identifier] = getTime();
    }
    function getFieldValueType(value) {
        var theType = 0 ;
        if (value !== null && value !== undefined) {
            var objType = typeof value;
            if (objType === "string") {
                theType = 1 ;
            }
            else if (objType === "number") {
                theType = 2 ;
            }
            else if (objType === "boolean") {
                theType = 3 ;
            }
            else if (objType === strShimObject) {
                theType = 4 ;
                if (isArray(value)) {
                    theType = 4096 ;
                    if (value[_DYN_LENGTH$1 ] > 0) {
                        theType |= getFieldValueType(value[0]);
                    }
                }
                else if (ObjHasOwnProperty.call(value, "value")) {
                    theType = 8192  | getFieldValueType(value[_DYN_VALUE ]);
                }
            }
        }
        return theType;
    }
    function isChromium() {
        return !!getInst("chrome");
    }
    function isGreaterThanZero(value) {
        return value > 0;
    }

    var STR_EMPTY = "";
    var STR_DROPPED = "drop";
    var STR_SENDING = "send";
    var STR_REQUEUE = "requeue";
    var STR_RESPONSE_FAIL = "rspFail";
    var STR_OTHER = "oth";
    var DEFAULT_CACHE_CONTROL = "no-cache, no-store";
    var DEFAULT_CONTENT_TYPE = "application/x-json-stream";
    var STR_CACHE_CONTROL = "cache-control";
    var STR_CONTENT_TYPE_HEADER = "content-type";
    var STR_KILL_TOKENS_HEADER = "kill-tokens";
    var STR_KILL_DURATION_HEADER = "kill-duration";
    var STR_TIME_DELTA_HEADER = "time-delta-millis";
    var STR_CLIENT_VERSION = "client-version";
    var STR_CLIENT_ID = "client-id";
    var STR_TIME_DELTA_TO_APPLY = "time-delta-to-apply-millis";
    var STR_UPLOAD_TIME = "upload-time";
    var STR_API_KEY = "apikey";
    var STR_MSA_DEVICE_TICKET = "AuthMsaDeviceTicket";
    var STR_AUTH_WEB_TOKEN = "WebAuthToken";
    var STR_AUTH_XTOKEN = "AuthXToken";
    var STR_NO_RESPONSE_BODY = "NoResponseBody";
    var STR_MSFPC = "msfpc";
    var STR_TRACE = "trace";
    var STR_USER = "user";

    var _DYN_ALLOW_REQUEST_SENDIN0 = "allowRequestSending";
    var _DYN_FIRST_REQUEST_SENT = "firstRequestSent";
    var _DYN_SHOULD_ADD_CLOCK_SKE1 = "shouldAddClockSkewHeaders";
    var _DYN_GET_CLOCK_SKEW_HEADE2 = "getClockSkewHeaderValue";
    var _DYN_SET_CLOCK_SKEW = "setClockSkew";
    var _DYN_LENGTH = "length";
    var _DYN_CONCAT = "concat";
    var _DYN_I_KEY = "iKey";
    var _DYN_COUNT = "count";
    var _DYN_EVENTS = "events";
    var _DYN_PUSH = "push";
    var _DYN_SPLIT = "split";
    var _DYN_SPLICE = "splice";
    var _DYN_TO_LOWER_CASE = "toLowerCase";
    var _DYN_HDRS = "hdrs";
    var _DYN_USE_HDRS = "useHdrs";
    var _DYN_INITIALIZE = "initialize";
    var _DYN_SET_TIMEOUT_OVERRIDE = "setTimeoutOverride";
    var _DYN_CLEAR_TIMEOUT_OVERRI3 = "clearTimeoutOverride";
    var _DYN_PAYLOAD_PREPROCESSOR = "payloadPreprocessor";
    var _DYN_OVERRIDE_ENDPOINT_UR4 = "overrideEndpointUrl";
    var _DYN_AVOID_OPTIONS = "avoidOptions";
    var _DYN_DISABLE_EVENT_TIMING5 = "disableEventTimings";
    var _DYN_STRINGIFY_OBJECTS = "stringifyObjects";
    var _DYN_ENABLE_COMPOUND_KEY = "enableCompoundKey";
    var _DYN_DISABLE_XHR_SYNC = "disableXhrSync";
    var _DYN_DISABLE_FETCH_KEEP_A6 = "disableFetchKeepAlive";
    var _DYN_ADD_NO_RESPONSE = "addNoResponse";
    var _DYN_EXCLUDE_CS_META_DATA = "excludeCsMetaData";
    var _DYN_USE_SEND_BEACON = "useSendBeacon";
    var _DYN_ALWAYS_USE_XHR_OVERR7 = "alwaysUseXhrOverride";
    var _DYN_UNLOAD_TRANSPORTS = "unloadTransports";
    var _DYN_SERIALIZE_OFFLINE_EV8 = "serializeOfflineEvt";
    var _DYN_GET_OFFLINE_REQUEST_9 = "getOfflineRequestDetails";
    var _DYN_CREATE_PAYLOAD = "createPayload";
    var _DYN_CREATE_ONE_DSPAYLOAD = "createOneDSPayload";
    var _DYN_PAYLOAD_BLOB = "payloadBlob";
    var _DYN_HEADERS = "headers";
    var _DYN__THE_PAYLOAD = "_thePayload";
    var _DYN_URL_STRING = "urlString";
    var _DYN_BATCHES = "batches";
    var _DYN_SEND_TYPE = "sendType";
    var _DYN_ADD_HEADER = "addHeader";
    var _DYN_CAN_SEND_REQUEST = "canSendRequest";
    var _DYN_SEND_QUEUED_REQUESTS = "sendQueuedRequests";
    var _DYN_IS_COMPLETELY_IDLE = "isCompletelyIdle";
    var _DYN_SET_UNLOADING = "setUnloading";
    var _DYN_IS_TENANT_KILLED = "isTenantKilled";
    var _DYN_SEND_SYNCHRONOUS_BAT10 = "sendSynchronousBatch";
    var _DYN__TRANSPORT = "_transport";
    var _DYN_GET_WPARAM = "getWParam";
    var _DYN_IS_BEACON = "isBeacon";
    var _DYN_TIMINGS = "timings";
    var _DYN_IS_TEARDOWN = "isTeardown";
    var _DYN_IS_SYNC = "isSync";
    var _DYN_DATA = "data";
    var _DYN_TIMEOUT = "timeout";
    var _DYN__SEND_REASON = "_sendReason";
    var _DYN_SET_KILL_SWITCH_TENA11 = "setKillSwitchTenants";
    var _DYN__BACK_OFF_TRANSMISSI12 = "_backOffTransmission";
    var _DYN_IDENTIFIER = "identifier";
    var _DYN_DISABLE_OPTIMIZE_OBJ = "disableOptimizeObj";
    var _DYN_IGNORE_MC1_MS0_COOKI13 = "ignoreMc1Ms0CookieProcessing";
    var _DYN_EVENTS_LIMIT_IN_MEM = "eventsLimitInMem";
    var _DYN_AUTO_FLUSH_EVENTS_LI14 = "autoFlushEventsLimit";
    var _DYN_DISABLE_AUTO_BATCH_F15 = "disableAutoBatchFlushLimit";
    var _DYN_OVERRIDE_INSTRUMENTA16 = "overrideInstrumentationKey";
    var _DYN_DISABLE_TELEMETRY = "disableTelemetry";
    var _DYN_BASE_DATA = "baseData";
    var _DYN_SEND_ATTEMPT = "sendAttempt";
    var _DYN_LATENCY = "latency";
    var _DYN_SYNC = "sync";

    function _getEventMsfpc(theEvent) {
        var intWeb = ((theEvent.ext || {})["intweb"]);
        if (intWeb && isValueAssigned(intWeb[STR_MSFPC])) {
            return intWeb[STR_MSFPC];
        }
        return null;
    }
    function _getMsfpc(theEvents) {
        var msfpc = null;
        for (var lp = 0; msfpc === null && lp < theEvents[_DYN_LENGTH ]; lp++) {
            msfpc = _getEventMsfpc(theEvents[lp]);
        }
        return msfpc;
    }
    var EventBatch = /** @class */ (function () {
        function EventBatch(iKey, addEvents) {
            var events = addEvents ? [][_DYN_CONCAT ](addEvents) : [];
            var _self = this;
            var _msfpc = _getMsfpc(events);
            _self[_DYN_I_KEY ] = function () {
                return iKey;
            };
            _self.Msfpc = function () {
                return _msfpc || STR_EMPTY;
            };
            _self[_DYN_COUNT ] = function () {
                return events[_DYN_LENGTH ];
            };
            _self[_DYN_EVENTS ] = function () {
                return events;
            };
            _self.addEvent = function (theEvent) {
                if (theEvent) {
                    events[_DYN_PUSH ](theEvent);
                    if (!_msfpc) {
                        _msfpc = _getEventMsfpc(theEvent);
                    }
                    return true;
                }
                return false;
            };
            _self[_DYN_SPLIT ] = function (fromEvent, numEvents) {
                var theEvents;
                if (fromEvent < events[_DYN_LENGTH ]) {
                    var cnt = events[_DYN_LENGTH ] - fromEvent;
                    if (!isNullOrUndefined(numEvents)) {
                        cnt = numEvents < cnt ? numEvents : cnt;
                    }
                    theEvents = events[_DYN_SPLICE ](fromEvent, cnt);
                    _msfpc = _getMsfpc(events);
                }
                return new EventBatch(iKey, theEvents);
            };
        }
        EventBatch.create = function (iKey, theEvents) {
            return new EventBatch(iKey, theEvents);
        };
        return EventBatch;
    }());

    var ClockSkewManager = /** @class */ (function () {
        function ClockSkewManager() {
            var _allowRequestSending = true;
            var _shouldAddClockSkewHeaders = true;
            var _isFirstRequest = true;
            var _clockSkewHeaderValue = "use-collector-delta";
            var _clockSkewSet = false;
            dynamicProto(ClockSkewManager, this, function (_self) {
                _self[_DYN_ALLOW_REQUEST_SENDIN0 ] = function () {
                    return _allowRequestSending;
                };
                _self[_DYN_FIRST_REQUEST_SENT ] = function () {
                    if (_isFirstRequest) {
                        _isFirstRequest = false;
                        if (!_clockSkewSet) {
                            _allowRequestSending = false;
                        }
                    }
                };
                _self[_DYN_SHOULD_ADD_CLOCK_SKE1 ] = function () {
                    return _shouldAddClockSkewHeaders;
                };
                _self[_DYN_GET_CLOCK_SKEW_HEADE2 ] = function () {
                    return _clockSkewHeaderValue;
                };
                _self[_DYN_SET_CLOCK_SKEW ] = function (timeDeltaInMillis) {
                    if (!_clockSkewSet) {
                        if (timeDeltaInMillis) {
                            _clockSkewHeaderValue = timeDeltaInMillis;
                            _shouldAddClockSkewHeaders = true;
                            _clockSkewSet = true;
                        }
                        else {
                            _shouldAddClockSkewHeaders = false;
                        }
                        _allowRequestSending = true;
                    }
                };
            });
        }
        ClockSkewManager.__ieDyn=1;
        return ClockSkewManager;
    }());

    var SecToMsMultiplier = 1000;
    var KillSwitch = /** @class */ (function () {
        function KillSwitch() {
            var _killedTokenDictionary = {};
            function _normalizeTenants(values) {
                var result = [];
                if (values) {
                    arrForEach(values, function (value) {
                        result[_DYN_PUSH ](strTrim(value));
                    });
                }
                return result;
            }
            dynamicProto(KillSwitch, this, function (_self) {
                _self[_DYN_SET_KILL_SWITCH_TENA11 ] = function (killTokens, killDuration) {
                    if (killTokens && killDuration) {
                        try {
                            var killedTokens = _normalizeTenants(killTokens[_DYN_SPLIT ](","));
                            if (killDuration === "this-request-only") {
                                return killedTokens;
                            }
                            var durationMs = parseInt(killDuration, 10) * SecToMsMultiplier;
                            for (var i = 0; i < killedTokens[_DYN_LENGTH ]; ++i) {
                                _killedTokenDictionary[killedTokens[i]] = utcNow() + durationMs;
                            }
                        }
                        catch (ex) {
                            return [];
                        }
                    }
                    return [];
                };
                _self[_DYN_IS_TENANT_KILLED ] = function (tenantToken) {
                    var killDictionary = _killedTokenDictionary;
                    var name = strTrim(tenantToken);
                    if (killDictionary[name] !== undefined && killDictionary[name] > utcNow()) {
                        return true;
                    }
                    delete killDictionary[name];
                    return false;
                };
            });
        }
        KillSwitch.__ieDyn=1;
        return KillSwitch;
    }());

    var RandomizationLowerThreshold = 0.8;
    var RandomizationUpperThreshold = 1.2;
    var BaseBackoff = 3000;
    var MaxBackoff = 600000;
    function retryPolicyShouldRetryForStatus(httpStatusCode) {
        return !((httpStatusCode >= 300 && httpStatusCode < 500 && httpStatusCode != 429)
            || (httpStatusCode == 501)
            || (httpStatusCode == 505));
    }
    function retryPolicyGetMillisToBackoffForRetry(retriesSoFar) {
        var waitDuration = 0;
        var minBackoff = BaseBackoff * RandomizationLowerThreshold;
        var maxBackoff = BaseBackoff * RandomizationUpperThreshold;
        var randomBackoff = Math.floor(Math.random() * (maxBackoff - minBackoff)) + minBackoff;
        waitDuration = Math.pow(2, retriesSoFar) * randomBackoff;
        return Math.min(waitDuration, MaxBackoff);
    }

    var _MAX_STRING_JOINS = 20;
    var RequestSizeLimitBytes = 3984588;
    var BeaconRequestSizeLimitBytes = 65000;
    var MaxRecordSize = 2000000;
    var MaxBeaconRecordSize = Math.min(MaxRecordSize, BeaconRequestSizeLimitBytes);
    var metadata = "metadata";
    var f = "f";
    var rCheckDot = /\./;
    var Serializer = /** @class */ (function () {
        function Serializer(perfManager, valueSanitizer, stringifyObjects, enableCompoundKey, getEncodedTypeOverride, excludeCsMetaData) {
            var strData = "data";
            var strBaseData = "baseData";
            var strExt = "ext";
            var _checkForCompoundkey = !!enableCompoundKey;
            var _processSubKeys = true;
            var _theSanitizer = valueSanitizer;
            var _isReservedCache = {};
            var _excludeCsMetaData = !!excludeCsMetaData;
            var _getEncodedType = getEncodedTypeOverride || getCommonSchemaMetaData;
            dynamicProto(Serializer, this, function (_self) {
                _self.createPayload = function (retryCnt, isTeardown, isSync, isReducedPayload, sendReason, sendType) {
                    return {
                        apiKeys: [],
                        payloadBlob: STR_EMPTY,
                        overflow: null,
                        sizeExceed: [],
                        failedEvts: [],
                        batches: [],
                        numEvents: 0,
                        retryCnt: retryCnt,
                        isTeardown: isTeardown,
                        isSync: isSync,
                        isBeacon: isReducedPayload,
                        sendType: sendType,
                        sendReason: sendReason
                    };
                };
                _self.appendPayload = function (payload, theBatch, maxEventsPerBatch) {
                    var canAddEvents = payload && theBatch && !payload.overflow;
                    if (canAddEvents) {
                        doPerf(perfManager, function () { return "Serializer:appendPayload"; }, function () {
                            var theEvents = theBatch.events();
                            var payloadBlob = payload.payloadBlob;
                            var payloadEvents = payload.numEvents;
                            var eventsAdded = false;
                            var sizeExceeded = [];
                            var failedEvts = [];
                            var isBeaconPayload = payload.isBeacon;
                            var requestMaxSize = isBeaconPayload ? BeaconRequestSizeLimitBytes : RequestSizeLimitBytes;
                            var recordMaxSize = isBeaconPayload ? MaxBeaconRecordSize : MaxRecordSize;
                            var lp = 0;
                            var joinCount = 0;
                            while (lp < theEvents.length) {
                                var theEvent = theEvents[lp];
                                if (theEvent) {
                                    if (payloadEvents >= maxEventsPerBatch) {
                                        payload.overflow = theBatch.split(lp);
                                        break;
                                    }
                                    var eventBlob = _self.getEventBlob(theEvent);
                                    if (eventBlob && eventBlob.length <= recordMaxSize) {
                                        var blobLength = eventBlob.length;
                                        var currentSize = payloadBlob.length;
                                        if (currentSize + blobLength > requestMaxSize) {
                                            payload.overflow = theBatch.split(lp);
                                            break;
                                        }
                                        if (payloadBlob) {
                                            payloadBlob += "\n";
                                        }
                                        payloadBlob += eventBlob;
                                        joinCount++;
                                        if (joinCount > _MAX_STRING_JOINS) {
                                            strSubstr(payloadBlob, 0, 1);
                                            joinCount = 0;
                                        }
                                        eventsAdded = true;
                                        payloadEvents++;
                                    }
                                    else {
                                        if (eventBlob) {
                                            sizeExceeded.push(theEvent);
                                        }
                                        else {
                                            failedEvts.push(theEvent);
                                        }
                                        theEvents.splice(lp, 1);
                                        lp--;
                                    }
                                }
                                lp++;
                            }
                            if (sizeExceeded.length > 0) {
                                payload.sizeExceed.push(EventBatch.create(theBatch.iKey(), sizeExceeded));
                            }
                            if (failedEvts.length > 0) {
                                payload.failedEvts.push(EventBatch.create(theBatch.iKey(), failedEvts));
                            }
                            if (eventsAdded) {
                                payload.batches.push(theBatch);
                                payload.payloadBlob = payloadBlob;
                                payload.numEvents = payloadEvents;
                                var apiKey = theBatch.iKey();
                                if (arrIndexOf(payload.apiKeys, apiKey) === -1) {
                                    payload.apiKeys.push(apiKey);
                                }
                            }
                        }, function () { return ({ payload: payload, theBatch: { iKey: theBatch.iKey(), evts: theBatch.events() }, max: maxEventsPerBatch }); });
                    }
                    return canAddEvents;
                };
                _self.getEventBlob = function (eventData) {
                    try {
                        return doPerf(perfManager, function () { return "Serializer.getEventBlob"; }, function () {
                            var serializedEvent = {};
                            serializedEvent.name = eventData.name;
                            serializedEvent.time = eventData.time;
                            serializedEvent.ver = eventData.ver;
                            serializedEvent.iKey = "o:" + getTenantId(eventData.iKey);
                            var serializedExt = {};
                            var _addMetadataCallback;
                            if (!_excludeCsMetaData) {
                                _addMetadataCallback = function (pathKeys, key, value) {
                                    _addJSONPropertyMetaData(_getEncodedType, serializedExt, pathKeys, key, value);
                                };
                            }
                            var eventExt = eventData[strExt];
                            if (eventExt) {
                                serializedEvent[strExt] = serializedExt;
                                objForEachKey(eventExt, function (key, value) {
                                    var data = serializedExt[key] = {};
                                    _processPathKeys(value, data, "ext." + key, true, null, null, true);
                                });
                            }
                            var serializedData = serializedEvent[strData] = {};
                            serializedData.baseType = eventData.baseType;
                            var serializedBaseData = serializedData[strBaseData] = {};
                            _processPathKeys(eventData.baseData, serializedBaseData, strBaseData, false, [strBaseData], _addMetadataCallback, _processSubKeys);
                            _processPathKeys(eventData.data, serializedData, strData, false, [], _addMetadataCallback, _processSubKeys);
                            return JSON.stringify(serializedEvent);
                        }, function () { return ({ item: eventData }); });
                    }
                    catch (e) {
                        return null;
                    }
                };
                function _isReservedField(path, name) {
                    var result = _isReservedCache[path];
                    if (result === undefined) {
                        if (path.length >= 7) {
                            result = strStartsWith(path, "ext.metadata") || strStartsWith(path, "ext.web");
                        }
                        _isReservedCache[path] = result;
                    }
                    return result;
                }
                function _processPathKeys(srcObj, target, thePath, checkReserved, metadataPathKeys, metadataCallback, processSubKeys) {
                    objForEachKey(srcObj, function (key, srcValue) {
                        var prop = null;
                        if (srcValue || isValueAssigned(srcValue)) {
                            var path = thePath;
                            var name_1 = key;
                            var theMetaPathKeys = metadataPathKeys;
                            var destObj = target;
                            if (_checkForCompoundkey && !checkReserved && rCheckDot.test(key)) {
                                var subKeys = key.split(".");
                                var keyLen = subKeys.length;
                                if (keyLen > 1) {
                                    if (theMetaPathKeys) {
                                        theMetaPathKeys = theMetaPathKeys.slice();
                                    }
                                    for (var lp = 0; lp < keyLen - 1; lp++) {
                                        var subKey = subKeys[lp];
                                        destObj = destObj[subKey] = destObj[subKey] || {};
                                        path += "." + subKey;
                                        if (theMetaPathKeys) {
                                            theMetaPathKeys.push(subKey);
                                        }
                                    }
                                    name_1 = subKeys[keyLen - 1];
                                }
                            }
                            var isReserved = checkReserved && _isReservedField(path);
                            if (!isReserved && _theSanitizer && _theSanitizer.handleField(path, name_1)) {
                                prop = _theSanitizer.value(path, name_1, srcValue, stringifyObjects);
                            }
                            else {
                                prop = sanitizeProperty(name_1, srcValue, stringifyObjects);
                            }
                            if (prop) {
                                var newValue = prop.value;
                                destObj[name_1] = newValue;
                                if (metadataCallback) {
                                    metadataCallback(theMetaPathKeys, name_1, prop);
                                }
                                if (processSubKeys && typeof newValue === "object" && !isArray(newValue)) {
                                    var newPath = theMetaPathKeys;
                                    if (newPath) {
                                        newPath = newPath.slice();
                                        newPath.push(name_1);
                                    }
                                    _processPathKeys(srcValue, newValue, path + "." + name_1, checkReserved, newPath, metadataCallback, processSubKeys);
                                }
                            }
                        }
                    });
                }
            });
        }
        Serializer.__ieDyn=1;
        return Serializer;
    }());
    function _addJSONPropertyMetaData(getEncodedType, json, propKeys, name, propertyValue) {
        if (propertyValue && json) {
            var encodedTypeValue = getEncodedType(propertyValue.value, propertyValue.kind, propertyValue.propertyType);
            if (encodedTypeValue > -1) {
                var metaData = json[metadata];
                if (!metaData) {
                    metaData = json[metadata] = { f: {} };
                }
                var metaTarget = metaData[f];
                if (!metaTarget) {
                    metaTarget = metaData[f] = {};
                }
                if (propKeys) {
                    for (var lp = 0; lp < propKeys.length; lp++) {
                        var key = propKeys[lp];
                        if (!metaTarget[key]) {
                            metaTarget[key] = { f: {} };
                        }
                        var newTarget = metaTarget[key][f];
                        if (!newTarget) {
                            newTarget = metaTarget[key][f] = {};
                        }
                        metaTarget = newTarget;
                    }
                }
                metaTarget = metaTarget[name] = {};
                if (isArray(propertyValue.value)) {
                    metaTarget["a"] = {
                        t: encodedTypeValue
                    };
                }
                else {
                    metaTarget["t"] = encodedTypeValue;
                }
            }
        }
    }

    function createTimeoutWrapper(argSetTimeout, argClearTimeout) {
        return {
            set: function (callback, ms) {
                var args = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    args[_i - 2] = arguments[_i];
                }
                return scheduleTimeoutWith([argSetTimeout, argClearTimeout], callback, ms, args);
            }
        };
    }

    var _a;
    var strSendAttempt = "sendAttempt";
    var _noResponseQs = "&" + STR_NO_RESPONSE_BODY + "=true";
    var UrlQueryString = "?cors=true&" + STR_CONTENT_TYPE_HEADER[_DYN_TO_LOWER_CASE ]() + "=" + DEFAULT_CONTENT_TYPE;
    var _eventActionMap = (_a = {},
        _a[1 ] = STR_REQUEUE,
        _a[100 ] = STR_REQUEUE,
        _a[200 ] = "sent",
        _a[8004 ] = STR_DROPPED,
        _a[8003 ] = STR_DROPPED,
        _a);
    var _collectorQsHeaders = {};
    var _collectorHeaderToQs = {};
    function _addCollectorHeaderQsMapping(qsName, headerName, allowQs) {
        _collectorQsHeaders[qsName] = headerName;
        if (allowQs !== false) {
            _collectorHeaderToQs[headerName] = qsName;
        }
    }
    _addCollectorHeaderQsMapping(STR_MSA_DEVICE_TICKET, STR_MSA_DEVICE_TICKET, false);
    _addCollectorHeaderQsMapping(STR_CLIENT_VERSION, STR_CLIENT_VERSION);
    _addCollectorHeaderQsMapping(STR_CLIENT_ID, "Client-Id");
    _addCollectorHeaderQsMapping(STR_API_KEY, STR_API_KEY);
    _addCollectorHeaderQsMapping(STR_TIME_DELTA_TO_APPLY, STR_TIME_DELTA_TO_APPLY);
    _addCollectorHeaderQsMapping(STR_UPLOAD_TIME, STR_UPLOAD_TIME);
    _addCollectorHeaderQsMapping(STR_AUTH_XTOKEN, STR_AUTH_XTOKEN);
    function _hasHeader(headers, header) {
        var hasHeader = false;
        if (headers && header) {
            var keys = objKeys(headers);
            if (keys && keys[_DYN_LENGTH ] > 0) {
                var lowerHeader = header[_DYN_TO_LOWER_CASE ]();
                for (var lp = 0; lp < keys[_DYN_LENGTH ]; lp++) {
                    var value = keys[lp];
                    if (value && objHasOwnProperty(header, value) &&
                        value[_DYN_TO_LOWER_CASE ]() === lowerHeader) {
                        hasHeader = true;
                        break;
                    }
                }
            }
        }
        return hasHeader;
    }
    function _addRequestDetails(details, name, value, useHeaders) {
        if (name && value && value[_DYN_LENGTH ] > 0) {
            if (useHeaders && _collectorQsHeaders[name]) {
                details[_DYN_HDRS ][_collectorQsHeaders[name]] = value;
                details[_DYN_USE_HDRS ] = true;
            }
            else {
                details.url += "&" + name + "=" + value;
            }
        }
    }
    function _addQueryStringParameter(qsParams, name, value) {
        for (var i = 0; i < qsParams[_DYN_LENGTH ]; i++) {
            if (qsParams[i].name === name) {
                qsParams[i].value = value;
                return;
            }
        }
        qsParams[_DYN_PUSH ]({ name: name, value: value });
    }
    function _removeQueryStringParameter(qsParams, name) {
        for (var i = 0; i < qsParams[_DYN_LENGTH ]; i++) {
            if (qsParams[i].name === name) {
                qsParams[_DYN_SPLICE ](i, 1);
                return;
            }
        }
    }
    var HttpManager = /** @class */ (function () {
        function HttpManager(maxEventsPerBatch, maxConnections, maxRequestRetriesBeforeBackoff, actions) {
            var _urlString;
            var _killSwitch;
            var _paused;
            var _clockSkewManager;
            var _useBeacons = false;
            var _outstandingRequests;
            var _postManager;
            var _logger;
            var _sendInterfaces;
            var _core;
            var _customHttpInterface;
            var _queryStringParameters;
            var _headers;
            var _batchQueue;
            var _serializer;
            var _enableEventTimings;
            var _cookieMgr;
            var _isUnloading;
            var _useHeaders;
            var _xhrTimeout;
            var _disableXhrSync;
            var _disableFetchKeepAlive;
            var _canHaveReducedPayload;
            var _addNoResponse;
            var _unloadHooks;
            var _sendHook;
            var _sendListener;
            var _responseHandlers;
            var _isInitialized;
            var _timeoutWrapper;
            var _excludeCsMetaData;
            var _sendPostMgr;
            dynamicProto(HttpManager, this, function (_self) {
                _initDefaults();
                var _sendCredentials = true;
                _self[_DYN_INITIALIZE ] = function (theConfig, core, postChannel) {
                    if (!_isInitialized) {
                        _core = core;
                        _cookieMgr = core.getCookieMgr();
                        _postManager = postChannel;
                        _logger = _postManager.diagLog();
                        arrAppend(_unloadHooks, onConfigChange(theConfig, function (details) {
                            var _a;
                            var coreConfig = details.cfg;
                            var channelConfig = details.cfg.extensionConfig[postChannel.identifier];
                            _timeoutWrapper = createTimeoutWrapper(channelConfig[_DYN_SET_TIMEOUT_OVERRIDE ], channelConfig[_DYN_CLEAR_TIMEOUT_OVERRI3 ]);
                            if (isValueAssigned(coreConfig.anonCookieName)) {
                                _addQueryStringParameter(_queryStringParameters, "anoncknm", coreConfig.anonCookieName);
                            }
                            else {
                                _removeQueryStringParameter(_queryStringParameters, "anoncknm");
                            }
                            _sendHook = channelConfig[_DYN_PAYLOAD_PREPROCESSOR ];
                            _sendListener = channelConfig.payloadListener;
                            var httpInterface = channelConfig.httpXHROverride;
                            var endpointUrl = channelConfig[_DYN_OVERRIDE_ENDPOINT_UR4 ] ? channelConfig[_DYN_OVERRIDE_ENDPOINT_UR4 ] : coreConfig.endpointUrl;
                            _urlString = endpointUrl + UrlQueryString;
                            _useHeaders = !isUndefined(channelConfig[_DYN_AVOID_OPTIONS ]) ? !channelConfig[_DYN_AVOID_OPTIONS ] : true;
                            _enableEventTimings = !channelConfig[_DYN_DISABLE_EVENT_TIMING5 ];
                            var valueSanitizer = channelConfig.valueSanitizer;
                            var stringifyObjects = channelConfig[_DYN_STRINGIFY_OBJECTS ];
                            var enableCompoundKey = !!coreConfig[_DYN_ENABLE_COMPOUND_KEY ];
                            if (!isUndefined(channelConfig[_DYN_ENABLE_COMPOUND_KEY ])) {
                                enableCompoundKey = !!channelConfig[_DYN_ENABLE_COMPOUND_KEY ];
                            }
                            _xhrTimeout = channelConfig.xhrTimeout;
                            _disableXhrSync = !!channelConfig[_DYN_DISABLE_XHR_SYNC ];
                            _disableFetchKeepAlive = !!channelConfig[_DYN_DISABLE_FETCH_KEEP_A6 ];
                            _addNoResponse = channelConfig[_DYN_ADD_NO_RESPONSE ] !== false;
                            _excludeCsMetaData = !!channelConfig[_DYN_EXCLUDE_CS_META_DATA ];
                            if (!!core.getPlugin("LocalStorage")) {
                                _disableFetchKeepAlive = true;
                            }
                            _useBeacons = !isReactNative();
                            _serializer = new Serializer(_core, valueSanitizer, stringifyObjects, enableCompoundKey, getCommonSchemaMetaData, _excludeCsMetaData);
                            if (!isNullOrUndefined(channelConfig[_DYN_USE_SEND_BEACON ])) {
                                _useBeacons = !!channelConfig[_DYN_USE_SEND_BEACON ];
                            }
                            var sendPostConfig = _getSendPostMgrConfig();
                            if (!_sendPostMgr) {
                                _sendPostMgr = new SenderPostManager();
                                _sendPostMgr[_DYN_INITIALIZE ](sendPostConfig, _logger);
                            }
                            else {
                                _sendPostMgr.SetConfig(sendPostConfig);
                            }
                            var syncHttpInterface = httpInterface;
                            var beaconHttpInterface = channelConfig[_DYN_ALWAYS_USE_XHR_OVERR7 ] ? httpInterface : null;
                            var fetchSyncHttpInterface = channelConfig[_DYN_ALWAYS_USE_XHR_OVERR7 ] ? httpInterface : null;
                            var beaconUnloadTransports = [3 , 2 ];
                            if (!httpInterface) {
                                _customHttpInterface = false;
                                var theTransports = [];
                                if (isReactNative()) {
                                    theTransports = [2 , 1 ];
                                    beaconUnloadTransports = [2 , 1 , 3 ];
                                }
                                else {
                                    theTransports = [1 , 2 , 3 ];
                                }
                                theTransports = prependTransports(theTransports, channelConfig.transports);
                                httpInterface = _getSenderInterface(theTransports, false);
                                if (!httpInterface) {
                                    _warnToConsole(_logger, "No available transport to send events");
                                }
                                syncHttpInterface = _getSenderInterface(theTransports, true);
                            }
                            if (!beaconHttpInterface) {
                                beaconUnloadTransports = prependTransports(beaconUnloadTransports, channelConfig[_DYN_UNLOAD_TRANSPORTS ]);
                                beaconHttpInterface = _getSenderInterface(beaconUnloadTransports, true);
                            }
                            _canHaveReducedPayload = !_customHttpInterface && ((_useBeacons && isBeaconsSupported()) || (!_disableFetchKeepAlive && isFetchSupported(true)));
                            _sendInterfaces = (_a = {},
                                _a[0 ] = httpInterface,
                                _a[1 ] = syncHttpInterface || _getSenderInterface([1 , 2 , 3 ], true),
                                _a[2 ] = beaconHttpInterface || syncHttpInterface || _getSenderInterface([1 ], true),
                                _a[3 ] = fetchSyncHttpInterface || _getSenderInterface([2 , 3 ], true) || syncHttpInterface || _getSenderInterface([1 ], true),
                                _a);
                        }));
                        _isInitialized = true;
                    }
                };
                _self.addResponseHandler = function (responseHandler) {
                    _responseHandlers[_DYN_PUSH ](responseHandler);
                    return {
                        rm: function () {
                            var index = _responseHandlers.indexOf(responseHandler);
                            if (index >= 0) {
                                _responseHandlers[_DYN_SPLICE ](index, 1);
                            }
                        }
                    };
                };
                _self[_DYN_SERIALIZE_OFFLINE_EV8 ] = function (evt) {
                    try {
                        if (_serializer) {
                            return _serializer.getEventBlob(evt);
                        }
                    }
                    catch (e) {
                    }
                    return STR_EMPTY;
                };
                _self[_DYN_GET_OFFLINE_REQUEST_9 ] = function () {
                    try {
                        var payload = _serializer && _serializer[_DYN_CREATE_PAYLOAD ](0, false, false, false, 1 , 0 );
                        return _buildRequestDetails(payload, _useHeaders);
                    }
                    catch (e) {
                    }
                    return null;
                };
                _self[_DYN_CREATE_ONE_DSPAYLOAD ] = function (evts, optimize) {
                    try {
                        var theBatches_1 = [];
                        arrForEach(evts, function (evt) {
                            if (optimize) {
                                evt = optimizeObject(evt);
                            }
                            var batch = EventBatch.create(evt[_DYN_I_KEY ], [evt]);
                            theBatches_1[_DYN_PUSH ](batch);
                        });
                        var thePayload = null;
                        while (theBatches_1[_DYN_LENGTH ] > 0 && _serializer) {
                            var theBatch = theBatches_1.shift();
                            if (theBatch && theBatch[_DYN_COUNT ]() > 0) {
                                thePayload = thePayload || _serializer[_DYN_CREATE_PAYLOAD ](0, false, false, false, 1 , 0 );
                                _serializer.appendPayload(thePayload, theBatch, maxEventsPerBatch);
                            }
                        }
                        var requestDetails = _buildRequestDetails(thePayload, _useHeaders);
                        var payloadData = {
                            data: thePayload[_DYN_PAYLOAD_BLOB ],
                            urlString: requestDetails.url,
                            headers: requestDetails[_DYN_HDRS ],
                            timeout: _xhrTimeout,
                            disableXhrSync: _disableXhrSync,
                            disableFetchKeepAlive: _disableFetchKeepAlive
                        };
                        if (_useHeaders) {
                            if (!_hasHeader(payloadData[_DYN_HEADERS ], STR_CACHE_CONTROL)) {
                                payloadData[_DYN_HEADERS ][STR_CACHE_CONTROL] = DEFAULT_CACHE_CONTROL;
                            }
                            if (!_hasHeader(payloadData[_DYN_HEADERS ], STR_CONTENT_TYPE_HEADER)) {
                                payloadData[_DYN_HEADERS ][STR_CONTENT_TYPE_HEADER] = DEFAULT_CONTENT_TYPE;
                            }
                        }
                        return payloadData;
                    }
                    catch (e) {
                    }
                    return null;
                };
                function _getSenderInterface(transports, syncSupport) {
                    try {
                        return _sendPostMgr && _sendPostMgr.getSenderInst(transports, syncSupport);
                    }
                    catch (e) {
                    }
                    return null;
                }
                _self["_getDbgPlgTargets"] = function () {
                    return [_sendInterfaces[0 ], _killSwitch, _serializer, _sendInterfaces];
                };
                function _getSendPostMgrConfig() {
                    try {
                        var onCompleteFuncs = {
                            xdrOnComplete: _xdrOncomplete,
                            fetchOnComplete: _fetchOnComplete,
                            xhrOnComplete: _xhrOnComplete,
                            beaconOnRetry: _onBeaconRetry
                        };
                        var config = {
                            enableSendPromise: false,
                            isOneDs: true,
                            disableCredentials: !_sendCredentials,
                            disableXhr: false,
                            disableBeacon: !_useBeacons,
                            disableBeaconSync: !_useBeacons,
                            disableFetchKeepAlive: _disableFetchKeepAlive,
                            timeWrapper: _timeoutWrapper,
                            addNoResponse: _addNoResponse,
                            senderOnCompleteCallBack: onCompleteFuncs
                        };
                        return config;
                    }
                    catch (e) {
                    }
                    return null;
                }
                function _xdrOncomplete(xdr, oncomplete, payload) {
                    var response = getResponseText(xdr);
                    _doOnComplete(oncomplete, 200, {}, response);
                    _handleCollectorResponse(response);
                }
                function _initDefaults() {
                    var undefValue;
                    _urlString = null;
                    _killSwitch = new KillSwitch();
                    _paused = false;
                    _clockSkewManager = new ClockSkewManager();
                    _useBeacons = false;
                    _outstandingRequests = 0;
                    _postManager = null;
                    _logger = null;
                    _sendInterfaces = null;
                    _core = null;
                    _customHttpInterface = true;
                    _queryStringParameters = [];
                    _headers = {};
                    _batchQueue = [];
                    _serializer = null;
                    _enableEventTimings = false;
                    _cookieMgr = null;
                    _isUnloading = false;
                    _useHeaders = false;
                    _xhrTimeout = undefValue;
                    _disableXhrSync = undefValue;
                    _disableFetchKeepAlive = undefValue;
                    _canHaveReducedPayload = undefValue;
                    _addNoResponse = undefValue;
                    _unloadHooks = [];
                    _sendHook = undefValue;
                    _sendListener = undefValue;
                    _responseHandlers = [];
                    _isInitialized = false;
                    _timeoutWrapper = createTimeoutWrapper();
                    _excludeCsMetaData = false;
                    _sendPostMgr = null;
                }
                function _fetchOnComplete(response, onComplete, resValue, payload) {
                    var handleResponse = function (status, headerMap, responseText) {
                        _doOnComplete(onComplete, status, headerMap, responseText);
                        _handleCollectorResponse(responseText);
                    };
                    var headerMap = {};
                    var headers = response[_DYN_HEADERS ];
                    if (headers) {
                        headers["forEach"](function (value, name) {
                            headerMap[name] = value;
                        });
                    }
                    handleResponse(response.status, headerMap, resValue || STR_EMPTY);
                }
                function _xhrOnComplete(request, oncomplete, payload) {
                    var response = getResponseText(request);
                    _doOnComplete(oncomplete, request.status, _getAllResponseHeaders(request, true), response);
                    _handleCollectorResponse(response);
                }
                function _doOnComplete(oncomplete, status, headers, response) {
                    try {
                        oncomplete(status, headers, response);
                    }
                    catch (e) {
                        _throwInternal(_logger, 2 , 518 , dumpObj(e));
                    }
                }
                function _onBeaconRetry(payload, onComplete, canSend) {
                    var internalPayloadData = payload;
                    var status = 200;
                    var thePayload = internalPayloadData[_DYN__THE_PAYLOAD ];
                    var theUrl = payload[_DYN_URL_STRING ] + (_addNoResponse ? _noResponseQs : STR_EMPTY);
                    try {
                        var nav_1 = getNavigator();
                        if (thePayload) {
                            var persistStorage = !!_core.getPlugin("LocalStorage");
                            var droppedBatches_1 = [];
                            var sentBatches_1 = [];
                            arrForEach(thePayload[_DYN_BATCHES ], function (theBatch) {
                                if (droppedBatches_1 && theBatch && theBatch[_DYN_COUNT ]() > 0) {
                                    var theEvents = theBatch[_DYN_EVENTS ]();
                                    for (var lp = 0; lp < theEvents[_DYN_LENGTH ]; lp++) {
                                        if (!nav_1.sendBeacon(theUrl, _serializer.getEventBlob(theEvents[lp]))) {
                                            droppedBatches_1[_DYN_PUSH ](theBatch[_DYN_SPLIT ](lp));
                                            break;
                                        }
                                        else {
                                            sentBatches_1[_DYN_PUSH ](theBatch[lp]);
                                        }
                                    }
                                }
                                else {
                                    droppedBatches_1[_DYN_PUSH ](theBatch[_DYN_SPLIT ](0));
                                }
                            });
                            if (sentBatches_1[_DYN_LENGTH ] > 0) {
                                thePayload.sentEvts = sentBatches_1;
                            }
                            if (!persistStorage) {
                                _sendBatchesNotification(droppedBatches_1, 8003 , thePayload[_DYN_SEND_TYPE ], true);
                            }
                        }
                        else {
                            status = 0;
                        }
                    }
                    catch (ex) {
                        _warnToConsole(_logger, "Failed to send telemetry using sendBeacon API. Ex:" + dumpObj(ex));
                        status = 0;
                    }
                    finally {
                        _doOnComplete(onComplete, status, {}, STR_EMPTY);
                    }
                }
                function _isBeaconPayload(sendType) {
                    return sendType === 2  || sendType === 3 ;
                }
                function _adjustSendType(sendType) {
                    if (_isUnloading && _isBeaconPayload(sendType)) {
                        sendType = 2 ;
                    }
                    return sendType;
                }
                _self[_DYN_ADD_HEADER ] = function (name, value) {
                    _headers[name] = value;
                };
                _self.removeHeader = function (name) {
                    delete _headers[name];
                };
                _self[_DYN_CAN_SEND_REQUEST ] = function () {
                    return _hasIdleConnection() && _clockSkewManager[_DYN_ALLOW_REQUEST_SENDIN0 ]();
                };
                _self[_DYN_SEND_QUEUED_REQUESTS ] = function (sendType, sendReason) {
                    if (isUndefined(sendType)) {
                        sendType = 0 ;
                    }
                    if (_isUnloading) {
                        sendType = _adjustSendType(sendType);
                        sendReason = 2 ;
                    }
                    if (_canSendPayload(_batchQueue, sendType, 0)) {
                        _sendBatches(_clearQueue(), 0, false, sendType, sendReason || 0 );
                    }
                };
                _self[_DYN_IS_COMPLETELY_IDLE ] = function () {
                    return !_paused && _outstandingRequests === 0 && _batchQueue[_DYN_LENGTH ] === 0;
                };
                _self[_DYN_SET_UNLOADING ] = function (value) {
                    _isUnloading = value;
                };
                _self.addBatch = function (theBatch) {
                    if (theBatch && theBatch[_DYN_COUNT ]() > 0) {
                        if (_killSwitch.isTenantKilled(theBatch[_DYN_I_KEY ]())) {
                            return false;
                        }
                        _batchQueue[_DYN_PUSH ](theBatch);
                    }
                    return true;
                };
                _self.teardown = function () {
                    if (_batchQueue[_DYN_LENGTH ] > 0) {
                        _sendBatches(_clearQueue(), 0, true, 2 , 2 );
                    }
                    arrForEach(_unloadHooks, function (hook) {
                        hook && hook.rm && hook.rm();
                    });
                    _unloadHooks = [];
                };
                _self.pause = function () {
                    _paused = true;
                };
                _self.resume = function () {
                    _paused = false;
                    _self[_DYN_SEND_QUEUED_REQUESTS ](0 , 4 );
                };
                _self[_DYN_SEND_SYNCHRONOUS_BAT10 ] = function (batch, sendType, sendReason) {
                    if (batch && batch[_DYN_COUNT ]() > 0) {
                        if (isNullOrUndefined(sendType)) {
                            sendType = 1 ;
                        }
                        if (_isUnloading) {
                            sendType = _adjustSendType(sendType);
                            sendReason = 2 ;
                        }
                        _sendBatches([batch], 0, false, sendType, sendReason || 0 );
                    }
                };
                function _hasIdleConnection() {
                    return !_paused && _outstandingRequests < maxConnections;
                }
                function _clearQueue() {
                    var theQueue = _batchQueue;
                    _batchQueue = [];
                    return theQueue;
                }
                function _canSendPayload(theBatches, sendType, retryCnt) {
                    var result = false;
                    if (theBatches && theBatches[_DYN_LENGTH ] > 0 && !_paused && _sendInterfaces[sendType] && _serializer) {
                        result = (sendType !== 0 ) || (_hasIdleConnection() && (retryCnt > 0 || _clockSkewManager[_DYN_ALLOW_REQUEST_SENDIN0 ]()));
                    }
                    return result;
                }
                function _createDebugBatches(theBatches) {
                    var values = {};
                    if (theBatches) {
                        arrForEach(theBatches, function (theBatch, idx) {
                            values[idx] = {
                                iKey: theBatch[_DYN_I_KEY ](),
                                evts: theBatch[_DYN_EVENTS ]()
                            };
                        });
                    }
                    return values;
                }
                function _sendBatches(theBatches, retryCount, isTeardown, sendType, sendReason) {
                    if (!theBatches || theBatches[_DYN_LENGTH ] === 0) {
                        return;
                    }
                    if (_paused) {
                        _sendBatchesNotification(theBatches, 1 , sendType);
                        return;
                    }
                    sendType = _adjustSendType(sendType);
                    try {
                        var orgBatches_1 = theBatches;
                        var isSynchronous_1 = sendType !== 0 ;
                        doPerf(_core, function () { return "HttpManager:_sendBatches"; }, function (perfEvt) {
                            if (perfEvt) {
                                theBatches = theBatches.slice(0);
                            }
                            var droppedBatches = [];
                            var thePayload = null;
                            var serializationStart = getTime();
                            var sendInterface = _sendInterfaces[sendType] || (isSynchronous_1 ? _sendInterfaces[1 ] : _sendInterfaces[0 ]);
                            var sendTransport = sendInterface && sendInterface[_DYN__TRANSPORT ];
                            var isReducedPayload = _canHaveReducedPayload && (_isUnloading || _isBeaconPayload(sendType) || (sendTransport === 3  || (sendInterface._isSync && sendTransport === 2 )));
                            while (_canSendPayload(theBatches, sendType, retryCount)) {
                                var theBatch = theBatches.shift();
                                if (theBatch && theBatch[_DYN_COUNT ]() > 0) {
                                    if (!_killSwitch.isTenantKilled(theBatch[_DYN_I_KEY ]())) {
                                        thePayload = thePayload || _serializer[_DYN_CREATE_PAYLOAD ](retryCount, isTeardown, isSynchronous_1, isReducedPayload, sendReason, sendType);
                                        if (!_serializer.appendPayload(thePayload, theBatch, maxEventsPerBatch)) {
                                            _doPayloadSend(thePayload, serializationStart, getTime(), sendReason);
                                            serializationStart = getTime();
                                            theBatches = [theBatch][_DYN_CONCAT ](theBatches);
                                            thePayload = null;
                                        }
                                        else if (thePayload.overflow !== null) {
                                            theBatches = [thePayload.overflow][_DYN_CONCAT ](theBatches);
                                            thePayload.overflow = null;
                                            _doPayloadSend(thePayload, serializationStart, getTime(), sendReason);
                                            serializationStart = getTime();
                                            thePayload = null;
                                        }
                                    }
                                    else {
                                        droppedBatches[_DYN_PUSH ](theBatch);
                                    }
                                }
                            }
                            if (thePayload) {
                                _doPayloadSend(thePayload, serializationStart, getTime(), sendReason);
                            }
                            if (theBatches[_DYN_LENGTH ] > 0) {
                                _batchQueue = theBatches[_DYN_CONCAT ](_batchQueue);
                            }
                            _sendBatchesNotification(droppedBatches, 8004 , sendType);
                        }, function () { return ({ batches: _createDebugBatches(orgBatches_1), retryCount: retryCount, isTeardown: isTeardown, isSynchronous: isSynchronous_1, sendReason: sendReason, useSendBeacon: _isBeaconPayload(sendType), sendType: sendType }); }, !isSynchronous_1);
                    }
                    catch (ex) {
                        _throwInternal(_logger, 2 , 48 , "Unexpected Exception sending batch: " + dumpObj(ex));
                    }
                }
                function _buildRequestDetails(thePayload, useHeaders) {
                    var requestDetails = {
                        url: _urlString,
                        hdrs: {},
                        useHdrs: false
                    };
                    if (!useHeaders) {
                        objForEachKey(_headers, function (name, value) {
                            if (_collectorHeaderToQs[name]) {
                                _addRequestDetails(requestDetails, _collectorHeaderToQs[name], value, false);
                            }
                            else {
                                requestDetails[_DYN_HDRS ][name] = value;
                                requestDetails[_DYN_USE_HDRS ] = true;
                            }
                        });
                    }
                    else {
                        requestDetails[_DYN_HDRS ] = extend(requestDetails[_DYN_HDRS ], _headers);
                        requestDetails.useHdrs = (objKeys(requestDetails.hdrs)[_DYN_LENGTH ] > 0);
                    }
                    _addRequestDetails(requestDetails, STR_CLIENT_ID, "NO_AUTH", useHeaders);
                    _addRequestDetails(requestDetails, STR_CLIENT_VERSION, FullVersionString, useHeaders);
                    var apiQsKeys = STR_EMPTY;
                    arrForEach(thePayload.apiKeys, function (apiKey) {
                        if (apiQsKeys[_DYN_LENGTH ] > 0) {
                            apiQsKeys += ",";
                        }
                        apiQsKeys += apiKey;
                    });
                    _addRequestDetails(requestDetails, STR_API_KEY, apiQsKeys, useHeaders);
                    _addRequestDetails(requestDetails, STR_UPLOAD_TIME, utcNow().toString(), useHeaders);
                    var msfpc = _getMsfpc(thePayload);
                    if (isValueAssigned(msfpc)) {
                        requestDetails.url += "&ext.intweb.msfpc=" + msfpc;
                    }
                    if (_clockSkewManager[_DYN_SHOULD_ADD_CLOCK_SKE1 ]()) {
                        _addRequestDetails(requestDetails, STR_TIME_DELTA_TO_APPLY, _clockSkewManager[_DYN_GET_CLOCK_SKEW_HEADE2 ](), useHeaders);
                    }
                    if (_core[_DYN_GET_WPARAM ]) {
                        var wParam = _core[_DYN_GET_WPARAM ]();
                        if (wParam >= 0) {
                            requestDetails.url += "&w=" + wParam;
                        }
                    }
                    for (var i = 0; i < _queryStringParameters[_DYN_LENGTH ]; i++) {
                        requestDetails.url += "&" + _queryStringParameters[i].name + "=" + _queryStringParameters[i].value;
                    }
                    return requestDetails;
                }
                function _setTimingValue(timings, name, value) {
                    timings[name] = timings[name] || {};
                    timings[name][_postManager.identifier] = value;
                }
                function _doPayloadSend(thePayload, serializationStart, serializationCompleted, sendReason) {
                    if (thePayload && thePayload.payloadBlob && thePayload.payloadBlob[_DYN_LENGTH ] > 0) {
                        var useSendHook_1 = !!_sendHook;
                        var sendInterface_1 = _sendInterfaces[thePayload.sendType];
                        if (!_isBeaconPayload(thePayload[_DYN_SEND_TYPE ]) && thePayload[_DYN_IS_BEACON ] && thePayload.sendReason === 2 ) {
                            sendInterface_1 = _sendInterfaces[2 ] || _sendInterfaces[3 ] || sendInterface_1;
                        }
                        var useHeaders_1 = _useHeaders;
                        if (thePayload.isBeacon || sendInterface_1[_DYN__TRANSPORT ] === 3 ) {
                            useHeaders_1 = false;
                        }
                        var requestDetails_1 = _buildRequestDetails(thePayload, useHeaders_1);
                        useHeaders_1 = useHeaders_1 || requestDetails_1[_DYN_USE_HDRS ];
                        var sendEventStart_1 = getTime();
                        doPerf(_core, function () { return "HttpManager:_doPayloadSend"; }, function () {
                            for (var batchLp = 0; batchLp < thePayload.batches[_DYN_LENGTH ]; batchLp++) {
                                var theBatch = thePayload[_DYN_BATCHES ][batchLp];
                                var theEvents = theBatch[_DYN_EVENTS ]();
                                for (var evtLp = 0; evtLp < theEvents[_DYN_LENGTH ]; evtLp++) {
                                    var telemetryItem = theEvents[evtLp];
                                    if (_enableEventTimings) {
                                        var timings = telemetryItem[_DYN_TIMINGS ] = telemetryItem[_DYN_TIMINGS ] || {};
                                        _setTimingValue(timings, "sendEventStart", sendEventStart_1);
                                        _setTimingValue(timings, "serializationStart", serializationStart);
                                        _setTimingValue(timings, "serializationCompleted", serializationCompleted);
                                    }
                                    telemetryItem[strSendAttempt] > 0 ? telemetryItem[strSendAttempt]++ : telemetryItem[strSendAttempt] = 1;
                                }
                            }
                            _sendBatchesNotification(thePayload[_DYN_BATCHES ], (1000  + (sendReason || 0 )), thePayload[_DYN_SEND_TYPE ], true);
                            var orgPayloadData = {
                                data: thePayload[_DYN_PAYLOAD_BLOB ],
                                urlString: requestDetails_1.url,
                                headers: requestDetails_1[_DYN_HDRS ],
                                _thePayload: thePayload,
                                _sendReason: sendReason,
                                timeout: _xhrTimeout,
                                disableXhrSync: _disableXhrSync,
                                disableFetchKeepAlive: _disableFetchKeepAlive
                            };
                            if (useHeaders_1) {
                                if (!_hasHeader(orgPayloadData[_DYN_HEADERS ], STR_CACHE_CONTROL)) {
                                    orgPayloadData[_DYN_HEADERS ][STR_CACHE_CONTROL] = DEFAULT_CACHE_CONTROL;
                                }
                                if (!_hasHeader(orgPayloadData[_DYN_HEADERS ], STR_CONTENT_TYPE_HEADER)) {
                                    orgPayloadData[_DYN_HEADERS ][STR_CONTENT_TYPE_HEADER] = DEFAULT_CONTENT_TYPE;
                                }
                            }
                            var sender = null;
                            if (sendInterface_1) {
                                sender = function (payload) {
                                    _clockSkewManager[_DYN_FIRST_REQUEST_SENT ]();
                                    var onComplete = function (status, headers) {
                                        _retryRequestIfNeeded(status, headers, thePayload, sendReason);
                                    };
                                    var isSync = thePayload[_DYN_IS_TEARDOWN ] || thePayload[_DYN_IS_SYNC ];
                                    try {
                                        sendInterface_1.sendPOST(payload, onComplete, isSync);
                                        if (_sendListener) {
                                            _sendListener(orgPayloadData, payload, isSync, thePayload[_DYN_IS_BEACON ]);
                                        }
                                    }
                                    catch (ex) {
                                        _warnToConsole(_logger, "Unexpected exception sending payload. Ex:" + dumpObj(ex));
                                        _doOnComplete(onComplete, 0, {});
                                    }
                                };
                            }
                            doPerf(_core, function () { return "HttpManager:_doPayloadSend.sender"; }, function () {
                                if (sender) {
                                    if (thePayload[_DYN_SEND_TYPE ] === 0 ) {
                                        _outstandingRequests++;
                                    }
                                    if (useSendHook_1 && !thePayload.isBeacon && sendInterface_1[_DYN__TRANSPORT ] !== 3 ) {
                                        var hookData_1 = {
                                            data: orgPayloadData[_DYN_DATA ],
                                            urlString: orgPayloadData[_DYN_URL_STRING ],
                                            headers: extend({}, orgPayloadData[_DYN_HEADERS ]),
                                            timeout: orgPayloadData[_DYN_TIMEOUT ],
                                            disableXhrSync: orgPayloadData[_DYN_DISABLE_XHR_SYNC ],
                                            disableFetchKeepAlive: orgPayloadData[_DYN_DISABLE_FETCH_KEEP_A6 ]
                                        };
                                        var senderCalled_1 = false;
                                        doPerf(_core, function () { return "HttpManager:_doPayloadSend.sendHook"; }, function () {
                                            try {
                                                _sendHook(hookData_1, function (payload) {
                                                    senderCalled_1 = true;
                                                    if (!_customHttpInterface && !payload[_DYN__THE_PAYLOAD ]) {
                                                        payload[_DYN__THE_PAYLOAD ] = payload[_DYN__THE_PAYLOAD ] || orgPayloadData[_DYN__THE_PAYLOAD ];
                                                        payload[_DYN__SEND_REASON ] = payload[_DYN__SEND_REASON ] || orgPayloadData[_DYN__SEND_REASON ];
                                                    }
                                                    sender(payload);
                                                }, thePayload.isSync || thePayload[_DYN_IS_TEARDOWN ]);
                                            }
                                            catch (ex) {
                                                if (!senderCalled_1) {
                                                    sender(orgPayloadData);
                                                }
                                            }
                                        });
                                    }
                                    else {
                                        sender(orgPayloadData);
                                    }
                                }
                            });
                        }, function () { return ({ thePayload: thePayload, serializationStart: serializationStart, serializationCompleted: serializationCompleted, sendReason: sendReason }); }, thePayload[_DYN_IS_SYNC ]);
                    }
                    if (thePayload.sizeExceed && thePayload.sizeExceed[_DYN_LENGTH ] > 0) {
                        _sendBatchesNotification(thePayload.sizeExceed, 8003 , thePayload[_DYN_SEND_TYPE ]);
                    }
                    if (thePayload.failedEvts && thePayload.failedEvts[_DYN_LENGTH ] > 0) {
                        _sendBatchesNotification(thePayload.failedEvts, 8002 , thePayload[_DYN_SEND_TYPE ]);
                    }
                }
                function _addEventCompletedTimings(theEvents, sendEventCompleted) {
                    if (_enableEventTimings) {
                        arrForEach(theEvents, function (theEvent) {
                            var timings = theEvent[_DYN_TIMINGS ] = theEvent[_DYN_TIMINGS ] || {};
                            _setTimingValue(timings, "sendEventCompleted", sendEventCompleted);
                        });
                    }
                }
                function _retryRequestIfNeeded(status, headers, thePayload, sendReason) {
                    var reason = 9000 ;
                    var droppedBatches = null;
                    var isRetrying = false;
                    var backOffTrans = false;
                    try {
                        var shouldRetry = true;
                        if (typeof status !== strShimUndefined) {
                            if (headers) {
                                _clockSkewManager[_DYN_SET_CLOCK_SKEW ](headers[STR_TIME_DELTA_HEADER]);
                                var killDuration = headers[STR_KILL_DURATION_HEADER] || headers["kill-duration-seconds"];
                                arrForEach(_killSwitch[_DYN_SET_KILL_SWITCH_TENA11 ](headers[STR_KILL_TOKENS_HEADER], killDuration), function (killToken) {
                                    arrForEach(thePayload[_DYN_BATCHES ], function (theBatch) {
                                        if (theBatch[_DYN_I_KEY ]() === killToken) {
                                            droppedBatches = droppedBatches || [];
                                            var removedEvents = theBatch[_DYN_SPLIT ](0);
                                            thePayload.numEvents -= removedEvents[_DYN_COUNT ]();
                                            droppedBatches[_DYN_PUSH ](removedEvents);
                                        }
                                    });
                                });
                            }
                            if (status == 200 || status == 204) {
                                reason = 200 ;
                                return;
                            }
                            if (!retryPolicyShouldRetryForStatus(status) || thePayload.numEvents <= 0) {
                                shouldRetry = false;
                            }
                            reason = 9000  + (status % 1000);
                        }
                        if (shouldRetry) {
                            reason = 100 ;
                            var retryCount_1 = thePayload.retryCnt;
                            if (thePayload[_DYN_SEND_TYPE ] === 0 ) {
                                if (retryCount_1 < maxRequestRetriesBeforeBackoff) {
                                    isRetrying = true;
                                    _doAction(function () {
                                        if (thePayload[_DYN_SEND_TYPE ] === 0 ) {
                                            _outstandingRequests--;
                                        }
                                        _sendBatches(thePayload[_DYN_BATCHES ], retryCount_1 + 1, thePayload[_DYN_IS_TEARDOWN ], _isUnloading ? 2  : thePayload[_DYN_SEND_TYPE ], 5 );
                                    }, _isUnloading, retryPolicyGetMillisToBackoffForRetry(retryCount_1));
                                }
                                else {
                                    backOffTrans = true;
                                    if (_isUnloading) {
                                        reason = 8001 ;
                                    }
                                }
                            }
                        }
                    }
                    finally {
                        if (!isRetrying) {
                            _clockSkewManager[_DYN_SET_CLOCK_SKEW ]();
                            _handleRequestFinished(thePayload, reason, sendReason, backOffTrans);
                        }
                        _sendBatchesNotification(droppedBatches, 8004 , thePayload[_DYN_SEND_TYPE ]);
                    }
                }
                function _handleRequestFinished(thePayload, batchReason, sendReason, backOffTrans) {
                    try {
                        if (backOffTrans) {
                            _postManager[_DYN__BACK_OFF_TRANSMISSI12 ]();
                        }
                        var theBatches = thePayload[_DYN_BATCHES ];
                        if (batchReason === 200 ) {
                            theBatches = thePayload.sentEvts || thePayload[_DYN_BATCHES ];
                            if (!backOffTrans && !thePayload[_DYN_IS_SYNC ]) {
                                _postManager._clearBackOff();
                            }
                            _addCompleteTimings(theBatches);
                        }
                        _sendBatchesNotification(theBatches, batchReason, thePayload[_DYN_SEND_TYPE ], true);
                    }
                    finally {
                        if (thePayload[_DYN_SEND_TYPE ] === 0 ) {
                            _outstandingRequests--;
                            if (sendReason !== 5 ) {
                                _self.sendQueuedRequests(thePayload[_DYN_SEND_TYPE ], sendReason);
                            }
                        }
                    }
                }
                function _addCompleteTimings(theBatches) {
                    if (_enableEventTimings) {
                        var sendEventCompleted_1 = getTime();
                        arrForEach(theBatches, function (theBatch) {
                            if (theBatch && theBatch[_DYN_COUNT ]() > 0) {
                                _addEventCompletedTimings(theBatch[_DYN_EVENTS ](), sendEventCompleted_1);
                            }
                        });
                    }
                }
                function _doAction(cb, isSync, interval) {
                    if (isSync) {
                        cb();
                    }
                    else {
                        _timeoutWrapper.set(cb, interval);
                    }
                }
                function _getMsfpc(thePayload) {
                    for (var lp = 0; lp < thePayload.batches[_DYN_LENGTH ]; lp++) {
                        var msfpc = thePayload[_DYN_BATCHES ][lp].Msfpc();
                        if (msfpc) {
                            return encodeURIComponent(msfpc);
                        }
                    }
                    return STR_EMPTY;
                }
                function _handleCollectorResponse(responseText) {
                    var responseHandlers = _responseHandlers;
                    try {
                        for (var i = 0; i < responseHandlers[_DYN_LENGTH ]; i++) {
                            try {
                                responseHandlers[i](responseText);
                            }
                            catch (e) {
                                _throwInternal(_logger, 1 , 519 , "Response handler failed: " + e);
                            }
                        }
                        if (responseText) {
                            var response = JSON.parse(responseText);
                            if (isValueAssigned(response.webResult) && isValueAssigned(response.webResult[STR_MSFPC])) {
                                _cookieMgr.set("MSFPC", response.webResult[STR_MSFPC], 365 * 86400);
                            }
                        }
                    }
                    catch (ex) {
                    }
                }
                function _sendBatchesNotification(theBatches, batchReason, sendType, sendSync) {
                    if (theBatches && theBatches[_DYN_LENGTH ] > 0 && actions) {
                        var theAction_1 = actions[_getNotificationAction(batchReason)];
                        if (theAction_1) {
                            var isSyncRequest_1 = sendType !== 0 ;
                            doPerf(_core, function () { return "HttpManager:_sendBatchesNotification"; }, function () {
                                _doAction(function () {
                                    try {
                                        theAction_1.call(actions, theBatches, batchReason, isSyncRequest_1, sendType);
                                    }
                                    catch (e) {
                                        _throwInternal(_logger, 1 , 74 , "send request notification failed: " + e);
                                    }
                                }, sendSync || isSyncRequest_1, 0);
                            }, function () { return ({ batches: _createDebugBatches(theBatches), reason: batchReason, isSync: isSyncRequest_1, sendSync: sendSync, sendType: sendType }); }, !isSyncRequest_1);
                        }
                    }
                }
                function _getNotificationAction(reason) {
                    var action = _eventActionMap[reason];
                    if (!isValueAssigned(action)) {
                        action = STR_OTHER;
                        if (reason >= 9000  && reason <= 9999 ) {
                            action = STR_RESPONSE_FAIL;
                        }
                        else if (reason >= 8000  && reason <= 8999 ) {
                            action = STR_DROPPED;
                        }
                        else if (reason >= 1000  && reason <= 1999 ) {
                            action = STR_SENDING;
                        }
                    }
                    return action;
                }
            });
        }
        HttpManager.__ieDyn=1;
        return HttpManager;
    }());

    var FlushCheckTimer = 0.250;
    var MaxNumberEventPerBatch = 500;
    var EventsDroppedAtOneTime = 20;
    var MaxSendAttempts = 6;
    var MaxSyncUnloadSendAttempts = 2;
    var MaxBackoffCount = 4;
    var MaxConnections = 2;
    var MaxRequestRetriesBeforeBackoff = 1;
    var MaxEventsLimitInMem = 10000;
    var strEventsDiscarded = "eventsDiscarded";
    var EMPTY_STR = "";
    var undefValue = undefined;
    var defaultPostChannelConfig = objDeepFreeze({
        eventsLimitInMem: { isVal: isGreaterThanZero, v: MaxEventsLimitInMem },
        immediateEventLimit: { isVal: isGreaterThanZero, v: 500 },
        autoFlushEventsLimit: { isVal: isGreaterThanZero, v: 0 },
        disableAutoBatchFlushLimit: false,
        httpXHROverride: { isVal: isOverrideFn, v: undefValue },
        overrideInstrumentationKey: undefValue,
        overrideEndpointUrl: undefValue,
        disableTelemetry: false,
        ignoreMc1Ms0CookieProcessing: false,
        setTimeoutOverride: undefValue,
        clearTimeoutOverride: undefValue,
        payloadPreprocessor: undefValue,
        payloadListener: undefValue,
        disableEventTimings: undefValue,
        valueSanitizer: undefValue,
        stringifyObjects: undefValue,
        enableCompoundKey: undefValue,
        disableOptimizeObj: false,
        transports: undefValue,
        unloadTransports: undefValue,
        useSendBeacon: undefValue,
        disableFetchKeepAlive: undefValue,
        avoidOptions: false,
        xhrTimeout: undefValue,
        disableXhrSync: undefValue,
        alwaysUseXhrOverride: false,
        maxEventRetryAttempts: { isVal: isNumber, v: MaxSendAttempts },
        maxUnloadEventRetryAttempts: { isVal: isNumber, v: MaxSyncUnloadSendAttempts },
        addNoResponse: undefValue,
        excludeCsMetaData: undefValue
    });
    function isOverrideFn(httpXHROverride) {
        return httpXHROverride && httpXHROverride.sendPOST;
    }
    var PostChannel = /** @class */ (function (_super) {
        __extendsFn(PostChannel, _super);
        function PostChannel() {
            var _this = _super.call(this) || this;
            _this.identifier = "PostChannel";
            _this.priority = 1011;
            _this.version = '4.2.2';
            var _postConfig;
            var _isTeardownCalled = false;
            var _flushCallbackQueue = [];
            var _flushCallbackTimer;
            var _paused = false;
            var _immediateQueueSize = 0;
            var _immediateQueueSizeLimit;
            var _queueSize = 0;
            var _queueSizeLimit;
            var _profiles = {};
            var _currentProfile = RT_PROFILE;
            var _scheduledTimer;
            var _immediateTimer;
            var _currentBackoffCount;
            var _timerCount;
            var _httpManager;
            var _batchQueues;
            var _autoFlushEventsLimit;
            var _autoFlushBatchLimit;
            var _delayedBatchSendLatency;
            var _delayedBatchReason;
            var _optimizeObject;
            var _isPageUnloadTriggered;
            var _maxEventSendAttempts;
            var _maxUnloadEventSendAttempts;
            var _evtNamespace;
            var _timeoutWrapper;
            var _ignoreMc1Ms0CookieProcessing;
            var _disableAutoBatchFlushLimit;
            var _notificationManager;
            var _unloadHandlersAdded;
            var _overrideInstrumentationKey;
            var _disableTelemetry;
            dynamicProto(PostChannel, _this, function (_self, _base) {
                _initDefaults();
                _self["_getDbgPlgTargets"] = function () {
                    return [_httpManager, _postConfig];
                };
                _self[_DYN_INITIALIZE ] = function (theConfig, core, extensions) {
                    doPerf(core, function () { return "PostChannel:initialize"; }, function () {
                        _base[_DYN_INITIALIZE ](theConfig, core, extensions);
                        _notificationManager = core.getNotifyMgr();
                        try {
                            _evtNamespace = mergeEvtNamespace(createUniqueNamespace(_self[_DYN_IDENTIFIER ]), core.evtNamespace && core.evtNamespace());
                            _self._addHook(onConfigChange(theConfig, function (details) {
                                var coreConfig = details.cfg;
                                var ctx = createProcessTelemetryContext(null, coreConfig, core);
                                _postConfig = ctx.getExtCfg(_self[_DYN_IDENTIFIER ], defaultPostChannelConfig);
                                _timeoutWrapper = createTimeoutWrapper(_postConfig[_DYN_SET_TIMEOUT_OVERRIDE ], _postConfig[_DYN_CLEAR_TIMEOUT_OVERRI3 ]);
                                _optimizeObject = !_postConfig[_DYN_DISABLE_OPTIMIZE_OBJ ] && isChromium();
                                _ignoreMc1Ms0CookieProcessing = _postConfig[_DYN_IGNORE_MC1_MS0_COOKI13 ];
                                _hookWParam(core);
                                _queueSizeLimit = _postConfig[_DYN_EVENTS_LIMIT_IN_MEM ];
                                _immediateQueueSizeLimit = _postConfig.immediateEventLimit;
                                _autoFlushEventsLimit = _postConfig[_DYN_AUTO_FLUSH_EVENTS_LI14 ];
                                _maxEventSendAttempts = _postConfig.maxEventRetryAttempts;
                                _maxUnloadEventSendAttempts = _postConfig.maxUnloadEventRetryAttempts;
                                _disableAutoBatchFlushLimit = _postConfig[_DYN_DISABLE_AUTO_BATCH_F15 ];
                                _setAutoLimits();
                                _overrideInstrumentationKey = _postConfig[_DYN_OVERRIDE_INSTRUMENTA16 ];
                                _disableTelemetry = !!_postConfig[_DYN_DISABLE_TELEMETRY ];
                                if (_unloadHandlersAdded) {
                                    _removeUnloadHandlers();
                                }
                                var excludePageUnloadEvents = coreConfig.disablePageUnloadEvents || [];
                                _unloadHandlersAdded = addPageUnloadEventListener(_handleUnloadEvents, excludePageUnloadEvents, _evtNamespace);
                                _unloadHandlersAdded = addPageHideEventListener(_handleUnloadEvents, excludePageUnloadEvents, _evtNamespace) || _unloadHandlersAdded;
                                _unloadHandlersAdded = addPageShowEventListener(_handleShowEvents, coreConfig.disablePageShowEvents, _evtNamespace) || _unloadHandlersAdded;
                            }));
                            _httpManager[_DYN_INITIALIZE ](theConfig, _self.core, _self);
                        }
                        catch (e) {
                            _self.setInitialized(false);
                            throw e;
                        }
                    }, function () { return ({ theConfig: theConfig, core: core, extensions: extensions }); });
                };
                _self.processTelemetry = function (ev, itemCtx) {
                    setProcessTelemetryTimings(ev, _self[_DYN_IDENTIFIER ]);
                    itemCtx = itemCtx || _self._getTelCtx(itemCtx);
                    var event = ev;
                    if (!_disableTelemetry && !_isTeardownCalled) {
                        if (_overrideInstrumentationKey) {
                            event[_DYN_I_KEY ] = _overrideInstrumentationKey;
                        }
                        _addEventToQueues(event, true);
                        if (_isPageUnloadTriggered) {
                            _releaseAllQueues(2 , 2 );
                        }
                        else {
                            _scheduleTimer();
                        }
                    }
                    _self.processNext(event, itemCtx);
                };
                _self.getOfflineSupport = function () {
                    try {
                        var details_1 = _httpManager && _httpManager[_DYN_GET_OFFLINE_REQUEST_9 ]();
                        if (_httpManager) {
                            return {
                                getUrl: function () {
                                    if (details_1) {
                                        return details_1.url;
                                    }
                                    return null;
                                },
                                serialize: _serialize,
                                batch: _batch,
                                shouldProcess: function (evt) {
                                    return !_disableTelemetry;
                                },
                                createPayload: function (evt) {
                                    return null;
                                },
                                createOneDSPayload: function (evts) {
                                    if (_httpManager[_DYN_CREATE_ONE_DSPAYLOAD ]) {
                                        return _httpManager[_DYN_CREATE_ONE_DSPAYLOAD ](evts, _optimizeObject);
                                    }
                                }
                            };
                        }
                    }
                    catch (e) {
                    }
                    return null;
                };
                _self._doTeardown = function (unloadCtx, unloadState) {
                    _releaseAllQueues(2 , 2 );
                    _isTeardownCalled = true;
                    _httpManager.teardown();
                    _removeUnloadHandlers();
                    _initDefaults();
                };
                function _removeUnloadHandlers() {
                    removePageUnloadEventListener(null, _evtNamespace);
                    removePageHideEventListener(null, _evtNamespace);
                    removePageShowEventListener(null, _evtNamespace);
                }
                function _hookWParam(core) {
                    var existingGetWParamMethod = core[_DYN_GET_WPARAM ];
                    core[_DYN_GET_WPARAM ] = function () {
                        var wparam = 0;
                        if (_ignoreMc1Ms0CookieProcessing) {
                            wparam = wparam | 2;
                        }
                        return wparam | existingGetWParamMethod.call(core);
                    };
                }
                function _batch(arr) {
                    var rlt = EMPTY_STR;
                    if (arr && arr[_DYN_LENGTH ]) {
                        arrForEach(arr, function (item) {
                            if (rlt) {
                                rlt += "\n";
                            }
                            rlt += item;
                        });
                    }
                    return rlt;
                }
                function _serialize(event) {
                    var rlt = EMPTY_STR;
                    try {
                        _cleanEvent(event);
                        rlt = _httpManager[_DYN_SERIALIZE_OFFLINE_EV8 ](event);
                    }
                    catch (e) {
                    }
                    return rlt;
                }
                function _handleUnloadEvents(evt) {
                    var theEvt = evt || getWindow().event;
                    if (theEvt.type !== "beforeunload") {
                        _isPageUnloadTriggered = true;
                        _httpManager[_DYN_SET_UNLOADING ](_isPageUnloadTriggered);
                    }
                    _releaseAllQueues(2 , 2 );
                }
                function _handleShowEvents(evt) {
                    _isPageUnloadTriggered = false;
                    _httpManager[_DYN_SET_UNLOADING ](_isPageUnloadTriggered);
                }
                function _cleanEvent(event) {
                    if (event.ext && event.ext[STR_TRACE]) {
                        delete (event.ext[STR_TRACE]);
                    }
                    if (event.ext && event.ext[STR_USER] && event.ext[STR_USER]["id"]) {
                        delete (event.ext[STR_USER]["id"]);
                    }
                    if (_optimizeObject) {
                        event.ext = optimizeObject(event.ext);
                        if (event[_DYN_BASE_DATA ]) {
                            event[_DYN_BASE_DATA ] = optimizeObject(event[_DYN_BASE_DATA ]);
                        }
                        if (event[_DYN_DATA ]) {
                            event[_DYN_DATA ] = optimizeObject(event[_DYN_DATA ]);
                        }
                    }
                }
                function _addEventToQueues(event, append) {
                    if (!event[_DYN_SEND_ATTEMPT ]) {
                        event[_DYN_SEND_ATTEMPT ] = 0;
                    }
                    if (!event[_DYN_LATENCY ]) {
                        event[_DYN_LATENCY ] = 1 ;
                    }
                    _cleanEvent(event);
                    if (event[_DYN_SYNC ]) {
                        if (_currentBackoffCount || _paused) {
                            event[_DYN_LATENCY ] = 3 ;
                            event[_DYN_SYNC ] = false;
                        }
                        else {
                            if (_httpManager) {
                                if (_optimizeObject) {
                                    event = optimizeObject(event);
                                }
                                _httpManager[_DYN_SEND_SYNCHRONOUS_BAT10 ](EventBatch.create(event[_DYN_I_KEY ], [event]), event[_DYN_SYNC ] === true ? 1  : event[_DYN_SYNC ], 3 );
                                return;
                            }
                        }
                    }
                    var evtLatency = event[_DYN_LATENCY ];
                    var queueSize = _queueSize;
                    var queueLimit = _queueSizeLimit;
                    if (evtLatency === 4 ) {
                        queueSize = _immediateQueueSize;
                        queueLimit = _immediateQueueSizeLimit;
                    }
                    var eventDropped = false;
                    if (queueSize < queueLimit) {
                        eventDropped = !_addEventToProperQueue(event, append);
                    }
                    else {
                        var dropLatency = 1 ;
                        var dropNumber = EventsDroppedAtOneTime;
                        if (evtLatency === 4 ) {
                            dropLatency = 4 ;
                            dropNumber = 1;
                        }
                        eventDropped = true;
                        if (_dropEventWithLatencyOrLess(event[_DYN_I_KEY ], event[_DYN_LATENCY ], dropLatency, dropNumber)) {
                            eventDropped = !_addEventToProperQueue(event, append);
                        }
                    }
                    if (eventDropped) {
                        _notifyEvents(strEventsDiscarded, [event], EventsDiscardedReason.QueueFull);
                    }
                }
                _self.setEventQueueLimits = function (eventLimit, autoFlushLimit) {
                    _postConfig[_DYN_EVENTS_LIMIT_IN_MEM ] = _queueSizeLimit = isGreaterThanZero(eventLimit) ? eventLimit : MaxEventsLimitInMem;
                    _postConfig[_DYN_AUTO_FLUSH_EVENTS_LI14 ] = _autoFlushEventsLimit = isGreaterThanZero(autoFlushLimit) ? autoFlushLimit : 0;
                    _setAutoLimits();
                    var doFlush = _queueSize > eventLimit;
                    if (!doFlush && _autoFlushBatchLimit > 0) {
                        for (var latency = 1 ; !doFlush && latency <= 3 ; latency++) {
                            var batchQueue = _batchQueues[latency];
                            if (batchQueue && batchQueue[_DYN_BATCHES ]) {
                                arrForEach(batchQueue[_DYN_BATCHES ], function (theBatch) {
                                    if (theBatch && theBatch[_DYN_COUNT ]() >= _autoFlushBatchLimit) {
                                        doFlush = true;
                                    }
                                });
                            }
                        }
                    }
                    _performAutoFlush(true, doFlush);
                };
                _self.pause = function () {
                    _clearScheduledTimer();
                    _paused = true;
                    _httpManager.pause();
                };
                _self.resume = function () {
                    _paused = false;
                    _httpManager.resume();
                    _scheduleTimer();
                };
                _self._loadTransmitProfiles = function (profiles) {
                    _resetTransmitProfiles();
                    objForEachKey(profiles, function (profileName, profileValue) {
                        var profLen = profileValue[_DYN_LENGTH ];
                        if (profLen >= 2) {
                            var directValue = (profLen > 2 ? profileValue[2] : 0);
                            profileValue[_DYN_SPLICE ](0, profLen - 2);
                            if (profileValue[1] < 0) {
                                profileValue[0] = -1;
                            }
                            if (profileValue[1] > 0 && profileValue[0] > 0) {
                                var timerMultiplier = profileValue[0] / profileValue[1];
                                profileValue[0] = Math.ceil(timerMultiplier) * profileValue[1];
                            }
                            if (directValue >= 0 && profileValue[1] >= 0 && directValue > profileValue[1]) {
                                directValue = profileValue[1];
                            }
                            profileValue[_DYN_PUSH ](directValue);
                            _profiles[profileName] = profileValue;
                        }
                    });
                };
                _self.flush = function (async, callback, sendReason) {
                    if (async === void 0) { async = true; }
                    var result;
                    if (!_paused) {
                        sendReason = sendReason || 1 ;
                        if (async) {
                            if (!callback) {
                                result = createPromise(function (resolve) {
                                    callback = resolve;
                                });
                            }
                            if (_flushCallbackTimer == null) {
                                _clearScheduledTimer();
                                _queueBatches(1 , 0 , sendReason);
                                _flushCallbackTimer = _createTimer(function () {
                                    _flushCallbackTimer = null;
                                    _flushImpl(callback, sendReason);
                                }, 0);
                            }
                            else {
                                _flushCallbackQueue[_DYN_PUSH ](callback);
                            }
                        }
                        else {
                            var cleared = _clearScheduledTimer();
                            _sendEventsForLatencyAndAbove(1 , 1 , sendReason);
                            callback && callback();
                            if (cleared) {
                                _scheduleTimer();
                            }
                        }
                    }
                    return result;
                };
                _self.setMsaAuthTicket = function (ticket) {
                    _httpManager[_DYN_ADD_HEADER ](STR_MSA_DEVICE_TICKET, ticket);
                };
                _self.setAuthPluginHeader = function (token) {
                    _httpManager[_DYN_ADD_HEADER ](STR_AUTH_WEB_TOKEN, token);
                };
                _self.removeAuthPluginHeader = function () {
                    _httpManager.removeHeader(STR_AUTH_WEB_TOKEN);
                };
                _self.hasEvents = _hasEvents;
                _self._setTransmitProfile = function (profileName) {
                    if (_currentProfile !== profileName && _profiles[profileName] !== undefined) {
                        _clearScheduledTimer();
                        _currentProfile = profileName;
                        _scheduleTimer();
                    }
                };
                proxyFunctions(_self, function () { return _httpManager; }, ["addResponseHandler"]);
                function _sendEventsForLatencyAndAbove(latency, sendType, sendReason) {
                    var queued = _queueBatches(latency, sendType, sendReason);
                    _httpManager[_DYN_SEND_QUEUED_REQUESTS ](sendType, sendReason);
                    return queued;
                }
                function _hasEvents() {
                    return _queueSize > 0;
                }
                function _scheduleTimer() {
                    if (_delayedBatchSendLatency >= 0 && _queueBatches(_delayedBatchSendLatency, 0 , _delayedBatchReason)) {
                        _httpManager[_DYN_SEND_QUEUED_REQUESTS ](0 , _delayedBatchReason);
                    }
                    if (_immediateQueueSize > 0 && !_immediateTimer && !_paused) {
                        var immediateTimeOut = _profiles[_currentProfile][2];
                        if (immediateTimeOut >= 0) {
                            _immediateTimer = _createTimer(function () {
                                _immediateTimer = null;
                                _sendEventsForLatencyAndAbove(4 , 0 , 1 );
                                _scheduleTimer();
                            }, immediateTimeOut);
                        }
                    }
                    var timeOut = _profiles[_currentProfile][1];
                    if (!_scheduledTimer && !_flushCallbackTimer && timeOut >= 0 && !_paused) {
                        if (_hasEvents()) {
                            _scheduledTimer = _createTimer(function () {
                                _scheduledTimer = null;
                                _sendEventsForLatencyAndAbove(_timerCount === 0 ? 3  : 1 , 0 , 1 );
                                _timerCount++;
                                _timerCount %= 2;
                                _scheduleTimer();
                            }, timeOut);
                        }
                        else {
                            _timerCount = 0;
                        }
                    }
                }
                _self[_DYN__BACK_OFF_TRANSMISSI12 ] = function () {
                    if (_currentBackoffCount < MaxBackoffCount) {
                        _currentBackoffCount++;
                        _clearScheduledTimer();
                        _scheduleTimer();
                    }
                };
                _self._clearBackOff = function () {
                    if (_currentBackoffCount) {
                        _currentBackoffCount = 0;
                        _clearScheduledTimer();
                        _scheduleTimer();
                    }
                };
                function _initDefaults() {
                    _postConfig = null;
                    _isTeardownCalled = false;
                    _flushCallbackQueue = [];
                    _flushCallbackTimer = null;
                    _paused = false;
                    _immediateQueueSize = 0;
                    _immediateQueueSizeLimit = 500;
                    _queueSize = 0;
                    _queueSizeLimit = MaxEventsLimitInMem;
                    _profiles = {};
                    _currentProfile = RT_PROFILE;
                    _scheduledTimer = null;
                    _immediateTimer = null;
                    _currentBackoffCount = 0;
                    _timerCount = 0;
                    _batchQueues = {};
                    _autoFlushEventsLimit = 0;
                    _unloadHandlersAdded = false;
                    _autoFlushBatchLimit = 0;
                    _delayedBatchSendLatency = -1;
                    _delayedBatchReason = null;
                    _optimizeObject = true;
                    _isPageUnloadTriggered = false;
                    _maxEventSendAttempts = MaxSendAttempts;
                    _maxUnloadEventSendAttempts = MaxSyncUnloadSendAttempts;
                    _evtNamespace = null;
                    _overrideInstrumentationKey = null;
                    _disableTelemetry = false;
                    _timeoutWrapper = createTimeoutWrapper();
                    _httpManager = new HttpManager(MaxNumberEventPerBatch, MaxConnections, MaxRequestRetriesBeforeBackoff, {
                        requeue: _requeueEvents,
                        send: _sendingEvent,
                        sent: _eventsSentEvent,
                        drop: _eventsDropped,
                        rspFail: _eventsResponseFail,
                        oth: _otherEvent
                    });
                    _initializeProfiles();
                    _clearQueues();
                    _setAutoLimits();
                }
                function _createTimer(theTimerFunc, timeOut) {
                    if (timeOut === 0 && _currentBackoffCount) {
                        timeOut = 1;
                    }
                    var timerMultiplier = 1000;
                    if (_currentBackoffCount) {
                        timerMultiplier = retryPolicyGetMillisToBackoffForRetry(_currentBackoffCount - 1);
                    }
                    return _timeoutWrapper.set(theTimerFunc, timeOut * timerMultiplier);
                }
                function _clearScheduledTimer() {
                    if (_scheduledTimer !== null) {
                        _scheduledTimer.cancel();
                        _scheduledTimer = null;
                        _timerCount = 0;
                        return true;
                    }
                    return false;
                }
                function _releaseAllQueues(sendType, sendReason) {
                    _clearScheduledTimer();
                    if (_flushCallbackTimer) {
                        _flushCallbackTimer.cancel();
                        _flushCallbackTimer = null;
                    }
                    if (!_paused) {
                        _sendEventsForLatencyAndAbove(1 , sendType, sendReason);
                    }
                }
                function _clearQueues() {
                    _batchQueues[4 ] = {
                        batches: [],
                        iKeyMap: {}
                    };
                    _batchQueues[3 ] = {
                        batches: [],
                        iKeyMap: {}
                    };
                    _batchQueues[2 ] = {
                        batches: [],
                        iKeyMap: {}
                    };
                    _batchQueues[1 ] = {
                        batches: [],
                        iKeyMap: {}
                    };
                }
                function _getEventBatch(iKey, latency, create) {
                    var batchQueue = _batchQueues[latency];
                    if (!batchQueue) {
                        latency = 1 ;
                        batchQueue = _batchQueues[latency];
                    }
                    var eventBatch = batchQueue.iKeyMap[iKey];
                    if (!eventBatch && create) {
                        eventBatch = EventBatch.create(iKey);
                        batchQueue.batches[_DYN_PUSH ](eventBatch);
                        batchQueue.iKeyMap[iKey] = eventBatch;
                    }
                    return eventBatch;
                }
                function _performAutoFlush(isAsync, doFlush) {
                    if (_httpManager[_DYN_CAN_SEND_REQUEST ]() && !_currentBackoffCount) {
                        if (_autoFlushEventsLimit > 0 && _queueSize > _autoFlushEventsLimit) {
                            doFlush = true;
                        }
                        if (doFlush && _flushCallbackTimer == null) {
                            _self.flush(isAsync, function () { }, 20 );
                        }
                    }
                }
                function _addEventToProperQueue(event, append) {
                    if (_optimizeObject) {
                        event = optimizeObject(event);
                    }
                    var latency = event[_DYN_LATENCY ];
                    var eventBatch = _getEventBatch(event[_DYN_I_KEY ], latency, true);
                    if (eventBatch.addEvent(event)) {
                        if (latency !== 4 ) {
                            _queueSize++;
                            if (append && event[_DYN_SEND_ATTEMPT ] === 0) {
                                _performAutoFlush(!event.sync, _autoFlushBatchLimit > 0 && eventBatch[_DYN_COUNT ]() >= _autoFlushBatchLimit);
                            }
                        }
                        else {
                            _immediateQueueSize++;
                        }
                        return true;
                    }
                    return false;
                }
                function _dropEventWithLatencyOrLess(iKey, latency, currentLatency, dropNumber) {
                    while (currentLatency <= latency) {
                        var eventBatch = _getEventBatch(iKey, latency, true);
                        if (eventBatch && eventBatch[_DYN_COUNT ]() > 0) {
                            var droppedEvents = eventBatch[_DYN_SPLIT ](0, dropNumber);
                            var droppedCount = droppedEvents[_DYN_COUNT ]();
                            if (droppedCount > 0) {
                                if (currentLatency === 4 ) {
                                    _immediateQueueSize -= droppedCount;
                                }
                                else {
                                    _queueSize -= droppedCount;
                                }
                                _notifyBatchEvents(strEventsDiscarded, [droppedEvents], EventsDiscardedReason.QueueFull);
                                return true;
                            }
                        }
                        currentLatency++;
                    }
                    _resetQueueCounts();
                    return false;
                }
                function _resetQueueCounts() {
                    var immediateQueue = 0;
                    var normalQueue = 0;
                    var _loop_1 = function (latency) {
                        var batchQueue = _batchQueues[latency];
                        if (batchQueue && batchQueue[_DYN_BATCHES ]) {
                            arrForEach(batchQueue[_DYN_BATCHES ], function (theBatch) {
                                if (latency === 4 ) {
                                    immediateQueue += theBatch[_DYN_COUNT ]();
                                }
                                else {
                                    normalQueue += theBatch[_DYN_COUNT ]();
                                }
                            });
                        }
                    };
                    for (var latency = 1 ; latency <= 4 ; latency++) {
                        _loop_1(latency);
                    }
                    _queueSize = normalQueue;
                    _immediateQueueSize = immediateQueue;
                }
                function _queueBatches(latency, sendType, sendReason) {
                    var eventsQueued = false;
                    var isAsync = sendType === 0 ;
                    if (!isAsync || _httpManager[_DYN_CAN_SEND_REQUEST ]()) {
                        doPerf(_self.core, function () { return "PostChannel._queueBatches"; }, function () {
                            var droppedEvents = [];
                            var latencyToProcess = 4 ;
                            while (latencyToProcess >= latency) {
                                var batchQueue = _batchQueues[latencyToProcess];
                                if (batchQueue && batchQueue.batches && batchQueue.batches[_DYN_LENGTH ] > 0) {
                                    arrForEach(batchQueue[_DYN_BATCHES ], function (theBatch) {
                                        if (!_httpManager.addBatch(theBatch)) {
                                            droppedEvents = droppedEvents[_DYN_CONCAT ](theBatch[_DYN_EVENTS ]());
                                        }
                                        else {
                                            eventsQueued = eventsQueued || (theBatch && theBatch[_DYN_COUNT ]() > 0);
                                        }
                                        if (latencyToProcess === 4 ) {
                                            _immediateQueueSize -= theBatch[_DYN_COUNT ]();
                                        }
                                        else {
                                            _queueSize -= theBatch[_DYN_COUNT ]();
                                        }
                                    });
                                    batchQueue[_DYN_BATCHES ] = [];
                                    batchQueue.iKeyMap = {};
                                }
                                latencyToProcess--;
                            }
                            if (droppedEvents[_DYN_LENGTH ] > 0) {
                                _notifyEvents(strEventsDiscarded, droppedEvents, EventsDiscardedReason.KillSwitch);
                            }
                            if (eventsQueued && _delayedBatchSendLatency >= latency) {
                                _delayedBatchSendLatency = -1;
                                _delayedBatchReason = 0 ;
                            }
                        }, function () { return ({ latency: latency, sendType: sendType, sendReason: sendReason }); }, !isAsync);
                    }
                    else {
                        _delayedBatchSendLatency = _delayedBatchSendLatency >= 0 ? Math.min(_delayedBatchSendLatency, latency) : latency;
                        _delayedBatchReason = Math.max(_delayedBatchReason, sendReason);
                    }
                    return eventsQueued;
                }
                function _flushImpl(callback, sendReason) {
                    _sendEventsForLatencyAndAbove(1 , 0 , sendReason);
                    _resetQueueCounts();
                    _waitForIdleManager(function () {
                        if (callback) {
                            callback();
                        }
                        if (_flushCallbackQueue[_DYN_LENGTH ] > 0) {
                            _flushCallbackTimer = _createTimer(function () {
                                _flushCallbackTimer = null;
                                _flushImpl(_flushCallbackQueue.shift(), sendReason);
                            }, 0);
                        }
                        else {
                            _flushCallbackTimer = null;
                            _scheduleTimer();
                        }
                    });
                }
                function _waitForIdleManager(callback) {
                    if (_httpManager[_DYN_IS_COMPLETELY_IDLE ]()) {
                        callback();
                    }
                    else {
                        _flushCallbackTimer = _createTimer(function () {
                            _flushCallbackTimer = null;
                            _waitForIdleManager(callback);
                        }, FlushCheckTimer);
                    }
                }
                function _resetTransmitProfiles() {
                    _clearScheduledTimer();
                    _initializeProfiles();
                    _currentProfile = RT_PROFILE;
                    _scheduleTimer();
                }
                function _initializeProfiles() {
                    _profiles = {};
                    _profiles[RT_PROFILE] = [2, 1, 0];
                    _profiles[NRT_PROFILE] = [6, 3, 0];
                    _profiles[BE_PROFILE] = [18, 9, 0];
                }
                function _requeueEvents(batches, reason) {
                    var droppedEvents = [];
                    var maxSendAttempts = _maxEventSendAttempts;
                    if (_isPageUnloadTriggered) {
                        maxSendAttempts = _maxUnloadEventSendAttempts;
                    }
                    arrForEach(batches, function (theBatch) {
                        if (theBatch && theBatch[_DYN_COUNT ]() > 0) {
                            arrForEach(theBatch[_DYN_EVENTS ](), function (theEvent) {
                                if (theEvent) {
                                    if (theEvent[_DYN_SYNC ]) {
                                        theEvent[_DYN_LATENCY ] = 4 ;
                                        theEvent[_DYN_SYNC ] = false;
                                    }
                                    if (theEvent[_DYN_SEND_ATTEMPT ] < maxSendAttempts) {
                                        setProcessTelemetryTimings(theEvent, _self[_DYN_IDENTIFIER ]);
                                        _addEventToQueues(theEvent, false);
                                    }
                                    else {
                                        droppedEvents[_DYN_PUSH ](theEvent);
                                    }
                                }
                            });
                        }
                    });
                    if (droppedEvents[_DYN_LENGTH ] > 0) {
                        _notifyEvents(strEventsDiscarded, droppedEvents, EventsDiscardedReason.NonRetryableStatus);
                    }
                    if (_isPageUnloadTriggered) {
                        _releaseAllQueues(2 , 2 );
                    }
                }
                function _callNotification(evtName, theArgs) {
                    var manager = (_notificationManager || {});
                    var notifyFunc = manager[evtName];
                    if (notifyFunc) {
                        try {
                            notifyFunc.apply(manager, theArgs);
                        }
                        catch (e) {
                            _throwInternal(_self.diagLog(), 1 , 74 , evtName + " notification failed: " + e);
                        }
                    }
                }
                function _notifyEvents(evtName, theEvents) {
                    var extraArgs = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        extraArgs[_i - 2] = arguments[_i];
                    }
                    if (theEvents && theEvents[_DYN_LENGTH ] > 0) {
                        _callNotification(evtName, [theEvents][_DYN_CONCAT ](extraArgs));
                    }
                }
                function _notifyBatchEvents(evtName, batches) {
                    var extraArgs = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        extraArgs[_i - 2] = arguments[_i];
                    }
                    if (batches && batches[_DYN_LENGTH ] > 0) {
                        arrForEach(batches, function (theBatch) {
                            if (theBatch && theBatch[_DYN_COUNT ]() > 0) {
                                _callNotification(evtName, [theBatch.events()][_DYN_CONCAT ](extraArgs));
                            }
                        });
                    }
                }
                function _sendingEvent(batches, reason, isSyncRequest) {
                    if (batches && batches[_DYN_LENGTH ] > 0) {
                        _callNotification("eventsSendRequest", [(reason >= 1000  && reason <= 1999  ?
                                reason - 1000  :
                                0 ), isSyncRequest !== true]);
                    }
                }
                function _eventsSentEvent(batches, reason) {
                    _notifyBatchEvents("eventsSent", batches, reason);
                    _scheduleTimer();
                }
                function _eventsDropped(batches, reason) {
                    _notifyBatchEvents(strEventsDiscarded, batches, (reason >= 8000  && reason <= 8999  ?
                        reason - 8000  :
                        EventsDiscardedReason.Unknown));
                }
                function _eventsResponseFail(batches) {
                    _notifyBatchEvents(strEventsDiscarded, batches, EventsDiscardedReason.NonRetryableStatus);
                    _scheduleTimer();
                }
                function _otherEvent(batches, reason) {
                    _notifyBatchEvents(strEventsDiscarded, batches, EventsDiscardedReason.Unknown);
                    _scheduleTimer();
                }
                function _setAutoLimits() {
                    if (!_disableAutoBatchFlushLimit) {
                        _autoFlushBatchLimit = Math.max(MaxNumberEventPerBatch * (MaxConnections + 1), _queueSizeLimit / 6);
                    }
                    else {
                        _autoFlushBatchLimit = 0;
                    }
                }
            });
            return _this;
        }
        PostChannel.__ieDyn=1;
        return PostChannel;
    }(BaseTelemetryPlugin));

    exports.BE_PROFILE = BE_PROFILE;
    exports.NRT_PROFILE = NRT_PROFILE;
    exports.PostChannel = PostChannel;
    exports.RT_PROFILE = RT_PROFILE;

}));
//# sourceMappingURL=ms.post.js.map


/***/ }),

/***/ 983:
/***/ (function(__unused_webpack_module, exports) {

/*!
 * Application Insights JavaScript SDK - Common, 3.2.2
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */
(function (global, factory) {
     true ? factory(exports) :
    0;
})(this, (function (exports) { 'use strict';

    /*! https://github.com/nevware21/ts-utils v0.11.2 */
    /*#__NO_SIDE_EFFECTS__*/
    function _pureAssign(func1, func2) {
        return func1 || func2;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _pureRef(value, name) {
        return value[name];
    }
    var UNDEF_VALUE = undefined;
    var NULL_VALUE = null;
    var EMPTY = "";
    var FUNCTION = "function";
    var OBJECT = "object";
    var PROTOTYPE = "prototype";
    var __PROTO__ = "__proto__";
    var UNDEFINED = "undefined";
    var CONSTRUCTOR = "constructor";
    var SYMBOL = "Symbol";
    var POLYFILL_TAG = "_polyfill";
    var LENGTH = "length";
    var NAME = "name";
    var CALL = "call";
    var TO_STRING = "toString";
    var ObjClass$1 = ( /*#__PURE__*/_pureAssign(Object));
    var ObjProto$1 = ( /*#__PURE__*/_pureRef(ObjClass$1, PROTOTYPE));
    var StrCls = ( /*#__PURE__*/_pureAssign(String));
    var StrProto = ( /*#__PURE__*/_pureRef(StrCls, PROTOTYPE));
    var MathCls = ( /*#__PURE__*/_pureAssign(Math));
    var ArrCls = ( /*#__PURE__*/_pureAssign(Array));
    var ArrProto = ( /*#__PURE__*/_pureRef(ArrCls, PROTOTYPE));
    var ArrSlice = ( /*#__PURE__*/_pureRef(ArrProto, "slice"));
    function safe(func, argArray) {
        try {
            return {
                v: func.apply(this, argArray)
            };
        }
        catch (e) {
            return { e: e };
        }
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _createIs(theType) {
        return function (value) {
            return typeof value === theType;
        };
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _createObjIs(theName) {
        var theType = "[object " + theName + "]";
        return function (value) {
            return !!(value && objToString(value) === theType);
        };
    }
    /*#__NO_SIDE_EFFECTS__*/
    function objToString(value) {
        return ObjProto$1[TO_STRING].call(value);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isUndefined(value) {
        return typeof value === UNDEFINED || value === UNDEFINED;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isNullOrUndefined(value) {
        return value === NULL_VALUE || isUndefined(value);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isDefined(arg) {
        return !!arg || arg !== UNDEF_VALUE;
    }
    var isString = ( /*#__PURE__*/_createIs("string"));
    var isFunction = ( /*#__PURE__*/_createIs(FUNCTION));
    /*#__NO_SIDE_EFFECTS__*/
    function isObject(value) {
        if (!value && isNullOrUndefined(value)) {
            return false;
        }
        return !!value && typeof value === OBJECT;
    }
    var isArray = ( /* #__PURE__*/_pureRef(ArrCls, "isArray"));
    var isError = ( /*#__PURE__*/_createObjIs("Error"));
    var objGetOwnPropertyDescriptor = ( /* #__PURE__ */_pureRef(ObjClass$1, "getOwnPropertyDescriptor"));
    /*#__NO_SIDE_EFFECTS__*/
    function objHasOwnProperty(obj, prop) {
        return !!obj && ObjProto$1.hasOwnProperty[CALL](obj, prop);
    }
    var objHasOwn = ( /*#__PURE__*/_pureAssign(( /* #__PURE__ */_pureRef(ObjClass$1, "hasOwn")), polyObjHasOwn));
    /*#__NO_SIDE_EFFECTS__*/
    function polyObjHasOwn(obj, prop) {
        return objHasOwnProperty(obj, prop) || !!objGetOwnPropertyDescriptor(obj, prop);
    }
    function objForEachKey(theObject, callbackfn, thisArg) {
        if (theObject && isObject(theObject)) {
            for (var prop in theObject) {
                if (objHasOwn(theObject, prop)) {
                    if (callbackfn[CALL](thisArg || theObject, prop, theObject[prop]) === -1) {
                        break;
                    }
                }
            }
        }
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _createKeyValueMap(values, keyType, valueType, completeFn) {
        var theMap = {};
        objForEachKey(values, function (key, value) {
            theMap[key] = keyType ? value : key;
            theMap[value] = valueType ? value : key;
        });
        return completeFn(theMap);
    }
    var asString = ( /* #__PURE__ */_pureAssign(StrCls));
    var ERROR_TYPE = "[object Error]";
    /*#__NO_SIDE_EFFECTS__*/
    function dumpObj(object, format) {
        var propertyValueDump = EMPTY;
        var objType = ObjProto$1[TO_STRING][CALL](object);
        if (objType === ERROR_TYPE) {
            object = { stack: asString(object.stack), message: asString(object.message), name: asString(object.name) };
        }
        try {
            propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? ((typeof format === "number") ? format : 4) : UNDEF_VALUE);
            propertyValueDump = (propertyValueDump && propertyValueDump.replace(/"(\w+)"\s*:\s{0,1}/g, "$1: ")) || asString(object);
        }
        catch (e) {
            propertyValueDump = " - " + dumpObj(e, format);
        }
        return objType + ": " + propertyValueDump;
    }
    function throwError(message) {
        throw new Error(message);
    }
    function throwTypeError(message) {
        throw new TypeError(message);
    }
    var _objFreeze = ( /* #__PURE__ */_pureRef(ObjClass$1, "freeze"));
    function _doNothing(value) {
        return value;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _getProto(value) {
        return value[__PROTO__] || NULL_VALUE;
    }
    var objAssign = ( /*#__PURE__*/_pureRef(ObjClass$1, "assign"));
    var objKeys = ( /*#__PURE__*/_pureRef(ObjClass$1, "keys"));
    function objDeepFreeze(value) {
        if (_objFreeze) {
            objForEachKey(value, function (key, value) {
                if (isArray(value) || isObject(value)) {
                    _objFreeze(value);
                }
            });
        }
        return objFreeze(value);
    }
    var objFreeze = ( /* #__PURE__*/_pureAssign(_objFreeze, _doNothing));
    var objGetPrototypeOf = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ObjClass$1, "getPrototypeOf")), _getProto));
    /*#__NO_SIDE_EFFECTS__*/
    function createEnum(values) {
        return _createKeyValueMap(values, 1 , 0 , objDeepFreeze);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function createSimpleMap(values) {
        var mapClass = {};
        objForEachKey(values, function (key, value) {
            mapClass[key] = value[1];
            mapClass[value[0]] = value[1];
        });
        return objDeepFreeze(mapClass);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function createTypeMap(values) {
        return createSimpleMap(values);
    }
    var GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg";
    var _globalCfg;
    /*#__NO_SIDE_EFFECTS__*/
    function _getGlobalValue() {
        var result;
        if (typeof globalThis !== UNDEFINED) {
            result = globalThis;
        }
        if (!result && typeof self !== UNDEFINED) {
            result = self;
        }
        if (!result && typeof window !== UNDEFINED) {
            result = window;
        }
        if (!result && typeof global !== UNDEFINED) {
            result = global;
        }
        return result;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _getGlobalConfig() {
        if (!_globalCfg) {
            var gbl = safe(_getGlobalValue).v || {};
            _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};
        }
        return _globalCfg;
    }
    var _unwrapFunction = ( _unwrapFunctionWithPoly);
    /*#__NO_SIDE_EFFECTS__*/
    function _unwrapFunctionWithPoly(funcName, clsProto, polyFunc) {
        var clsFn = clsProto && clsProto[funcName];
        return function (thisArg) {
            var theFunc = (thisArg && thisArg[funcName]) || clsFn;
            if (theFunc || polyFunc) {
                var theArgs = arguments;
                return (theFunc || polyFunc).apply(thisArg, theFunc ? ArrSlice[CALL](theArgs, 1) : theArgs);
            }
            throwTypeError("\"" + asString(funcName) + "\" not defined for " + dumpObj(thisArg));
        };
    }
    var mathMax = ( /*#__PURE__*/_pureRef(MathCls, "max"));
    var strSlice = ( /*#__PURE__*/_unwrapFunction("slice", StrProto));
    var strSubstring = ( /*#__PURE__*/_unwrapFunction("substring", StrProto));
    var strSubstr = ( /*#__PURE__*/_unwrapFunctionWithPoly("substr", StrProto, polyStrSubstr));
    /*#__NO_SIDE_EFFECTS__*/
    function polyStrSubstr(value, start, length) {
        if (isNullOrUndefined(value)) {
            throwTypeError("Invalid " + dumpObj(value));
        }
        if (length < 0) {
            return EMPTY;
        }
        start = start || 0;
        if (start < 0) {
            start = mathMax(start + value[LENGTH], 0);
        }
        if (isUndefined(length)) {
            return strSlice(value, start);
        }
        return strSlice(value, start, start + length);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function strLeft(value, count) {
        return strSubstring(value, 0, count);
    }
    var UNIQUE_REGISTRY_ID = "_urid";
    var _polySymbols;
    /*#__NO_SIDE_EFFECTS__*/
    function _globalSymbolRegistry() {
        if (!_polySymbols) {
            var gblCfg = _getGlobalConfig();
            _polySymbols = gblCfg.gblSym = gblCfg.gblSym || { k: {}, s: {} };
        }
        return _polySymbols;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function polyNewSymbol(description) {
        var theSymbol = {
            description: asString(description),
            toString: function () { return SYMBOL + "(" + description + ")"; }
        };
        theSymbol[POLYFILL_TAG] = true;
        return theSymbol;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function polySymbolFor(key) {
        var registry = _globalSymbolRegistry();
        if (!objHasOwn(registry.k, key)) {
            var newSymbol_1 = polyNewSymbol(key);
            var regId_1 = objKeys(registry.s).length;
            newSymbol_1[UNIQUE_REGISTRY_ID] = function () { return regId_1 + "_" + newSymbol_1[TO_STRING](); };
            registry.k[key] = newSymbol_1;
            registry.s[newSymbol_1[UNIQUE_REGISTRY_ID]()] = asString(key);
        }
        return registry.k[key];
    }
    var propMap = {
        e: "enumerable",
        c: "configurable",
        v: "value",
        w: "writable",
        g: "get",
        s: "set"
    };
    /*#__NO_SIDE_EFFECTS__*/
    function _createProp(value) {
        var prop = {};
        prop[propMap["c"]] = true;
        prop[propMap["e"]] = true;
        if (value.l) {
            prop.get = function () { return value.l.v; };
            var desc = objGetOwnPropertyDescriptor(value.l, "v");
            if (desc && desc.set) {
                prop.set = function (newValue) {
                    value.l.v = newValue;
                };
            }
        }
        objForEachKey(value, function (key, value) {
            prop[propMap[key]] = isUndefined(value) ? prop[propMap[key]] : value;
        });
        return prop;
    }
    var objDefineProp = ( /*#__PURE__*/_pureRef(ObjClass$1, "defineProperty"));
    function objDefine(target, key, propDesc) {
        return objDefineProp(target, key, _createProp(propDesc));
    }
    var _globalLazyTestHooks;
    function _initTestHooks() {
        _globalLazyTestHooks = _getGlobalConfig();
    }
    /*#__NO_SIDE_EFFECTS__*/
    function createCachedValue(value) {
        return objDefineProp({
            toJSON: function () { return value; }
        }, "v", { value: value });
    }
    var WINDOW = "window";
    var _cachedGlobal;
    function _getGlobalInstFn(getFn, theArgs) {
        var cachedValue;
        return function () {
            !_globalLazyTestHooks && _initTestHooks();
            (!cachedValue || _globalLazyTestHooks.lzy) && (cachedValue = createCachedValue(safe(getFn, theArgs).v));
            return cachedValue.v;
        };
    }
    /*#__NO_SIDE_EFFECTS__*/
    function getGlobal(useCached) {
        !_globalLazyTestHooks && _initTestHooks();
        (!_cachedGlobal || useCached === false || _globalLazyTestHooks.lzy) && (_cachedGlobal = createCachedValue(safe(_getGlobalValue).v || NULL_VALUE));
        return _cachedGlobal.v;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function getInst(name, useCached) {
        var gbl = (!_cachedGlobal || useCached === false) ? getGlobal(useCached) : _cachedGlobal.v;
        if (gbl && gbl[name]) {
            return gbl[name];
        }
        if (name === WINDOW) {
            return getWindow();
        }
        return NULL_VALUE;
    }
    var getDocument = ( /*#__PURE__*/_getGlobalInstFn(getInst, ["document"]));
    /*#__NO_SIDE_EFFECTS__*/
    function hasWindow() {
        return !!( /*#__PURE__*/getWindow());
    }
    var getWindow = ( /*#__PURE__*/_getGlobalInstFn(getInst, [WINDOW]));
    /*#__NO_SIDE_EFFECTS__*/
    function hasNavigator() {
        return !!( /*#__PURE__*/getNavigator());
    }
    var getNavigator = ( /*#__PURE__*/_getGlobalInstFn(getInst, ["navigator"]));
    var _symbol;
    var _symbolFor;
    /*#__NO_SIDE_EFFECTS__*/
    function _initSymbol() {
        _symbol = ( /*#__PURE__*/createCachedValue(safe((getInst), [SYMBOL]).v));
        return _symbol;
    }
    function _getSymbolKey(key) {
        var gblSym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());
        return (gblSym.v ? gblSym.v[key] : UNDEF_VALUE);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function newSymbol(description, noPoly) {
        !_globalLazyTestHooks && _initTestHooks();
        var sym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());
        return sym.v ? sym.v(description) : (!noPoly ? polyNewSymbol(description) : NULL_VALUE);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function symbolFor(key) {
        !_globalLazyTestHooks && _initTestHooks();
        _symbolFor = ((!_globalLazyTestHooks.lzy ? _symbolFor : 0) || ( /*#__PURE__*/createCachedValue(safe((_getSymbolKey), ["for"]).v)));
        return (_symbolFor.v || polySymbolFor)(key);
    }
    function fnApply(fn, thisArg, argArray) {
        return fn.apply(thisArg, argArray);
    }
    function arrForEach(theArray, callbackfn, thisArg) {
        if (theArray) {
            var len = theArray[LENGTH] >>> 0;
            for (var idx = 0; idx < len; idx++) {
                if (idx in theArray) {
                    if (callbackfn[CALL](thisArg || theArray, theArray[idx], idx, theArray) === -1) {
                        break;
                    }
                }
            }
        }
    }
    var arrIndexOf = ( /*#__PURE__*/_unwrapFunction("indexOf", ArrProto));
    var arrMap = ( /*#__PURE__*/_unwrapFunction("map", ArrProto));
    var arrReduce = ( /*#__PURE__*/_unwrapFunction("reduce", ArrProto));
    var objCreate = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ObjClass$1, "create")), polyObjCreate));
    /*#__NO_SIDE_EFFECTS__*/
    function polyObjCreate(obj) {
        if (!obj) {
            return {};
        }
        var type = typeof obj;
        if (type !== OBJECT && type !== FUNCTION) {
            throwTypeError("Prototype must be an Object or function: " + dumpObj(obj));
        }
        function tempFunc() { }
        tempFunc[PROTOTYPE] = obj;
        return new tempFunc();
    }
    var _isProtoArray;
    function objSetPrototypeOf(obj, proto) {
        var fn = ObjClass$1["setPrototypeOf"] ||
            function (d, b) {
                var _a;
                !_isProtoArray && (_isProtoArray = createCachedValue((_a = {}, _a[__PROTO__] = [], _a) instanceof Array));
                _isProtoArray.v ? d[__PROTO__] = b : objForEachKey(b, function (key, value) { return d[key] = value; });
            };
        return fn(obj, proto);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _createCustomError(name, d, b) {
        safe(objDefine, [d, NAME, { v: name, c: true, e: false }]);
        d = objSetPrototypeOf(d, b);
        function __() {
            this[CONSTRUCTOR] = d;
            safe(objDefine, [this, NAME, { v: name, c: true, e: false }]);
        }
        d[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : (__[PROTOTYPE] = b[PROTOTYPE], new __());
        return d;
    }
    function _setName(baseClass, name) {
        name && (baseClass[NAME] = name);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function createCustomError(name, constructCb, errorBase) {
        var theBaseClass = errorBase || Error;
        var orgName = theBaseClass[PROTOTYPE][NAME];
        var captureFn = Error.captureStackTrace;
        return _createCustomError(name, function () {
            var _this = this;
            var theArgs = arguments;
            try {
                safe(_setName, [theBaseClass, name]);
                var _self = fnApply(theBaseClass, _this, ArrSlice[CALL](theArgs)) || _this;
                if (_self !== _this) {
                    var orgProto = objGetPrototypeOf(_this);
                    if (orgProto !== objGetPrototypeOf(_self)) {
                        objSetPrototypeOf(_self, orgProto);
                    }
                }
                captureFn && captureFn(_self, _this[CONSTRUCTOR]);
                constructCb && constructCb(_self, theArgs);
                return _self;
            }
            finally {
                safe(_setName, [theBaseClass, orgName]);
            }
        }, theBaseClass);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function utcNow() {
        return (Date.now || polyUtcNow)();
    }
    /*#__NO_SIDE_EFFECTS__*/
    function polyUtcNow() {
        return new Date().getTime();
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _createTrimFn(exp) {
        return function _doTrim(value) {
            if (isNullOrUndefined(value)) {
                throwTypeError("strTrim called [" + dumpObj(value) + "]");
            }
            if (value && value.replace) {
                value = value.replace(exp, EMPTY);
            }
            return value;
        };
    }
    var polyStrTrim = ( /*#__PURE__*/_createTrimFn(/^\s+|(?=\s)\s+$/g));
    var strTrim = ( /*#__PURE__*/_unwrapFunctionWithPoly("trim", StrProto, polyStrTrim));
    var _fnToString;
    var _objCtrFnString;
    var _gblWindow;
    /*#__NO_SIDE_EFFECTS__*/
    function isPlainObject(value) {
        if (!value || typeof value !== OBJECT) {
            return false;
        }
        if (!_gblWindow) {
            _gblWindow = hasWindow() ? getWindow() : true;
        }
        var result = false;
        if (value !== _gblWindow) {
            if (!_objCtrFnString) {
                _fnToString = Function[PROTOTYPE][TO_STRING];
                _objCtrFnString = _fnToString[CALL](ObjClass$1);
            }
            try {
                var proto = objGetPrototypeOf(value);
                result = !proto;
                if (!result) {
                    if (objHasOwnProperty(proto, CONSTRUCTOR)) {
                        proto = proto[CONSTRUCTOR];
                    }
                    result = proto && typeof proto === FUNCTION && _fnToString[CALL](proto) === _objCtrFnString;
                }
            }
            catch (ex) {
            }
        }
        return result;
    }
    var _perf;
    /*#__NO_SIDE_EFFECTS__*/
    function getPerformance() {
        !_globalLazyTestHooks && _initTestHooks();
        (!_perf || _globalLazyTestHooks.lzy) && (_perf = createCachedValue(safe((getInst), ["performance"]).v));
        return _perf.v;
    }
    var strEndsWith = ( /*#__PURE__*/_unwrapFunctionWithPoly("endsWith", StrProto, polyStrEndsWith));
    /*#__NO_SIDE_EFFECTS__*/
    function polyStrEndsWith(value, searchString, length) {
        if (!isString(value)) {
            throwTypeError("'" + dumpObj(value) + "' is not a string");
        }
        var searchValue = isString(searchString) ? searchString : asString(searchString);
        var end = !isUndefined(length) && length < value[LENGTH] ? length : value[LENGTH];
        return strSubstring(value, end - searchValue[LENGTH], end) === searchValue;
    }
    var strIndexOf = ( /*#__PURE__*/_unwrapFunction("indexOf", StrProto));
    var REF = "ref";
    var UNREF = "unref";
    var HAS_REF = "hasRef";
    var ENABLED = "enabled";
    /*#__NO_SIDE_EFFECTS__*/
    function _createTimerHandler(startTimer, refreshFn, cancelFn) {
        var ref = true;
        var timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE;
        var theTimerHandler;
        function _unref() {
            ref = false;
            timerId && timerId[UNREF] && timerId[UNREF]();
            return theTimerHandler;
        }
        function _cancel() {
            timerId && cancelFn(timerId);
            timerId = NULL_VALUE;
        }
        function _refresh() {
            timerId = refreshFn(timerId);
            if (!ref) {
                _unref();
            }
            return theTimerHandler;
        }
        function _setEnabled(value) {
            !value && timerId && _cancel();
            value && !timerId && _refresh();
        }
        theTimerHandler = {
            cancel: _cancel,
            refresh: _refresh
        };
        theTimerHandler[HAS_REF] = function () {
            if (timerId && timerId[HAS_REF]) {
                return timerId[HAS_REF]();
            }
            return ref;
        };
        theTimerHandler[REF] = function () {
            ref = true;
            timerId && timerId[REF] && timerId[REF]();
            return theTimerHandler;
        };
        theTimerHandler[UNREF] = _unref;
        theTimerHandler = objDefineProp(theTimerHandler, ENABLED, {
            get: function () { return !!timerId; },
            set: _setEnabled
        });
        return {
            h: theTimerHandler,
            dn: function () {
                timerId = NULL_VALUE;
            }
        };
    }
    function _createTimeoutWith(startTimer, overrideFn, theArgs) {
        var isArr = isArray(overrideFn);
        var len = isArr ? overrideFn.length : 0;
        var setFn = (len > 0 ? overrideFn[0] : (!isArr ? overrideFn : UNDEF_VALUE)) || setTimeout;
        var clearFn = (len > 1 ? overrideFn[1] : UNDEF_VALUE) || clearTimeout;
        var timerFn = theArgs[0];
        theArgs[0] = function () {
            handler.dn();
            fnApply(timerFn, UNDEF_VALUE, ArrSlice[CALL](arguments));
        };
        var handler = _createTimerHandler(startTimer, function (timerId) {
            if (timerId) {
                if (timerId.refresh) {
                    timerId.refresh();
                    return timerId;
                }
                fnApply(clearFn, UNDEF_VALUE, [timerId]);
            }
            return fnApply(setFn, UNDEF_VALUE, theArgs);
        }, function (timerId) {
            fnApply(clearFn, UNDEF_VALUE, [timerId]);
        });
        return handler.h;
    }
    function scheduleTimeout(callback, timeout) {
        return _createTimeoutWith(true, UNDEF_VALUE, ArrSlice[CALL](arguments));
    }

    var createEnumStyle = createEnum;
    var createValueMap = createTypeMap;

    var _DYN_TO_LOWER_CASE$1 = "toLowerCase";
    var _DYN_BLK_VAL = "blkVal";
    var _DYN_LENGTH$1 = "length";
    var _DYN_RD_ONLY = "rdOnly";
    var _DYN_NOTIFY = "notify";
    var _DYN_WARN_TO_CONSOLE = "warnToConsole";
    var _DYN_THROW_INTERNAL = "throwInternal";
    var _DYN_SET_DF = "setDf";
    var _DYN_WATCH = "watch";
    var _DYN_LOGGER = "logger";
    var _DYN_APPLY = "apply";
    var _DYN_PUSH$1 = "push";
    var _DYN_SPLICE = "splice";
    var _DYN_HDLR = "hdlr";
    var _DYN_CANCEL = "cancel";
    var _DYN_NAME$1 = "name";
    var _DYN_UNLOAD = "unload";
    var _DYN_VERSION = "version";
    var _DYN_LOGGING_LEVEL_CONSOL4 = "loggingLevelConsole";
    var _DYN_MESSAGE_ID = "messageId";
    var _DYN_MESSAGE$1 = "message";
    var _DYN_DIAG_LOG = "diagLog";
    var _DYN_USER_AGENT = "userAgent";
    var _DYN_SPLIT$1 = "split";
    var _DYN_NODE_TYPE = "nodeType";
    var _DYN_REPLACE = "replace";
    var _DYN_LOG_INTERNAL_MESSAGE = "logInternalMessage";
    var _DYN_TYPE = "type";
    var _DYN_HANDLER = "handler";
    var _DYN_TRACE_ID = "traceId";
    var _DYN_SPAN_ID = "spanId";
    var _DYN_TRACE_FLAGS = "traceFlags";

    var aggregationErrorType;
    function throwAggregationError(message, sourceErrors) {
        if (!aggregationErrorType) {
            aggregationErrorType = createCustomError("AggregationError", function (self, args) {
                if (args[_DYN_LENGTH$1 ] > 1) {
                    self.errors = args[1];
                }
            });
        }
        var theMessage = message || "One or more errors occurred.";
        arrForEach(sourceErrors, function (srcError, idx) {
            theMessage += "\n".concat(idx, " > ").concat(dumpObj(srcError));
        });
        throw new aggregationErrorType(theMessage, sourceErrors || []);
    }

    var strShimFunction = "function";
    var strShimObject = "object";
    var strShimUndefined = "undefined";
    var strShimPrototype = "prototype";
    var ObjClass = Object;
    var ObjProto = ObjClass[strShimPrototype];

    var strHasOwnProperty = "hasOwnProperty";
    var __objAssignFnImpl = function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (ObjProto[strHasOwnProperty].call(s, p)) {
                    t[p] = s[p];
                }
            }
        }
        return t;
    };
    var __assignFn = objAssign || __objAssignFnImpl;
    var extendStaticsFn = function (d, b) {
        extendStaticsFn = ObjClass["setPrototypeOf"] ||
            ({ __proto__: [] } instanceof Array && function (d, b) {
                d.__proto__ = b;
            }) ||
            function (d, b) {
                for (var p in b) {
                    if (b[strHasOwnProperty](p)) {
                        d[p] = b[p];
                    }
                }
            };
        return extendStaticsFn(d, b);
    };
    function __extendsFn(d, b) {
        if (typeof b !== strShimFunction && b !== null) {
            throwTypeError("Class extends value " + String(b) + " is not a constructor or null");
        }
        extendStaticsFn(d, b);
        function __() {
            this.constructor = d;
        }
        d[strShimPrototype] = b === null ? objCreate(b) : (__[strShimPrototype] = b[strShimPrototype], new __());
    }

    var _a$1;
    var Constructor = 'constructor';
    var Prototype = 'prototype';
    var strFunction = 'function';
    var DynInstFuncTable = '_dynInstFuncs';
    var DynProxyTag = '_isDynProxy';
    var DynClassName = '_dynClass';
    var DynClassNamePrefix = '_dynCls$';
    var DynInstChkTag = '_dynInstChk';
    var DynAllowInstChkTag = DynInstChkTag;
    var DynProtoDefaultOptions = '_dfOpts';
    var UnknownValue = '_unknown_';
    var str__Proto = "__proto__";
    var DynProtoBaseProto = "_dyn" + str__Proto;
    var DynProtoGlobalSettings = "__dynProto$Gbl";
    var DynProtoCurrent = "_dynInstProto";
    var strUseBaseInst = 'useBaseInst';
    var strSetInstFuncs = 'setInstFuncs';
    var Obj = Object;
    var _objGetPrototypeOf = Obj["getPrototypeOf"];
    var _objGetOwnProps = Obj["getOwnPropertyNames"];
    var _gbl = getGlobal();
    var _gblInst = _gbl[DynProtoGlobalSettings] || (_gbl[DynProtoGlobalSettings] = {
        o: (_a$1 = {},
            _a$1[strSetInstFuncs] = true,
            _a$1[strUseBaseInst] = true,
            _a$1),
        n: 1000
    });
    function _isObjectOrArrayPrototype(target) {
        return target && (target === Obj[Prototype] || target === Array[Prototype]);
    }
    function _isObjectArrayOrFunctionPrototype(target) {
        return _isObjectOrArrayPrototype(target) || target === Function[Prototype];
    }
    function _getObjProto(target) {
        var newProto;
        if (target) {
            if (_objGetPrototypeOf) {
                return _objGetPrototypeOf(target);
            }
            var curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);
            newProto = target[DynProtoBaseProto] || curProto;
            if (!objHasOwnProperty(target, DynProtoBaseProto)) {
                delete target[DynProtoCurrent];
                newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto];
                target[DynProtoCurrent] = curProto;
            }
        }
        return newProto;
    }
    function _forEachProp(target, func) {
        var props = [];
        if (_objGetOwnProps) {
            props = _objGetOwnProps(target);
        }
        else {
            for (var name_1 in target) {
                if (typeof name_1 === "string" && objHasOwnProperty(target, name_1)) {
                    props.push(name_1);
                }
            }
        }
        if (props && props.length > 0) {
            for (var lp = 0; lp < props.length; lp++) {
                func(props[lp]);
            }
        }
    }
    function _isDynamicCandidate(target, funcName, skipOwn) {
        return (funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || objHasOwnProperty(target, funcName)) && funcName !== str__Proto && funcName !== Prototype);
    }
    function _throwTypeError(message) {
        throwTypeError("DynamicProto: " + message);
    }
    function _getInstanceFuncs(thisTarget) {
        var instFuncs = objCreate(null);
        _forEachProp(thisTarget, function (name) {
            if (!instFuncs[name] && _isDynamicCandidate(thisTarget, name, false)) {
                instFuncs[name] = thisTarget[name];
            }
        });
        return instFuncs;
    }
    function _hasVisited(values, value) {
        for (var lp = values.length - 1; lp >= 0; lp--) {
            if (values[lp] === value) {
                return true;
            }
        }
        return false;
    }
    function _getBaseFuncs(classProto, thisTarget, instFuncs, useBaseInst) {
        function _instFuncProxy(target, funcHost, funcName) {
            var theFunc = funcHost[funcName];
            if (theFunc[DynProxyTag] && useBaseInst) {
                var instFuncTable = target[DynInstFuncTable] || {};
                if (instFuncTable[DynAllowInstChkTag] !== false) {
                    theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc;
                }
            }
            return function () {
                return theFunc.apply(target, arguments);
            };
        }
        var baseFuncs = objCreate(null);
        _forEachProp(instFuncs, function (name) {
            baseFuncs[name] = _instFuncProxy(thisTarget, instFuncs, name);
        });
        var baseProto = _getObjProto(classProto);
        var visited = [];
        while (baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto)) {
            _forEachProp(baseProto, function (name) {
                if (!baseFuncs[name] && _isDynamicCandidate(baseProto, name, !_objGetPrototypeOf)) {
                    baseFuncs[name] = _instFuncProxy(thisTarget, baseProto, name);
                }
            });
            visited.push(baseProto);
            baseProto = _getObjProto(baseProto);
        }
        return baseFuncs;
    }
    function _getInstFunc(target, funcName, proto, currentDynProtoProxy) {
        var instFunc = null;
        if (target && objHasOwnProperty(proto, DynClassName)) {
            var instFuncTable = target[DynInstFuncTable] || objCreate(null);
            instFunc = (instFuncTable[proto[DynClassName]] || objCreate(null))[funcName];
            if (!instFunc) {
                _throwTypeError("Missing [" + funcName + "] " + strFunction);
            }
            if (!instFunc[DynInstChkTag] && instFuncTable[DynAllowInstChkTag] !== false) {
                var canAddInst = !objHasOwnProperty(target, funcName);
                var objProto = _getObjProto(target);
                var visited = [];
                while (canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto)) {
                    var protoFunc = objProto[funcName];
                    if (protoFunc) {
                        canAddInst = (protoFunc === currentDynProtoProxy);
                        break;
                    }
                    visited.push(objProto);
                    objProto = _getObjProto(objProto);
                }
                try {
                    if (canAddInst) {
                        target[funcName] = instFunc;
                    }
                    instFunc[DynInstChkTag] = 1;
                }
                catch (e) {
                    instFuncTable[DynAllowInstChkTag] = false;
                }
            }
        }
        return instFunc;
    }
    function _getProtoFunc(funcName, proto, currentDynProtoProxy) {
        var protoFunc = proto[funcName];
        if (protoFunc === currentDynProtoProxy) {
            protoFunc = _getObjProto(proto)[funcName];
        }
        if (typeof protoFunc !== strFunction) {
            _throwTypeError("[" + funcName + "] is not a " + strFunction);
        }
        return protoFunc;
    }
    function _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {
        function _createDynamicPrototype(proto, funcName) {
            var dynProtoProxy = function () {
                var instFunc = _getInstFunc(this, funcName, proto, dynProtoProxy) || _getProtoFunc(funcName, proto, dynProtoProxy);
                return instFunc.apply(this, arguments);
            };
            dynProtoProxy[DynProxyTag] = 1;
            return dynProtoProxy;
        }
        if (!_isObjectOrArrayPrototype(proto)) {
            var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || objCreate(null);
            if (!_isObjectOrArrayPrototype(instFuncTable)) {
                var instFuncs_1 = instFuncTable[className] = (instFuncTable[className] || objCreate(null));
                if (instFuncTable[DynAllowInstChkTag] !== false) {
                    instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc;
                }
                if (!_isObjectOrArrayPrototype(instFuncs_1)) {
                    _forEachProp(target, function (name) {
                        if (_isDynamicCandidate(target, name, false) && target[name] !== baseInstFuncs[name]) {
                            instFuncs_1[name] = target[name];
                            delete target[name];
                            if (!objHasOwnProperty(proto, name) || (proto[name] && !proto[name][DynProxyTag])) {
                                proto[name] = _createDynamicPrototype(proto, name);
                            }
                        }
                    });
                }
            }
        }
    }
    function _checkPrototype(classProto, thisTarget) {
        if (_objGetPrototypeOf) {
            var visited = [];
            var thisProto = _getObjProto(thisTarget);
            while (thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto)) {
                if (thisProto === classProto) {
                    return true;
                }
                visited.push(thisProto);
                thisProto = _getObjProto(thisProto);
            }
            return false;
        }
        return true;
    }
    function _getObjName(target, unknownValue) {
        if (objHasOwnProperty(target, Prototype)) {
            return target.name || unknownValue || UnknownValue;
        }
        return (((target || {})[Constructor]) || {}).name || unknownValue || UnknownValue;
    }
    function dynamicProto(theClass, target, delegateFunc, options) {
        if (!objHasOwnProperty(theClass, Prototype)) {
            _throwTypeError("theClass is an invalid class definition.");
        }
        var classProto = theClass[Prototype];
        if (!_checkPrototype(classProto, target)) {
            _throwTypeError("[" + _getObjName(theClass) + "] not in hierarchy of [" + _getObjName(target) + "]");
        }
        var className = null;
        if (objHasOwnProperty(classProto, DynClassName)) {
            className = classProto[DynClassName];
        }
        else {
            className = DynClassNamePrefix + _getObjName(theClass, "_") + "$" + _gblInst.n;
            _gblInst.n++;
            classProto[DynClassName] = className;
        }
        var perfOptions = dynamicProto[DynProtoDefaultOptions];
        var useBaseInst = !!perfOptions[strUseBaseInst];
        if (useBaseInst && options && options[strUseBaseInst] !== undefined) {
            useBaseInst = !!options[strUseBaseInst];
        }
        var instFuncs = _getInstanceFuncs(target);
        var baseFuncs = _getBaseFuncs(classProto, target, instFuncs, useBaseInst);
        delegateFunc(target, baseFuncs);
        var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];
        if (setInstanceFunc && options) {
            setInstanceFunc = !!options[strSetInstFuncs];
        }
        _populatePrototype(classProto, className, target, instFuncs, setInstanceFunc !== false);
    }
    dynamicProto[DynProtoDefaultOptions] = _gblInst.o;

    var UNDEFINED_VALUE = undefined;
    var STR_EMPTY = "";
    var STR_NOT_DYNAMIC_ERROR = "Not dynamic - ";

    var rCamelCase = /-([a-z])/g;
    var rNormalizeInvalid = /([^\w\d_$])/g;
    var rLeadingNumeric = /^(\d+[\w\d_$])/;
    function isNotNullOrUndefined(value) {
        return !isNullOrUndefined(value);
    }
    function normalizeJsName(name) {
        var value = name;
        if (value && isString(value)) {
            value = value[_DYN_REPLACE ](rCamelCase, function (_all, letter) {
                return letter.toUpperCase();
            });
            value = value[_DYN_REPLACE ](rNormalizeInvalid, "_");
            value = value[_DYN_REPLACE ](rLeadingNumeric, function (_all, match) {
                return "_" + match;
            });
        }
        return value;
    }
    function strContains(value, search) {
        if (value && search) {
            return strIndexOf(value, search) !== -1;
        }
        return false;
    }
    function toISOString(date) {
        return date && date.toISOString() || "";
    }
    function getExceptionName(object) {
        if (isError(object)) {
            return object[_DYN_NAME$1 ];
        }
        return STR_EMPTY;
    }
    function createClassFromInterface(defaults) {
        return /** @class */ (function () {
            function class_1() {
                var _this = this;
                if (defaults) {
                    objForEachKey(defaults, function (field, value) {
                        _this[field] = value;
                    });
                }
            }
            return class_1;
        }());
    }

    var strConsole = "console";
    var strJSON = "JSON";
    var strCrypto = "crypto";
    var strMsCrypto = "msCrypto";
    var strMsie = "msie";
    var strTrident = "trident/";
    var _isTrident = null;
    var _navUserAgentCheck = null;
    var _beaconsSupported = null;
    function getConsole() {
        if (typeof console !== strShimUndefined) {
            return console;
        }
        return getInst(strConsole);
    }
    function hasJSON() {
        return Boolean((typeof JSON === strShimObject && JSON) || getInst(strJSON) !== null);
    }
    function getJSON() {
        if (hasJSON()) {
            return JSON || getInst(strJSON);
        }
        return null;
    }
    function getCrypto() {
        return getInst(strCrypto);
    }
    function getMsCrypto() {
        return getInst(strMsCrypto);
    }
    function isIE() {
        var nav = getNavigator();
        if (nav && (nav[_DYN_USER_AGENT ] !== _navUserAgentCheck || _isTrident === null)) {
            _navUserAgentCheck = nav[_DYN_USER_AGENT ];
            var userAgent = (_navUserAgentCheck || STR_EMPTY)[_DYN_TO_LOWER_CASE$1 ]();
            _isTrident = (strContains(userAgent, strMsie) || strContains(userAgent, strTrident));
        }
        return _isTrident;
    }
    function isBeaconsSupported(useCached) {
        if (_beaconsSupported === null || useCached === false) {
            _beaconsSupported = hasNavigator() && Boolean(getNavigator().sendBeacon);
        }
        return _beaconsSupported;
    }
    function _getNamedValue(values, name) {
        if (values) {
            for (var i = 0; i < values[_DYN_LENGTH$1 ]; i++) {
                var value = values[i];
                if (value[_DYN_NAME$1 ]) {
                    if (value[_DYN_NAME$1 ] === name) {
                        return value;
                    }
                }
            }
        }
        return {};
    }
    function findMetaTag(name) {
        var doc = getDocument();
        if (doc && name) {
            return _getNamedValue(doc.querySelectorAll("meta"), name).content;
        }
        return null;
    }
    function findNamedServerTiming(name) {
        var value;
        var perf = getPerformance();
        if (perf) {
            var navPerf = perf.getEntriesByType("navigation") || [];
            value = _getNamedValue((navPerf[_DYN_LENGTH$1 ] > 0 ? navPerf[0] : {}).serverTiming, name).description;
        }
        return value;
    }

    var UInt32Mask = 0x100000000;
    var MaxUInt32 = 0xffffffff;
    var SEED1 = 123456789;
    var SEED2 = 987654321;
    var _mwcSeeded = false;
    var _mwcW = SEED1;
    var _mwcZ = SEED2;
    function _mwcSeed(seedValue) {
        if (seedValue < 0) {
            seedValue >>>= 0;
        }
        _mwcW = (SEED1 + seedValue) & MaxUInt32;
        _mwcZ = (SEED2 - seedValue) & MaxUInt32;
        _mwcSeeded = true;
    }
    function _autoSeedMwc() {
        try {
            var now = utcNow() & 0x7fffffff;
            _mwcSeed(((Math.random() * UInt32Mask) ^ now) + now);
        }
        catch (e) {
        }
    }
    function randomValue(maxValue) {
        if (maxValue > 0) {
            return Math.floor((random32() / MaxUInt32) * (maxValue + 1)) >>> 0;
        }
        return 0;
    }
    function random32(signed) {
        var value = 0;
        var c = getCrypto() || getMsCrypto();
        if (c && c.getRandomValues) {
            value = c.getRandomValues(new Uint32Array(1))[0] & MaxUInt32;
        }
        if (value === 0 && isIE()) {
            if (!_mwcSeeded) {
                _autoSeedMwc();
            }
            value = mwcRandom32() & MaxUInt32;
        }
        if (value === 0) {
            value = Math.floor((UInt32Mask * Math.random()) | 0);
        }
        if (!signed) {
            value >>>= 0;
        }
        return value;
    }
    function mwcRandom32(signed) {
        _mwcZ = (36969 * (_mwcZ & 0xFFFF) + (_mwcZ >> 16)) & MaxUInt32;
        _mwcW = (18000 * (_mwcW & 0xFFFF) + (_mwcW >> 16)) & MaxUInt32;
        var value = (((_mwcZ << 16) + (_mwcW & 0xFFFF)) >>> 0) & MaxUInt32 | 0;
        if (!signed) {
            value >>>= 0;
        }
        return value;
    }
    function newId(maxLength) {
        if (maxLength === void 0) { maxLength = 22; }
        var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var number = random32() >>> 0;
        var chars = 0;
        var result = STR_EMPTY;
        while (result[_DYN_LENGTH$1 ] < maxLength) {
            chars++;
            result += base64chars.charAt(number & 0x3F);
            number >>>= 6;
            if (chars === 5) {
                number = (((random32() << 2) & 0xFFFFFFFF) | (number & 0x03)) >>> 0;
                chars = 0;
            }
        }
        return result;
    }

    var version = '3.2.2';
    var instanceName = "." + newId(6);
    var _dataUid = 0;
    function _canAcceptData(target) {
        return target[_DYN_NODE_TYPE ] === 1 || target[_DYN_NODE_TYPE ] === 9 || !(+target[_DYN_NODE_TYPE ]);
    }
    function _getCache(data, target) {
        var theCache = target[data.id];
        if (!theCache) {
            theCache = {};
            try {
                if (_canAcceptData(target)) {
                    objDefine(target, data.id, {
                        e: false,
                        v: theCache
                    });
                }
            }
            catch (e) {
            }
        }
        return theCache;
    }
    function createUniqueNamespace(name, includeVersion) {
        if (includeVersion === void 0) { includeVersion = false; }
        return normalizeJsName(name + (_dataUid++) + (includeVersion ? "." + version : STR_EMPTY) + instanceName);
    }
    function createElmNodeData(name) {
        var data = {
            id: createUniqueNamespace("_aiData-" + (name || STR_EMPTY) + "." + version),
            accept: function (target) {
                return _canAcceptData(target);
            },
            get: function (target, name, defValue, addDefault) {
                var theCache = target[data.id];
                if (!theCache) {
                    if (addDefault) {
                        theCache = _getCache(data, target);
                        theCache[normalizeJsName(name)] = defValue;
                    }
                    return defValue;
                }
                return theCache[normalizeJsName(name)];
            },
            kill: function (target, name) {
                if (target && target[name]) {
                    try {
                        delete target[name];
                    }
                    catch (e) {
                    }
                }
            }
        };
        return data;
    }

    function _isConfigDefaults(value) {
        return (value && isObject(value) && (value.isVal || value.fb || objHasOwn(value, "v") || objHasOwn(value, "mrg") || objHasOwn(value, "ref") || value.set));
    }
    function _getDefault(dynamicHandler, theConfig, cfgDefaults) {
        var defValue;
        var isDefaultValid = cfgDefaults.dfVal || isDefined;
        if (theConfig && cfgDefaults.fb) {
            var fallbacks = cfgDefaults.fb;
            if (!isArray(fallbacks)) {
                fallbacks = [fallbacks];
            }
            for (var lp = 0; lp < fallbacks[_DYN_LENGTH$1 ]; lp++) {
                var fallback = fallbacks[lp];
                var fbValue = theConfig[fallback];
                if (isDefaultValid(fbValue)) {
                    defValue = fbValue;
                }
                else if (dynamicHandler) {
                    fbValue = dynamicHandler.cfg[fallback];
                    if (isDefaultValid(fbValue)) {
                        defValue = fbValue;
                    }
                    dynamicHandler.set(dynamicHandler.cfg, asString(fallback), fbValue);
                }
                if (isDefaultValid(defValue)) {
                    break;
                }
            }
        }
        if (!isDefaultValid(defValue) && isDefaultValid(cfgDefaults.v)) {
            defValue = cfgDefaults.v;
        }
        return defValue;
    }
    function _resolveDefaultValue(dynamicHandler, theConfig, cfgDefaults) {
        var theValue = cfgDefaults;
        if (cfgDefaults && _isConfigDefaults(cfgDefaults)) {
            theValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);
        }
        if (theValue) {
            if (_isConfigDefaults(theValue)) {
                theValue = _resolveDefaultValue(dynamicHandler, theConfig, theValue);
            }
            var newValue_1;
            if (isArray(theValue)) {
                newValue_1 = [];
                newValue_1[_DYN_LENGTH$1 ] = theValue[_DYN_LENGTH$1 ];
            }
            else if (isPlainObject(theValue)) {
                newValue_1 = {};
            }
            if (newValue_1) {
                objForEachKey(theValue, function (key, value) {
                    if (value && _isConfigDefaults(value)) {
                        value = _resolveDefaultValue(dynamicHandler, theConfig, value);
                    }
                    newValue_1[key] = value;
                });
                theValue = newValue_1;
            }
        }
        return theValue;
    }
    function _applyDefaultValue(dynamicHandler, theConfig, name, defaultValue) {
        var isValid;
        var setFn;
        var defValue;
        var cfgDefaults = defaultValue;
        var mergeDf;
        var reference;
        var readOnly;
        var blkDynamicValue;
        if (_isConfigDefaults(cfgDefaults)) {
            isValid = cfgDefaults.isVal;
            setFn = cfgDefaults.set;
            readOnly = cfgDefaults[_DYN_RD_ONLY ];
            blkDynamicValue = cfgDefaults[_DYN_BLK_VAL ];
            mergeDf = cfgDefaults.mrg;
            reference = cfgDefaults.ref;
            if (!reference && isUndefined(reference)) {
                reference = !!mergeDf;
            }
            defValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);
        }
        else {
            defValue = defaultValue;
        }
        if (blkDynamicValue) {
            dynamicHandler[_DYN_BLK_VAL ](theConfig, name);
        }
        var theValue;
        var usingDefault = true;
        var cfgValue = theConfig[name];
        if (cfgValue || !isNullOrUndefined(cfgValue)) {
            theValue = cfgValue;
            usingDefault = false;
            if (isValid && theValue !== defValue && !isValid(theValue)) {
                theValue = defValue;
                usingDefault = true;
            }
            if (setFn) {
                theValue = setFn(theValue, defValue, theConfig);
                usingDefault = theValue === defValue;
            }
        }
        if (!usingDefault) {
            if (isPlainObject(theValue) || isArray(defValue)) {
                if (mergeDf && defValue && (isPlainObject(defValue) || isArray(defValue))) {
                    objForEachKey(defValue, function (dfName, dfValue) {
                        _applyDefaultValue(dynamicHandler, theValue, dfName, dfValue);
                    });
                }
            }
        }
        else if (defValue) {
            theValue = _resolveDefaultValue(dynamicHandler, theConfig, defValue);
        }
        else {
            theValue = defValue;
        }
        dynamicHandler.set(theConfig, name, theValue);
        if (reference) {
            dynamicHandler.ref(theConfig, name);
        }
        if (readOnly) {
            dynamicHandler[_DYN_RD_ONLY ](theConfig, name);
        }
    }

    var CFG_HANDLER_LINK = symbolFor("[[ai_dynCfg_1]]");
    var BLOCK_DYNAMIC = symbolFor("[[ai_blkDynCfg_1]]");
    var FORCE_DYNAMIC = symbolFor("[[ai_frcDynCfg_1]]");
    function _cfgDeepCopy(source) {
        if (source) {
            var target_1;
            if (isArray(source)) {
                target_1 = [];
                target_1[_DYN_LENGTH$1 ] = source[_DYN_LENGTH$1 ];
            }
            else if (isPlainObject(source)) {
                target_1 = {};
            }
            if (target_1) {
                objForEachKey(source, function (key, value) {
                    target_1[key] = _cfgDeepCopy(value);
                });
                return target_1;
            }
        }
        return source;
    }
    function getDynamicConfigHandler(value) {
        if (value) {
            var handler = value[CFG_HANDLER_LINK] || value;
            if (handler.cfg && (handler.cfg === value || handler.cfg[CFG_HANDLER_LINK] === handler)) {
                return handler;
            }
        }
        return null;
    }
    function blockDynamicConversion(value) {
        if (value && (isPlainObject(value) || isArray(value))) {
            try {
                value[BLOCK_DYNAMIC] = true;
            }
            catch (e) {
            }
        }
        return value;
    }
    function _canMakeDynamic(getFunc, state, value) {
        var result = false;
        if (value && !getFunc[state.blkVal]) {
            result = value[FORCE_DYNAMIC];
            if (!result && !value[BLOCK_DYNAMIC]) {
                result = isPlainObject(value) || isArray(value);
            }
        }
        return result;
    }
    function throwInvalidAccess(message) {
        throwTypeError("InvalidAccess:" + message);
    }

    var arrayMethodsToPatch = [
        "push",
        "pop",
        "shift",
        "unshift",
        "splice"
    ];
    var _throwDynamicError = function (logger, name, desc, e) {
        logger && logger[_DYN_THROW_INTERNAL ](3 , 108 , "".concat(desc, " [").concat(name, "] failed - ") + dumpObj(e));
    };
    function _patchArray(state, target, name) {
        if (isArray(target)) {
            arrForEach(arrayMethodsToPatch, function (method) {
                var orgMethod = target[method];
                target[method] = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    var result = orgMethod[_DYN_APPLY ](this, args);
                    _makeDynamicObject(state, target, name, "Patching");
                    return result;
                };
            });
        }
    }
    function _getOwnPropGetter(target, name) {
        var propDesc = objGetOwnPropertyDescriptor(target, name);
        return propDesc && propDesc.get;
    }
    function _createDynamicProperty(state, theConfig, name, value) {
        var detail = {
            n: name,
            h: [],
            trk: function (handler) {
                if (handler && handler.fn) {
                    if (arrIndexOf(detail.h, handler) === -1) {
                        detail.h[_DYN_PUSH$1 ](handler);
                    }
                    state.trk(handler, detail);
                }
            },
            clr: function (handler) {
                var idx = arrIndexOf(detail.h, handler);
                if (idx !== -1) {
                    detail.h[_DYN_SPLICE ](idx, 1);
                }
            }
        };
        var checkDynamic = true;
        var isObjectOrArray = false;
        function _getProperty() {
            if (checkDynamic) {
                isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value);
                if (value && !value[CFG_HANDLER_LINK] && isObjectOrArray) {
                    value = _makeDynamicObject(state, value, name, "Converting");
                }
                checkDynamic = false;
            }
            var activeHandler = state.act;
            if (activeHandler) {
                detail.trk(activeHandler);
            }
            return value;
        }
        _getProperty[state.prop] = {
            chng: function () {
                state.add(detail);
            }
        };
        function _setProperty(newValue) {
            if (value !== newValue) {
                if (!!_getProperty[state.ro] && !state.upd) {
                    throwInvalidAccess("[" + name + "] is read-only:" + dumpObj(theConfig));
                }
                if (checkDynamic) {
                    isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value);
                    checkDynamic = false;
                }
                var isReferenced = isObjectOrArray && _getProperty[state.rf];
                if (isObjectOrArray) {
                    if (isReferenced) {
                        objForEachKey(value, function (key) {
                            value[key] = newValue ? newValue[key] : UNDEFINED_VALUE;
                        });
                        try {
                            objForEachKey(newValue, function (key, theValue) {
                                _setDynamicProperty(state, value, key, theValue);
                            });
                            newValue = value;
                        }
                        catch (e) {
                            _throwDynamicError((state.hdlr || {})[_DYN_LOGGER ], name, "Assigning", e);
                            isObjectOrArray = false;
                        }
                    }
                    else if (value && value[CFG_HANDLER_LINK]) {
                        objForEachKey(value, function (key) {
                            var getter = _getOwnPropGetter(value, key);
                            if (getter) {
                                var valueState = getter[state.prop];
                                valueState && valueState.chng();
                            }
                        });
                    }
                }
                if (newValue !== value) {
                    var newIsObjectOrArray = newValue && _canMakeDynamic(_getProperty, state, newValue);
                    if (!isReferenced && newIsObjectOrArray) {
                        newValue = _makeDynamicObject(state, newValue, name, "Converting");
                    }
                    value = newValue;
                    isObjectOrArray = newIsObjectOrArray;
                }
                state.add(detail);
            }
        }
        objDefine(theConfig, detail.n, { g: _getProperty, s: _setProperty });
    }
    function _setDynamicProperty(state, target, name, value) {
        if (target) {
            var getter = _getOwnPropGetter(target, name);
            var isDynamic = getter && !!getter[state.prop];
            if (!isDynamic) {
                _createDynamicProperty(state, target, name, value);
            }
            else {
                target[name] = value;
            }
        }
        return target;
    }
    function _setDynamicPropertyState(state, target, name, flags) {
        if (target) {
            var getter = _getOwnPropGetter(target, name);
            var isDynamic = getter && !!getter[state.prop];
            var inPlace = flags && flags[0 ];
            var rdOnly = flags && flags[1 ];
            var blkProp = flags && flags[2 ];
            if (!isDynamic) {
                if (blkProp) {
                    try {
                        blockDynamicConversion(target);
                    }
                    catch (e) {
                        _throwDynamicError((state.hdlr || {})[_DYN_LOGGER ], name, "Blocking", e);
                    }
                }
                try {
                    _setDynamicProperty(state, target, name, target[name]);
                    getter = _getOwnPropGetter(target, name);
                }
                catch (e) {
                    _throwDynamicError((state.hdlr || {})[_DYN_LOGGER ], name, "State", e);
                }
            }
            if (inPlace) {
                getter[state.rf] = inPlace;
            }
            if (rdOnly) {
                getter[state.ro] = rdOnly;
            }
            if (blkProp) {
                getter[state.blkVal] = true;
            }
        }
        return target;
    }
    function _makeDynamicObject(state, target, name, desc) {
        try {
            objForEachKey(target, function (key, value) {
                _setDynamicProperty(state, target, key, value);
            });
            if (!target[CFG_HANDLER_LINK]) {
                objDefineProp(target, CFG_HANDLER_LINK, {
                    get: function () {
                        return state[_DYN_HDLR ];
                    }
                });
                _patchArray(state, target, name);
            }
        }
        catch (e) {
            _throwDynamicError((state.hdlr || {})[_DYN_LOGGER ], name, desc, e);
        }
        return target;
    }

    var symPrefix = "[[ai_";
    var symPostfix = "]]";
    function _createState(cfgHandler) {
        var _a;
        var dynamicPropertySymbol = newSymbol(symPrefix + "get" + cfgHandler.uid + symPostfix);
        var dynamicPropertyReadOnly = newSymbol(symPrefix + "ro" + cfgHandler.uid + symPostfix);
        var dynamicPropertyReferenced = newSymbol(symPrefix + "rf" + cfgHandler.uid + symPostfix);
        var dynamicPropertyBlockValue = newSymbol(symPrefix + "blkVal" + cfgHandler.uid + symPostfix);
        var dynamicPropertyDetail = newSymbol(symPrefix + "dtl" + cfgHandler.uid + symPostfix);
        var _waitingHandlers = null;
        var _watcherTimer = null;
        var theState;
        function _useHandler(activeHandler, callback) {
            var prevWatcher = theState.act;
            try {
                theState.act = activeHandler;
                if (activeHandler && activeHandler[dynamicPropertyDetail]) {
                    arrForEach(activeHandler[dynamicPropertyDetail], function (detail) {
                        detail.clr(activeHandler);
                    });
                    activeHandler[dynamicPropertyDetail] = [];
                }
                callback({
                    cfg: cfgHandler.cfg,
                    set: cfgHandler.set.bind(cfgHandler),
                    setDf: cfgHandler[_DYN_SET_DF ].bind(cfgHandler),
                    ref: cfgHandler.ref.bind(cfgHandler),
                    rdOnly: cfgHandler[_DYN_RD_ONLY ].bind(cfgHandler)
                });
            }
            catch (e) {
                var logger = cfgHandler[_DYN_LOGGER ];
                if (logger) {
                    logger[_DYN_THROW_INTERNAL ](1 , 107 , dumpObj(e));
                }
                throw e;
            }
            finally {
                theState.act = prevWatcher || null;
            }
        }
        function _notifyWatchers() {
            if (_waitingHandlers) {
                var notifyHandlers = _waitingHandlers;
                _waitingHandlers = null;
                _watcherTimer && _watcherTimer[_DYN_CANCEL ]();
                _watcherTimer = null;
                var watcherFailures_1 = [];
                arrForEach(notifyHandlers, function (handler) {
                    if (handler) {
                        if (handler[dynamicPropertyDetail]) {
                            arrForEach(handler[dynamicPropertyDetail], function (detail) {
                                detail.clr(handler);
                            });
                            handler[dynamicPropertyDetail] = null;
                        }
                        if (handler.fn) {
                            try {
                                _useHandler(handler, handler.fn);
                            }
                            catch (e) {
                                watcherFailures_1[_DYN_PUSH$1 ](e);
                            }
                        }
                    }
                });
                if (_waitingHandlers) {
                    try {
                        _notifyWatchers();
                    }
                    catch (e) {
                        watcherFailures_1[_DYN_PUSH$1 ](e);
                    }
                }
                if (watcherFailures_1[_DYN_LENGTH$1 ] > 0) {
                    throwAggregationError("Watcher error(s): ", watcherFailures_1);
                }
            }
        }
        function _addWatcher(detail) {
            if (detail && detail.h[_DYN_LENGTH$1 ] > 0) {
                if (!_waitingHandlers) {
                    _waitingHandlers = [];
                }
                if (!_watcherTimer) {
                    _watcherTimer = scheduleTimeout(function () {
                        _watcherTimer = null;
                        _notifyWatchers();
                    }, 0);
                }
                for (var idx = 0; idx < detail.h[_DYN_LENGTH$1 ]; idx++) {
                    var handler = detail.h[idx];
                    if (handler && arrIndexOf(_waitingHandlers, handler) === -1) {
                        _waitingHandlers[_DYN_PUSH$1 ](handler);
                    }
                }
            }
        }
        function _trackHandler(handler, detail) {
            if (handler) {
                var details = handler[dynamicPropertyDetail] = handler[dynamicPropertyDetail] || [];
                if (arrIndexOf(details, detail) === -1) {
                    details[_DYN_PUSH$1 ](detail);
                }
            }
        }
        theState = (_a = {
                prop: dynamicPropertySymbol,
                ro: dynamicPropertyReadOnly,
                rf: dynamicPropertyReferenced
            },
            _a[_DYN_BLK_VAL ] = dynamicPropertyBlockValue,
            _a[_DYN_HDLR ] = cfgHandler,
            _a.add = _addWatcher,
            _a[_DYN_NOTIFY ] = _notifyWatchers,
            _a.use = _useHandler,
            _a.trk = _trackHandler,
            _a);
        return theState;
    }

    function _createAndUseHandler(state, configHandler) {
        var handler = {
            fn: configHandler,
            rm: function () {
                handler.fn = null;
                state = null;
                configHandler = null;
            }
        };
        objDefine(handler, "toJSON", { v: function () { return "WatcherHandler" + (handler.fn ? "" : "[X]"); } });
        state.use(handler, configHandler);
        return handler;
    }
    function _createDynamicHandler(logger, target, inPlace) {
        var _a;
        var dynamicHandler = getDynamicConfigHandler(target);
        if (dynamicHandler) {
            return dynamicHandler;
        }
        var uid = createUniqueNamespace("dyncfg", true);
        var newTarget = (target && inPlace !== false) ? target : _cfgDeepCopy(target);
        var theState;
        function _notifyWatchers() {
            theState[_DYN_NOTIFY ]();
        }
        function _setValue(target, name, value) {
            try {
                target = _setDynamicProperty(theState, target, name, value);
            }
            catch (e) {
                _throwDynamicError(logger, name, "Setting value", e);
            }
            return target[name];
        }
        function _watch(configHandler) {
            return _createAndUseHandler(theState, configHandler);
        }
        function _block(configHandler, allowUpdate) {
            theState.use(null, function (details) {
                var prevUpd = theState.upd;
                try {
                    if (!isUndefined(allowUpdate)) {
                        theState.upd = allowUpdate;
                    }
                    configHandler(details);
                }
                finally {
                    theState.upd = prevUpd;
                }
            });
        }
        function _ref(target, name) {
            var _a;
            return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[0 ] = true, _a))[name];
        }
        function _rdOnly(target, name) {
            var _a;
            return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[1 ] = true, _a))[name];
        }
        function _blkPropValue(target, name) {
            var _a;
            return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[2 ] = true, _a))[name];
        }
        function _applyDefaults(theConfig, defaultValues) {
            if (defaultValues) {
                objForEachKey(defaultValues, function (name, value) {
                    _applyDefaultValue(cfgHandler, theConfig, name, value);
                });
            }
            return theConfig;
        }
        var cfgHandler = (_a = {
                uid: null,
                cfg: newTarget
            },
            _a[_DYN_LOGGER ] = logger,
            _a[_DYN_NOTIFY ] = _notifyWatchers,
            _a.set = _setValue,
            _a[_DYN_SET_DF ] = _applyDefaults,
            _a[_DYN_WATCH ] = _watch,
            _a.ref = _ref,
            _a[_DYN_RD_ONLY ] = _rdOnly,
            _a[_DYN_BLK_VAL ] = _blkPropValue,
            _a._block = _block,
            _a);
        objDefine(cfgHandler, "uid", {
            c: false,
            e: false,
            w: false,
            v: uid
        });
        theState = _createState(cfgHandler);
        _makeDynamicObject(theState, newTarget, "config", "Creating");
        return cfgHandler;
    }
    function _logInvalidAccess(logger, message) {
        if (logger) {
            logger[_DYN_WARN_TO_CONSOLE ](message);
            logger[_DYN_THROW_INTERNAL ](2 , 108 , message);
        }
        else {
            throwInvalidAccess(message);
        }
    }
    function createDynamicConfig(config, defaultConfig, logger, inPlace) {
        var dynamicHandler = _createDynamicHandler(logger, config || {}, inPlace);
        if (defaultConfig) {
            dynamicHandler[_DYN_SET_DF ](dynamicHandler.cfg, defaultConfig);
        }
        return dynamicHandler;
    }
    function onConfigChange(config, configHandler, logger) {
        var handler = config[CFG_HANDLER_LINK] || config;
        if (handler.cfg && (handler.cfg === config || handler.cfg[CFG_HANDLER_LINK] === handler)) {
            return handler[_DYN_WATCH ](configHandler);
        }
        _logInvalidAccess(logger, STR_NOT_DYNAMIC_ERROR + dumpObj(config));
        return createDynamicConfig(config, null, logger)[_DYN_WATCH ](configHandler);
    }

    var _aiNamespace = null;
    function _getExtensionNamespace() {
        var target = getInst("Microsoft");
        if (target) {
            _aiNamespace = target["ApplicationInsights"];
        }
        return _aiNamespace;
    }
    function getDebugExt(config) {
        var ns = _aiNamespace;
        if (!ns && config.disableDbgExt !== true) {
            ns = _aiNamespace || _getExtensionNamespace();
        }
        return ns ? ns["ChromeDbgExt"] : null;
    }

    var _a;
    var STR_WARN_TO_CONSOLE = "warnToConsole";
    var AiNonUserActionablePrefix = "AI (Internal): ";
    var AiUserActionablePrefix = "AI: ";
    var AIInternalMessagePrefix = "AITR_";
    var defaultValues = {
        loggingLevelConsole: 0,
        loggingLevelTelemetry: 1,
        maxMessageLimit: 25,
        enableDebug: false
    };
    var _logFuncs = (_a = {},
        _a[0 ] = null,
        _a[1 ] = "errorToConsole",
        _a[2 ] = STR_WARN_TO_CONSOLE,
        _a[3 ] = "debugToConsole",
        _a);
    function _sanitizeDiagnosticText(text) {
        if (text) {
            return "\"" + text[_DYN_REPLACE ](/\"/g, STR_EMPTY) + "\"";
        }
        return STR_EMPTY;
    }
    function _logToConsole(func, message) {
        var theConsole = getConsole();
        if (!!theConsole) {
            var logFunc = "log";
            if (theConsole[func]) {
                logFunc = func;
            }
            if (isFunction(theConsole[logFunc])) {
                theConsole[logFunc](message);
            }
        }
    }
    var _InternalLogMessage = /** @class */ (function () {
        function _InternalLogMessage(msgId, msg, isUserAct, properties) {
            if (isUserAct === void 0) { isUserAct = false; }
            var _self = this;
            _self[_DYN_MESSAGE_ID ] = msgId;
            _self[_DYN_MESSAGE$1 ] =
                (isUserAct ? AiUserActionablePrefix : AiNonUserActionablePrefix) +
                    msgId;
            var strProps = STR_EMPTY;
            if (hasJSON()) {
                strProps = getJSON().stringify(properties);
            }
            var diagnosticText = (msg ? " message:" + _sanitizeDiagnosticText(msg) : STR_EMPTY) +
                (properties ? " props:" + _sanitizeDiagnosticText(strProps) : STR_EMPTY);
            _self[_DYN_MESSAGE$1 ] += diagnosticText;
        }
        _InternalLogMessage.dataType = "MessageData";
        return _InternalLogMessage;
    }());
    function safeGetLogger(core, config) {
        return (core || {})[_DYN_LOGGER ] || new DiagnosticLogger(config);
    }
    var DiagnosticLogger = /** @class */ (function () {
        function DiagnosticLogger(config) {
            this.identifier = "DiagnosticLogger";
            this.queue = [];
            var _messageCount = 0;
            var _messageLogged = {};
            var _loggingLevelConsole;
            var _loggingLevelTelemetry;
            var _maxInternalMessageLimit;
            var _enableDebug;
            var _unloadHandler;
            dynamicProto(DiagnosticLogger, this, function (_self) {
                _unloadHandler = _setDefaultsFromConfig(config || {});
                _self.consoleLoggingLevel = function () { return _loggingLevelConsole; };
                _self[_DYN_THROW_INTERNAL ] = function (severity, msgId, msg, properties, isUserAct) {
                    if (isUserAct === void 0) { isUserAct = false; }
                    var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);
                    if (_enableDebug) {
                        throw dumpObj(message);
                    }
                    else {
                        var logFunc = _logFuncs[severity] || STR_WARN_TO_CONSOLE;
                        if (!isUndefined(message[_DYN_MESSAGE$1 ])) {
                            if (isUserAct) {
                                var messageKey = +message[_DYN_MESSAGE_ID ];
                                if (!_messageLogged[messageKey] && _loggingLevelConsole >= severity) {
                                    _self[logFunc](message[_DYN_MESSAGE$1 ]);
                                    _messageLogged[messageKey] = true;
                                }
                            }
                            else {
                                if (_loggingLevelConsole >= severity) {
                                    _self[logFunc](message[_DYN_MESSAGE$1 ]);
                                }
                            }
                            _logInternalMessage(severity, message);
                        }
                        else {
                            _debugExtMsg("throw" + (severity === 1  ? "Critical" : "Warning"), message);
                        }
                    }
                };
                _self.debugToConsole = function (message) {
                    _logToConsole("debug", message);
                    _debugExtMsg("warning", message);
                };
                _self[_DYN_WARN_TO_CONSOLE ] = function (message) {
                    _logToConsole("warn", message);
                    _debugExtMsg("warning", message);
                };
                _self.errorToConsole = function (message) {
                    _logToConsole("error", message);
                    _debugExtMsg("error", message);
                };
                _self.resetInternalMessageCount = function () {
                    _messageCount = 0;
                    _messageLogged = {};
                };
                _self[_DYN_LOG_INTERNAL_MESSAGE ] = _logInternalMessage;
                _self[_DYN_UNLOAD ] = function (isAsync) {
                    _unloadHandler && _unloadHandler.rm();
                    _unloadHandler = null;
                };
                function _logInternalMessage(severity, message) {
                    if (_areInternalMessagesThrottled()) {
                        return;
                    }
                    var logMessage = true;
                    var messageKey = AIInternalMessagePrefix + message[_DYN_MESSAGE_ID ];
                    if (_messageLogged[messageKey]) {
                        logMessage = false;
                    }
                    else {
                        _messageLogged[messageKey] = true;
                    }
                    if (logMessage) {
                        if (severity <= _loggingLevelTelemetry) {
                            _self.queue[_DYN_PUSH$1 ](message);
                            _messageCount++;
                            _debugExtMsg((severity === 1  ? "error" : "warn"), message);
                        }
                        if (_messageCount === _maxInternalMessageLimit) {
                            var throttleLimitMessage = "Internal events throttle limit per PageView reached for this app.";
                            var throttleMessage = new _InternalLogMessage(23 , throttleLimitMessage, false);
                            _self.queue[_DYN_PUSH$1 ](throttleMessage);
                            if (severity === 1 ) {
                                _self.errorToConsole(throttleLimitMessage);
                            }
                            else {
                                _self[_DYN_WARN_TO_CONSOLE ](throttleLimitMessage);
                            }
                        }
                    }
                }
                function _setDefaultsFromConfig(config) {
                    return onConfigChange(createDynamicConfig(config, defaultValues, _self).cfg, function (details) {
                        var config = details.cfg;
                        _loggingLevelConsole = config[_DYN_LOGGING_LEVEL_CONSOL4 ];
                        _loggingLevelTelemetry = config.loggingLevelTelemetry;
                        _maxInternalMessageLimit = config.maxMessageLimit;
                        _enableDebug = config.enableDebug;
                    });
                }
                function _areInternalMessagesThrottled() {
                    return _messageCount >= _maxInternalMessageLimit;
                }
                function _debugExtMsg(name, data) {
                    var dbgExt = getDebugExt(config || {});
                    if (dbgExt && dbgExt[_DYN_DIAG_LOG ]) {
                        dbgExt[_DYN_DIAG_LOG ](name, data);
                    }
                }
            });
        }
        DiagnosticLogger.__ieDyn=1;
        return DiagnosticLogger;
    }());
    function _getLogger(logger) {
        return (logger || new DiagnosticLogger());
    }
    function _throwInternal(logger, severity, msgId, msg, properties, isUserAct) {
        if (isUserAct === void 0) { isUserAct = false; }
        _getLogger(logger)[_DYN_THROW_INTERNAL ](severity, msgId, msg, properties, isUserAct);
    }

    function generateW3CId() {
        var hexValues = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
        var oct = STR_EMPTY, tmp;
        for (var a = 0; a < 4; a++) {
            tmp = random32();
            oct +=
                hexValues[tmp & 0xF] +
                    hexValues[tmp >> 4 & 0xF] +
                    hexValues[tmp >> 8 & 0xF] +
                    hexValues[tmp >> 12 & 0xF] +
                    hexValues[tmp >> 16 & 0xF] +
                    hexValues[tmp >> 20 & 0xF] +
                    hexValues[tmp >> 24 & 0xF] +
                    hexValues[tmp >> 28 & 0xF];
        }
        var clockSequenceHi = hexValues[8 + (random32() & 0x03) | 0];
        return strSubstr(oct, 0, 8) + strSubstr(oct, 9, 4) + "4" + strSubstr(oct, 13, 3) + clockSequenceHi + strSubstr(oct, 16, 3) + strSubstr(oct, 19, 12);
    }

    var TRACE_PARENT_REGEX = /^([\da-f]{2})-([\da-f]{32})-([\da-f]{16})-([\da-f]{2})(-[^\s]{1,64})?$/i;
    var DEFAULT_VERSION = "00";
    var INVALID_VERSION = "ff";
    var INVALID_TRACE_ID = "00000000000000000000000000000000";
    var INVALID_SPAN_ID = "0000000000000000";
    var SAMPLED_FLAG = 0x01;
    function _isValid(value, len, invalidValue) {
        if (value && value[_DYN_LENGTH$1 ] === len && value !== invalidValue) {
            return !!value.match(/^[\da-f]*$/i);
        }
        return false;
    }
    function _formatValue(value, len, defValue) {
        if (_isValid(value, len)) {
            return value;
        }
        return defValue;
    }
    function _formatFlags(value) {
        if (isNaN(value) || value < 0 || value > 255) {
            value = 0x01;
        }
        var result = value.toString(16);
        while (result[_DYN_LENGTH$1 ] < 2) {
            result = "0" + result;
        }
        return result;
    }
    function createTraceParent(traceId, spanId, flags, version) {
        var _a;
        return _a = {},
            _a[_DYN_VERSION ] = _isValid(version, 2, INVALID_VERSION) ? version : DEFAULT_VERSION,
            _a[_DYN_TRACE_ID ] = isValidTraceId(traceId) ? traceId : generateW3CId(),
            _a[_DYN_SPAN_ID ] = isValidSpanId(spanId) ? spanId : strLeft(generateW3CId(), 16),
            _a.traceFlags = flags >= 0 && flags <= 0xFF ? flags : 1,
            _a;
    }
    function parseTraceParent(value, selectIdx) {
        var _a;
        if (!value) {
            return null;
        }
        if (isArray(value)) {
            value = value[0] || "";
        }
        if (!value || !isString(value) || value[_DYN_LENGTH$1 ] > 8192) {
            return null;
        }
        if (value.indexOf(",") !== -1) {
            var values = value[_DYN_SPLIT$1 ](",");
            value = values[selectIdx > 0 && values[_DYN_LENGTH$1 ] > selectIdx ? selectIdx : 0];
        }
        var match = TRACE_PARENT_REGEX.exec(strTrim(value));
        if (!match ||
            match[1] === INVALID_VERSION ||
            match[2] === INVALID_TRACE_ID ||
            match[3] === INVALID_SPAN_ID) {
            return null;
        }
        return _a = {
                version: (match[1] || STR_EMPTY)[_DYN_TO_LOWER_CASE$1 ](),
                traceId: (match[2] || STR_EMPTY)[_DYN_TO_LOWER_CASE$1 ](),
                spanId: (match[3] || STR_EMPTY)[_DYN_TO_LOWER_CASE$1 ]()
            },
            _a[_DYN_TRACE_FLAGS ] = parseInt(match[4], 16),
            _a;
    }
    function isValidTraceId(value) {
        return _isValid(value, 32, INVALID_TRACE_ID);
    }
    function isValidSpanId(value) {
        return _isValid(value, 16, INVALID_SPAN_ID);
    }
    function isValidTraceParent(value) {
        if (!value ||
            !_isValid(value[_DYN_VERSION ], 2, INVALID_VERSION) ||
            !_isValid(value[_DYN_TRACE_ID ], 32, INVALID_TRACE_ID) ||
            !_isValid(value[_DYN_SPAN_ID ], 16, INVALID_SPAN_ID) ||
            !_isValid(_formatFlags(value[_DYN_TRACE_FLAGS ]), 2)) {
            return false;
        }
        return true;
    }
    function isSampledFlag(value) {
        if (isValidTraceParent(value)) {
            return (value[_DYN_TRACE_FLAGS ] & SAMPLED_FLAG) === SAMPLED_FLAG;
        }
        return false;
    }
    function formatTraceParent(value) {
        if (value) {
            var flags = _formatFlags(value[_DYN_TRACE_FLAGS ]);
            if (!_isValid(flags, 2)) {
                flags = "01";
            }
            var version = value[_DYN_VERSION ] || DEFAULT_VERSION;
            if (version !== "00" && version !== "ff") {
                version = DEFAULT_VERSION;
            }
            return "".concat(version.toLowerCase(), "-").concat(_formatValue(value.traceId, 32, INVALID_TRACE_ID).toLowerCase(), "-").concat(_formatValue(value.spanId, 16, INVALID_SPAN_ID).toLowerCase(), "-").concat(flags.toLowerCase());
        }
        return "";
    }
    function findW3cTraceParent(selectIdx) {
        var name = "traceparent";
        var traceParent = parseTraceParent(findMetaTag(name), selectIdx);
        if (!traceParent) {
            traceParent = parseTraceParent(findNamedServerTiming(name), selectIdx);
        }
        return traceParent;
    }

    var strOnPrefix = "on";
    var strAttachEvent = "attachEvent";
    var strAddEventHelper = "addEventListener";
    var strDetachEvent = "detachEvent";
    var strRemoveEventListener = "removeEventListener";
    var strEvents = "events";
    createUniqueNamespace("aiEvtPageHide");
    createUniqueNamespace("aiEvtPageShow");
    var rRemoveEmptyNs = /\.[\.]+/g;
    var rRemoveTrailingEmptyNs = /[\.]+$/;
    var _guid = 1;
    var elmNodeData = createElmNodeData("events");
    var eventNamespace = /^([^.]*)(?:\.(.+)|)/;
    function _normalizeNamespace(name) {
        if (name && name[_DYN_REPLACE ]) {
            return name[_DYN_REPLACE ](/^[\s\.]+|(?=[\s\.])[\.\s]+$/g, STR_EMPTY);
        }
        return name;
    }
    function _getEvtNamespace(eventName, evtNamespace) {
        var _a;
        if (evtNamespace) {
            var theNamespace_1 = STR_EMPTY;
            if (isArray(evtNamespace)) {
                theNamespace_1 = STR_EMPTY;
                arrForEach(evtNamespace, function (name) {
                    name = _normalizeNamespace(name);
                    if (name) {
                        if (name[0] !== ".") {
                            name = "." + name;
                        }
                        theNamespace_1 += name;
                    }
                });
            }
            else {
                theNamespace_1 = _normalizeNamespace(evtNamespace);
            }
            if (theNamespace_1) {
                if (theNamespace_1[0] !== ".") {
                    theNamespace_1 = "." + theNamespace_1;
                }
                eventName = (eventName || STR_EMPTY) + theNamespace_1;
            }
        }
        var parsedEvent = (eventNamespace.exec(eventName || STR_EMPTY) || []);
        return _a = {},
            _a[_DYN_TYPE ] = parsedEvent[1],
            _a.ns = ((parsedEvent[2] || STR_EMPTY).replace(rRemoveEmptyNs, ".").replace(rRemoveTrailingEmptyNs, STR_EMPTY)[_DYN_SPLIT$1 ](".").sort()).join("."),
            _a;
    }
    function _getRegisteredEvents(target, evtName, addDefault) {
        if (addDefault === void 0) { addDefault = true; }
        var aiEvts = elmNodeData.get(target, strEvents, {}, addDefault);
        var registeredEvents = aiEvts[evtName];
        if (!registeredEvents) {
            registeredEvents = aiEvts[evtName] = [];
        }
        return registeredEvents;
    }
    function _doDetach(obj, evtName, handlerRef, useCapture) {
        if (obj && evtName && evtName[_DYN_TYPE ]) {
            if (obj[strRemoveEventListener]) {
                obj[strRemoveEventListener](evtName[_DYN_TYPE ], handlerRef, useCapture);
            }
            else if (obj[strDetachEvent]) {
                obj[strDetachEvent](strOnPrefix + evtName[_DYN_TYPE ], handlerRef);
            }
        }
    }
    function _doAttach(obj, evtName, handlerRef, useCapture) {
        var result = false;
        if (obj && evtName && evtName[_DYN_TYPE ] && handlerRef) {
            if (obj[strAddEventHelper]) {
                obj[strAddEventHelper](evtName[_DYN_TYPE ], handlerRef, useCapture);
                result = true;
            }
            else if (obj[strAttachEvent]) {
                obj[strAttachEvent](strOnPrefix + evtName[_DYN_TYPE ], handlerRef);
                result = true;
            }
        }
        return result;
    }
    function _doUnregister(target, events, evtName, unRegFn) {
        var idx = events[_DYN_LENGTH$1 ];
        while (idx--) {
            var theEvent = events[idx];
            if (theEvent) {
                if (!evtName.ns || evtName.ns === theEvent.evtName.ns) {
                    if (!unRegFn || unRegFn(theEvent)) {
                        _doDetach(target, theEvent.evtName, theEvent[_DYN_HANDLER ], theEvent.capture);
                        events[_DYN_SPLICE ](idx, 1);
                    }
                }
            }
        }
    }
    function _unregisterEvents(target, evtName, unRegFn) {
        if (evtName[_DYN_TYPE ]) {
            _doUnregister(target, _getRegisteredEvents(target, evtName[_DYN_TYPE ]), evtName, unRegFn);
        }
        else {
            var eventCache = elmNodeData.get(target, strEvents, {});
            objForEachKey(eventCache, function (evtType, events) {
                _doUnregister(target, events, evtName, unRegFn);
            });
            if (objKeys(eventCache)[_DYN_LENGTH$1 ] === 0) {
                elmNodeData.kill(target, strEvents);
            }
        }
    }
    function mergeEvtNamespace(theNamespace, namespaces) {
        var newNamespaces;
        if (namespaces) {
            if (isArray(namespaces)) {
                newNamespaces = [theNamespace].concat(namespaces);
            }
            else {
                newNamespaces = [theNamespace, namespaces];
            }
            newNamespaces = (_getEvtNamespace("xx", newNamespaces).ns)[_DYN_SPLIT$1 ](".");
        }
        else {
            newNamespaces = theNamespace;
        }
        return newNamespaces;
    }
    function eventOn(target, eventName, handlerRef, evtNamespace, useCapture) {
        var _a;
        if (useCapture === void 0) { useCapture = false; }
        var result = false;
        if (target) {
            try {
                var evtName = _getEvtNamespace(eventName, evtNamespace);
                result = _doAttach(target, evtName, handlerRef, useCapture);
                if (result && elmNodeData.accept(target)) {
                    var registeredEvent = (_a = {
                            guid: _guid++,
                            evtName: evtName
                        },
                        _a[_DYN_HANDLER ] = handlerRef,
                        _a.capture = useCapture,
                        _a);
                    _getRegisteredEvents(target, evtName.type)[_DYN_PUSH$1 ](registeredEvent);
                }
            }
            catch (e) {
            }
        }
        return result;
    }
    function eventOff(target, eventName, handlerRef, evtNamespace, useCapture) {
        if (useCapture === void 0) { useCapture = false; }
        if (target) {
            try {
                var evtName_1 = _getEvtNamespace(eventName, evtNamespace);
                var found_1 = false;
                _unregisterEvents(target, evtName_1, function (regEvent) {
                    if ((evtName_1.ns && !handlerRef) || regEvent[_DYN_HANDLER ] === handlerRef) {
                        found_1 = true;
                        return true;
                    }
                    return false;
                });
                if (!found_1) {
                    _doDetach(target, evtName_1, handlerRef, useCapture);
                }
            }
            catch (e) {
            }
        }
    }

    var DisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
    var SampleRate = "sampleRate";
    var ProcessLegacy = "ProcessLegacy";
    var HttpMethod = "http.method";
    var DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com";
    var DEFAULT_BREEZE_PATH = "/v2/track";
    var strNotSpecified = "not_specified";
    var strIkey = "iKey";

    var RequestHeaders = createValueMap({
        requestContextHeader: [0 , "Request-Context"],
        requestContextTargetKey: [1 , "appId"],
        requestContextAppIdFormat: [2 , "appId=cid-v1:"],
        requestIdHeader: [3 , "Request-Id"],
        traceParentHeader: [4 , "traceparent"],
        traceStateHeader: [5 , "tracestate"],
        sdkContextHeader: [6 , "Sdk-Context"],
        sdkContextHeaderAppIdRequest: [7 , "appId"],
        requestContextHeaderLowerCase: [8 , "request-context"]
    });

    var _DYN_SPLIT = "split";
    var _DYN_LENGTH = "length";
    var _DYN_TO_LOWER_CASE = "toLowerCase";
    var _DYN_INGESTIONENDPOINT = "ingestionendpoint";
    var _DYN_TO_STRING = "toString";
    var _DYN_PUSH = "push";
    var _DYN_REMOVE_ITEM = "removeItem";
    var _DYN_NAME = "name";
    var _DYN_MESSAGE = "message";
    var _DYN_COUNT = "count";
    var _DYN_PRE_TRIGGER_DATE = "preTriggerDate";
    var _DYN_DISABLED = "disabled";
    var _DYN_INTERVAL = "interval";
    var _DYN_DAYS_OF_MONTH = "daysOfMonth";
    var _DYN_DATE = "date";
    var _DYN_GET_UTCDATE = "getUTCDate";
    var _DYN_STRINGIFY = "stringify";
    var _DYN_PATHNAME = "pathname";
    var _DYN_CORRELATION_HEADER_E0 = "correlationHeaderExcludePatterns";
    var _DYN_EXTENSION_CONFIG = "extensionConfig";
    var _DYN_EXCEPTIONS = "exceptions";
    var _DYN_PARSED_STACK = "parsedStack";
    var _DYN_PROPERTIES = "properties";
    var _DYN_MEASUREMENTS = "measurements";
    var _DYN_SIZE_IN_BYTES = "sizeInBytes";
    var _DYN_TYPE_NAME = "typeName";
    var _DYN_SEVERITY_LEVEL = "severityLevel";
    var _DYN_PROBLEM_GROUP = "problemGroup";
    var _DYN_IS_MANUAL = "isManual";
    var _DYN__CREATE_FROM_INTERFA1 = "CreateFromInterface";
    var _DYN_ASSEMBLY = "assembly";
    var _DYN_FILE_NAME = "fileName";
    var _DYN_HAS_FULL_STACK = "hasFullStack";
    var _DYN_LEVEL = "level";
    var _DYN_METHOD = "method";
    var _DYN_LINE = "line";
    var _DYN_DURATION = "duration";
    var _DYN_RECEIVED_RESPONSE = "receivedResponse";

    function dataSanitizeKeyAndAddUniqueness(logger, key, map) {
        var origLength = key[_DYN_LENGTH ];
        var field = dataSanitizeKey(logger, key);
        if (field[_DYN_LENGTH ] !== origLength) {
            var i = 0;
            var uniqueField = field;
            while (map[uniqueField] !== undefined) {
                i++;
                uniqueField = strSubstring(field, 0, 150  - 3) + dsPadNumber(i);
            }
            field = uniqueField;
        }
        return field;
    }
    function dataSanitizeKey(logger, name) {
        var nameTrunc;
        if (name) {
            name = strTrim(asString(name));
            if (name[_DYN_LENGTH ] > 150 ) {
                nameTrunc = strSubstring(name, 0, 150 );
                _throwInternal(logger, 2 , 57 , "name is too long.  It has been truncated to " + 150  + " characters.", { name: name }, true);
            }
        }
        return nameTrunc || name;
    }
    function dataSanitizeString(logger, value, maxLength) {
        if (maxLength === void 0) { maxLength = 1024 ; }
        var valueTrunc;
        if (value) {
            maxLength = maxLength ? maxLength : 1024 ;
            value = strTrim(asString(value));
            if (value[_DYN_LENGTH ] > maxLength) {
                valueTrunc = strSubstring(value, 0, maxLength);
                _throwInternal(logger, 2 , 61 , "string value is too long. It has been truncated to " + maxLength + " characters.", { value: value }, true);
            }
        }
        return valueTrunc || value;
    }
    function dataSanitizeUrl(logger, url) {
        return dataSanitizeInput(logger, url, 2048 , 66 );
    }
    function dataSanitizeMessage(logger, message) {
        var messageTrunc;
        if (message) {
            if (message[_DYN_LENGTH ] > 32768 ) {
                messageTrunc = strSubstring(message, 0, 32768 );
                _throwInternal(logger, 2 , 56 , "message is too long, it has been truncated to " + 32768  + " characters.", { message: message }, true);
            }
        }
        return messageTrunc || message;
    }
    function dataSanitizeException(logger, exception) {
        var exceptionTrunc;
        if (exception) {
            var value = "" + exception;
            if (value[_DYN_LENGTH ] > 32768 ) {
                exceptionTrunc = strSubstring(value, 0, 32768 );
                _throwInternal(logger, 2 , 52 , "exception is too long, it has been truncated to " + 32768  + " characters.", { exception: exception }, true);
            }
        }
        return exceptionTrunc || exception;
    }
    function dataSanitizeProperties(logger, properties) {
        if (properties) {
            var tempProps_1 = {};
            objForEachKey(properties, function (prop, value) {
                if (isObject(value) && hasJSON()) {
                    try {
                        value = getJSON()[_DYN_STRINGIFY ](value);
                    }
                    catch (e) {
                        _throwInternal(logger, 2 , 49 , "custom property is not valid", { exception: e }, true);
                    }
                }
                value = dataSanitizeString(logger, value, 8192 );
                prop = dataSanitizeKeyAndAddUniqueness(logger, prop, tempProps_1);
                tempProps_1[prop] = value;
            });
            properties = tempProps_1;
        }
        return properties;
    }
    function dataSanitizeMeasurements(logger, measurements) {
        if (measurements) {
            var tempMeasurements_1 = {};
            objForEachKey(measurements, function (measure, value) {
                measure = dataSanitizeKeyAndAddUniqueness(logger, measure, tempMeasurements_1);
                tempMeasurements_1[measure] = value;
            });
            measurements = tempMeasurements_1;
        }
        return measurements;
    }
    function dataSanitizeId(logger, id) {
        return id ? dataSanitizeInput(logger, id, 128 , 69 )[_DYN_TO_STRING ]() : id;
    }
    function dataSanitizeInput(logger, input, maxLength, _msgId) {
        var inputTrunc;
        if (input) {
            input = strTrim(asString(input));
            if (input[_DYN_LENGTH ] > maxLength) {
                inputTrunc = strSubstring(input, 0, maxLength);
                _throwInternal(logger, 2 , _msgId, "input is too long, it has been truncated to " + maxLength + " characters.", { data: input }, true);
            }
        }
        return inputTrunc || input;
    }
    function dsPadNumber(num) {
        var s = "00" + num;
        return strSubstr(s, s[_DYN_LENGTH ] - 3);
    }

    var _document = getDocument() || {};
    var _htmlAnchorIdx = 0;
    var _htmlAnchorElement = [null, null, null, null, null];
    function urlParseUrl(url) {
        var anchorIdx = _htmlAnchorIdx;
        var anchorCache = _htmlAnchorElement;
        var tempAnchor = anchorCache[anchorIdx];
        if (!_document.createElement) {
            tempAnchor = { host: urlParseHost(url, true) };
        }
        else if (!anchorCache[anchorIdx]) {
            tempAnchor = anchorCache[anchorIdx] = _document.createElement("a");
        }
        tempAnchor.href = url;
        anchorIdx++;
        if (anchorIdx >= anchorCache[_DYN_LENGTH ]) {
            anchorIdx = 0;
        }
        _htmlAnchorIdx = anchorIdx;
        return tempAnchor;
    }
    function urlGetAbsoluteUrl(url) {
        var result;
        var a = urlParseUrl(url);
        if (a) {
            result = a.href;
        }
        return result;
    }
    function urlGetPathName(url) {
        var result;
        var a = urlParseUrl(url);
        if (a) {
            result = a[_DYN_PATHNAME ];
        }
        return result;
    }
    function urlGetCompleteUrl(method, absoluteUrl) {
        if (method) {
            return method.toUpperCase() + " " + absoluteUrl;
        }
        return absoluteUrl;
    }
    function urlParseHost(url, inclPort) {
        var fullHost = urlParseFullHost(url, inclPort) || "";
        if (fullHost) {
            var match = fullHost.match(/(www\d{0,5}\.)?([^\/:]{1,256})(:\d{1,20})?/i);
            if (match != null && match[_DYN_LENGTH ] > 3 && isString(match[2]) && match[2][_DYN_LENGTH ] > 0) {
                return match[2] + (match[3] || "");
            }
        }
        return fullHost;
    }
    function urlParseFullHost(url, inclPort) {
        var result = null;
        if (url) {
            var match = url.match(/(\w{1,150}):\/\/([^\/:]{1,256})(:\d{1,20})?/i);
            if (match != null && match[_DYN_LENGTH ] > 2 && isString(match[2]) && match[2][_DYN_LENGTH ] > 0) {
                result = match[2] || "";
                if (inclPort && match[_DYN_LENGTH ] > 2) {
                    var protocol = (match[1] || "")[_DYN_TO_LOWER_CASE ]();
                    var port = match[3] || "";
                    if (protocol === "http" && port === ":80") {
                        port = "";
                    }
                    else if (protocol === "https" && port === ":443") {
                        port = "";
                    }
                    result += port;
                }
            }
        }
        return result;
    }

    var _internalEndpoints = [
        DEFAULT_BREEZE_ENDPOINT + DEFAULT_BREEZE_PATH,
        "https://breeze.aimon.applicationinsights.io" + DEFAULT_BREEZE_PATH,
        "https://dc-int.services.visualstudio.com" + DEFAULT_BREEZE_PATH
    ];
    var _correlationIdPrefix = "cid-v1:";
    function isInternalApplicationInsightsEndpoint(endpointUrl) {
        return arrIndexOf(_internalEndpoints, endpointUrl[_DYN_TO_LOWER_CASE ]()) !== -1;
    }
    function correlationIdSetPrefix(prefix) {
        _correlationIdPrefix = prefix;
    }
    function correlationIdGetPrefix() {
        return _correlationIdPrefix;
    }
    function correlationIdCanIncludeCorrelationHeader(config, requestUrl, currentHost) {
        if (!requestUrl || (config && config.disableCorrelationHeaders)) {
            return false;
        }
        if (config && config[_DYN_CORRELATION_HEADER_E0 ]) {
            for (var i = 0; i < config.correlationHeaderExcludePatterns[_DYN_LENGTH ]; i++) {
                if (config[_DYN_CORRELATION_HEADER_E0 ][i].test(requestUrl)) {
                    return false;
                }
            }
        }
        var requestHost = urlParseUrl(requestUrl).host[_DYN_TO_LOWER_CASE ]();
        if (requestHost && (strIndexOf(requestHost, ":443") !== -1 || strIndexOf(requestHost, ":80") !== -1)) {
            requestHost = (urlParseFullHost(requestUrl, true) || "")[_DYN_TO_LOWER_CASE ]();
        }
        if ((!config || !config.enableCorsCorrelation) && (requestHost && requestHost !== currentHost)) {
            return false;
        }
        var includedDomains = config && config.correlationHeaderDomains;
        if (includedDomains) {
            var matchExists_1;
            arrForEach(includedDomains, function (domain) {
                var regex = new RegExp(domain.toLowerCase().replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*"));
                matchExists_1 = matchExists_1 || regex.test(requestHost);
            });
            if (!matchExists_1) {
                return false;
            }
        }
        var excludedDomains = config && config.correlationHeaderExcludedDomains;
        if (!excludedDomains || excludedDomains[_DYN_LENGTH ] === 0) {
            return true;
        }
        for (var i = 0; i < excludedDomains[_DYN_LENGTH ]; i++) {
            var regex = new RegExp(excludedDomains[i].toLowerCase().replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*"));
            if (regex.test(requestHost)) {
                return false;
            }
        }
        return requestHost && requestHost[_DYN_LENGTH ] > 0;
    }
    function correlationIdGetCorrelationContext(responseHeader) {
        if (responseHeader) {
            var correlationId = correlationIdGetCorrelationContextValue(responseHeader, RequestHeaders[1 ]);
            if (correlationId && correlationId !== _correlationIdPrefix) {
                return correlationId;
            }
        }
    }
    function correlationIdGetCorrelationContextValue(responseHeader, key) {
        if (responseHeader) {
            var keyValues = responseHeader[_DYN_SPLIT ](",");
            for (var i = 0; i < keyValues[_DYN_LENGTH ]; ++i) {
                var keyValue = keyValues[i][_DYN_SPLIT ]("=");
                if (keyValue[_DYN_LENGTH ] === 2 && keyValue[0] === key) {
                    return keyValue[1];
                }
            }
        }
    }
    function AjaxHelperParseDependencyPath(logger, absoluteUrl, method, commandName) {
        var target, name = commandName, data = commandName;
        if (absoluteUrl && absoluteUrl[_DYN_LENGTH ] > 0) {
            var parsedUrl = urlParseUrl(absoluteUrl);
            target = parsedUrl.host;
            if (!name) {
                if (parsedUrl[_DYN_PATHNAME ] != null) {
                    var pathName = (parsedUrl.pathname[_DYN_LENGTH ] === 0) ? "/" : parsedUrl[_DYN_PATHNAME ];
                    if (pathName.charAt(0) !== "/") {
                        pathName = "/" + pathName;
                    }
                    data = parsedUrl[_DYN_PATHNAME ];
                    name = dataSanitizeString(logger, method ? method + " " + pathName : pathName);
                }
                else {
                    name = dataSanitizeString(logger, absoluteUrl);
                }
            }
        }
        else {
            target = commandName;
            name = commandName;
        }
        return {
            target: target,
            name: name,
            data: data
        };
    }
    function dateTimeUtilsNow() {
        var perf = getPerformance();
        if (perf && perf.now && perf.timing) {
            var now = perf.now() + perf.timing.navigationStart;
            if (now > 0) {
                return now;
            }
        }
        return utcNow();
    }
    function dateTimeUtilsDuration(start, end) {
        var result = null;
        if (start !== 0 && end !== 0 && !isNullOrUndefined(start) && !isNullOrUndefined(end)) {
            result = end - start;
        }
        return result;
    }
    function createDistributedTraceContextFromTrace(telemetryTrace, parentCtx) {
        var trace = telemetryTrace || {};
        return {
            getName: function () {
                return trace[_DYN_NAME ];
            },
            setName: function (newValue) {
                parentCtx && parentCtx.setName(newValue);
                trace[_DYN_NAME ] = newValue;
            },
            getTraceId: function () {
                return trace.traceID;
            },
            setTraceId: function (newValue) {
                parentCtx && parentCtx.setTraceId(newValue);
                if (isValidTraceId(newValue)) {
                    trace.traceID = newValue;
                }
            },
            getSpanId: function () {
                return trace.parentID;
            },
            setSpanId: function (newValue) {
                parentCtx && parentCtx.setSpanId(newValue);
                if (isValidSpanId(newValue)) {
                    trace.parentID = newValue;
                }
            },
            getTraceFlags: function () {
                return trace.traceFlags;
            },
            setTraceFlags: function (newTraceFlags) {
                parentCtx && parentCtx.setTraceFlags(newTraceFlags);
                trace.traceFlags = newTraceFlags;
            }
        };
    }

    var StorageType = createEnumStyle({
        LocalStorage: 0 ,
        SessionStorage: 1
    });
    var DistributedTracingModes = createEnumStyle({
        AI: 0 ,
        AI_AND_W3C: 1 ,
        W3C: 2
    });
    var EventPersistence = createEnumStyle({
        Normal: 1 ,
        Critical: 2
    });

    var _canUseLocalStorage = undefined;
    var _canUseSessionStorage = undefined;
    var _storagePrefix = "";
    function _getLocalStorageObject() {
        if (utlCanUseLocalStorage()) {
            return _getVerifiedStorageObject(StorageType.LocalStorage);
        }
        return null;
    }
    function _getVerifiedStorageObject(storageType) {
        try {
            if (isNullOrUndefined(getGlobal())) {
                return null;
            }
            var uid = (new Date)[_DYN_TO_STRING ]();
            var storage = getInst(storageType === StorageType.LocalStorage ? "localStorage" : "sessionStorage");
            var name_1 = _storagePrefix + uid;
            storage.setItem(name_1, uid);
            var fail = storage.getItem(name_1) !== uid;
            storage[_DYN_REMOVE_ITEM ](name_1);
            if (!fail) {
                return storage;
            }
        }
        catch (exception) {
        }
        return null;
    }
    function _getSessionStorageObject() {
        if (utlCanUseSessionStorage()) {
            return _getVerifiedStorageObject(StorageType.SessionStorage);
        }
        return null;
    }
    function utlDisableStorage() {
        _canUseLocalStorage = false;
        _canUseSessionStorage = false;
    }
    function utlSetStoragePrefix(storagePrefix) {
        _storagePrefix = storagePrefix || "";
    }
    function utlEnableStorage() {
        _canUseLocalStorage = utlCanUseLocalStorage(true);
        _canUseSessionStorage = utlCanUseSessionStorage(true);
    }
    function utlCanUseLocalStorage(reset) {
        if (reset || _canUseLocalStorage === undefined) {
            _canUseLocalStorage = !!_getVerifiedStorageObject(StorageType.LocalStorage);
        }
        return _canUseLocalStorage;
    }
    function utlGetLocalStorage(logger, name) {
        var storage = _getLocalStorageObject();
        if (storage !== null) {
            try {
                return storage.getItem(name);
            }
            catch (e) {
                _canUseLocalStorage = false;
                _throwInternal(logger, 2 , 1 , "Browser failed read of local storage. " + getExceptionName(e), { exception: dumpObj(e) });
            }
        }
        return null;
    }
    function utlSetLocalStorage(logger, name, data) {
        var storage = _getLocalStorageObject();
        if (storage !== null) {
            try {
                storage.setItem(name, data);
                return true;
            }
            catch (e) {
                _canUseLocalStorage = false;
                _throwInternal(logger, 2 , 3 , "Browser failed write to local storage. " + getExceptionName(e), { exception: dumpObj(e) });
            }
        }
        return false;
    }
    function utlRemoveStorage(logger, name) {
        var storage = _getLocalStorageObject();
        if (storage !== null) {
            try {
                storage[_DYN_REMOVE_ITEM ](name);
                return true;
            }
            catch (e) {
                _canUseLocalStorage = false;
                _throwInternal(logger, 2 , 5 , "Browser failed removal of local storage item. " + getExceptionName(e), { exception: dumpObj(e) });
            }
        }
        return false;
    }
    function utlCanUseSessionStorage(reset) {
        if (reset || _canUseSessionStorage === undefined) {
            _canUseSessionStorage = !!_getVerifiedStorageObject(StorageType.SessionStorage);
        }
        return _canUseSessionStorage;
    }
    function utlGetSessionStorageKeys() {
        var keys = [];
        if (utlCanUseSessionStorage()) {
            objForEachKey(getInst("sessionStorage"), function (key) {
                keys[_DYN_PUSH ](key);
            });
        }
        return keys;
    }
    function utlGetSessionStorage(logger, name) {
        var storage = _getSessionStorageObject();
        if (storage !== null) {
            try {
                return storage.getItem(name);
            }
            catch (e) {
                _canUseSessionStorage = false;
                _throwInternal(logger, 2 , 2 , "Browser failed read of session storage. " + getExceptionName(e), { exception: dumpObj(e) });
            }
        }
        return null;
    }
    function utlSetSessionStorage(logger, name, data) {
        var storage = _getSessionStorageObject();
        if (storage !== null) {
            try {
                storage.setItem(name, data);
                return true;
            }
            catch (e) {
                _canUseSessionStorage = false;
                _throwInternal(logger, 2 , 4 , "Browser failed write to session storage. " + getExceptionName(e), { exception: dumpObj(e) });
            }
        }
        return false;
    }
    function utlRemoveSessionStorage(logger, name) {
        var storage = _getSessionStorageObject();
        if (storage !== null) {
            try {
                storage[_DYN_REMOVE_ITEM ](name);
                return true;
            }
            catch (e) {
                _canUseSessionStorage = false;
                _throwInternal(logger, 2 , 6 , "Browser failed removal of session storage item. " + getExceptionName(e), { exception: dumpObj(e) });
            }
        }
        return false;
    }

    var THROTTLE_STORAGE_PREFIX = "appInsightsThrottle";
    var ThrottleMgr = /** @class */ (function () {
        function ThrottleMgr(core, namePrefix) {
            var _self = this;
            var _canUseLocalStorage;
            var _logger;
            var _config;
            var _localStorageObj;
            var _isTriggered;
            var _namePrefix;
            var _queue;
            var _isReady = false;
            var _isSpecificDaysGiven = false;
            _initConfig();
            _self["_getDbgPlgTargets"] = function () {
                return [_queue];
            };
            _self.getConfig = function () {
                return _config;
            };
            _self.canThrottle = function (msgId) {
                var localObj = _getLocalStorageObjByKey(msgId);
                var cfg = _getCfgByKey(msgId);
                return _canThrottle(cfg, _canUseLocalStorage, localObj);
            };
            _self.isTriggered = function (msgId) {
                return _isTrigger(msgId);
            };
            _self.isReady = function () {
                return _isReady;
            };
            _self.flush = function (msgId) {
                try {
                    var queue = _getQueueByKey(msgId);
                    if (queue && queue[_DYN_LENGTH ] > 0) {
                        var items = queue.slice(0);
                        _queue[msgId] = [];
                        arrForEach(items, function (item) {
                            _flushMessage(item.msgID, item[_DYN_MESSAGE ], item.severity, false);
                        });
                        return true;
                    }
                }
                catch (err) {
                }
                return false;
            };
            _self.flushAll = function () {
                try {
                    if (_queue) {
                        var result_1 = true;
                        objForEachKey(_queue, function (key) {
                            var isFlushed = _self.flush(parseInt(key));
                            result_1 = result_1 && isFlushed;
                        });
                        return result_1;
                    }
                }
                catch (err) {
                }
                return false;
            };
            _self.onReadyState = function (isReady, flushAll) {
                if (flushAll === void 0) { flushAll = true; }
                _isReady = isNullOrUndefined(isReady) ? true : isReady;
                if (_isReady && flushAll) {
                    return _self.flushAll();
                }
                return null;
            };
            _self.sendMessage = function (msgID, message, severity) {
                return _flushMessage(msgID, message, severity, true);
            };
            function _flushMessage(msgID, message, severity, saveUnsentMsg) {
                if (_isReady) {
                    var isSampledIn = _canSampledIn(msgID);
                    if (!isSampledIn) {
                        return;
                    }
                    var cfg = _getCfgByKey(msgID);
                    var localStorageObj = _getLocalStorageObjByKey(msgID);
                    var canThrottle = _canThrottle(cfg, _canUseLocalStorage, localStorageObj);
                    var throttled = false;
                    var number = 0;
                    var isTriggered = _isTrigger(msgID);
                    try {
                        if (canThrottle && !isTriggered) {
                            number = Math.min(cfg.limit.maxSendNumber, localStorageObj[_DYN_COUNT ] + 1);
                            localStorageObj[_DYN_COUNT ] = 0;
                            throttled = true;
                            _isTriggered[msgID] = true;
                            localStorageObj[_DYN_PRE_TRIGGER_DATE ] = new Date();
                        }
                        else {
                            _isTriggered[msgID] = canThrottle;
                            localStorageObj[_DYN_COUNT ] += 1;
                        }
                        var localStorageName = _getLocalStorageName(msgID);
                        _resetLocalStorage(_logger, localStorageName, localStorageObj);
                        for (var i = 0; i < number; i++) {
                            _sendMessage(msgID, _logger, message, severity);
                        }
                    }
                    catch (e) {
                    }
                    return {
                        isThrottled: throttled,
                        throttleNum: number
                    };
                }
                else {
                    if (!!saveUnsentMsg) {
                        var queue = _getQueueByKey(msgID);
                        queue[_DYN_PUSH ]({
                            msgID: msgID,
                            message: message,
                            severity: severity
                        });
                    }
                }
                return null;
            }
            function _initConfig() {
                _logger = safeGetLogger(core);
                _isTriggered = {};
                _localStorageObj = {};
                _queue = {};
                _config = {};
                _setCfgByKey(109 );
                _namePrefix = isNotNullOrUndefined(namePrefix) ? namePrefix : "";
                core.addUnloadHook(onConfigChange(core.config, function (details) {
                    var coreConfig = details.cfg;
                    _canUseLocalStorage = utlCanUseLocalStorage();
                    var configMgr = coreConfig.throttleMgrCfg || {};
                    objForEachKey(configMgr, function (key, cfg) {
                        _setCfgByKey(parseInt(key), cfg);
                    });
                }));
            }
            function _getCfgByKey(msgID) {
                return _config[msgID] || _config[109 ];
            }
            function _setCfgByKey(msgID, config) {
                var _a, _b;
                try {
                    var cfg = config || {};
                    var curCfg = {};
                    curCfg[_DYN_DISABLED ] = !!cfg[_DYN_DISABLED ];
                    var configInterval = cfg[_DYN_INTERVAL ] || {};
                    _isSpecificDaysGiven = (configInterval === null || configInterval === void 0 ? void 0 : configInterval.daysOfMonth) && (configInterval === null || configInterval === void 0 ? void 0 : configInterval.daysOfMonth[_DYN_LENGTH ]) > 0;
                    curCfg[_DYN_INTERVAL ] = _getIntervalConfig(configInterval);
                    var limit = {
                        samplingRate: ((_a = cfg.limit) === null || _a === void 0 ? void 0 : _a.samplingRate) || 100,
                        maxSendNumber: ((_b = cfg.limit) === null || _b === void 0 ? void 0 : _b.maxSendNumber) || 1
                    };
                    curCfg.limit = limit;
                    _config[msgID] = curCfg;
                }
                catch (e) {
                }
            }
            function _getIntervalConfig(interval) {
                interval = interval || {};
                var monthInterval = interval === null || interval === void 0 ? void 0 : interval.monthInterval;
                var dayInterval = interval === null || interval === void 0 ? void 0 : interval.dayInterval;
                if (isNullOrUndefined(monthInterval) && isNullOrUndefined(dayInterval)) {
                    interval.monthInterval = 3;
                    if (!_isSpecificDaysGiven) {
                        interval[_DYN_DAYS_OF_MONTH ] = [28];
                        _isSpecificDaysGiven = true;
                    }
                }
                interval = {
                    monthInterval: interval === null || interval === void 0 ? void 0 : interval.monthInterval,
                    dayInterval: interval === null || interval === void 0 ? void 0 : interval.dayInterval,
                    daysOfMonth: interval === null || interval === void 0 ? void 0 : interval.daysOfMonth
                };
                return interval;
            }
            function _canThrottle(config, canUseLocalStorage, localStorageObj) {
                if (config && !config[_DYN_DISABLED ] && canUseLocalStorage && isNotNullOrUndefined(localStorageObj)) {
                    var curDate = _getThrottleDate();
                    var date = localStorageObj[_DYN_DATE ];
                    var interval = config[_DYN_INTERVAL ];
                    var monthCheck = 1;
                    if (interval === null || interval === void 0 ? void 0 : interval.monthInterval) {
                        var monthExpand = (curDate.getUTCFullYear() - date.getUTCFullYear()) * 12 + curDate.getUTCMonth() - date.getUTCMonth();
                        monthCheck = _checkInterval(interval.monthInterval, 0, monthExpand);
                    }
                    var dayCheck = 1;
                    if (_isSpecificDaysGiven) {
                        dayCheck = arrIndexOf(interval[_DYN_DAYS_OF_MONTH ], curDate[_DYN_GET_UTCDATE ]());
                    }
                    else if (interval === null || interval === void 0 ? void 0 : interval.dayInterval) {
                        var daySpan = Math.floor((curDate.getTime() - date.getTime()) / 86400000);
                        dayCheck = _checkInterval(interval.dayInterval, 0, daySpan);
                    }
                    return monthCheck >= 0 && dayCheck >= 0;
                }
                return false;
            }
            function _getLocalStorageName(msgKey, prefix) {
                var fix = isNotNullOrUndefined(prefix) ? prefix : "";
                if (msgKey) {
                    return THROTTLE_STORAGE_PREFIX + fix + "-" + msgKey;
                }
                return null;
            }
            function _isTriggeredOnCurDate(preTriggerDate) {
                try {
                    if (preTriggerDate) {
                        var curDate = new Date();
                        return preTriggerDate.getUTCFullYear() === curDate.getUTCFullYear() &&
                            preTriggerDate.getUTCMonth() === curDate.getUTCMonth() &&
                            preTriggerDate[_DYN_GET_UTCDATE ]() === curDate[_DYN_GET_UTCDATE ]();
                    }
                }
                catch (e) {
                }
                return false;
            }
            function _getLocalStorageObj(value, logger, storageName) {
                try {
                    var storageObj = {
                        date: _getThrottleDate(),
                        count: 0
                    };
                    if (value) {
                        var obj = JSON.parse(value);
                        var curObj = {
                            date: _getThrottleDate(obj[_DYN_DATE ]) || storageObj[_DYN_DATE ],
                            count: obj[_DYN_COUNT ] || storageObj[_DYN_COUNT ],
                            preTriggerDate: obj.preTriggerDate ? _getThrottleDate(obj[_DYN_PRE_TRIGGER_DATE ]) : undefined
                        };
                        return curObj;
                    }
                    else {
                        _resetLocalStorage(logger, storageName, storageObj);
                        return storageObj;
                    }
                }
                catch (e) {
                }
                return null;
            }
            function _getThrottleDate(dateStr) {
                try {
                    if (dateStr) {
                        var date = new Date(dateStr);
                        if (!isNaN(date.getDate())) {
                            return date;
                        }
                    }
                    else {
                        return new Date();
                    }
                }
                catch (e) {
                }
                return null;
            }
            function _resetLocalStorage(logger, storageName, obj) {
                try {
                    return utlSetLocalStorage(logger, storageName, strTrim(JSON[_DYN_STRINGIFY ](obj)));
                }
                catch (e) {
                }
                return false;
            }
            function _checkInterval(interval, start, current) {
                if (interval <= 0) {
                    return 1;
                }
                return (current >= start) && (current - start) % interval == 0 ? Math.floor((current - start) / interval) + 1 : -1;
            }
            function _sendMessage(msgID, logger, message, severity) {
                _throwInternal(logger, severity || 1 , msgID, message);
            }
            function _canSampledIn(msgID) {
                try {
                    var cfg = _getCfgByKey(msgID);
                    return randomValue(1000000) <= cfg.limit.samplingRate;
                }
                catch (e) {
                }
                return false;
            }
            function _getLocalStorageObjByKey(key) {
                try {
                    var curObj = _localStorageObj[key];
                    if (!curObj) {
                        var localStorageName = _getLocalStorageName(key, _namePrefix);
                        curObj = _getLocalStorageObj(utlGetLocalStorage(_logger, localStorageName), _logger, localStorageName);
                        _localStorageObj[key] = curObj;
                    }
                    return _localStorageObj[key];
                }
                catch (e) {
                }
                return null;
            }
            function _isTrigger(key) {
                var isTrigger = _isTriggered[key];
                if (isNullOrUndefined(isTrigger)) {
                    isTrigger = false;
                    var localStorageObj = _getLocalStorageObjByKey(key);
                    if (localStorageObj) {
                        isTrigger = _isTriggeredOnCurDate(localStorageObj[_DYN_PRE_TRIGGER_DATE ]);
                    }
                    _isTriggered[key] = isTrigger;
                }
                return _isTriggered[key];
            }
            function _getQueueByKey(key) {
                _queue = _queue || {};
                if (isNullOrUndefined(_queue[key])) {
                    _queue[key] = [];
                }
                return _queue[key];
            }
        }
        return ThrottleMgr;
    }());

    var _FIELDS_SEPARATOR = ";";
    var _FIELD_KEY_VALUE_SEPARATOR = "=";
    function parseConnectionString(connectionString) {
        if (!connectionString) {
            return {};
        }
        var kvPairs = connectionString[_DYN_SPLIT ](_FIELDS_SEPARATOR);
        var result = arrReduce(kvPairs, function (fields, kv) {
            var kvParts = kv[_DYN_SPLIT ](_FIELD_KEY_VALUE_SEPARATOR);
            if (kvParts[_DYN_LENGTH ] === 2) {
                var key = kvParts[0][_DYN_TO_LOWER_CASE ]();
                var value = kvParts[1];
                fields[key] = value;
            }
            return fields;
        }, {});
        if (objKeys(result)[_DYN_LENGTH ] > 0) {
            if (result.endpointsuffix) {
                var locationPrefix = result.location ? result.location + "." : "";
                result[_DYN_INGESTIONENDPOINT ] = result[_DYN_INGESTIONENDPOINT ] || ("https://" + locationPrefix + "dc." + result.endpointsuffix);
            }
            result[_DYN_INGESTIONENDPOINT ] = result[_DYN_INGESTIONENDPOINT ] || DEFAULT_BREEZE_ENDPOINT;
            if (strEndsWith(result[_DYN_INGESTIONENDPOINT ], "/")) {
                result[_DYN_INGESTIONENDPOINT ] = result[_DYN_INGESTIONENDPOINT ].slice(0, -1);
            }
        }
        return result;
    }
    var ConnectionStringParser = {
        parse: parseConnectionString
    };

    var Envelope = /** @class */ (function () {
        function Envelope(logger, data, name) {
            var _this = this;
            var _self = this;
            _self.ver = 1;
            _self.sampleRate = 100.0;
            _self.tags = {};
            _self[_DYN_NAME ] = dataSanitizeString(logger, name) || strNotSpecified;
            _self.data = data;
            _self.time = toISOString(new Date());
            _self.aiDataContract = {
                time: 1 ,
                iKey: 1 ,
                name: 1 ,
                sampleRate: function () {
                    return (_this.sampleRate === 100) ? 4  : 1 ;
                },
                tags: 1 ,
                data: 1
            };
        }
        return Envelope;
    }());

    var Event$1 = /** @class */ (function () {
        function Event(logger, name, properties, measurements) {
            this.aiDataContract = {
                ver: 1 ,
                name: 1 ,
                properties: 0 ,
                measurements: 0
            };
            var _self = this;
            _self.ver = 2;
            _self[_DYN_NAME ] = dataSanitizeString(logger, name) || strNotSpecified;
            _self[_DYN_PROPERTIES ] = dataSanitizeProperties(logger, properties);
            _self[_DYN_MEASUREMENTS ] = dataSanitizeMeasurements(logger, measurements);
        }
        Event.envelopeType = "Microsoft.ApplicationInsights.{0}.Event";
        Event.dataType = "EventData";
        return Event;
    }());

    var NoMethod = "<no_method>";
    var strError = "error";
    var strStack = "stack";
    var strStackDetails = "stackDetails";
    var strErrorSrc = "errorSrc";
    var strMessage = "message";
    var strDescription = "description";
    function _stringify(value, convertToString) {
        var result = value;
        if (result && !isString(result)) {
            if (JSON && JSON[_DYN_STRINGIFY ]) {
                result = JSON[_DYN_STRINGIFY ](value);
                if (convertToString && (!result || result === "{}")) {
                    if (isFunction(value[_DYN_TO_STRING ])) {
                        result = value[_DYN_TO_STRING ]();
                    }
                    else {
                        result = "" + value;
                    }
                }
            }
            else {
                result = "" + value + " - (Missing JSON.stringify)";
            }
        }
        return result || "";
    }
    function _formatMessage(theEvent, errorType) {
        var evtMessage = theEvent;
        if (theEvent) {
            if (evtMessage && !isString(evtMessage)) {
                evtMessage = theEvent[strMessage] || theEvent[strDescription] || evtMessage;
            }
            if (evtMessage && !isString(evtMessage)) {
                evtMessage = _stringify(evtMessage, true);
            }
            if (theEvent["filename"]) {
                evtMessage = evtMessage + " @" + (theEvent["filename"] || "") + ":" + (theEvent["lineno"] || "?") + ":" + (theEvent["colno"] || "?");
            }
        }
        if (errorType && errorType !== "String" && errorType !== "Object" && errorType !== "Error" && strIndexOf(evtMessage || "", errorType) === -1) {
            evtMessage = errorType + ": " + evtMessage;
        }
        return evtMessage || "";
    }
    function _isExceptionDetailsInternal(value) {
        try {
            if (isObject(value)) {
                return "hasFullStack" in value && "typeName" in value;
            }
        }
        catch (e) {
        }
        return false;
    }
    function _isExceptionInternal(value) {
        try {
            if (isObject(value)) {
                return ("ver" in value && "exceptions" in value && "properties" in value);
            }
        }
        catch (e) {
        }
        return false;
    }
    function _isStackDetails(details) {
        return details && details.src && isString(details.src) && details.obj && isArray(details.obj);
    }
    function _convertStackObj(errorStack) {
        var src = errorStack || "";
        if (!isString(src)) {
            if (isString(src[strStack])) {
                src = src[strStack];
            }
            else {
                src = "" + src;
            }
        }
        var items = src[_DYN_SPLIT ]("\n");
        return {
            src: src,
            obj: items
        };
    }
    function _getOperaStack(errorMessage) {
        var stack = [];
        var lines = errorMessage[_DYN_SPLIT ]("\n");
        for (var lp = 0; lp < lines[_DYN_LENGTH ]; lp++) {
            var entry = lines[lp];
            if (lines[lp + 1]) {
                entry += "@" + lines[lp + 1];
                lp++;
            }
            stack[_DYN_PUSH ](entry);
        }
        return {
            src: errorMessage,
            obj: stack
        };
    }
    function _getStackFromErrorObj(errorObj) {
        var details = null;
        if (errorObj) {
            try {
                if (errorObj[strStack]) {
                    details = _convertStackObj(errorObj[strStack]);
                }
                else if (errorObj[strError] && errorObj[strError][strStack]) {
                    details = _convertStackObj(errorObj[strError][strStack]);
                }
                else if (errorObj["exception"] && errorObj.exception[strStack]) {
                    details = _convertStackObj(errorObj.exception[strStack]);
                }
                else if (_isStackDetails(errorObj)) {
                    details = errorObj;
                }
                else if (_isStackDetails(errorObj[strStackDetails])) {
                    details = errorObj[strStackDetails];
                }
                else if (getWindow() && getWindow()["opera"] && errorObj[strMessage]) {
                    details = _getOperaStack(errorObj[_DYN_MESSAGE ]);
                }
                else if (errorObj["reason"] && errorObj.reason[strStack]) {
                    details = _convertStackObj(errorObj.reason[strStack]);
                }
                else if (isString(errorObj)) {
                    details = _convertStackObj(errorObj);
                }
                else {
                    var evtMessage = errorObj[strMessage] || errorObj[strDescription] || "";
                    if (isString(errorObj[strErrorSrc])) {
                        if (evtMessage) {
                            evtMessage += "\n";
                        }
                        evtMessage += " from " + errorObj[strErrorSrc];
                    }
                    if (evtMessage) {
                        details = _convertStackObj(evtMessage);
                    }
                }
            }
            catch (e) {
                details = _convertStackObj(e);
            }
        }
        return details || {
            src: "",
            obj: null
        };
    }
    function _formatStackTrace(stackDetails) {
        var stack = "";
        if (stackDetails) {
            if (stackDetails.obj) {
                arrForEach(stackDetails.obj, function (entry) {
                    stack += entry + "\n";
                });
            }
            else {
                stack = stackDetails.src || "";
            }
        }
        return stack;
    }
    function _parseStack(stack) {
        var parsedStack;
        var frames = stack.obj;
        if (frames && frames[_DYN_LENGTH ] > 0) {
            parsedStack = [];
            var level_1 = 0;
            var totalSizeInBytes_1 = 0;
            arrForEach(frames, function (frame) {
                var theFrame = frame[_DYN_TO_STRING ]();
                if (_StackFrame.regex.test(theFrame)) {
                    var parsedFrame = new _StackFrame(theFrame, level_1++);
                    totalSizeInBytes_1 += parsedFrame[_DYN_SIZE_IN_BYTES ];
                    parsedStack[_DYN_PUSH ](parsedFrame);
                }
            });
            var exceptionParsedStackThreshold = 32 * 1024;
            if (totalSizeInBytes_1 > exceptionParsedStackThreshold) {
                var left = 0;
                var right = parsedStack[_DYN_LENGTH ] - 1;
                var size = 0;
                var acceptedLeft = left;
                var acceptedRight = right;
                while (left < right) {
                    var lSize = parsedStack[left][_DYN_SIZE_IN_BYTES ];
                    var rSize = parsedStack[right][_DYN_SIZE_IN_BYTES ];
                    size += lSize + rSize;
                    if (size > exceptionParsedStackThreshold) {
                        var howMany = acceptedRight - acceptedLeft + 1;
                        parsedStack.splice(acceptedLeft, howMany);
                        break;
                    }
                    acceptedLeft = left;
                    acceptedRight = right;
                    left++;
                    right--;
                }
            }
        }
        return parsedStack;
    }
    function _getErrorType(errorType) {
        var typeName = "";
        if (errorType) {
            typeName = errorType.typeName || errorType[_DYN_NAME ] || "";
            if (!typeName) {
                try {
                    var funcNameRegex = /function (.{1,200})\(/;
                    var results = (funcNameRegex).exec((errorType).constructor[_DYN_TO_STRING ]());
                    typeName = (results && results[_DYN_LENGTH ] > 1) ? results[1] : "";
                }
                catch (e) {
                }
            }
        }
        return typeName;
    }
    function _formatErrorCode(errorObj) {
        if (errorObj) {
            try {
                if (!isString(errorObj)) {
                    var errorType = _getErrorType(errorObj);
                    var result = _stringify(errorObj, false);
                    if (!result || result === "{}") {
                        if (errorObj[strError]) {
                            errorObj = errorObj[strError];
                            errorType = _getErrorType(errorObj);
                        }
                        result = _stringify(errorObj, true);
                    }
                    if (strIndexOf(result, errorType) !== 0 && errorType !== "String") {
                        return errorType + ":" + result;
                    }
                    return result;
                }
            }
            catch (e) {
            }
        }
        return "" + (errorObj || "");
    }
    var Exception = /** @class */ (function () {
        function Exception(logger, exception, properties, measurements, severityLevel, id) {
            this.aiDataContract = {
                ver: 1 ,
                exceptions: 1 ,
                severityLevel: 0 ,
                properties: 0 ,
                measurements: 0
            };
            var _self = this;
            _self.ver = 2;
            if (!_isExceptionInternal(exception)) {
                if (!properties) {
                    properties = {};
                }
                if (id) {
                    properties.id = id;
                }
                _self[_DYN_EXCEPTIONS ] = [new _ExceptionDetails(logger, exception, properties)];
                _self[_DYN_PROPERTIES ] = dataSanitizeProperties(logger, properties);
                _self[_DYN_MEASUREMENTS ] = dataSanitizeMeasurements(logger, measurements);
                if (severityLevel) {
                    _self[_DYN_SEVERITY_LEVEL ] = severityLevel;
                }
                if (id) {
                    _self.id = id;
                }
            }
            else {
                _self[_DYN_EXCEPTIONS ] = exception[_DYN_EXCEPTIONS ] || [];
                _self[_DYN_PROPERTIES ] = exception[_DYN_PROPERTIES ];
                _self[_DYN_MEASUREMENTS ] = exception[_DYN_MEASUREMENTS ];
                if (exception[_DYN_SEVERITY_LEVEL ]) {
                    _self[_DYN_SEVERITY_LEVEL ] = exception[_DYN_SEVERITY_LEVEL ];
                }
                if (exception.id) {
                    _self.id = exception.id;
                    exception[_DYN_PROPERTIES ].id = exception.id;
                }
                if (exception[_DYN_PROBLEM_GROUP ]) {
                    _self[_DYN_PROBLEM_GROUP ] = exception[_DYN_PROBLEM_GROUP ];
                }
                if (!isNullOrUndefined(exception[_DYN_IS_MANUAL ])) {
                    _self[_DYN_IS_MANUAL ] = exception[_DYN_IS_MANUAL ];
                }
            }
        }
        Exception.CreateAutoException = function (message, url, lineNumber, columnNumber, error, evt, stack, errorSrc) {
            var _a;
            var errorType = _getErrorType(error || evt || message);
            return _a = {},
                _a[_DYN_MESSAGE ] = _formatMessage(message, errorType),
                _a.url = url,
                _a.lineNumber = lineNumber,
                _a.columnNumber = columnNumber,
                _a.error = _formatErrorCode(error || evt || message),
                _a.evt = _formatErrorCode(evt || message),
                _a[_DYN_TYPE_NAME ] = errorType,
                _a.stackDetails = _getStackFromErrorObj(stack || error || evt),
                _a.errorSrc = errorSrc,
                _a;
        };
        Exception.CreateFromInterface = function (logger, exception, properties, measurements) {
            var exceptions = exception[_DYN_EXCEPTIONS ]
                && arrMap(exception[_DYN_EXCEPTIONS ], function (ex) { return _ExceptionDetails[_DYN__CREATE_FROM_INTERFA1 ](logger, ex); });
            var exceptionData = new Exception(logger, __assignFn(__assignFn({}, exception), { exceptions: exceptions }), properties, measurements);
            return exceptionData;
        };
        Exception.prototype.toInterface = function () {
            var _a;
            var _b = this, exceptions = _b.exceptions, properties = _b.properties, measurements = _b.measurements, severityLevel = _b.severityLevel, problemGroup = _b.problemGroup, id = _b.id, isManual = _b.isManual;
            var exceptionDetailsInterface = exceptions instanceof Array
                && arrMap(exceptions, function (exception) { return exception.toInterface(); })
                || undefined;
            return _a = {
                    ver: "4.0"
                },
                _a[_DYN_EXCEPTIONS ] = exceptionDetailsInterface,
                _a.severityLevel = severityLevel,
                _a.properties = properties,
                _a.measurements = measurements,
                _a.problemGroup = problemGroup,
                _a.id = id,
                _a.isManual = isManual,
                _a;
        };
        Exception.CreateSimpleException = function (message, typeName, assembly, fileName, details, line) {
            var _a;
            return {
                exceptions: [
                    (_a = {},
                        _a[_DYN_HAS_FULL_STACK ] = true,
                        _a.message = message,
                        _a.stack = details,
                        _a.typeName = typeName,
                        _a)
                ]
            };
        };
        Exception.envelopeType = "Microsoft.ApplicationInsights.{0}.Exception";
        Exception.dataType = "ExceptionData";
        Exception.formatError = _formatErrorCode;
        return Exception;
    }());
    var _ExceptionDetails = /** @class */ (function () {
        function _ExceptionDetails(logger, exception, properties) {
            this.aiDataContract = {
                id: 0 ,
                outerId: 0 ,
                typeName: 1 ,
                message: 1 ,
                hasFullStack: 0 ,
                stack: 0 ,
                parsedStack: 2
            };
            var _self = this;
            if (!_isExceptionDetailsInternal(exception)) {
                var error = exception;
                var evt = error && error.evt;
                if (!isError(error)) {
                    error = error[strError] || evt || error;
                }
                _self[_DYN_TYPE_NAME ] = dataSanitizeString(logger, _getErrorType(error)) || strNotSpecified;
                _self[_DYN_MESSAGE ] = dataSanitizeMessage(logger, _formatMessage(exception || error, _self[_DYN_TYPE_NAME ])) || strNotSpecified;
                var stack = exception[strStackDetails] || _getStackFromErrorObj(exception);
                _self[_DYN_PARSED_STACK ] = _parseStack(stack);
                if (isArray(_self[_DYN_PARSED_STACK ])) {
                    arrMap(_self[_DYN_PARSED_STACK ], function (frame) {
                        frame[_DYN_ASSEMBLY ] = dataSanitizeString(logger, frame[_DYN_ASSEMBLY ]);
                        frame[_DYN_FILE_NAME ] = dataSanitizeString(logger, frame[_DYN_FILE_NAME ]);
                    });
                }
                _self[strStack] = dataSanitizeException(logger, _formatStackTrace(stack));
                _self.hasFullStack = isArray(_self.parsedStack) && _self.parsedStack[_DYN_LENGTH ] > 0;
                if (properties) {
                    properties[_DYN_TYPE_NAME ] = properties[_DYN_TYPE_NAME ] || _self[_DYN_TYPE_NAME ];
                }
            }
            else {
                _self[_DYN_TYPE_NAME ] = exception[_DYN_TYPE_NAME ];
                _self[_DYN_MESSAGE ] = exception[_DYN_MESSAGE ];
                _self[strStack] = exception[strStack];
                _self[_DYN_PARSED_STACK ] = exception[_DYN_PARSED_STACK ] || [];
                _self[_DYN_HAS_FULL_STACK ] = exception[_DYN_HAS_FULL_STACK ];
            }
        }
        _ExceptionDetails.prototype.toInterface = function () {
            var _a;
            var _self = this;
            var parsedStack = _self[_DYN_PARSED_STACK ] instanceof Array
                && arrMap(_self[_DYN_PARSED_STACK ], function (frame) { return frame.toInterface(); });
            var exceptionDetailsInterface = (_a = {
                    id: _self.id,
                    outerId: _self.outerId,
                    typeName: _self[_DYN_TYPE_NAME ],
                    message: _self[_DYN_MESSAGE ],
                    hasFullStack: _self[_DYN_HAS_FULL_STACK ],
                    stack: _self[strStack]
                },
                _a[_DYN_PARSED_STACK ] = parsedStack || undefined,
                _a);
            return exceptionDetailsInterface;
        };
        _ExceptionDetails.CreateFromInterface = function (logger, exception) {
            var parsedStack = (exception[_DYN_PARSED_STACK ] instanceof Array
                && arrMap(exception[_DYN_PARSED_STACK ], function (frame) { return _StackFrame[_DYN__CREATE_FROM_INTERFA1 ](frame); }))
                || exception[_DYN_PARSED_STACK ];
            var exceptionDetails = new _ExceptionDetails(logger, __assignFn(__assignFn({}, exception), { parsedStack: parsedStack }));
            return exceptionDetails;
        };
        return _ExceptionDetails;
    }());
    var _StackFrame = /** @class */ (function () {
        function _StackFrame(sourceFrame, level) {
            this.aiDataContract = {
                level: 1 ,
                method: 1 ,
                assembly: 0 ,
                fileName: 0 ,
                line: 0
            };
            var _self = this;
            _self[_DYN_SIZE_IN_BYTES ] = 0;
            if (typeof sourceFrame === "string") {
                var frame = sourceFrame;
                _self[_DYN_LEVEL ] = level;
                _self[_DYN_METHOD ] = NoMethod;
                _self[_DYN_ASSEMBLY ] = strTrim(frame);
                _self[_DYN_FILE_NAME ] = "";
                _self[_DYN_LINE ] = 0;
                var matches = frame.match(_StackFrame.regex);
                if (matches && matches[_DYN_LENGTH ] >= 5) {
                    _self[_DYN_METHOD ] = strTrim(matches[2]) || _self[_DYN_METHOD ];
                    _self[_DYN_FILE_NAME ] = strTrim(matches[4]);
                    _self[_DYN_LINE ] = parseInt(matches[5]) || 0;
                }
            }
            else {
                _self[_DYN_LEVEL ] = sourceFrame[_DYN_LEVEL ];
                _self[_DYN_METHOD ] = sourceFrame[_DYN_METHOD ];
                _self[_DYN_ASSEMBLY ] = sourceFrame[_DYN_ASSEMBLY ];
                _self[_DYN_FILE_NAME ] = sourceFrame[_DYN_FILE_NAME ];
                _self[_DYN_LINE ] = sourceFrame[_DYN_LINE ];
                _self[_DYN_SIZE_IN_BYTES ] = 0;
            }
            _self.sizeInBytes += _self.method[_DYN_LENGTH ];
            _self.sizeInBytes += _self.fileName[_DYN_LENGTH ];
            _self.sizeInBytes += _self.assembly[_DYN_LENGTH ];
            _self[_DYN_SIZE_IN_BYTES ] += _StackFrame.baseSize;
            _self.sizeInBytes += _self.level.toString()[_DYN_LENGTH ];
            _self.sizeInBytes += _self.line.toString()[_DYN_LENGTH ];
        }
        _StackFrame.CreateFromInterface = function (frame) {
            return new _StackFrame(frame, null );
        };
        _StackFrame.prototype.toInterface = function () {
            var _self = this;
            return {
                level: _self[_DYN_LEVEL ],
                method: _self[_DYN_METHOD ],
                assembly: _self[_DYN_ASSEMBLY ],
                fileName: _self[_DYN_FILE_NAME ],
                line: _self[_DYN_LINE ]
            };
        };
        _StackFrame.regex = /^([\s]+at)?[\s]{0,50}([^\@\()]+?)[\s]{0,50}(\@|\()([^\(\n]+):([0-9]+):([0-9]+)(\)?)$/;
        _StackFrame.baseSize = 58;
        return _StackFrame;
    }());

    var DataPoint = /** @class */ (function () {
        function DataPoint() {
            this.aiDataContract = {
                name: 1 ,
                kind: 0 ,
                value: 1 ,
                count: 0 ,
                min: 0 ,
                max: 0 ,
                stdDev: 0
            };
            this.kind = 0 ;
        }
        return DataPoint;
    }());

    var Metric = /** @class */ (function () {
        function Metric(logger, name, value, count, min, max, stdDev, properties, measurements) {
            this.aiDataContract = {
                ver: 1 ,
                metrics: 1 ,
                properties: 0
            };
            var _self = this;
            _self.ver = 2;
            var dataPoint = new DataPoint();
            dataPoint[_DYN_COUNT ] = count > 0 ? count : undefined;
            dataPoint.max = isNaN(max) || max === null ? undefined : max;
            dataPoint.min = isNaN(min) || min === null ? undefined : min;
            dataPoint[_DYN_NAME ] = dataSanitizeString(logger, name) || strNotSpecified;
            dataPoint.value = value;
            dataPoint.stdDev = isNaN(stdDev) || stdDev === null ? undefined : stdDev;
            _self.metrics = [dataPoint];
            _self[_DYN_PROPERTIES ] = dataSanitizeProperties(logger, properties);
            _self[_DYN_MEASUREMENTS ] = dataSanitizeMeasurements(logger, measurements);
        }
        Metric.envelopeType = "Microsoft.ApplicationInsights.{0}.Metric";
        Metric.dataType = "MetricData";
        return Metric;
    }());

    var strEmpty = "";
    function stringToBoolOrDefault(str, defaultValue) {
        if (defaultValue === void 0) { defaultValue = false; }
        if (str === undefined || str === null) {
            return defaultValue;
        }
        return str.toString()[_DYN_TO_LOWER_CASE ]() === "true";
    }
    function msToTimeSpan(totalms) {
        if (isNaN(totalms) || totalms < 0) {
            totalms = 0;
        }
        totalms = Math.round(totalms);
        var ms = strEmpty + totalms % 1000;
        var sec = strEmpty + Math.floor(totalms / 1000) % 60;
        var min = strEmpty + Math.floor(totalms / (1000 * 60)) % 60;
        var hour = strEmpty + Math.floor(totalms / (1000 * 60 * 60)) % 24;
        var days = Math.floor(totalms / (1000 * 60 * 60 * 24));
        ms = ms[_DYN_LENGTH ] === 1 ? "00" + ms : ms[_DYN_LENGTH ] === 2 ? "0" + ms : ms;
        sec = sec[_DYN_LENGTH ] < 2 ? "0" + sec : sec;
        min = min[_DYN_LENGTH ] < 2 ? "0" + min : min;
        hour = hour[_DYN_LENGTH ] < 2 ? "0" + hour : hour;
        return (days > 0 ? days + "." : strEmpty) + hour + ":" + min + ":" + sec + "." + ms;
    }
    function getExtensionByName(extensions, identifier) {
        var extension = null;
        arrForEach(extensions, function (value) {
            if (value.identifier === identifier) {
                extension = value;
                return -1;
            }
        });
        return extension;
    }
    function isCrossOriginError(message, url, lineNumber, columnNumber, error) {
        return !error && isString(message) && (message === "Script error." || message === "Script error");
    }

    var PageView = /** @class */ (function () {
        function PageView(logger, name, url, durationMs, properties, measurements, id) {
            this.aiDataContract = {
                ver: 1 ,
                name: 0 ,
                url: 0 ,
                duration: 0 ,
                properties: 0 ,
                measurements: 0 ,
                id: 0
            };
            var _self = this;
            _self.ver = 2;
            _self.id = dataSanitizeId(logger, id);
            _self.url = dataSanitizeUrl(logger, url);
            _self[_DYN_NAME ] = dataSanitizeString(logger, name) || strNotSpecified;
            if (!isNaN(durationMs)) {
                _self[_DYN_DURATION ] = msToTimeSpan(durationMs);
            }
            _self[_DYN_PROPERTIES ] = dataSanitizeProperties(logger, properties);
            _self[_DYN_MEASUREMENTS ] = dataSanitizeMeasurements(logger, measurements);
        }
        PageView.envelopeType = "Microsoft.ApplicationInsights.{0}.Pageview";
        PageView.dataType = "PageviewData";
        return PageView;
    }());

    var RemoteDependencyData = /** @class */ (function () {
        function RemoteDependencyData(logger, id, absoluteUrl, commandName, value, success, resultCode, method, requestAPI, correlationContext, properties, measurements) {
            if (requestAPI === void 0) { requestAPI = "Ajax"; }
            this.aiDataContract = {
                id: 1 ,
                ver: 1 ,
                name: 0 ,
                resultCode: 0 ,
                duration: 0 ,
                success: 0 ,
                data: 0 ,
                target: 0 ,
                type: 0 ,
                properties: 0 ,
                measurements: 0 ,
                kind: 0 ,
                value: 0 ,
                count: 0 ,
                min: 0 ,
                max: 0 ,
                stdDev: 0 ,
                dependencyKind: 0 ,
                dependencySource: 0 ,
                commandName: 0 ,
                dependencyTypeName: 0
            };
            var _self = this;
            _self.ver = 2;
            _self.id = id;
            _self[_DYN_DURATION ] = msToTimeSpan(value);
            _self.success = success;
            _self.resultCode = resultCode + "";
            _self.type = dataSanitizeString(logger, requestAPI);
            var dependencyFields = AjaxHelperParseDependencyPath(logger, absoluteUrl, method, commandName);
            _self.data = dataSanitizeUrl(logger, commandName) || dependencyFields.data;
            _self.target = dataSanitizeString(logger, dependencyFields.target);
            if (correlationContext) {
                _self.target = "".concat(_self.target, " | ").concat(correlationContext);
            }
            _self[_DYN_NAME ] = dataSanitizeString(logger, dependencyFields[_DYN_NAME ]);
            _self[_DYN_PROPERTIES ] = dataSanitizeProperties(logger, properties);
            _self[_DYN_MEASUREMENTS ] = dataSanitizeMeasurements(logger, measurements);
        }
        RemoteDependencyData.envelopeType = "Microsoft.ApplicationInsights.{0}.RemoteDependency";
        RemoteDependencyData.dataType = "RemoteDependencyData";
        return RemoteDependencyData;
    }());

    var Trace = /** @class */ (function () {
        function Trace(logger, message, severityLevel, properties, measurements) {
            this.aiDataContract = {
                ver: 1 ,
                message: 1 ,
                severityLevel: 0 ,
                properties: 0
            };
            var _self = this;
            _self.ver = 2;
            message = message || strNotSpecified;
            _self[_DYN_MESSAGE ] = dataSanitizeMessage(logger, message);
            _self[_DYN_PROPERTIES ] = dataSanitizeProperties(logger, properties);
            _self[_DYN_MEASUREMENTS ] = dataSanitizeMeasurements(logger, measurements);
            if (severityLevel) {
                _self[_DYN_SEVERITY_LEVEL ] = severityLevel;
            }
        }
        Trace.envelopeType = "Microsoft.ApplicationInsights.{0}.Message";
        Trace.dataType = "MessageData";
        return Trace;
    }());

    var PageViewPerformance = /** @class */ (function () {
        function PageViewPerformance(logger, name, url, unused, properties, measurements, cs4BaseData) {
            this.aiDataContract = {
                ver: 1 ,
                name: 0 ,
                url: 0 ,
                duration: 0 ,
                perfTotal: 0 ,
                networkConnect: 0 ,
                sentRequest: 0 ,
                receivedResponse: 0 ,
                domProcessing: 0 ,
                properties: 0 ,
                measurements: 0
            };
            var _self = this;
            _self.ver = 2;
            _self.url = dataSanitizeUrl(logger, url);
            _self[_DYN_NAME ] = dataSanitizeString(logger, name) || strNotSpecified;
            _self[_DYN_PROPERTIES ] = dataSanitizeProperties(logger, properties);
            _self[_DYN_MEASUREMENTS ] = dataSanitizeMeasurements(logger, measurements);
            if (cs4BaseData) {
                _self.domProcessing = cs4BaseData.domProcessing;
                _self[_DYN_DURATION ] = cs4BaseData[_DYN_DURATION ];
                _self.networkConnect = cs4BaseData.networkConnect;
                _self.perfTotal = cs4BaseData.perfTotal;
                _self[_DYN_RECEIVED_RESPONSE ] = cs4BaseData[_DYN_RECEIVED_RESPONSE ];
                _self.sentRequest = cs4BaseData.sentRequest;
            }
        }
        PageViewPerformance.envelopeType = "Microsoft.ApplicationInsights.{0}.PageviewPerformance";
        PageViewPerformance.dataType = "PageviewPerformanceData";
        return PageViewPerformance;
    }());

    var Data = /** @class */ (function () {
        function Data(baseType, data) {
            this.aiDataContract = {
                baseType: 1 ,
                baseData: 1
            };
            this.baseType = baseType;
            this.baseData = data;
        }
        return Data;
    }());

    var SeverityLevel = createEnumStyle({
        Verbose: 0 ,
        Information: 1 ,
        Warning: 2 ,
        Error: 3 ,
        Critical: 4
    });

    var ConfigurationManager = /** @class */ (function () {
        function ConfigurationManager() {
        }
        ConfigurationManager.getConfig = function (config, field, identifier, defaultValue) {
            if (defaultValue === void 0) { defaultValue = false; }
            var configValue;
            if (identifier && config[_DYN_EXTENSION_CONFIG ] && config[_DYN_EXTENSION_CONFIG ][identifier] && !isNullOrUndefined(config[_DYN_EXTENSION_CONFIG ][identifier][field])) {
                configValue = config[_DYN_EXTENSION_CONFIG ][identifier][field];
            }
            else {
                configValue = config[field];
            }
            return !isNullOrUndefined(configValue) ? configValue : defaultValue;
        };
        return ConfigurationManager;
    }());

    function _aiNameFunc(baseName) {
        var aiName = "ai." + baseName + ".";
        return function (name) {
            return aiName + name;
        };
    }
    var _aiApplication = _aiNameFunc("application");
    var _aiDevice = _aiNameFunc("device");
    var _aiLocation = _aiNameFunc("location");
    var _aiOperation = _aiNameFunc("operation");
    var _aiSession = _aiNameFunc("session");
    var _aiUser = _aiNameFunc("user");
    var _aiCloud = _aiNameFunc("cloud");
    var _aiInternal = _aiNameFunc("internal");
    var ContextTagKeys = /** @class */ (function (_super) {
        __extendsFn(ContextTagKeys, _super);
        function ContextTagKeys() {
            return _super.call(this) || this;
        }
        return ContextTagKeys;
    }(createClassFromInterface({
        applicationVersion: _aiApplication("ver"),
        applicationBuild: _aiApplication("build"),
        applicationTypeId: _aiApplication("typeId"),
        applicationId: _aiApplication("applicationId"),
        applicationLayer: _aiApplication("layer"),
        deviceId: _aiDevice("id"),
        deviceIp: _aiDevice("ip"),
        deviceLanguage: _aiDevice("language"),
        deviceLocale: _aiDevice("locale"),
        deviceModel: _aiDevice("model"),
        deviceFriendlyName: _aiDevice("friendlyName"),
        deviceNetwork: _aiDevice("network"),
        deviceNetworkName: _aiDevice("networkName"),
        deviceOEMName: _aiDevice("oemName"),
        deviceOS: _aiDevice("os"),
        deviceOSVersion: _aiDevice("osVersion"),
        deviceRoleInstance: _aiDevice("roleInstance"),
        deviceRoleName: _aiDevice("roleName"),
        deviceScreenResolution: _aiDevice("screenResolution"),
        deviceType: _aiDevice("type"),
        deviceMachineName: _aiDevice("machineName"),
        deviceVMName: _aiDevice("vmName"),
        deviceBrowser: _aiDevice("browser"),
        deviceBrowserVersion: _aiDevice("browserVersion"),
        locationIp: _aiLocation("ip"),
        locationCountry: _aiLocation("country"),
        locationProvince: _aiLocation("province"),
        locationCity: _aiLocation("city"),
        operationId: _aiOperation("id"),
        operationName: _aiOperation("name"),
        operationParentId: _aiOperation("parentId"),
        operationRootId: _aiOperation("rootId"),
        operationSyntheticSource: _aiOperation("syntheticSource"),
        operationCorrelationVector: _aiOperation("correlationVector"),
        sessionId: _aiSession("id"),
        sessionIsFirst: _aiSession("isFirst"),
        sessionIsNew: _aiSession("isNew"),
        userAccountAcquisitionDate: _aiUser("accountAcquisitionDate"),
        userAccountId: _aiUser("accountId"),
        userAgent: _aiUser("userAgent"),
        userId: _aiUser("id"),
        userStoreRegion: _aiUser("storeRegion"),
        userAuthUserId: _aiUser("authUserId"),
        userAnonymousUserAcquisitionDate: _aiUser("anonUserAcquisitionDate"),
        userAuthenticatedUserAcquisitionDate: _aiUser("authUserAcquisitionDate"),
        cloudName: _aiCloud("name"),
        cloudRole: _aiCloud("role"),
        cloudRoleVer: _aiCloud("roleVer"),
        cloudRoleInstance: _aiCloud("roleInstance"),
        cloudEnvironment: _aiCloud("environment"),
        cloudLocation: _aiCloud("location"),
        cloudDeploymentUnit: _aiCloud("deploymentUnit"),
        internalNodeName: _aiInternal("nodeName"),
        internalSdkVersion: _aiInternal("sdkVersion"),
        internalAgentVersion: _aiInternal("agentVersion"),
        internalSnippet: _aiInternal("snippet"),
        internalSdkSrc: _aiInternal("sdkSrc")
    })));

    function createTelemetryItem(item, baseType, envelopeName, logger, customProperties, systemProperties) {
        var _a;
        envelopeName = dataSanitizeString(logger, envelopeName) || strNotSpecified;
        if (isNullOrUndefined(item) ||
            isNullOrUndefined(baseType) ||
            isNullOrUndefined(envelopeName)) {
            throwError("Input doesn't contain all required fields");
        }
        var iKey = "";
        if (item[strIkey]) {
            iKey = item[strIkey];
            delete item[strIkey];
        }
        var telemetryItem = (_a = {},
            _a[_DYN_NAME ] = envelopeName,
            _a.time = toISOString(new Date()),
            _a.iKey = iKey,
            _a.ext = systemProperties ? systemProperties : {},
            _a.tags = [],
            _a.data = {},
            _a.baseType = baseType,
            _a.baseData = item
        ,
            _a);
        if (!isNullOrUndefined(customProperties)) {
            objForEachKey(customProperties, function (prop, value) {
                telemetryItem.data[prop] = value;
            });
        }
        return telemetryItem;
    }
    var TelemetryItemCreator = /** @class */ (function () {
        function TelemetryItemCreator() {
        }
        TelemetryItemCreator.create = createTelemetryItem;
        return TelemetryItemCreator;
    }());

    var Extensions = {
        UserExt: "user",
        DeviceExt: "device",
        TraceExt: "trace",
        WebExt: "web",
        AppExt: "app",
        OSExt: "os",
        SessionExt: "ses",
        SDKExt: "sdk"
    };
    var CtxTagKeys = new ContextTagKeys();

    function createDomEvent(eventName) {
        var event = null;
        if (isFunction(Event)) {
            event = new Event(eventName);
        }
        else {
            var doc = getDocument();
            if (doc && doc.createEvent) {
                event = doc.createEvent("Event");
                event.initEvent(eventName, true, true);
            }
        }
        return event;
    }

    function _disableEvents(target, evtNamespace) {
        eventOff(target, null, null, evtNamespace);
    }
    function createOfflineListener(parentEvtNamespace) {
        var _document = getDocument();
        var _navigator = getNavigator();
        var _isListening = false;
        var listenerList = [];
        var rState = 1 ;
        if (_navigator && !isNullOrUndefined(_navigator.onLine) && !_navigator.onLine) {
            rState = 2 ;
        }
        var uState = 0 ;
        var _currentState = calCurrentState();
        var _evtNamespace = mergeEvtNamespace(createUniqueNamespace("OfflineListener"), parentEvtNamespace);
        try {
            if (_enableEvents(getWindow())) {
                _isListening = true;
            }
            if (_document) {
                var target = _document.body || _document;
                if (target.ononline) {
                    if (_enableEvents(target)) {
                        _isListening = true;
                    }
                }
            }
        }
        catch (e) {
            _isListening = false;
        }
        function _enableEvents(target) {
            var enabled = false;
            if (target) {
                enabled = eventOn(target, "online", _setOnline, _evtNamespace);
                if (enabled) {
                    eventOn(target, "offline", _setOffline, _evtNamespace);
                }
            }
            return enabled;
        }
        function _isOnline() {
            return _currentState;
        }
        function calCurrentState() {
            if (uState === 2  || rState === 2 ) {
                return false;
            }
            return true;
        }
        function listnerNoticeCheck() {
            var newState = calCurrentState();
            if (_currentState !== newState) {
                _currentState = newState;
                arrForEach(listenerList, function (callback) {
                    var offlineState = {
                        isOnline: _currentState,
                        rState: rState,
                        uState: uState
                    };
                    try {
                        callback(offlineState);
                    }
                    catch (e) {
                    }
                });
            }
        }
        function setOnlineState(newState) {
            uState = newState;
            listnerNoticeCheck();
        }
        function _setOnline() {
            rState = 1 ;
            listnerNoticeCheck();
        }
        function _setOffline() {
            rState = 2 ;
            listnerNoticeCheck();
        }
        function _unload() {
            var win = getWindow();
            if (win && _isListening) {
                _disableEvents(win, _evtNamespace);
                if (_document) {
                    var target = _document.body || _document;
                    if (!isUndefined(target.ononline)) {
                        _disableEvents(target, _evtNamespace);
                    }
                }
                _isListening = false;
            }
        }
        function addListener(callback) {
            listenerList[_DYN_PUSH ](callback);
            return {
                rm: function () {
                    var index = listenerList.indexOf(callback);
                    if (index > -1) {
                        return listenerList.splice(index, 1);
                    }
                    else {
                        return;
                    }
                }
            };
        }
        return {
            isOnline: _isOnline,
            isListening: function () { return _isListening; },
            unload: _unload,
            addListener: addListener,
            setOnlineState: setOnlineState
        };
    }

    var PropertiesPluginIdentifier = "AppInsightsPropertiesPlugin";
    var BreezeChannelIdentifier = "AppInsightsChannelPlugin";
    var AnalyticsPluginIdentifier = "ApplicationInsightsAnalytics";

    exports.AnalyticsPluginIdentifier = AnalyticsPluginIdentifier;
    exports.BreezeChannelIdentifier = BreezeChannelIdentifier;
    exports.ConfigurationManager = ConfigurationManager;
    exports.ConnectionStringParser = ConnectionStringParser;
    exports.ContextTagKeys = ContextTagKeys;
    exports.CtxTagKeys = CtxTagKeys;
    exports.DEFAULT_BREEZE_ENDPOINT = DEFAULT_BREEZE_ENDPOINT;
    exports.DEFAULT_BREEZE_PATH = DEFAULT_BREEZE_PATH;
    exports.Data = Data;
    exports.DisabledPropertyName = DisabledPropertyName;
    exports.DistributedTracingModes = DistributedTracingModes;
    exports.Envelope = Envelope;
    exports.Event = Event$1;
    exports.EventPersistence = EventPersistence;
    exports.Exception = Exception;
    exports.Extensions = Extensions;
    exports.HttpMethod = HttpMethod;
    exports.Metric = Metric;
    exports.PageView = PageView;
    exports.PageViewPerformance = PageViewPerformance;
    exports.ProcessLegacy = ProcessLegacy;
    exports.PropertiesPluginIdentifier = PropertiesPluginIdentifier;
    exports.RemoteDependencyData = RemoteDependencyData;
    exports.RequestHeaders = RequestHeaders;
    exports.SampleRate = SampleRate;
    exports.SeverityLevel = SeverityLevel;
    exports.TelemetryItemCreator = TelemetryItemCreator;
    exports.ThrottleMgr = ThrottleMgr;
    exports.Trace = Trace;
    exports.correlationIdCanIncludeCorrelationHeader = correlationIdCanIncludeCorrelationHeader;
    exports.correlationIdGetCorrelationContext = correlationIdGetCorrelationContext;
    exports.correlationIdGetCorrelationContextValue = correlationIdGetCorrelationContextValue;
    exports.correlationIdGetPrefix = correlationIdGetPrefix;
    exports.correlationIdSetPrefix = correlationIdSetPrefix;
    exports.createDistributedTraceContextFromTrace = createDistributedTraceContextFromTrace;
    exports.createDomEvent = createDomEvent;
    exports.createOfflineListener = createOfflineListener;
    exports.createTelemetryItem = createTelemetryItem;
    exports.createTraceParent = createTraceParent;
    exports.dataSanitizeException = dataSanitizeException;
    exports.dataSanitizeId = dataSanitizeId;
    exports.dataSanitizeInput = dataSanitizeInput;
    exports.dataSanitizeKey = dataSanitizeKey;
    exports.dataSanitizeKeyAndAddUniqueness = dataSanitizeKeyAndAddUniqueness;
    exports.dataSanitizeMeasurements = dataSanitizeMeasurements;
    exports.dataSanitizeMessage = dataSanitizeMessage;
    exports.dataSanitizeProperties = dataSanitizeProperties;
    exports.dataSanitizeString = dataSanitizeString;
    exports.dataSanitizeUrl = dataSanitizeUrl;
    exports.dateTimeUtilsDuration = dateTimeUtilsDuration;
    exports.dateTimeUtilsNow = dateTimeUtilsNow;
    exports.dsPadNumber = dsPadNumber;
    exports.findW3cTraceParent = findW3cTraceParent;
    exports.formatTraceParent = formatTraceParent;
    exports.getExtensionByName = getExtensionByName;
    exports.isBeaconApiSupported = isBeaconsSupported;
    exports.isCrossOriginError = isCrossOriginError;
    exports.isInternalApplicationInsightsEndpoint = isInternalApplicationInsightsEndpoint;
    exports.isSampledFlag = isSampledFlag;
    exports.isValidSpanId = isValidSpanId;
    exports.isValidTraceId = isValidTraceId;
    exports.isValidTraceParent = isValidTraceParent;
    exports.msToTimeSpan = msToTimeSpan;
    exports.parseConnectionString = parseConnectionString;
    exports.parseTraceParent = parseTraceParent;
    exports.strNotSpecified = strNotSpecified;
    exports.stringToBoolOrDefault = stringToBoolOrDefault;
    exports.urlGetAbsoluteUrl = urlGetAbsoluteUrl;
    exports.urlGetCompleteUrl = urlGetCompleteUrl;
    exports.urlGetPathName = urlGetPathName;
    exports.urlParseFullHost = urlParseFullHost;
    exports.urlParseHost = urlParseHost;
    exports.urlParseUrl = urlParseUrl;
    exports.utlCanUseLocalStorage = utlCanUseLocalStorage;
    exports.utlCanUseSessionStorage = utlCanUseSessionStorage;
    exports.utlDisableStorage = utlDisableStorage;
    exports.utlEnableStorage = utlEnableStorage;
    exports.utlGetLocalStorage = utlGetLocalStorage;
    exports.utlGetSessionStorage = utlGetSessionStorage;
    exports.utlGetSessionStorageKeys = utlGetSessionStorageKeys;
    exports.utlRemoveSessionStorage = utlRemoveSessionStorage;
    exports.utlRemoveStorage = utlRemoveStorage;
    exports.utlSetLocalStorage = utlSetLocalStorage;
    exports.utlSetSessionStorage = utlSetSessionStorage;
    exports.utlSetStoragePrefix = utlSetStoragePrefix;

}));
//# sourceMappingURL=applicationinsights-common.js.map


/***/ }),

/***/ 569:
/***/ (function(__unused_webpack_module, exports) {

/*!
 * Application Insights JavaScript Web SDK - Basic, 3.2.2
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */
(function (global, factory) {
     true ? factory(exports) :
    0;
})(this, (function (exports) { 'use strict';

    /*! https://github.com/nevware21/ts-utils v0.11.2 */
    /*#__NO_SIDE_EFFECTS__*/
    function _pureAssign(func1, func2) {
        return func1 || func2;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _pureRef(value, name) {
        return value[name];
    }
    var UNDEF_VALUE = undefined;
    var NULL_VALUE = null;
    var EMPTY = "";
    var FUNCTION = "function";
    var OBJECT = "object";
    var PROTOTYPE = "prototype";
    var __PROTO__ = "__proto__";
    var UNDEFINED = "undefined";
    var CONSTRUCTOR = "constructor";
    var SYMBOL = "Symbol";
    var POLYFILL_TAG = "_polyfill";
    var LENGTH = "length";
    var NAME = "name";
    var CALL = "call";
    var TO_STRING = "toString";
    var ObjClass$1 = ( /*#__PURE__*/_pureAssign(Object));
    var ObjProto$1 = ( /*#__PURE__*/_pureRef(ObjClass$1, PROTOTYPE));
    var StrCls = ( /*#__PURE__*/_pureAssign(String));
    var StrProto = ( /*#__PURE__*/_pureRef(StrCls, PROTOTYPE));
    var MathCls = ( /*#__PURE__*/_pureAssign(Math));
    var ArrCls = ( /*#__PURE__*/_pureAssign(Array));
    var ArrProto = ( /*#__PURE__*/_pureRef(ArrCls, PROTOTYPE));
    var ArrSlice = ( /*#__PURE__*/_pureRef(ArrProto, "slice"));
    function safe(func, argArray) {
        try {
            return {
                v: func.apply(this, argArray)
            };
        }
        catch (e) {
            return { e: e };
        }
    }
    /*#__NO_SIDE_EFFECTS__*/
    function safeGet(cb, defValue) {
        var result = safe(cb);
        return result.e ? defValue : result.v;
    }
    var _primitiveTypes;
    /*#__NO_SIDE_EFFECTS__*/
    function _createIs(theType) {
        return function (value) {
            return typeof value === theType;
        };
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _createObjIs(theName) {
        var theType = "[object " + theName + "]";
        return function (value) {
            return !!(value && objToString(value) === theType);
        };
    }
    /*#__NO_SIDE_EFFECTS__*/
    function objToString(value) {
        return ObjProto$1[TO_STRING].call(value);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isUndefined(value) {
        return typeof value === UNDEFINED || value === UNDEFINED;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isNullOrUndefined(value) {
        return value === NULL_VALUE || isUndefined(value);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isStrictNullOrUndefined(value) {
        return value === NULL_VALUE || !isDefined(value);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isDefined(arg) {
        return !!arg || arg !== UNDEF_VALUE;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isPrimitiveType(theType) {
        !_primitiveTypes && (_primitiveTypes = ["string", "number", "boolean", UNDEFINED, "symbol", "bigint"]);
        return theType !== OBJECT && _primitiveTypes.indexOf(theType) !== -1;
    }
    var isString = ( /*#__PURE__*/_createIs("string"));
    var isFunction = ( /*#__PURE__*/_createIs(FUNCTION));
    /*#__NO_SIDE_EFFECTS__*/
    function isObject(value) {
        if (!value && isNullOrUndefined(value)) {
            return false;
        }
        return !!value && typeof value === OBJECT;
    }
    var isArray = ( /* #__PURE__*/_pureRef(ArrCls, "isArray"));
    var isDate = ( /*#__PURE__*/_createObjIs("Date"));
    var isNumber = ( /*#__PURE__*/_createIs("number"));
    var isBoolean = ( /*#__PURE__*/_createIs("boolean"));
    var isError = ( /*#__PURE__*/_createObjIs("Error"));
    /*#__NO_SIDE_EFFECTS__*/
    function isPromiseLike(value) {
        return !!(value && value.then && isFunction(value.then));
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isTruthy(value) {
        return !(!value || safeGet(function () { return !(value && (0 + value)); }, !value));
    }
    var objGetOwnPropertyDescriptor = ( /* #__PURE__ */_pureRef(ObjClass$1, "getOwnPropertyDescriptor"));
    /*#__NO_SIDE_EFFECTS__*/
    function objHasOwnProperty(obj, prop) {
        return !!obj && ObjProto$1.hasOwnProperty[CALL](obj, prop);
    }
    var objHasOwn = ( /*#__PURE__*/_pureAssign(( /* #__PURE__ */_pureRef(ObjClass$1, "hasOwn")), polyObjHasOwn));
    /*#__NO_SIDE_EFFECTS__*/
    function polyObjHasOwn(obj, prop) {
        return objHasOwnProperty(obj, prop) || !!objGetOwnPropertyDescriptor(obj, prop);
    }
    function objForEachKey(theObject, callbackfn, thisArg) {
        if (theObject && isObject(theObject)) {
            for (var prop in theObject) {
                if (objHasOwn(theObject, prop)) {
                    if (callbackfn[CALL](thisArg || theObject, prop, theObject[prop]) === -1) {
                        break;
                    }
                }
            }
        }
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _createKeyValueMap(values, keyType, valueType, completeFn) {
        var theMap = {};
        objForEachKey(values, function (key, value) {
            theMap[key] = keyType ? value : key;
            theMap[value] = valueType ? value : key;
        });
        return completeFn(theMap);
    }
    var asString = ( /* #__PURE__ */_pureAssign(StrCls));
    var ERROR_TYPE = "[object Error]";
    /*#__NO_SIDE_EFFECTS__*/
    function dumpObj(object, format) {
        var propertyValueDump = EMPTY;
        var objType = ObjProto$1[TO_STRING][CALL](object);
        if (objType === ERROR_TYPE) {
            object = { stack: asString(object.stack), message: asString(object.message), name: asString(object.name) };
        }
        try {
            propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? ((typeof format === "number") ? format : 4) : UNDEF_VALUE);
            propertyValueDump = (propertyValueDump && propertyValueDump.replace(/"(\w+)"\s*:\s{0,1}/g, "$1: ")) || asString(object);
        }
        catch (e) {
            propertyValueDump = " - " + dumpObj(e, format);
        }
        return objType + ": " + propertyValueDump;
    }
    function throwError(message) {
        throw new Error(message);
    }
    function throwTypeError(message) {
        throw new TypeError(message);
    }
    var _objFreeze = ( /* #__PURE__ */_pureRef(ObjClass$1, "freeze"));
    function _doNothing(value) {
        return value;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _getProto(value) {
        return value[__PROTO__] || NULL_VALUE;
    }
    var objAssign = ( /*#__PURE__*/_pureRef(ObjClass$1, "assign"));
    var objKeys = ( /*#__PURE__*/_pureRef(ObjClass$1, "keys"));
    function objDeepFreeze(value) {
        if (_objFreeze) {
            objForEachKey(value, function (key, value) {
                if (isArray(value) || isObject(value)) {
                    _objFreeze(value);
                }
            });
        }
        return objFreeze(value);
    }
    var objFreeze = ( /* #__PURE__*/_pureAssign(_objFreeze, _doNothing));
    var objGetPrototypeOf = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ObjClass$1, "getPrototypeOf")), _getProto));
    /*#__NO_SIDE_EFFECTS__*/
    function createEnum(values) {
        return _createKeyValueMap(values, 1 , 0 , objDeepFreeze);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function createEnumKeyMap(values) {
        return _createKeyValueMap(values, 0 , 0 , objDeepFreeze);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function createSimpleMap(values) {
        var mapClass = {};
        objForEachKey(values, function (key, value) {
            mapClass[key] = value[1];
            mapClass[value[0]] = value[1];
        });
        return objDeepFreeze(mapClass);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function createTypeMap(values) {
        return createSimpleMap(values);
    }
    var _wellKnownSymbolMap = /*#__PURE__*/ createEnumKeyMap({
        asyncIterator: 0 ,
        hasInstance: 1 ,
        isConcatSpreadable: 2 ,
        iterator: 3 ,
        match: 4 ,
        matchAll: 5 ,
        replace: 6 ,
        search: 7 ,
        species: 8 ,
        split: 9 ,
        toPrimitive: 10 ,
        toStringTag: 11 ,
        unscopables: 12
    });
    var GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg";
    var _globalCfg;
    /*#__NO_SIDE_EFFECTS__*/
    function _getGlobalValue() {
        var result;
        if (typeof globalThis !== UNDEFINED) {
            result = globalThis;
        }
        if (!result && typeof self !== UNDEFINED) {
            result = self;
        }
        if (!result && typeof window !== UNDEFINED) {
            result = window;
        }
        if (!result && typeof global !== UNDEFINED) {
            result = global;
        }
        return result;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _getGlobalConfig() {
        if (!_globalCfg) {
            var gbl = safe(_getGlobalValue).v || {};
            _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};
        }
        return _globalCfg;
    }
    var _unwrapFunction = ( _unwrapFunctionWithPoly);
    /*#__NO_SIDE_EFFECTS__*/
    function _unwrapFunctionWithPoly(funcName, clsProto, polyFunc) {
        var clsFn = clsProto && clsProto[funcName];
        return function (thisArg) {
            var theFunc = (thisArg && thisArg[funcName]) || clsFn;
            if (theFunc || polyFunc) {
                var theArgs = arguments;
                return (theFunc || polyFunc).apply(thisArg, theFunc ? ArrSlice[CALL](theArgs, 1) : theArgs);
            }
            throwTypeError("\"" + asString(funcName) + "\" not defined for " + dumpObj(thisArg));
        };
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _unwrapProp(propName) {
        return function (thisArg) {
            return thisArg[propName];
        };
    }
    var mathMax = ( /*#__PURE__*/_pureRef(MathCls, "max"));
    var strSlice = ( /*#__PURE__*/_unwrapFunction("slice", StrProto));
    var strSubstring = ( /*#__PURE__*/_unwrapFunction("substring", StrProto));
    var strSubstr = ( /*#__PURE__*/_unwrapFunctionWithPoly("substr", StrProto, polyStrSubstr));
    /*#__NO_SIDE_EFFECTS__*/
    function polyStrSubstr(value, start, length) {
        if (isNullOrUndefined(value)) {
            throwTypeError("Invalid " + dumpObj(value));
        }
        if (length < 0) {
            return EMPTY;
        }
        start = start || 0;
        if (start < 0) {
            start = mathMax(start + value[LENGTH], 0);
        }
        if (isUndefined(length)) {
            return strSlice(value, start);
        }
        return strSlice(value, start, start + length);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function strLeft(value, count) {
        return strSubstring(value, 0, count);
    }
    var UNIQUE_REGISTRY_ID = "_urid";
    var _polySymbols;
    /*#__NO_SIDE_EFFECTS__*/
    function _globalSymbolRegistry() {
        if (!_polySymbols) {
            var gblCfg = _getGlobalConfig();
            _polySymbols = gblCfg.gblSym = gblCfg.gblSym || { k: {}, s: {} };
        }
        return _polySymbols;
    }
    var _wellKnownSymbolCache;
    /*#__NO_SIDE_EFFECTS__*/
    function polyNewSymbol(description) {
        var theSymbol = {
            description: asString(description),
            toString: function () { return SYMBOL + "(" + description + ")"; }
        };
        theSymbol[POLYFILL_TAG] = true;
        return theSymbol;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function polySymbolFor(key) {
        var registry = _globalSymbolRegistry();
        if (!objHasOwn(registry.k, key)) {
            var newSymbol_1 = polyNewSymbol(key);
            var regId_1 = objKeys(registry.s).length;
            newSymbol_1[UNIQUE_REGISTRY_ID] = function () { return regId_1 + "_" + newSymbol_1[TO_STRING](); };
            registry.k[key] = newSymbol_1;
            registry.s[newSymbol_1[UNIQUE_REGISTRY_ID]()] = asString(key);
        }
        return registry.k[key];
    }
    /*#__NO_SIDE_EFFECTS__*/
    function polyGetKnownSymbol(name) {
        !_wellKnownSymbolCache && (_wellKnownSymbolCache = {});
        var result;
        var knownName = _wellKnownSymbolMap[name];
        if (knownName) {
            result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || polyNewSymbol(SYMBOL + "." + knownName);
        }
        return result;
    }
    var propMap = {
        e: "enumerable",
        c: "configurable",
        v: "value",
        w: "writable",
        g: "get",
        s: "set"
    };
    /*#__NO_SIDE_EFFECTS__*/
    function _createProp(value) {
        var prop = {};
        prop[propMap["c"]] = true;
        prop[propMap["e"]] = true;
        if (value.l) {
            prop.get = function () { return value.l.v; };
            var desc = objGetOwnPropertyDescriptor(value.l, "v");
            if (desc && desc.set) {
                prop.set = function (newValue) {
                    value.l.v = newValue;
                };
            }
        }
        objForEachKey(value, function (key, value) {
            prop[propMap[key]] = isUndefined(value) ? prop[propMap[key]] : value;
        });
        return prop;
    }
    var objDefineProp = ( /*#__PURE__*/_pureRef(ObjClass$1, "defineProperty"));
    function objDefine(target, key, propDesc) {
        return objDefineProp(target, key, _createProp(propDesc));
    }
    var _globalLazyTestHooks;
    function _initTestHooks() {
        _globalLazyTestHooks = _getGlobalConfig();
    }
    /*#__NO_SIDE_EFFECTS__*/
    function getLazy(cb) {
        var lazyValue = {};
        !_globalLazyTestHooks && _initTestHooks();
        lazyValue.b = _globalLazyTestHooks.lzy;
        objDefineProp(lazyValue, "v", {
            configurable: true,
            get: function () {
                var result = cb();
                if (!_globalLazyTestHooks.lzy) {
                    objDefineProp(lazyValue, "v", {
                        value: result
                    });
                }
                lazyValue.b = _globalLazyTestHooks.lzy;
                return result;
            }
        });
        return lazyValue;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function createCachedValue(value) {
        return objDefineProp({
            toJSON: function () { return value; }
        }, "v", { value: value });
    }
    var WINDOW = "window";
    var _cachedGlobal;
    function _getGlobalInstFn(getFn, theArgs) {
        var cachedValue;
        return function () {
            !_globalLazyTestHooks && _initTestHooks();
            (!cachedValue || _globalLazyTestHooks.lzy) && (cachedValue = createCachedValue(safe(getFn, theArgs).v));
            return cachedValue.v;
        };
    }
    /*#__NO_SIDE_EFFECTS__*/
    function getGlobal(useCached) {
        !_globalLazyTestHooks && _initTestHooks();
        (!_cachedGlobal || useCached === false || _globalLazyTestHooks.lzy) && (_cachedGlobal = createCachedValue(safe(_getGlobalValue).v || NULL_VALUE));
        return _cachedGlobal.v;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function getInst(name, useCached) {
        var gbl = (!_cachedGlobal || useCached === false) ? getGlobal(useCached) : _cachedGlobal.v;
        if (gbl && gbl[name]) {
            return gbl[name];
        }
        if (name === WINDOW) {
            return getWindow();
        }
        return NULL_VALUE;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function hasDocument() {
        return !!( /*#__PURE__*/getDocument());
    }
    var getDocument = ( /*#__PURE__*/_getGlobalInstFn(getInst, ["document"]));
    /*#__NO_SIDE_EFFECTS__*/
    function hasWindow() {
        return !!( /*#__PURE__*/getWindow());
    }
    var getWindow = ( /*#__PURE__*/_getGlobalInstFn(getInst, [WINDOW]));
    /*#__NO_SIDE_EFFECTS__*/
    function hasNavigator() {
        return !!( /*#__PURE__*/getNavigator());
    }
    var getNavigator = ( /*#__PURE__*/_getGlobalInstFn(getInst, ["navigator"]));
    var isNode = ( /*#__PURE__*/_getGlobalInstFn(function () {
        return !!( safe(function () { return (process && (process.versions || {}).node); }).v);
    }));
    var _symbol;
    var _symbolFor;
    /*#__NO_SIDE_EFFECTS__*/
    function _initSymbol() {
        _symbol = ( /*#__PURE__*/createCachedValue(safe((getInst), [SYMBOL]).v));
        return _symbol;
    }
    function _getSymbolKey(key) {
        var gblSym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());
        return (gblSym.v ? gblSym.v[key] : UNDEF_VALUE);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function hasSymbol() {
        return !!( /*#__PURE__*/getSymbol());
    }
    /*#__NO_SIDE_EFFECTS__*/
    function getSymbol() {
        !_globalLazyTestHooks && _initTestHooks();
        return ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol()).v;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function getKnownSymbol(name, noPoly) {
        var knownName = _wellKnownSymbolMap[name];
        !_globalLazyTestHooks && _initTestHooks();
        var sym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());
        return sym.v ? sym.v[knownName || name] : (!noPoly ? polyGetKnownSymbol(name) : UNDEF_VALUE);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function newSymbol(description, noPoly) {
        !_globalLazyTestHooks && _initTestHooks();
        var sym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());
        return sym.v ? sym.v(description) : (!noPoly ? polyNewSymbol(description) : NULL_VALUE);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function symbolFor(key) {
        !_globalLazyTestHooks && _initTestHooks();
        _symbolFor = ((!_globalLazyTestHooks.lzy ? _symbolFor : 0) || ( /*#__PURE__*/createCachedValue(safe((_getSymbolKey), ["for"]).v)));
        return (_symbolFor.v || polySymbolFor)(key);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isIterator(value) {
        return !!value && isFunction(value.next);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function isIterable(value) {
        return !isStrictNullOrUndefined(value) && isFunction(value[getKnownSymbol(3 )]);
    }
    var _iterSymbol$1;
    function iterForOf(iter, callbackfn, thisArg) {
        if (iter) {
            if (!isIterator(iter)) {
                !_iterSymbol$1 && (_iterSymbol$1 = createCachedValue(getKnownSymbol(3 )));
                iter = iter[_iterSymbol$1.v] ? iter[_iterSymbol$1.v]() : null;
            }
            if (isIterator(iter)) {
                var err = UNDEF_VALUE;
                var iterResult = UNDEF_VALUE;
                try {
                    var count = 0;
                    while (!(iterResult = iter.next()).done) {
                        if (callbackfn[CALL](thisArg || iter, iterResult.value, count, iter) === -1) {
                            break;
                        }
                        count++;
                    }
                }
                catch (failed) {
                    err = { e: failed };
                    if (iter.throw) {
                        iterResult = NULL_VALUE;
                        iter.throw(err);
                    }
                }
                finally {
                    try {
                        if (iterResult && !iterResult.done) {
                            iter.return && iter.return(iterResult);
                        }
                    }
                    finally {
                        if (err) {
                            throw err.e;
                        }
                    }
                }
            }
        }
    }
    function fnApply(fn, thisArg, argArray) {
        return fn.apply(thisArg, argArray);
    }
    function arrAppend(target, elms) {
        if (!isUndefined(elms) && target) {
            if (isArray(elms)) {
                fnApply(target.push, target, elms);
            }
            else if (isIterator(elms) || isIterable(elms)) {
                iterForOf(elms, function (elm) {
                    target.push(elm);
                });
            }
            else {
                target.push(elms);
            }
        }
        return target;
    }
    function arrForEach(theArray, callbackfn, thisArg) {
        if (theArray) {
            var len = theArray[LENGTH] >>> 0;
            for (var idx = 0; idx < len; idx++) {
                if (idx in theArray) {
                    if (callbackfn[CALL](thisArg || theArray, theArray[idx], idx, theArray) === -1) {
                        break;
                    }
                }
            }
        }
    }
    var arrIndexOf = ( /*#__PURE__*/_unwrapFunction("indexOf", ArrProto));
    var arrMap = ( /*#__PURE__*/_unwrapFunction("map", ArrProto));
    function arrSlice(theArray, start, end) {
        return ((theArray && theArray["slice"]) || ArrSlice).apply(theArray, ArrSlice[CALL](arguments, 1));
    }
    var arrReduce = ( /*#__PURE__*/_unwrapFunction("reduce", ArrProto));
    var objCreate = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ObjClass$1, "create")), polyObjCreate));
    /*#__NO_SIDE_EFFECTS__*/
    function polyObjCreate(obj) {
        if (!obj) {
            return {};
        }
        var type = typeof obj;
        if (type !== OBJECT && type !== FUNCTION) {
            throwTypeError("Prototype must be an Object or function: " + dumpObj(obj));
        }
        function tempFunc() { }
        tempFunc[PROTOTYPE] = obj;
        return new tempFunc();
    }
    var _isProtoArray;
    function objSetPrototypeOf(obj, proto) {
        var fn = ObjClass$1["setPrototypeOf"] ||
            function (d, b) {
                var _a;
                !_isProtoArray && (_isProtoArray = createCachedValue((_a = {}, _a[__PROTO__] = [], _a) instanceof Array));
                _isProtoArray.v ? d[__PROTO__] = b : objForEachKey(b, function (key, value) { return d[key] = value; });
            };
        return fn(obj, proto);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _createCustomError(name, d, b) {
        safe(objDefine, [d, NAME, { v: name, c: true, e: false }]);
        d = objSetPrototypeOf(d, b);
        function __() {
            this[CONSTRUCTOR] = d;
            safe(objDefine, [this, NAME, { v: name, c: true, e: false }]);
        }
        d[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : (__[PROTOTYPE] = b[PROTOTYPE], new __());
        return d;
    }
    function _setName(baseClass, name) {
        name && (baseClass[NAME] = name);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function createCustomError(name, constructCb, errorBase) {
        var theBaseClass = errorBase || Error;
        var orgName = theBaseClass[PROTOTYPE][NAME];
        var captureFn = Error.captureStackTrace;
        return _createCustomError(name, function () {
            var _this = this;
            var theArgs = arguments;
            try {
                safe(_setName, [theBaseClass, name]);
                var _self = fnApply(theBaseClass, _this, ArrSlice[CALL](theArgs)) || _this;
                if (_self !== _this) {
                    var orgProto = objGetPrototypeOf(_this);
                    if (orgProto !== objGetPrototypeOf(_self)) {
                        objSetPrototypeOf(_self, orgProto);
                    }
                }
                captureFn && captureFn(_self, _this[CONSTRUCTOR]);
                constructCb && constructCb(_self, theArgs);
                return _self;
            }
            finally {
                safe(_setName, [theBaseClass, orgName]);
            }
        }, theBaseClass);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function utcNow() {
        return (Date.now || polyUtcNow)();
    }
    /*#__NO_SIDE_EFFECTS__*/
    function polyUtcNow() {
        return new Date().getTime();
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _createTrimFn(exp) {
        return function _doTrim(value) {
            if (isNullOrUndefined(value)) {
                throwTypeError("strTrim called [" + dumpObj(value) + "]");
            }
            if (value && value.replace) {
                value = value.replace(exp, EMPTY);
            }
            return value;
        };
    }
    var polyStrTrim = ( /*#__PURE__*/_createTrimFn(/^\s+|(?=\s)\s+$/g));
    var strTrim = ( /*#__PURE__*/_unwrapFunctionWithPoly("trim", StrProto, polyStrTrim));
    var _fnToString;
    var _objCtrFnString;
    var _gblWindow;
    /*#__NO_SIDE_EFFECTS__*/
    function isPlainObject(value) {
        if (!value || typeof value !== OBJECT) {
            return false;
        }
        if (!_gblWindow) {
            _gblWindow = hasWindow() ? getWindow() : true;
        }
        var result = false;
        if (value !== _gblWindow) {
            if (!_objCtrFnString) {
                _fnToString = Function[PROTOTYPE][TO_STRING];
                _objCtrFnString = _fnToString[CALL](ObjClass$1);
            }
            try {
                var proto = objGetPrototypeOf(value);
                result = !proto;
                if (!result) {
                    if (objHasOwnProperty(proto, CONSTRUCTOR)) {
                        proto = proto[CONSTRUCTOR];
                    }
                    result = proto && typeof proto === FUNCTION && _fnToString[CALL](proto) === _objCtrFnString;
                }
            }
            catch (ex) {
            }
        }
        return result;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _defaultDeepCopyHandler(details) {
        details.value && plainObjDeepCopyHandler(details);
        return true;
    }
    var defaultDeepCopyHandlers = [
        arrayDeepCopyHandler,
        plainObjDeepCopyHandler,
        functionDeepCopyHandler,
        dateDeepCopyHandler
    ];
    /*#__NO_SIDE_EFFECTS__*/
    function _getSetVisited(visitMap, source, newPath, cb) {
        var theEntry;
        arrForEach(visitMap, function (entry) {
            if (entry.k === source) {
                theEntry = entry;
                return -1;
            }
        });
        if (!theEntry) {
            theEntry = { k: source, v: source };
            visitMap.push(theEntry);
            cb(theEntry);
        }
        return theEntry.v;
    }
    function _deepCopy(visitMap, value, ctx, key) {
        var userHandler = ctx.handler;
        var newPath = ctx.path ? (key ? ctx.path.concat(key) : ctx.path) : [];
        var newCtx = {
            handler: ctx.handler,
            src: ctx.src,
            path: newPath
        };
        var theType = typeof value;
        var isPlain = false;
        var isPrim = false;
        if (value && theType === OBJECT) {
            isPlain = isPlainObject(value);
        }
        else {
            isPrim = value === NULL_VALUE || isPrimitiveType(theType);
        }
        var details = {
            type: theType,
            isPrim: isPrim,
            isPlain: isPlain,
            value: value,
            result: value,
            path: newPath,
            origin: ctx.src,
            copy: function (source, newKey) {
                return _deepCopy(visitMap, source, newKey ? newCtx : ctx, newKey);
            },
            copyTo: function (target, source) {
                return _copyProps(visitMap, target, source, newCtx);
            }
        };
        if (!details.isPrim) {
            return _getSetVisited(visitMap, value, newPath, function (newEntry) {
                objDefine(details, "result", {
                    g: function () {
                        return newEntry.v;
                    },
                    s: function (newValue) {
                        newEntry.v = newValue;
                    }
                });
                var idx = 0;
                var handler = userHandler;
                while (!(handler || (idx < defaultDeepCopyHandlers.length ? defaultDeepCopyHandlers[idx++] : _defaultDeepCopyHandler))[CALL](ctx, details)) {
                    handler = NULL_VALUE;
                }
            });
        }
        if (userHandler && userHandler[CALL](ctx, details)) {
            return details.result;
        }
        return value;
    }
    function _copyProps(visitMap, target, source, ctx) {
        if (!isNullOrUndefined(source)) {
            for (var key in source) {
                target[key] = _deepCopy(visitMap, source[key], ctx, key);
            }
        }
        return target;
    }
    function objCopyProps(target, source, handler) {
        var ctx = {
            handler: handler,
            src: source,
            path: []
        };
        return _copyProps([], target, source, ctx);
    }
    /*#__NO_SIDE_EFFECTS__*/
    function objDeepCopy(source, handler) {
        var ctx = {
            handler: handler,
            src: source
        };
        return _deepCopy([], source, ctx);
    }
    function arrayDeepCopyHandler(details) {
        var value = details.value;
        if (isArray(value)) {
            var target = details.result = [];
            target.length = value.length;
            details.copyTo(target, value);
            return true;
        }
        return false;
    }
    function dateDeepCopyHandler(details) {
        var value = details.value;
        if (isDate(value)) {
            details.result = new Date(value.getTime());
            return true;
        }
        return false;
    }
    function functionDeepCopyHandler(details) {
        if (details.type === FUNCTION) {
            return true;
        }
        return false;
    }
    function plainObjDeepCopyHandler(details) {
        var value = details.value;
        if (value && details.isPlain) {
            var target = details.result = {};
            details.copyTo(target, value);
            return true;
        }
        return false;
    }
    function _doExtend(target, theArgs) {
        arrForEach(theArgs, function (theArg) {
            objCopyProps(target, theArg);
        });
        return target;
    }
    function deepExtend(target, obj1, obj2, obj3, obj4, obj5, obj6) {
        return _doExtend(objDeepCopy(target) || {}, ArrSlice[CALL](arguments));
    }
    var getLength = ( /*#__PURE__*/_unwrapProp(LENGTH));
    var strEndsWith = ( /*#__PURE__*/_unwrapFunctionWithPoly("endsWith", StrProto, polyStrEndsWith));
    /*#__NO_SIDE_EFFECTS__*/
    function polyStrEndsWith(value, searchString, length) {
        if (!isString(value)) {
            throwTypeError("'" + dumpObj(value) + "' is not a string");
        }
        var searchValue = isString(searchString) ? searchString : asString(searchString);
        var end = !isUndefined(length) && length < value[LENGTH] ? length : value[LENGTH];
        return strSubstring(value, end - searchValue[LENGTH], end) === searchValue;
    }
    var strIndexOf = ( /*#__PURE__*/_unwrapFunction("indexOf", StrProto));
    var REF = "ref";
    var UNREF = "unref";
    var HAS_REF = "hasRef";
    var ENABLED = "enabled";
    /*#__NO_SIDE_EFFECTS__*/
    function _createTimerHandler(startTimer, refreshFn, cancelFn) {
        var ref = true;
        var timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE;
        var theTimerHandler;
        function _unref() {
            ref = false;
            timerId && timerId[UNREF] && timerId[UNREF]();
            return theTimerHandler;
        }
        function _cancel() {
            timerId && cancelFn(timerId);
            timerId = NULL_VALUE;
        }
        function _refresh() {
            timerId = refreshFn(timerId);
            if (!ref) {
                _unref();
            }
            return theTimerHandler;
        }
        function _setEnabled(value) {
            !value && timerId && _cancel();
            value && !timerId && _refresh();
        }
        theTimerHandler = {
            cancel: _cancel,
            refresh: _refresh
        };
        theTimerHandler[HAS_REF] = function () {
            if (timerId && timerId[HAS_REF]) {
                return timerId[HAS_REF]();
            }
            return ref;
        };
        theTimerHandler[REF] = function () {
            ref = true;
            timerId && timerId[REF] && timerId[REF]();
            return theTimerHandler;
        };
        theTimerHandler[UNREF] = _unref;
        theTimerHandler = objDefineProp(theTimerHandler, ENABLED, {
            get: function () { return !!timerId; },
            set: _setEnabled
        });
        return {
            h: theTimerHandler,
            dn: function () {
                timerId = NULL_VALUE;
            }
        };
    }
    function _createTimeoutWith(startTimer, overrideFn, theArgs) {
        var isArr = isArray(overrideFn);
        var len = isArr ? overrideFn.length : 0;
        var setFn = (len > 0 ? overrideFn[0] : (!isArr ? overrideFn : UNDEF_VALUE)) || setTimeout;
        var clearFn = (len > 1 ? overrideFn[1] : UNDEF_VALUE) || clearTimeout;
        var timerFn = theArgs[0];
        theArgs[0] = function () {
            handler.dn();
            fnApply(timerFn, UNDEF_VALUE, ArrSlice[CALL](arguments));
        };
        var handler = _createTimerHandler(startTimer, function (timerId) {
            if (timerId) {
                if (timerId.refresh) {
                    timerId.refresh();
                    return timerId;
                }
                fnApply(clearFn, UNDEF_VALUE, [timerId]);
            }
            return fnApply(setFn, UNDEF_VALUE, theArgs);
        }, function (timerId) {
            fnApply(clearFn, UNDEF_VALUE, [timerId]);
        });
        return handler.h;
    }
    function scheduleTimeout(callback, timeout) {
        return _createTimeoutWith(true, UNDEF_VALUE, ArrSlice[CALL](arguments));
    }
    function createTimeout(callback, timeout) {
        return _createTimeoutWith(false, UNDEF_VALUE, ArrSlice[CALL](arguments));
    }

    var _a$5;
    var Constructor = 'constructor';
    var Prototype = 'prototype';
    var strFunction = 'function';
    var DynInstFuncTable = '_dynInstFuncs';
    var DynProxyTag = '_isDynProxy';
    var DynClassName = '_dynClass';
    var DynClassNamePrefix = '_dynCls$';
    var DynInstChkTag = '_dynInstChk';
    var DynAllowInstChkTag = DynInstChkTag;
    var DynProtoDefaultOptions = '_dfOpts';
    var UnknownValue = '_unknown_';
    var str__Proto = "__proto__";
    var DynProtoBaseProto = "_dyn" + str__Proto;
    var DynProtoGlobalSettings = "__dynProto$Gbl";
    var DynProtoCurrent = "_dynInstProto";
    var strUseBaseInst = 'useBaseInst';
    var strSetInstFuncs = 'setInstFuncs';
    var Obj = Object;
    var _objGetPrototypeOf = Obj["getPrototypeOf"];
    var _objGetOwnProps = Obj["getOwnPropertyNames"];
    var _gbl = getGlobal();
    var _gblInst = _gbl[DynProtoGlobalSettings] || (_gbl[DynProtoGlobalSettings] = {
        o: (_a$5 = {},
            _a$5[strSetInstFuncs] = true,
            _a$5[strUseBaseInst] = true,
            _a$5),
        n: 1000
    });
    function _isObjectOrArrayPrototype(target) {
        return target && (target === Obj[Prototype] || target === Array[Prototype]);
    }
    function _isObjectArrayOrFunctionPrototype(target) {
        return _isObjectOrArrayPrototype(target) || target === Function[Prototype];
    }
    function _getObjProto(target) {
        var newProto;
        if (target) {
            if (_objGetPrototypeOf) {
                return _objGetPrototypeOf(target);
            }
            var curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);
            newProto = target[DynProtoBaseProto] || curProto;
            if (!objHasOwnProperty(target, DynProtoBaseProto)) {
                delete target[DynProtoCurrent];
                newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto];
                target[DynProtoCurrent] = curProto;
            }
        }
        return newProto;
    }
    function _forEachProp(target, func) {
        var props = [];
        if (_objGetOwnProps) {
            props = _objGetOwnProps(target);
        }
        else {
            for (var name_1 in target) {
                if (typeof name_1 === "string" && objHasOwnProperty(target, name_1)) {
                    props.push(name_1);
                }
            }
        }
        if (props && props.length > 0) {
            for (var lp = 0; lp < props.length; lp++) {
                func(props[lp]);
            }
        }
    }
    function _isDynamicCandidate(target, funcName, skipOwn) {
        return (funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || objHasOwnProperty(target, funcName)) && funcName !== str__Proto && funcName !== Prototype);
    }
    function _throwTypeError(message) {
        throwTypeError("DynamicProto: " + message);
    }
    function _getInstanceFuncs(thisTarget) {
        var instFuncs = objCreate(null);
        _forEachProp(thisTarget, function (name) {
            if (!instFuncs[name] && _isDynamicCandidate(thisTarget, name, false)) {
                instFuncs[name] = thisTarget[name];
            }
        });
        return instFuncs;
    }
    function _hasVisited(values, value) {
        for (var lp = values.length - 1; lp >= 0; lp--) {
            if (values[lp] === value) {
                return true;
            }
        }
        return false;
    }
    function _getBaseFuncs(classProto, thisTarget, instFuncs, useBaseInst) {
        function _instFuncProxy(target, funcHost, funcName) {
            var theFunc = funcHost[funcName];
            if (theFunc[DynProxyTag] && useBaseInst) {
                var instFuncTable = target[DynInstFuncTable] || {};
                if (instFuncTable[DynAllowInstChkTag] !== false) {
                    theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc;
                }
            }
            return function () {
                return theFunc.apply(target, arguments);
            };
        }
        var baseFuncs = objCreate(null);
        _forEachProp(instFuncs, function (name) {
            baseFuncs[name] = _instFuncProxy(thisTarget, instFuncs, name);
        });
        var baseProto = _getObjProto(classProto);
        var visited = [];
        while (baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto)) {
            _forEachProp(baseProto, function (name) {
                if (!baseFuncs[name] && _isDynamicCandidate(baseProto, name, !_objGetPrototypeOf)) {
                    baseFuncs[name] = _instFuncProxy(thisTarget, baseProto, name);
                }
            });
            visited.push(baseProto);
            baseProto = _getObjProto(baseProto);
        }
        return baseFuncs;
    }
    function _getInstFunc(target, funcName, proto, currentDynProtoProxy) {
        var instFunc = null;
        if (target && objHasOwnProperty(proto, DynClassName)) {
            var instFuncTable = target[DynInstFuncTable] || objCreate(null);
            instFunc = (instFuncTable[proto[DynClassName]] || objCreate(null))[funcName];
            if (!instFunc) {
                _throwTypeError("Missing [" + funcName + "] " + strFunction);
            }
            if (!instFunc[DynInstChkTag] && instFuncTable[DynAllowInstChkTag] !== false) {
                var canAddInst = !objHasOwnProperty(target, funcName);
                var objProto = _getObjProto(target);
                var visited = [];
                while (canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto)) {
                    var protoFunc = objProto[funcName];
                    if (protoFunc) {
                        canAddInst = (protoFunc === currentDynProtoProxy);
                        break;
                    }
                    visited.push(objProto);
                    objProto = _getObjProto(objProto);
                }
                try {
                    if (canAddInst) {
                        target[funcName] = instFunc;
                    }
                    instFunc[DynInstChkTag] = 1;
                }
                catch (e) {
                    instFuncTable[DynAllowInstChkTag] = false;
                }
            }
        }
        return instFunc;
    }
    function _getProtoFunc(funcName, proto, currentDynProtoProxy) {
        var protoFunc = proto[funcName];
        if (protoFunc === currentDynProtoProxy) {
            protoFunc = _getObjProto(proto)[funcName];
        }
        if (typeof protoFunc !== strFunction) {
            _throwTypeError("[" + funcName + "] is not a " + strFunction);
        }
        return protoFunc;
    }
    function _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {
        function _createDynamicPrototype(proto, funcName) {
            var dynProtoProxy = function () {
                var instFunc = _getInstFunc(this, funcName, proto, dynProtoProxy) || _getProtoFunc(funcName, proto, dynProtoProxy);
                return instFunc.apply(this, arguments);
            };
            dynProtoProxy[DynProxyTag] = 1;
            return dynProtoProxy;
        }
        if (!_isObjectOrArrayPrototype(proto)) {
            var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || objCreate(null);
            if (!_isObjectOrArrayPrototype(instFuncTable)) {
                var instFuncs_1 = instFuncTable[className] = (instFuncTable[className] || objCreate(null));
                if (instFuncTable[DynAllowInstChkTag] !== false) {
                    instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc;
                }
                if (!_isObjectOrArrayPrototype(instFuncs_1)) {
                    _forEachProp(target, function (name) {
                        if (_isDynamicCandidate(target, name, false) && target[name] !== baseInstFuncs[name]) {
                            instFuncs_1[name] = target[name];
                            delete target[name];
                            if (!objHasOwnProperty(proto, name) || (proto[name] && !proto[name][DynProxyTag])) {
                                proto[name] = _createDynamicPrototype(proto, name);
                            }
                        }
                    });
                }
            }
        }
    }
    function _checkPrototype(classProto, thisTarget) {
        if (_objGetPrototypeOf) {
            var visited = [];
            var thisProto = _getObjProto(thisTarget);
            while (thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto)) {
                if (thisProto === classProto) {
                    return true;
                }
                visited.push(thisProto);
                thisProto = _getObjProto(thisProto);
            }
            return false;
        }
        return true;
    }
    function _getObjName(target, unknownValue) {
        if (objHasOwnProperty(target, Prototype)) {
            return target.name || unknownValue || UnknownValue;
        }
        return (((target || {})[Constructor]) || {}).name || unknownValue || UnknownValue;
    }
    function dynamicProto(theClass, target, delegateFunc, options) {
        if (!objHasOwnProperty(theClass, Prototype)) {
            _throwTypeError("theClass is an invalid class definition.");
        }
        var classProto = theClass[Prototype];
        if (!_checkPrototype(classProto, target)) {
            _throwTypeError("[" + _getObjName(theClass) + "] not in hierarchy of [" + _getObjName(target) + "]");
        }
        var className = null;
        if (objHasOwnProperty(classProto, DynClassName)) {
            className = classProto[DynClassName];
        }
        else {
            className = DynClassNamePrefix + _getObjName(theClass, "_") + "$" + _gblInst.n;
            _gblInst.n++;
            classProto[DynClassName] = className;
        }
        var perfOptions = dynamicProto[DynProtoDefaultOptions];
        var useBaseInst = !!perfOptions[strUseBaseInst];
        if (useBaseInst && options && options[strUseBaseInst] !== undefined) {
            useBaseInst = !!options[strUseBaseInst];
        }
        var instFuncs = _getInstanceFuncs(target);
        var baseFuncs = _getBaseFuncs(classProto, target, instFuncs, useBaseInst);
        delegateFunc(target, baseFuncs);
        var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];
        if (setInstanceFunc && options) {
            setInstanceFunc = !!options[strSetInstFuncs];
        }
        _populatePrototype(classProto, className, target, instFuncs, setInstanceFunc !== false);
    }
    dynamicProto[DynProtoDefaultOptions] = _gblInst.o;

    var strShimFunction = "function";
    var strShimObject = "object";
    var strShimUndefined = "undefined";
    var strShimPrototype = "prototype";
    var ObjClass = Object;
    var ObjProto = ObjClass[strShimPrototype];

    var strHasOwnProperty = "hasOwnProperty";
    var __objAssignFnImpl = function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (ObjProto[strHasOwnProperty].call(s, p)) {
                    t[p] = s[p];
                }
            }
        }
        return t;
    };
    var __assignFn = objAssign || __objAssignFnImpl;
    var extendStaticsFn = function (d, b) {
        extendStaticsFn = ObjClass["setPrototypeOf"] ||
            ({ __proto__: [] } instanceof Array && function (d, b) {
                d.__proto__ = b;
            }) ||
            function (d, b) {
                for (var p in b) {
                    if (b[strHasOwnProperty](p)) {
                        d[p] = b[p];
                    }
                }
            };
        return extendStaticsFn(d, b);
    };
    function __extendsFn(d, b) {
        if (typeof b !== strShimFunction && b !== null) {
            throwTypeError("Class extends value " + String(b) + " is not a constructor or null");
        }
        extendStaticsFn(d, b);
        function __() {
            this.constructor = d;
        }
        d[strShimPrototype] = b === null ? objCreate(b) : (__[strShimPrototype] = b[strShimPrototype], new __());
    }
    function __spreadArrayFn(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {
            to[j] = from[i];
        }
        return to;
    }

    var createEnumStyle = createEnum;
    var createValueMap = createTypeMap;

    var _DYN_TO_LOWER_CASE$1 = "toLowerCase";
    var _DYN_BLK_VAL = "blkVal";
    var _DYN_LENGTH$2 = "length";
    var _DYN_RD_ONLY = "rdOnly";
    var _DYN_NOTIFY = "notify";
    var _DYN_WARN_TO_CONSOLE = "warnToConsole";
    var _DYN_THROW_INTERNAL = "throwInternal";
    var _DYN_SET_DF = "setDf";
    var _DYN_WATCH = "watch";
    var _DYN_LOGGER = "logger";
    var _DYN_APPLY = "apply";
    var _DYN_PUSH$2 = "push";
    var _DYN_SPLICE = "splice";
    var _DYN_HDLR = "hdlr";
    var _DYN_CANCEL = "cancel";
    var _DYN_INITIALIZE$1 = "initialize";
    var _DYN_IDENTIFIER = "identifier";
    var _DYN_REMOVE_NOTIFICATION_0 = "removeNotificationListener";
    var _DYN_ADD_NOTIFICATION_LIS1 = "addNotificationListener";
    var _DYN_IS_INITIALIZED = "isInitialized";
    var _DYN_GET_NOTIFY_MGR = "getNotifyMgr";
    var _DYN_GET_PLUGIN = "getPlugin";
    var _DYN_POLL_INTERNAL_LOGS = "pollInternalLogs";
    var _DYN_NAME$2 = "name";
    var _DYN_TIME = "time";
    var _DYN_PROCESS_NEXT = "processNext";
    var _DYN_GET_PROCESS_TEL_CONT2 = "getProcessTelContext";
    var _DYN_ENABLED = "enabled";
    var _DYN_STOP_POLLING_INTERNA3 = "stopPollingInternalLogs";
    var _DYN_UNLOAD = "unload";
    var _DYN_ON_COMPLETE = "onComplete";
    var _DYN_VERSION = "version";
    var _DYN_LOGGING_LEVEL_CONSOL4 = "loggingLevelConsole";
    var _DYN_CREATE_NEW$1 = "createNew";
    var _DYN_TEARDOWN = "teardown";
    var _DYN_MESSAGE_ID = "messageId";
    var _DYN_MESSAGE$1 = "message";
    var _DYN_IS_ASYNC = "isAsync";
    var _DYN_DIAG_LOG$1 = "diagLog";
    var _DYN__DO_TEARDOWN = "_doTeardown";
    var _DYN_UPDATE = "update";
    var _DYN_GET_NEXT = "getNext";
    var _DYN_SET_NEXT_PLUGIN = "setNextPlugin";
    var _DYN_PROTOCOL = "protocol";
    var _DYN_USER_AGENT = "userAgent";
    var _DYN_SPLIT$1 = "split";
    var _DYN_NODE_TYPE = "nodeType";
    var _DYN_REPLACE = "replace";
    var _DYN_LOG_INTERNAL_MESSAGE = "logInternalMessage";
    var _DYN_TYPE = "type";
    var _DYN_HANDLER = "handler";
    var _DYN_STATUS = "status";
    var _DYN_GET_RESPONSE_HEADER = "getResponseHeader";
    var _DYN_GET_ALL_RESPONSE_HEA5 = "getAllResponseHeaders";
    var _DYN_IS_CHILD_EVT = "isChildEvt";
    var _DYN_DATA$1 = "data";
    var _DYN_GET_CTX = "getCtx";
    var _DYN_SET_CTX = "setCtx";
    var _DYN_COMPLETE = "complete";
    var _DYN_ITEMS_RECEIVED$1 = "itemsReceived";
    var _DYN_URL_STRING = "urlString";
    var _DYN_SEND_POST = "sendPOST";
    var _DYN_HEADERS = "headers";
    var _DYN_TIMEOUT = "timeout";
    var _DYN_SET_REQUEST_HEADER = "setRequestHeader";
    var _DYN_TRACE_ID$1 = "traceId";
    var _DYN_SPAN_ID = "spanId";
    var _DYN_TRACE_FLAGS = "traceFlags";

    var aggregationErrorType;
    function throwAggregationError(message, sourceErrors) {
        if (!aggregationErrorType) {
            aggregationErrorType = createCustomError("AggregationError", function (self, args) {
                if (args[_DYN_LENGTH$2 ] > 1) {
                    self.errors = args[1];
                }
            });
        }
        var theMessage = message || "One or more errors occurred.";
        arrForEach(sourceErrors, function (srcError, idx) {
            theMessage += "\n".concat(idx, " > ").concat(dumpObj(srcError));
        });
        throw new aggregationErrorType(theMessage, sourceErrors || []);
    }

    /*!
     * NevWare21 - ts-async, 0.5.1
     * https://github.com/nevware21/ts-async
     * Copyright (c) NevWare21 and contributors. All rights reserved.
     * Licensed under the MIT license.
     */
    var STR_PROMISE = "Promise";
    var REJECTED = "rejected";
    function doAwaitResponse(value, cb) {
        return doAwait(value, function (value) {
            return cb ? cb({
                status: "fulfilled",
                rejected: false,
                value: value
            }) : value;
        }, function (reason) {
            return cb ? cb({
                status: REJECTED,
                rejected: true,
                reason: reason
            }) : reason;
        });
    }
    function doAwait(value, resolveFn, rejectFn, finallyFn) {
        var result = value;
        try {
            if (isPromiseLike(value)) {
                if (resolveFn || rejectFn) {
                    result = value.then(resolveFn, rejectFn);
                }
            }
            else {
                try {
                    if (resolveFn) {
                        result = resolveFn(value);
                    }
                }
                catch (err) {
                    if (rejectFn) {
                        result = rejectFn(err);
                    }
                    else {
                        throw err;
                    }
                }
            }
        }
        finally {
            if (finallyFn) {
                doFinally(result, finallyFn);
            }
        }
        return result;
    }
    function doFinally(value, finallyFn) {
        var result = value;
        if (finallyFn) {
            if (isPromiseLike(value)) {
                if (value.finally) {
                    result = value.finally(finallyFn);
                }
                else {
                    result = value.then(function (value) {
                        finallyFn();
                        return value;
                    }, function (reason) {
                        finallyFn();
                        throw reason;
                    });
                }
            }
            else {
                finallyFn();
            }
        }
        return result;
    }
    var STRING_STATES =  [
        "pending", "resolving", "resolved", REJECTED
    ];
    var DISPATCH_EVENT = "dispatchEvent";
    var _hasInitEvent;
    function _hasInitEventFn(doc) {
        var evt;
        if (doc && doc.createEvent) {
            evt = doc.createEvent("Event");
        }
        return (!!evt && evt.initEvent);
    }
    function emitEvent(target, evtName, populateEvent, useNewEvent) {
        var doc = getDocument();
        !_hasInitEvent && (_hasInitEvent = createCachedValue(!!safe(_hasInitEventFn, [doc]).v));
        var theEvt = _hasInitEvent.v ? doc.createEvent("Event") : (useNewEvent ? new Event(evtName) : {});
        populateEvent && populateEvent(theEvt);
        if (_hasInitEvent.v) {
            theEvt.initEvent(evtName, false, true);
        }
        if (theEvt && target[DISPATCH_EVENT]) {
            target[DISPATCH_EVENT](theEvt);
        }
        else {
            var handler = target["on" + evtName];
            if (handler) {
                handler(theEvt);
            }
            else {
                var theConsole = getInst("console");
                theConsole && (theConsole["error"] || theConsole["log"])(evtName, dumpObj(theEvt));
            }
        }
    }
    var NODE_UNHANDLED_REJECTION = "unhandledRejection";
    var UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();
    var _unhandledRejectionTimeout = 10;
    var _hasPromiseRejectionEvent;
    function dumpFnObj(value) {
        if (isFunction(value)) {
            return value.toString();
        }
        return dumpObj(value);
    }
    function _createPromise(newPromise, processor, executor) {
        var additionalArgs = arrSlice(arguments, 3);
        var _state = 0 ;
        var _hasResolved = false;
        var _settledValue;
        var _queue = [];
        var _handled = false;
        var _unHandledRejectionHandler = null;
        var _thePromise;
        function _then(onResolved, onRejected) {
            try {
                _handled = true;
                _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
                _unHandledRejectionHandler = null;
                var thenPromise = newPromise(function (resolve, reject) {
                    _queue.push(function () {
                        try {
                            var handler = _state === 2  ? onResolved : onRejected;
                            var value = isUndefined(handler) ? _settledValue : (isFunction(handler) ? handler(_settledValue) : handler);
                            if (isPromiseLike(value)) {
                                value.then(resolve, reject);
                            }
                            else if (handler) {
                                resolve(value);
                            }
                            else if (_state === 3 ) {
                                reject(value);
                            }
                            else {
                                resolve(value);
                            }
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                    if (_hasResolved) {
                        _processQueue();
                    }
                }, additionalArgs);
                return thenPromise;
            }
            finally {
            }
        }
        function _catch(onRejected) {
            return _then(undefined, onRejected);
        }
        function _finally(onFinally) {
            var thenFinally = onFinally;
            var catchFinally = onFinally;
            if (isFunction(onFinally)) {
                thenFinally = function (value) {
                    onFinally && onFinally();
                    return value;
                };
                catchFinally = function (reason) {
                    onFinally && onFinally();
                    throw reason;
                };
            }
            return _then(thenFinally, catchFinally);
        }
        function _strState() {
            return STRING_STATES[_state];
        }
        function _processQueue() {
            if (_queue.length > 0) {
                var pending = _queue.slice();
                _queue = [];
                _handled = true;
                _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
                _unHandledRejectionHandler = null;
                processor(pending);
            }
        }
        function _createSettleIfFn(newState, allowState) {
            return function (theValue) {
                if (_state === allowState) {
                    if (newState === 2  && isPromiseLike(theValue)) {
                        _state = 1 ;
                        theValue.then(_createSettleIfFn(2 , 1 ), _createSettleIfFn(3 , 1 ));
                        return;
                    }
                    _state = newState;
                    _hasResolved = true;
                    _settledValue = theValue;
                    _processQueue();
                    if (!_handled && newState === 3  && !_unHandledRejectionHandler) {
                        _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout);
                    }
                }
            };
        }
        function _notifyUnhandledRejection() {
            if (!_handled) {
                _handled = true;
                if (isNode()) {
                    process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);
                }
                else {
                    var gbl = getWindow() || getGlobal();
                    !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = createCachedValue(safe((getInst), [STR_PROMISE + "RejectionEvent"]).v));
                    emitEvent(gbl, UNHANDLED_REJECTION, function (theEvt) {
                        objDefine(theEvt, "promise", { g: function () { return _thePromise; } });
                        theEvt.reason = _settledValue;
                        return theEvt;
                    }, !!_hasPromiseRejectionEvent.v);
                }
            }
        }
        _thePromise = {
            then: _then,
            "catch": _catch,
            finally: _finally
        };
        objDefineProp(_thePromise, "state", {
            get: _strState
        });
        if (hasSymbol()) {
            _thePromise[getKnownSymbol(11 )] = "IPromise";
        }
        function _toString() {
            return "IPromise" + ("") + " " + _strState() + (_hasResolved ? (" - " + dumpFnObj(_settledValue)) : "") + ("");
        }
        _thePromise.toString = _toString;
        (function _initialize() {
            if (!isFunction(executor)) {
                throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpFnObj(executor));
            }
            var _rejectFn = _createSettleIfFn(3 , 0 );
            try {
                executor.call(_thePromise, _createSettleIfFn(2 , 0 ), _rejectFn);
            }
            catch (e) {
                _rejectFn(e);
            }
        })();
        return _thePromise;
    }
    /*#__NO_SIDE_EFFECTS__*/
    function _createAllPromise(newPromise) {
        return function (input) {
            var additionalArgs = arrSlice(arguments, 1);
            return newPromise(function (resolve, reject) {
                try {
                    var values_1 = [];
                    var pending_1 = 1;
                    iterForOf(input, function (item, idx) {
                        if (item) {
                            pending_1++;
                            doAwait(item, function (value) {
                                values_1[idx] = value;
                                if (--pending_1 === 0) {
                                    resolve(values_1);
                                }
                            }, reject);
                        }
                    });
                    pending_1--;
                    if (pending_1 === 0) {
                        resolve(values_1);
                    }
                }
                catch (e) {
                    reject(e);
                }
            }, additionalArgs);
        };
    }
    function syncItemProcessor(pending) {
        arrForEach(pending, function (fn) {
            try {
                fn();
            }
            catch (e) {
            }
        });
    }
    function timeoutItemProcessor(timeout) {
        var callbackTimeout = isNumber(timeout) ? timeout : 0;
        return function (pending) {
            scheduleTimeout(function () {
                syncItemProcessor(pending);
            }, callbackTimeout);
        };
    }
    function createAsyncPromise(executor, timeout) {
        return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);
    }
    var _promiseCls;
    function createNativePromise(executor, timeout) {
        !_promiseCls && (_promiseCls = createCachedValue((safe(getInst, [STR_PROMISE]).v) || null));
        var PrmCls = _promiseCls.v;
        if (!PrmCls) {
            return createAsyncPromise(executor);
        }
        if (!isFunction(executor)) {
            throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpObj(executor));
        }
        var _state = 0 ;
        function _strState() {
            return STRING_STATES[_state];
        }
        var thePromise = new PrmCls(function (resolve, reject) {
            function _resolve(value) {
                _state = 2 ;
                resolve(value);
            }
            function _reject(reason) {
                _state = 3 ;
                reject(reason);
            }
            executor(_resolve, _reject);
        });
        objDefineProp(thePromise, "state", {
            get: _strState
        });
        return thePromise;
    }
    var _promiseCreator;
    function createPromise(executor, timeout) {
        !_promiseCreator && (_promiseCreator = createCachedValue(createNativePromise));
        return _promiseCreator.v.call(this, executor, timeout);
    }
    var createAllPromise = /*#__PURE__*/ _createAllPromise(createPromise);

    var UNDEFINED_VALUE$1 = undefined;
    var STR_EMPTY$1 = "";
    var STR_CHANNELS = "channels";
    var STR_CORE = "core";
    var STR_CREATE_PERF_MGR = "createPerfMgr";
    var STR_DISABLED = "disabled";
    var STR_EXTENSION_CONFIG = "extensionConfig";
    var STR_EXTENSIONS = "extensions";
    var STR_PROCESS_TELEMETRY = "processTelemetry";
    var STR_PRIORITY = "priority";
    var STR_EVENTS_SENT = "eventsSent";
    var STR_EVENTS_DISCARDED = "eventsDiscarded";
    var STR_EVENTS_SEND_REQUEST = "eventsSendRequest";
    var STR_PERF_EVENT = "perfEvent";
    var STR_OFFLINE_STORE = "offlineEventsStored";
    var STR_OFFLINE_SENT = "offlineBatchSent";
    var STR_OFFLINE_DROP = "offlineBatchDrop";
    var STR_GET_PERF_MGR = "getPerfMgr";
    var STR_DOMAIN = "domain";
    var STR_PATH = "path";
    var STR_NOT_DYNAMIC_ERROR = "Not dynamic - ";

    var rCamelCase = /-([a-z])/g;
    var rNormalizeInvalid = /([^\w\d_$])/g;
    var rLeadingNumeric = /^(\d+[\w\d_$])/;
    function isNotNullOrUndefined(value) {
        return !isNullOrUndefined(value);
    }
    function normalizeJsName(name) {
        var value = name;
        if (value && isString(value)) {
            value = value[_DYN_REPLACE ](rCamelCase, function (_all, letter) {
                return letter.toUpperCase();
            });
            value = value[_DYN_REPLACE ](rNormalizeInvalid, "_");
            value = value[_DYN_REPLACE ](rLeadingNumeric, function (_all, match) {
                return "_" + match;
            });
        }
        return value;
    }
    function strContains(value, search) {
        if (value && search) {
            return strIndexOf(value, search) !== -1;
        }
        return false;
    }
    function toISOString(date) {
        return date && date.toISOString() || "";
    }
    function getExceptionName(object) {
        if (isError(object)) {
            return object[_DYN_NAME$2 ];
        }
        return STR_EMPTY$1;
    }
    function setValue(target, field, value, valChk, srcChk) {
        var theValue = value;
        if (target) {
            theValue = target[field];
            if (theValue !== value && (!srcChk || srcChk(theValue)) && (!valChk || valChk(value))) {
                theValue = value;
                target[field] = theValue;
            }
        }
        return theValue;
    }
    function getSetValue(target, field, defValue) {
        var theValue;
        if (target) {
            theValue = target[field];
            if (!theValue && isNullOrUndefined(theValue)) {
                theValue = !isUndefined(defValue) ? defValue : {};
                target[field] = theValue;
            }
        }
        else {
            theValue = !isUndefined(defValue) ? defValue : {};
        }
        return theValue;
    }
    function _createProxyFunction(source, funcName) {
        var srcFunc = null;
        var src = null;
        if (isFunction(source)) {
            srcFunc = source;
        }
        else {
            src = source;
        }
        return function () {
            var originalArguments = arguments;
            if (srcFunc) {
                src = srcFunc();
            }
            if (src) {
                return src[funcName][_DYN_APPLY ](src, originalArguments);
            }
        };
    }
    function proxyFunctionAs(target, name, source, theFunc, overwriteTarget) {
        if (target && name && source) {
            if (overwriteTarget !== false || isUndefined(target[name])) {
                target[name] = _createProxyFunction(source, theFunc);
            }
        }
    }
    function proxyFunctions(target, source, functionsToProxy, overwriteTarget) {
        if (target && source && isObject(target) && isArray(functionsToProxy)) {
            arrForEach(functionsToProxy, function (theFuncName) {
                if (isString(theFuncName)) {
                    proxyFunctionAs(target, theFuncName, source, theFuncName, overwriteTarget);
                }
            });
        }
        return target;
    }
    function createClassFromInterface(defaults) {
        return /** @class */ (function () {
            function class_1() {
                var _this = this;
                if (defaults) {
                    objForEachKey(defaults, function (field, value) {
                        _this[field] = value;
                    });
                }
            }
            return class_1;
        }());
    }
    function optimizeObject(theObject) {
        if (theObject && objAssign) {
            theObject = ObjClass(objAssign({}, theObject));
        }
        return theObject;
    }
    function objExtend(obj1, obj2, obj3, obj4, obj5, obj6) {
        var theArgs = arguments;
        var extended = theArgs[0] || {};
        var argLen = theArgs[_DYN_LENGTH$2 ];
        var deep = false;
        var idx = 1;
        if (argLen > 0 && isBoolean(extended)) {
            deep = extended;
            extended = theArgs[idx] || {};
            idx++;
        }
        if (!isObject(extended)) {
            extended = {};
        }
        for (; idx < argLen; idx++) {
            var arg = theArgs[idx];
            var isArgArray = isArray(arg);
            var isArgObj = isObject(arg);
            for (var prop in arg) {
                var propOk = (isArgArray && (prop in arg)) || (isArgObj && objHasOwn(arg, prop));
                if (!propOk) {
                    continue;
                }
                var newValue = arg[prop];
                var isNewArray = void 0;
                if (deep && newValue && ((isNewArray = isArray(newValue)) || isPlainObject(newValue))) {
                    var clone = extended[prop];
                    if (isNewArray) {
                        if (!isArray(clone)) {
                            clone = [];
                        }
                    }
                    else if (!isPlainObject(clone)) {
                        clone = {};
                    }
                    newValue = objExtend(deep, clone, newValue);
                }
                if (newValue !== undefined) {
                    extended[prop] = newValue;
                }
            }
        }
        return extended;
    }
    function getResponseText(xhr) {
        try {
            return xhr.responseText;
        }
        catch (e) {
        }
        return null;
    }
    function formatErrorMessageXdr(xdr, message) {
        if (xdr) {
            return "XDomainRequest,Response:" + getResponseText(xdr) || 0;
        }
        return message;
    }
    function formatErrorMessageXhr(xhr, message) {
        if (xhr) {
            return "XMLHttpRequest,Status:" + xhr[_DYN_STATUS ] + ",Response:" + getResponseText(xhr) || 0 || 0;
        }
        return message;
    }
    function prependTransports(theTransports, newTransports) {
        if (newTransports) {
            if (isNumber(newTransports)) {
                theTransports = [newTransports].concat(theTransports);
            }
            else if (isArray(newTransports)) {
                theTransports = newTransports.concat(theTransports);
            }
        }
        return theTransports;
    }
    var strDisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
    var strWithCredentials = "withCredentials";
    var strTimeout = "timeout";
    function openXhr(method, urlString, withCredentials, disabled, isSync, timeout) {
        if (disabled === void 0) { disabled = false; }
        if (isSync === void 0) { isSync = false; }
        function _wrapSetXhrProp(xhr, prop, value) {
            try {
                xhr[prop] = value;
            }
            catch (e) {
            }
        }
        var xhr = new XMLHttpRequest();
        if (disabled) {
            _wrapSetXhrProp(xhr, strDisabledPropertyName, disabled);
        }
        if (withCredentials) {
            _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
        }
        xhr.open(method, urlString, !isSync);
        if (withCredentials) {
            _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
        }
        if (!isSync && timeout) {
            _wrapSetXhrProp(xhr, strTimeout, timeout);
        }
        return xhr;
    }
    function convertAllHeadersToMap(headersString) {
        var headers = {};
        if (isString(headersString)) {
            var headersArray = strTrim(headersString)[_DYN_SPLIT$1 ](/[\r\n]+/);
            arrForEach(headersArray, function (headerEntry) {
                if (headerEntry) {
                    var idx = headerEntry.indexOf(": ");
                    if (idx !== -1) {
                        var header = strTrim(headerEntry.substring(0, idx))[_DYN_TO_LOWER_CASE$1 ]();
                        var value = strTrim(headerEntry.substring(idx + 1));
                        headers[header] = value;
                    }
                    else {
                        headers[strTrim(headerEntry)] = 1;
                    }
                }
            });
        }
        return headers;
    }
    function _appendHeader(theHeaders, xhr, name) {
        if (!theHeaders[name] && xhr && xhr[_DYN_GET_RESPONSE_HEADER ]) {
            var value = xhr[_DYN_GET_RESPONSE_HEADER ](name);
            if (value) {
                theHeaders[name] = strTrim(value);
            }
        }
        return theHeaders;
    }
    var STR_KILL_DURATION_HEADER = "kill-duration";
    var STR_KILL_DURATION_SECONDS_HEADER = "kill-duration-seconds";
    var STR_TIME_DELTA_HEADER = "time-delta-millis";
    function _getAllResponseHeaders(xhr, isOneDs) {
        var theHeaders = {};
        if (!xhr[_DYN_GET_ALL_RESPONSE_HEA5 ]) {
            if (!!isOneDs) {
                theHeaders = _appendHeader(theHeaders, xhr, STR_TIME_DELTA_HEADER);
                theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_HEADER);
                theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_SECONDS_HEADER);
            }
        }
        else {
            theHeaders = convertAllHeadersToMap(xhr[_DYN_GET_ALL_RESPONSE_HEA5 ]());
        }
        return theHeaders;
    }

    var strDocumentMode = "documentMode";
    var strLocation = "location";
    var strConsole = "console";
    var strJSON = "JSON";
    var strCrypto = "crypto";
    var strMsCrypto = "msCrypto";
    var strMsie = "msie";
    var strTrident = "trident/";
    var strXMLHttpRequest = "XMLHttpRequest";
    var _isTrident = null;
    var _navUserAgentCheck = null;
    var _enableMocks = false;
    var _useXDomainRequest = null;
    var _beaconsSupported = null;
    function _hasProperty(theClass, property) {
        var supported = false;
        if (theClass) {
            try {
                supported = property in theClass;
                if (!supported) {
                    var proto = theClass[strShimPrototype];
                    if (proto) {
                        supported = property in proto;
                    }
                }
            }
            catch (e) {
            }
            if (!supported) {
                try {
                    var tmp = new theClass();
                    supported = !isUndefined(tmp[property]);
                }
                catch (e) {
                }
            }
        }
        return supported;
    }
    function getLocation(checkForMock) {
        if (checkForMock && _enableMocks) {
            var mockLocation = getInst("__mockLocation");
            if (mockLocation) {
                return mockLocation;
            }
        }
        if (typeof location === strShimObject && location) {
            return location;
        }
        return getInst(strLocation);
    }
    function getConsole() {
        if (typeof console !== strShimUndefined) {
            return console;
        }
        return getInst(strConsole);
    }
    function hasJSON() {
        return Boolean((typeof JSON === strShimObject && JSON) || getInst(strJSON) !== null);
    }
    function getJSON() {
        if (hasJSON()) {
            return JSON || getInst(strJSON);
        }
        return null;
    }
    function getCrypto() {
        return getInst(strCrypto);
    }
    function getMsCrypto() {
        return getInst(strMsCrypto);
    }
    function isIE() {
        var nav = getNavigator();
        if (nav && (nav[_DYN_USER_AGENT ] !== _navUserAgentCheck || _isTrident === null)) {
            _navUserAgentCheck = nav[_DYN_USER_AGENT ];
            var userAgent = (_navUserAgentCheck || STR_EMPTY$1)[_DYN_TO_LOWER_CASE$1 ]();
            _isTrident = (strContains(userAgent, strMsie) || strContains(userAgent, strTrident));
        }
        return _isTrident;
    }
    function getIEVersion(userAgentStr) {
        if (userAgentStr === void 0) { userAgentStr = null; }
        if (!userAgentStr) {
            var navigator_1 = getNavigator() || {};
            userAgentStr = navigator_1 ? (navigator_1.userAgent || STR_EMPTY$1)[_DYN_TO_LOWER_CASE$1 ]() : STR_EMPTY$1;
        }
        var ua = (userAgentStr || STR_EMPTY$1)[_DYN_TO_LOWER_CASE$1 ]();
        if (strContains(ua, strMsie)) {
            var doc = getDocument() || {};
            return Math.max(parseInt(ua[_DYN_SPLIT$1 ](strMsie)[1]), (doc[strDocumentMode] || 0));
        }
        else if (strContains(ua, strTrident)) {
            var tridentVer = parseInt(ua[_DYN_SPLIT$1 ](strTrident)[1]);
            if (tridentVer) {
                return tridentVer + 4;
            }
        }
        return null;
    }
    function isBeaconsSupported(useCached) {
        if (_beaconsSupported === null || useCached === false) {
            _beaconsSupported = hasNavigator() && Boolean(getNavigator().sendBeacon);
        }
        return _beaconsSupported;
    }
    function isFetchSupported(withKeepAlive) {
        var isSupported = false;
        try {
            isSupported = !!getInst("fetch");
            var request = getInst("Request");
            if (isSupported && withKeepAlive && request) {
                isSupported = _hasProperty(request, "keepalive");
            }
        }
        catch (e) {
        }
        return isSupported;
    }
    function useXDomainRequest() {
        if (_useXDomainRequest === null) {
            _useXDomainRequest = (typeof XDomainRequest !== strShimUndefined);
            if (_useXDomainRequest && isXhrSupported()) {
                _useXDomainRequest = _useXDomainRequest && !_hasProperty(getInst(strXMLHttpRequest), "withCredentials");
            }
        }
        return _useXDomainRequest;
    }
    function isXhrSupported() {
        var isSupported = false;
        try {
            var xmlHttpRequest = getInst(strXMLHttpRequest);
            isSupported = !!xmlHttpRequest;
        }
        catch (e) {
        }
        return isSupported;
    }

    var UInt32Mask = 0x100000000;
    var MaxUInt32 = 0xffffffff;
    var SEED1 = 123456789;
    var SEED2 = 987654321;
    var _mwcSeeded = false;
    var _mwcW = SEED1;
    var _mwcZ = SEED2;
    function _mwcSeed(seedValue) {
        if (seedValue < 0) {
            seedValue >>>= 0;
        }
        _mwcW = (SEED1 + seedValue) & MaxUInt32;
        _mwcZ = (SEED2 - seedValue) & MaxUInt32;
        _mwcSeeded = true;
    }
    function _autoSeedMwc() {
        try {
            var now = utcNow() & 0x7fffffff;
            _mwcSeed(((Math.random() * UInt32Mask) ^ now) + now);
        }
        catch (e) {
        }
    }
    function random32(signed) {
        var value = 0;
        var c = getCrypto() || getMsCrypto();
        if (c && c.getRandomValues) {
            value = c.getRandomValues(new Uint32Array(1))[0] & MaxUInt32;
        }
        if (value === 0 && isIE()) {
            if (!_mwcSeeded) {
                _autoSeedMwc();
            }
            value = mwcRandom32() & MaxUInt32;
        }
        if (value === 0) {
            value = Math.floor((UInt32Mask * Math.random()) | 0);
        }
        if (!signed) {
            value >>>= 0;
        }
        return value;
    }
    function mwcRandom32(signed) {
        _mwcZ = (36969 * (_mwcZ & 0xFFFF) + (_mwcZ >> 16)) & MaxUInt32;
        _mwcW = (18000 * (_mwcW & 0xFFFF) + (_mwcW >> 16)) & MaxUInt32;
        var value = (((_mwcZ << 16) + (_mwcW & 0xFFFF)) >>> 0) & MaxUInt32 | 0;
        if (!signed) {
            value >>>= 0;
        }
        return value;
    }
    function newId(maxLength) {
        if (maxLength === void 0) { maxLength = 22; }
        var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var number = random32() >>> 0;
        var chars = 0;
        var result = STR_EMPTY$1;
        while (result[_DYN_LENGTH$2 ] < maxLength) {
            chars++;
            result += base64chars.charAt(number & 0x3F);
            number >>>= 6;
            if (chars === 5) {
                number = (((random32() << 2) & 0xFFFFFFFF) | (number & 0x03)) >>> 0;
                chars = 0;
            }
        }
        return result;
    }

    var version = '3.2.2';
    var instanceName = "." + newId(6);
    var _dataUid = 0;
    function _canAcceptData(target) {
        return target[_DYN_NODE_TYPE ] === 1 || target[_DYN_NODE_TYPE ] === 9 || !(+target[_DYN_NODE_TYPE ]);
    }
    function _getCache(data, target) {
        var theCache = target[data.id];
        if (!theCache) {
            theCache = {};
            try {
                if (_canAcceptData(target)) {
                    objDefine(target, data.id, {
                        e: false,
                        v: theCache
                    });
                }
            }
            catch (e) {
            }
        }
        return theCache;
    }
    function createUniqueNamespace(name, includeVersion) {
        if (includeVersion === void 0) { includeVersion = false; }
        return normalizeJsName(name + (_dataUid++) + (includeVersion ? "." + version : STR_EMPTY$1) + instanceName);
    }
    function createElmNodeData(name) {
        var data = {
            id: createUniqueNamespace("_aiData-" + (name || STR_EMPTY$1) + "." + version),
            accept: function (target) {
                return _canAcceptData(target);
            },
            get: function (target, name, defValue, addDefault) {
                var theCache = target[data.id];
                if (!theCache) {
                    if (addDefault) {
                        theCache = _getCache(data, target);
                        theCache[normalizeJsName(name)] = defValue;
                    }
                    return defValue;
                }
                return theCache[normalizeJsName(name)];
            },
            kill: function (target, name) {
                if (target && target[name]) {
                    try {
                        delete target[name];
                    }
                    catch (e) {
                    }
                }
            }
        };
        return data;
    }

    function _isConfigDefaults(value) {
        return (value && isObject(value) && (value.isVal || value.fb || objHasOwn(value, "v") || objHasOwn(value, "mrg") || objHasOwn(value, "ref") || value.set));
    }
    function _getDefault(dynamicHandler, theConfig, cfgDefaults) {
        var defValue;
        var isDefaultValid = cfgDefaults.dfVal || isDefined;
        if (theConfig && cfgDefaults.fb) {
            var fallbacks = cfgDefaults.fb;
            if (!isArray(fallbacks)) {
                fallbacks = [fallbacks];
            }
            for (var lp = 0; lp < fallbacks[_DYN_LENGTH$2 ]; lp++) {
                var fallback = fallbacks[lp];
                var fbValue = theConfig[fallback];
                if (isDefaultValid(fbValue)) {
                    defValue = fbValue;
                }
                else if (dynamicHandler) {
                    fbValue = dynamicHandler.cfg[fallback];
                    if (isDefaultValid(fbValue)) {
                        defValue = fbValue;
                    }
                    dynamicHandler.set(dynamicHandler.cfg, asString(fallback), fbValue);
                }
                if (isDefaultValid(defValue)) {
                    break;
                }
            }
        }
        if (!isDefaultValid(defValue) && isDefaultValid(cfgDefaults.v)) {
            defValue = cfgDefaults.v;
        }
        return defValue;
    }
    function _resolveDefaultValue(dynamicHandler, theConfig, cfgDefaults) {
        var theValue = cfgDefaults;
        if (cfgDefaults && _isConfigDefaults(cfgDefaults)) {
            theValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);
        }
        if (theValue) {
            if (_isConfigDefaults(theValue)) {
                theValue = _resolveDefaultValue(dynamicHandler, theConfig, theValue);
            }
            var newValue_1;
            if (isArray(theValue)) {
                newValue_1 = [];
                newValue_1[_DYN_LENGTH$2 ] = theValue[_DYN_LENGTH$2 ];
            }
            else if (isPlainObject(theValue)) {
                newValue_1 = {};
            }
            if (newValue_1) {
                objForEachKey(theValue, function (key, value) {
                    if (value && _isConfigDefaults(value)) {
                        value = _resolveDefaultValue(dynamicHandler, theConfig, value);
                    }
                    newValue_1[key] = value;
                });
                theValue = newValue_1;
            }
        }
        return theValue;
    }
    function _applyDefaultValue(dynamicHandler, theConfig, name, defaultValue) {
        var isValid;
        var setFn;
        var defValue;
        var cfgDefaults = defaultValue;
        var mergeDf;
        var reference;
        var readOnly;
        var blkDynamicValue;
        if (_isConfigDefaults(cfgDefaults)) {
            isValid = cfgDefaults.isVal;
            setFn = cfgDefaults.set;
            readOnly = cfgDefaults[_DYN_RD_ONLY ];
            blkDynamicValue = cfgDefaults[_DYN_BLK_VAL ];
            mergeDf = cfgDefaults.mrg;
            reference = cfgDefaults.ref;
            if (!reference && isUndefined(reference)) {
                reference = !!mergeDf;
            }
            defValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);
        }
        else {
            defValue = defaultValue;
        }
        if (blkDynamicValue) {
            dynamicHandler[_DYN_BLK_VAL ](theConfig, name);
        }
        var theValue;
        var usingDefault = true;
        var cfgValue = theConfig[name];
        if (cfgValue || !isNullOrUndefined(cfgValue)) {
            theValue = cfgValue;
            usingDefault = false;
            if (isValid && theValue !== defValue && !isValid(theValue)) {
                theValue = defValue;
                usingDefault = true;
            }
            if (setFn) {
                theValue = setFn(theValue, defValue, theConfig);
                usingDefault = theValue === defValue;
            }
        }
        if (!usingDefault) {
            if (isPlainObject(theValue) || isArray(defValue)) {
                if (mergeDf && defValue && (isPlainObject(defValue) || isArray(defValue))) {
                    objForEachKey(defValue, function (dfName, dfValue) {
                        _applyDefaultValue(dynamicHandler, theValue, dfName, dfValue);
                    });
                }
            }
        }
        else if (defValue) {
            theValue = _resolveDefaultValue(dynamicHandler, theConfig, defValue);
        }
        else {
            theValue = defValue;
        }
        dynamicHandler.set(theConfig, name, theValue);
        if (reference) {
            dynamicHandler.ref(theConfig, name);
        }
        if (readOnly) {
            dynamicHandler[_DYN_RD_ONLY ](theConfig, name);
        }
    }

    var CFG_HANDLER_LINK = symbolFor("[[ai_dynCfg_1]]");
    var BLOCK_DYNAMIC = symbolFor("[[ai_blkDynCfg_1]]");
    var FORCE_DYNAMIC = symbolFor("[[ai_frcDynCfg_1]]");
    function _cfgDeepCopy(source) {
        if (source) {
            var target_1;
            if (isArray(source)) {
                target_1 = [];
                target_1[_DYN_LENGTH$2 ] = source[_DYN_LENGTH$2 ];
            }
            else if (isPlainObject(source)) {
                target_1 = {};
            }
            if (target_1) {
                objForEachKey(source, function (key, value) {
                    target_1[key] = _cfgDeepCopy(value);
                });
                return target_1;
            }
        }
        return source;
    }
    function getDynamicConfigHandler(value) {
        if (value) {
            var handler = value[CFG_HANDLER_LINK] || value;
            if (handler.cfg && (handler.cfg === value || handler.cfg[CFG_HANDLER_LINK] === handler)) {
                return handler;
            }
        }
        return null;
    }
    function blockDynamicConversion(value) {
        if (value && (isPlainObject(value) || isArray(value))) {
            try {
                value[BLOCK_DYNAMIC] = true;
            }
            catch (e) {
            }
        }
        return value;
    }
    function _canMakeDynamic(getFunc, state, value) {
        var result = false;
        if (value && !getFunc[state.blkVal]) {
            result = value[FORCE_DYNAMIC];
            if (!result && !value[BLOCK_DYNAMIC]) {
                result = isPlainObject(value) || isArray(value);
            }
        }
        return result;
    }
    function throwInvalidAccess(message) {
        throwTypeError("InvalidAccess:" + message);
    }

    var arrayMethodsToPatch = [
        "push",
        "pop",
        "shift",
        "unshift",
        "splice"
    ];
    var _throwDynamicError = function (logger, name, desc, e) {
        logger && logger[_DYN_THROW_INTERNAL ](3 , 108 , "".concat(desc, " [").concat(name, "] failed - ") + dumpObj(e));
    };
    function _patchArray(state, target, name) {
        if (isArray(target)) {
            arrForEach(arrayMethodsToPatch, function (method) {
                var orgMethod = target[method];
                target[method] = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    var result = orgMethod[_DYN_APPLY ](this, args);
                    _makeDynamicObject(state, target, name, "Patching");
                    return result;
                };
            });
        }
    }
    function _getOwnPropGetter(target, name) {
        var propDesc = objGetOwnPropertyDescriptor(target, name);
        return propDesc && propDesc.get;
    }
    function _createDynamicProperty(state, theConfig, name, value) {
        var detail = {
            n: name,
            h: [],
            trk: function (handler) {
                if (handler && handler.fn) {
                    if (arrIndexOf(detail.h, handler) === -1) {
                        detail.h[_DYN_PUSH$2 ](handler);
                    }
                    state.trk(handler, detail);
                }
            },
            clr: function (handler) {
                var idx = arrIndexOf(detail.h, handler);
                if (idx !== -1) {
                    detail.h[_DYN_SPLICE ](idx, 1);
                }
            }
        };
        var checkDynamic = true;
        var isObjectOrArray = false;
        function _getProperty() {
            if (checkDynamic) {
                isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value);
                if (value && !value[CFG_HANDLER_LINK] && isObjectOrArray) {
                    value = _makeDynamicObject(state, value, name, "Converting");
                }
                checkDynamic = false;
            }
            var activeHandler = state.act;
            if (activeHandler) {
                detail.trk(activeHandler);
            }
            return value;
        }
        _getProperty[state.prop] = {
            chng: function () {
                state.add(detail);
            }
        };
        function _setProperty(newValue) {
            if (value !== newValue) {
                if (!!_getProperty[state.ro] && !state.upd) {
                    throwInvalidAccess("[" + name + "] is read-only:" + dumpObj(theConfig));
                }
                if (checkDynamic) {
                    isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value);
                    checkDynamic = false;
                }
                var isReferenced = isObjectOrArray && _getProperty[state.rf];
                if (isObjectOrArray) {
                    if (isReferenced) {
                        objForEachKey(value, function (key) {
                            value[key] = newValue ? newValue[key] : UNDEFINED_VALUE$1;
                        });
                        try {
                            objForEachKey(newValue, function (key, theValue) {
                                _setDynamicProperty(state, value, key, theValue);
                            });
                            newValue = value;
                        }
                        catch (e) {
                            _throwDynamicError((state.hdlr || {})[_DYN_LOGGER ], name, "Assigning", e);
                            isObjectOrArray = false;
                        }
                    }
                    else if (value && value[CFG_HANDLER_LINK]) {
                        objForEachKey(value, function (key) {
                            var getter = _getOwnPropGetter(value, key);
                            if (getter) {
                                var valueState = getter[state.prop];
                                valueState && valueState.chng();
                            }
                        });
                    }
                }
                if (newValue !== value) {
                    var newIsObjectOrArray = newValue && _canMakeDynamic(_getProperty, state, newValue);
                    if (!isReferenced && newIsObjectOrArray) {
                        newValue = _makeDynamicObject(state, newValue, name, "Converting");
                    }
                    value = newValue;
                    isObjectOrArray = newIsObjectOrArray;
                }
                state.add(detail);
            }
        }
        objDefine(theConfig, detail.n, { g: _getProperty, s: _setProperty });
    }
    function _setDynamicProperty(state, target, name, value) {
        if (target) {
            var getter = _getOwnPropGetter(target, name);
            var isDynamic = getter && !!getter[state.prop];
            if (!isDynamic) {
                _createDynamicProperty(state, target, name, value);
            }
            else {
                target[name] = value;
            }
        }
        return target;
    }
    function _setDynamicPropertyState(state, target, name, flags) {
        if (target) {
            var getter = _getOwnPropGetter(target, name);
            var isDynamic = getter && !!getter[state.prop];
            var inPlace = flags && flags[0 ];
            var rdOnly = flags && flags[1 ];
            var blkProp = flags && flags[2 ];
            if (!isDynamic) {
                if (blkProp) {
                    try {
                        blockDynamicConversion(target);
                    }
                    catch (e) {
                        _throwDynamicError((state.hdlr || {})[_DYN_LOGGER ], name, "Blocking", e);
                    }
                }
                try {
                    _setDynamicProperty(state, target, name, target[name]);
                    getter = _getOwnPropGetter(target, name);
                }
                catch (e) {
                    _throwDynamicError((state.hdlr || {})[_DYN_LOGGER ], name, "State", e);
                }
            }
            if (inPlace) {
                getter[state.rf] = inPlace;
            }
            if (rdOnly) {
                getter[state.ro] = rdOnly;
            }
            if (blkProp) {
                getter[state.blkVal] = true;
            }
        }
        return target;
    }
    function _makeDynamicObject(state, target, name, desc) {
        try {
            objForEachKey(target, function (key, value) {
                _setDynamicProperty(state, target, key, value);
            });
            if (!target[CFG_HANDLER_LINK]) {
                objDefineProp(target, CFG_HANDLER_LINK, {
                    get: function () {
                        return state[_DYN_HDLR ];
                    }
                });
                _patchArray(state, target, name);
            }
        }
        catch (e) {
            _throwDynamicError((state.hdlr || {})[_DYN_LOGGER ], name, desc, e);
        }
        return target;
    }

    var symPrefix = "[[ai_";
    var symPostfix = "]]";
    function _createState(cfgHandler) {
        var _a;
        var dynamicPropertySymbol = newSymbol(symPrefix + "get" + cfgHandler.uid + symPostfix);
        var dynamicPropertyReadOnly = newSymbol(symPrefix + "ro" + cfgHandler.uid + symPostfix);
        var dynamicPropertyReferenced = newSymbol(symPrefix + "rf" + cfgHandler.uid + symPostfix);
        var dynamicPropertyBlockValue = newSymbol(symPrefix + "blkVal" + cfgHandler.uid + symPostfix);
        var dynamicPropertyDetail = newSymbol(symPrefix + "dtl" + cfgHandler.uid + symPostfix);
        var _waitingHandlers = null;
        var _watcherTimer = null;
        var theState;
        function _useHandler(activeHandler, callback) {
            var prevWatcher = theState.act;
            try {
                theState.act = activeHandler;
                if (activeHandler && activeHandler[dynamicPropertyDetail]) {
                    arrForEach(activeHandler[dynamicPropertyDetail], function (detail) {
                        detail.clr(activeHandler);
                    });
                    activeHandler[dynamicPropertyDetail] = [];
                }
                callback({
                    cfg: cfgHandler.cfg,
                    set: cfgHandler.set.bind(cfgHandler),
                    setDf: cfgHandler[_DYN_SET_DF ].bind(cfgHandler),
                    ref: cfgHandler.ref.bind(cfgHandler),
                    rdOnly: cfgHandler[_DYN_RD_ONLY ].bind(cfgHandler)
                });
            }
            catch (e) {
                var logger = cfgHandler[_DYN_LOGGER ];
                if (logger) {
                    logger[_DYN_THROW_INTERNAL ](1 , 107 , dumpObj(e));
                }
                throw e;
            }
            finally {
                theState.act = prevWatcher || null;
            }
        }
        function _notifyWatchers() {
            if (_waitingHandlers) {
                var notifyHandlers = _waitingHandlers;
                _waitingHandlers = null;
                _watcherTimer && _watcherTimer[_DYN_CANCEL ]();
                _watcherTimer = null;
                var watcherFailures_1 = [];
                arrForEach(notifyHandlers, function (handler) {
                    if (handler) {
                        if (handler[dynamicPropertyDetail]) {
                            arrForEach(handler[dynamicPropertyDetail], function (detail) {
                                detail.clr(handler);
                            });
                            handler[dynamicPropertyDetail] = null;
                        }
                        if (handler.fn) {
                            try {
                                _useHandler(handler, handler.fn);
                            }
                            catch (e) {
                                watcherFailures_1[_DYN_PUSH$2 ](e);
                            }
                        }
                    }
                });
                if (_waitingHandlers) {
                    try {
                        _notifyWatchers();
                    }
                    catch (e) {
                        watcherFailures_1[_DYN_PUSH$2 ](e);
                    }
                }
                if (watcherFailures_1[_DYN_LENGTH$2 ] > 0) {
                    throwAggregationError("Watcher error(s): ", watcherFailures_1);
                }
            }
        }
        function _addWatcher(detail) {
            if (detail && detail.h[_DYN_LENGTH$2 ] > 0) {
                if (!_waitingHandlers) {
                    _waitingHandlers = [];
                }
                if (!_watcherTimer) {
                    _watcherTimer = scheduleTimeout(function () {
                        _watcherTimer = null;
                        _notifyWatchers();
                    }, 0);
                }
                for (var idx = 0; idx < detail.h[_DYN_LENGTH$2 ]; idx++) {
                    var handler = detail.h[idx];
                    if (handler && arrIndexOf(_waitingHandlers, handler) === -1) {
                        _waitingHandlers[_DYN_PUSH$2 ](handler);
                    }
                }
            }
        }
        function _trackHandler(handler, detail) {
            if (handler) {
                var details = handler[dynamicPropertyDetail] = handler[dynamicPropertyDetail] || [];
                if (arrIndexOf(details, detail) === -1) {
                    details[_DYN_PUSH$2 ](detail);
                }
            }
        }
        theState = (_a = {
                prop: dynamicPropertySymbol,
                ro: dynamicPropertyReadOnly,
                rf: dynamicPropertyReferenced
            },
            _a[_DYN_BLK_VAL ] = dynamicPropertyBlockValue,
            _a[_DYN_HDLR ] = cfgHandler,
            _a.add = _addWatcher,
            _a[_DYN_NOTIFY ] = _notifyWatchers,
            _a.use = _useHandler,
            _a.trk = _trackHandler,
            _a);
        return theState;
    }

    function _createAndUseHandler(state, configHandler) {
        var handler = {
            fn: configHandler,
            rm: function () {
                handler.fn = null;
                state = null;
                configHandler = null;
            }
        };
        objDefine(handler, "toJSON", { v: function () { return "WatcherHandler" + (handler.fn ? "" : "[X]"); } });
        state.use(handler, configHandler);
        return handler;
    }
    function _createDynamicHandler(logger, target, inPlace) {
        var _a;
        var dynamicHandler = getDynamicConfigHandler(target);
        if (dynamicHandler) {
            return dynamicHandler;
        }
        var uid = createUniqueNamespace("dyncfg", true);
        var newTarget = (target && inPlace !== false) ? target : _cfgDeepCopy(target);
        var theState;
        function _notifyWatchers() {
            theState[_DYN_NOTIFY ]();
        }
        function _setValue(target, name, value) {
            try {
                target = _setDynamicProperty(theState, target, name, value);
            }
            catch (e) {
                _throwDynamicError(logger, name, "Setting value", e);
            }
            return target[name];
        }
        function _watch(configHandler) {
            return _createAndUseHandler(theState, configHandler);
        }
        function _block(configHandler, allowUpdate) {
            theState.use(null, function (details) {
                var prevUpd = theState.upd;
                try {
                    if (!isUndefined(allowUpdate)) {
                        theState.upd = allowUpdate;
                    }
                    configHandler(details);
                }
                finally {
                    theState.upd = prevUpd;
                }
            });
        }
        function _ref(target, name) {
            var _a;
            return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[0 ] = true, _a))[name];
        }
        function _rdOnly(target, name) {
            var _a;
            return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[1 ] = true, _a))[name];
        }
        function _blkPropValue(target, name) {
            var _a;
            return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[2 ] = true, _a))[name];
        }
        function _applyDefaults(theConfig, defaultValues) {
            if (defaultValues) {
                objForEachKey(defaultValues, function (name, value) {
                    _applyDefaultValue(cfgHandler, theConfig, name, value);
                });
            }
            return theConfig;
        }
        var cfgHandler = (_a = {
                uid: null,
                cfg: newTarget
            },
            _a[_DYN_LOGGER ] = logger,
            _a[_DYN_NOTIFY ] = _notifyWatchers,
            _a.set = _setValue,
            _a[_DYN_SET_DF ] = _applyDefaults,
            _a[_DYN_WATCH ] = _watch,
            _a.ref = _ref,
            _a[_DYN_RD_ONLY ] = _rdOnly,
            _a[_DYN_BLK_VAL ] = _blkPropValue,
            _a._block = _block,
            _a);
        objDefine(cfgHandler, "uid", {
            c: false,
            e: false,
            w: false,
            v: uid
        });
        theState = _createState(cfgHandler);
        _makeDynamicObject(theState, newTarget, "config", "Creating");
        return cfgHandler;
    }
    function _logInvalidAccess(logger, message) {
        if (logger) {
            logger[_DYN_WARN_TO_CONSOLE ](message);
            logger[_DYN_THROW_INTERNAL ](2 , 108 , message);
        }
        else {
            throwInvalidAccess(message);
        }
    }
    function createDynamicConfig(config, defaultConfig, logger, inPlace) {
        var dynamicHandler = _createDynamicHandler(logger, config || {}, inPlace);
        if (defaultConfig) {
            dynamicHandler[_DYN_SET_DF ](dynamicHandler.cfg, defaultConfig);
        }
        return dynamicHandler;
    }
    function onConfigChange(config, configHandler, logger) {
        var handler = config[CFG_HANDLER_LINK] || config;
        if (handler.cfg && (handler.cfg === config || handler.cfg[CFG_HANDLER_LINK] === handler)) {
            return handler[_DYN_WATCH ](configHandler);
        }
        _logInvalidAccess(logger, STR_NOT_DYNAMIC_ERROR + dumpObj(config));
        return createDynamicConfig(config, null, logger)[_DYN_WATCH ](configHandler);
    }

    function runTargetUnload(target, isAsync) {
        if (target && target[_DYN_UNLOAD ]) {
            return target[_DYN_UNLOAD ](isAsync);
        }
    }
    function doUnloadAll(targets, isAsync, done) {
        var result;
        if (!done) {
            result = createPromise(function (resolved) {
                done = resolved;
            });
        }
        if (targets && getLength(targets) > 0) {
            doAwaitResponse(runTargetUnload(targets[0], isAsync), function () {
                doUnloadAll(arrSlice(targets, 1), isAsync, done);
            });
        }
        else {
            done();
        }
        return result;
    }

    var ChannelControllerPriority = 500;
    var DisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";

    function _stringToBoolOrDefault(theValue, defaultValue, theConfig) {
        if (!theValue && isNullOrUndefined(theValue)) {
            return defaultValue;
        }
        if (isBoolean(theValue)) {
            return theValue;
        }
        return asString(theValue)[_DYN_TO_LOWER_CASE$1 ]() === "true";
    }
    function cfgDfMerge(defaultValue) {
        return {
            mrg: true,
            v: defaultValue
        };
    }
    function cfgDfValidate(validator, defaultValue, fallBackName) {
        return {
            fb: fallBackName,
            isVal: validator,
            v: defaultValue
        };
    }
    function cfgDfBoolean(defaultValue, fallBackName) {
        return {
            fb: fallBackName,
            set: _stringToBoolOrDefault,
            v: !!defaultValue
        };
    }

    var listenerFuncs = [STR_EVENTS_SENT, STR_EVENTS_DISCARDED, STR_EVENTS_SEND_REQUEST, STR_PERF_EVENT];
    var _aiNamespace = null;
    var _debugListener;
    function _listenerProxyFunc(name, config) {
        return function () {
            var args = arguments;
            var dbgExt = getDebugExt(config);
            if (dbgExt) {
                var listener = dbgExt.listener;
                if (listener && listener[name]) {
                    listener[name][_DYN_APPLY ](listener, args);
                }
            }
        };
    }
    function _getExtensionNamespace() {
        var target = getInst("Microsoft");
        if (target) {
            _aiNamespace = target["ApplicationInsights"];
        }
        return _aiNamespace;
    }
    function getDebugExt(config) {
        var ns = _aiNamespace;
        if (!ns && config.disableDbgExt !== true) {
            ns = _aiNamespace || _getExtensionNamespace();
        }
        return ns ? ns["ChromeDbgExt"] : null;
    }
    function getDebugListener(config) {
        if (!_debugListener) {
            _debugListener = {};
            for (var lp = 0; lp < listenerFuncs[_DYN_LENGTH$2 ]; lp++) {
                _debugListener[listenerFuncs[lp]] = _listenerProxyFunc(listenerFuncs[lp], config);
            }
        }
        return _debugListener;
    }

    var _a$4;
    var STR_WARN_TO_CONSOLE = "warnToConsole";
    var AiNonUserActionablePrefix = "AI (Internal): ";
    var AiUserActionablePrefix = "AI: ";
    var AIInternalMessagePrefix = "AITR_";
    var defaultValues$2 = {
        loggingLevelConsole: 0,
        loggingLevelTelemetry: 1,
        maxMessageLimit: 25,
        enableDebug: false
    };
    var _logFuncs = (_a$4 = {},
        _a$4[0 ] = null,
        _a$4[1 ] = "errorToConsole",
        _a$4[2 ] = STR_WARN_TO_CONSOLE,
        _a$4[3 ] = "debugToConsole",
        _a$4);
    function _sanitizeDiagnosticText(text) {
        if (text) {
            return "\"" + text[_DYN_REPLACE ](/\"/g, STR_EMPTY$1) + "\"";
        }
        return STR_EMPTY$1;
    }
    function _logToConsole(func, message) {
        var theConsole = getConsole();
        if (!!theConsole) {
            var logFunc = "log";
            if (theConsole[func]) {
                logFunc = func;
            }
            if (isFunction(theConsole[logFunc])) {
                theConsole[logFunc](message);
            }
        }
    }
    var _InternalLogMessage = /** @class */ (function () {
        function _InternalLogMessage(msgId, msg, isUserAct, properties) {
            if (isUserAct === void 0) { isUserAct = false; }
            var _self = this;
            _self[_DYN_MESSAGE_ID ] = msgId;
            _self[_DYN_MESSAGE$1 ] =
                (isUserAct ? AiUserActionablePrefix : AiNonUserActionablePrefix) +
                    msgId;
            var strProps = STR_EMPTY$1;
            if (hasJSON()) {
                strProps = getJSON().stringify(properties);
            }
            var diagnosticText = (msg ? " message:" + _sanitizeDiagnosticText(msg) : STR_EMPTY$1) +
                (properties ? " props:" + _sanitizeDiagnosticText(strProps) : STR_EMPTY$1);
            _self[_DYN_MESSAGE$1 ] += diagnosticText;
        }
        _InternalLogMessage.dataType = "MessageData";
        return _InternalLogMessage;
    }());
    function safeGetLogger(core, config) {
        return (core || {})[_DYN_LOGGER ] || new DiagnosticLogger(config);
    }
    var DiagnosticLogger = /** @class */ (function () {
        function DiagnosticLogger(config) {
            this.identifier = "DiagnosticLogger";
            this.queue = [];
            var _messageCount = 0;
            var _messageLogged = {};
            var _loggingLevelConsole;
            var _loggingLevelTelemetry;
            var _maxInternalMessageLimit;
            var _enableDebug;
            var _unloadHandler;
            dynamicProto(DiagnosticLogger, this, function (_self) {
                _unloadHandler = _setDefaultsFromConfig(config || {});
                _self.consoleLoggingLevel = function () { return _loggingLevelConsole; };
                _self[_DYN_THROW_INTERNAL ] = function (severity, msgId, msg, properties, isUserAct) {
                    if (isUserAct === void 0) { isUserAct = false; }
                    var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);
                    if (_enableDebug) {
                        throw dumpObj(message);
                    }
                    else {
                        var logFunc = _logFuncs[severity] || STR_WARN_TO_CONSOLE;
                        if (!isUndefined(message[_DYN_MESSAGE$1 ])) {
                            if (isUserAct) {
                                var messageKey = +message[_DYN_MESSAGE_ID ];
                                if (!_messageLogged[messageKey] && _loggingLevelConsole >= severity) {
                                    _self[logFunc](message[_DYN_MESSAGE$1 ]);
                                    _messageLogged[messageKey] = true;
                                }
                            }
                            else {
                                if (_loggingLevelConsole >= severity) {
                                    _self[logFunc](message[_DYN_MESSAGE$1 ]);
                                }
                            }
                            _logInternalMessage(severity, message);
                        }
                        else {
                            _debugExtMsg("throw" + (severity === 1  ? "Critical" : "Warning"), message);
                        }
                    }
                };
                _self.debugToConsole = function (message) {
                    _logToConsole("debug", message);
                    _debugExtMsg("warning", message);
                };
                _self[_DYN_WARN_TO_CONSOLE ] = function (message) {
                    _logToConsole("warn", message);
                    _debugExtMsg("warning", message);
                };
                _self.errorToConsole = function (message) {
                    _logToConsole("error", message);
                    _debugExtMsg("error", message);
                };
                _self.resetInternalMessageCount = function () {
                    _messageCount = 0;
                    _messageLogged = {};
                };
                _self[_DYN_LOG_INTERNAL_MESSAGE ] = _logInternalMessage;
                _self[_DYN_UNLOAD ] = function (isAsync) {
                    _unloadHandler && _unloadHandler.rm();
                    _unloadHandler = null;
                };
                function _logInternalMessage(severity, message) {
                    if (_areInternalMessagesThrottled()) {
                        return;
                    }
                    var logMessage = true;
                    var messageKey = AIInternalMessagePrefix + message[_DYN_MESSAGE_ID ];
                    if (_messageLogged[messageKey]) {
                        logMessage = false;
                    }
                    else {
                        _messageLogged[messageKey] = true;
                    }
                    if (logMessage) {
                        if (severity <= _loggingLevelTelemetry) {
                            _self.queue[_DYN_PUSH$2 ](message);
                            _messageCount++;
                            _debugExtMsg((severity === 1  ? "error" : "warn"), message);
                        }
                        if (_messageCount === _maxInternalMessageLimit) {
                            var throttleLimitMessage = "Internal events throttle limit per PageView reached for this app.";
                            var throttleMessage = new _InternalLogMessage(23 , throttleLimitMessage, false);
                            _self.queue[_DYN_PUSH$2 ](throttleMessage);
                            if (severity === 1 ) {
                                _self.errorToConsole(throttleLimitMessage);
                            }
                            else {
                                _self[_DYN_WARN_TO_CONSOLE ](throttleLimitMessage);
                            }
                        }
                    }
                }
                function _setDefaultsFromConfig(config) {
                    return onConfigChange(createDynamicConfig(config, defaultValues$2, _self).cfg, function (details) {
                        var config = details.cfg;
                        _loggingLevelConsole = config[_DYN_LOGGING_LEVEL_CONSOL4 ];
                        _loggingLevelTelemetry = config.loggingLevelTelemetry;
                        _maxInternalMessageLimit = config.maxMessageLimit;
                        _enableDebug = config.enableDebug;
                    });
                }
                function _areInternalMessagesThrottled() {
                    return _messageCount >= _maxInternalMessageLimit;
                }
                function _debugExtMsg(name, data) {
                    var dbgExt = getDebugExt(config || {});
                    if (dbgExt && dbgExt[_DYN_DIAG_LOG$1 ]) {
                        dbgExt[_DYN_DIAG_LOG$1 ](name, data);
                    }
                }
            });
        }
        DiagnosticLogger.__ieDyn=1;
        return DiagnosticLogger;
    }());
    function _getLogger(logger) {
        return (logger || new DiagnosticLogger());
    }
    function _throwInternal(logger, severity, msgId, msg, properties, isUserAct) {
        if (isUserAct === void 0) { isUserAct = false; }
        _getLogger(logger)[_DYN_THROW_INTERNAL ](severity, msgId, msg, properties, isUserAct);
    }
    function _warnToConsole(logger, message) {
        _getLogger(logger)[_DYN_WARN_TO_CONSOLE ](message);
    }

    var _a$3, _b$1;
    var strToGMTString = "toGMTString";
    var strToUTCString = "toUTCString";
    var strCookie = "cookie";
    var strExpires = "expires";
    var strIsCookieUseDisabled = "isCookieUseDisabled";
    var strDisableCookiesUsage = "disableCookiesUsage";
    var strConfigCookieMgr = "_ckMgr";
    var _supportsCookies = null;
    var _allowUaSameSite = null;
    var _parsedCookieValue = null;
    var _doc;
    var _cookieCache = {};
    var _globalCookieConfig = {};
    var rootDefaultConfig = (_a$3 = {
            cookieCfg: cfgDfMerge((_b$1 = {},
                _b$1[STR_DOMAIN] = { fb: "cookieDomain", dfVal: isNotNullOrUndefined },
                _b$1.path = { fb: "cookiePath", dfVal: isNotNullOrUndefined },
                _b$1.enabled = UNDEFINED_VALUE$1,
                _b$1.ignoreCookies = UNDEFINED_VALUE$1,
                _b$1.blockedCookies = UNDEFINED_VALUE$1,
                _b$1)),
            cookieDomain: UNDEFINED_VALUE$1,
            cookiePath: UNDEFINED_VALUE$1
        },
        _a$3[strDisableCookiesUsage] = UNDEFINED_VALUE$1,
        _a$3);
    function _getDoc() {
        !_doc && (_doc = getLazy(function () { return getDocument(); }));
    }
    function _isMgrEnabled(cookieMgr) {
        if (cookieMgr) {
            return cookieMgr.isEnabled();
        }
        return true;
    }
    function _isIgnoredCookie(cookieMgrCfg, name) {
        if (name && cookieMgrCfg && isArray(cookieMgrCfg.ignoreCookies)) {
            return arrIndexOf(cookieMgrCfg.ignoreCookies, name) !== -1;
        }
        return false;
    }
    function _isBlockedCookie(cookieMgrCfg, name) {
        if (name && cookieMgrCfg && isArray(cookieMgrCfg.blockedCookies)) {
            if (arrIndexOf(cookieMgrCfg.blockedCookies, name) !== -1) {
                return true;
            }
        }
        return _isIgnoredCookie(cookieMgrCfg, name);
    }
    function _isCfgEnabled(rootConfig, cookieMgrConfig) {
        var isCfgEnabled = cookieMgrConfig[_DYN_ENABLED ];
        if (isNullOrUndefined(isCfgEnabled)) {
            var cookieEnabled = void 0;
            if (!isUndefined(rootConfig[strIsCookieUseDisabled])) {
                cookieEnabled = !rootConfig[strIsCookieUseDisabled];
            }
            if (!isUndefined(rootConfig[strDisableCookiesUsage])) {
                cookieEnabled = !rootConfig[strDisableCookiesUsage];
            }
            isCfgEnabled = cookieEnabled;
        }
        return isCfgEnabled;
    }
    function createCookieMgr(rootConfig, logger) {
        var _a;
        var cookieMgrConfig;
        var _path;
        var _domain;
        var unloadHandler;
        var _enabled;
        var _getCookieFn;
        var _setCookieFn;
        var _delCookieFn;
        rootConfig = createDynamicConfig(rootConfig || _globalCookieConfig, null, logger).cfg;
        unloadHandler = onConfigChange(rootConfig, function (details) {
            details[_DYN_SET_DF ](details.cfg, rootDefaultConfig);
            cookieMgrConfig = details.ref(details.cfg, "cookieCfg");
            _path = cookieMgrConfig[STR_PATH ] || "/";
            _domain = cookieMgrConfig[STR_DOMAIN ];
            _enabled = _isCfgEnabled(rootConfig, cookieMgrConfig) !== false;
            _getCookieFn = cookieMgrConfig.getCookie || _getCookieValue;
            _setCookieFn = cookieMgrConfig.setCookie || _setCookieValue;
            _delCookieFn = cookieMgrConfig.delCookie || _setCookieValue;
        }, logger);
        var cookieMgr = (_a = {
                isEnabled: function () {
                    var enabled = _isCfgEnabled(rootConfig, cookieMgrConfig) !== false && _enabled && areCookiesSupported(logger);
                    var gblManager = _globalCookieConfig[strConfigCookieMgr];
                    if (enabled && gblManager && cookieMgr !== gblManager) {
                        enabled = _isMgrEnabled(gblManager);
                    }
                    return enabled;
                },
                setEnabled: function (value) {
                    _enabled = value !== false;
                    cookieMgrConfig[_DYN_ENABLED ] = value;
                },
                set: function (name, value, maxAgeSec, domain, path) {
                    var result = false;
                    if (_isMgrEnabled(cookieMgr) && !_isBlockedCookie(cookieMgrConfig, name)) {
                        var values = {};
                        var theValue = strTrim(value || STR_EMPTY$1);
                        var idx = strIndexOf(theValue, ";");
                        if (idx !== -1) {
                            theValue = strTrim(strLeft(value, idx));
                            values = _extractParts(strSubstring(value, idx + 1));
                        }
                        setValue(values, STR_DOMAIN, domain || _domain, isTruthy, isUndefined);
                        if (!isNullOrUndefined(maxAgeSec)) {
                            var _isIE = isIE();
                            if (isUndefined(values[strExpires])) {
                                var nowMs = utcNow();
                                var expireMs = nowMs + (maxAgeSec * 1000);
                                if (expireMs > 0) {
                                    var expiry = new Date();
                                    expiry.setTime(expireMs);
                                    setValue(values, strExpires, _formatDate(expiry, !_isIE ? strToUTCString : strToGMTString) || _formatDate(expiry, _isIE ? strToGMTString : strToUTCString) || STR_EMPTY$1, isTruthy);
                                }
                            }
                            if (!_isIE) {
                                setValue(values, "max-age", STR_EMPTY$1 + maxAgeSec, null, isUndefined);
                            }
                        }
                        var location_1 = getLocation();
                        if (location_1 && location_1[_DYN_PROTOCOL ] === "https:") {
                            setValue(values, "secure", null, null, isUndefined);
                            if (_allowUaSameSite === null) {
                                _allowUaSameSite = !uaDisallowsSameSiteNone((getNavigator() || {})[_DYN_USER_AGENT ]);
                            }
                            if (_allowUaSameSite) {
                                setValue(values, "SameSite", "None", null, isUndefined);
                            }
                        }
                        setValue(values, STR_PATH, path || _path, null, isUndefined);
                        _setCookieFn(name, _formatCookieValue(theValue, values));
                        result = true;
                    }
                    return result;
                },
                get: function (name) {
                    var value = STR_EMPTY$1;
                    if (_isMgrEnabled(cookieMgr) && !_isIgnoredCookie(cookieMgrConfig, name)) {
                        value = _getCookieFn(name);
                    }
                    return value;
                },
                del: function (name, path) {
                    var result = false;
                    if (_isMgrEnabled(cookieMgr)) {
                        result = cookieMgr.purge(name, path);
                    }
                    return result;
                },
                purge: function (name, path) {
                    var _a;
                    var result = false;
                    if (areCookiesSupported(logger)) {
                        var values = (_a = {},
                            _a[STR_PATH] = path ? path : "/",
                            _a[strExpires] = "Thu, 01 Jan 1970 00:00:01 GMT",
                            _a);
                        if (!isIE()) {
                            values["max-age"] = "0";
                        }
                        _delCookieFn(name, _formatCookieValue(STR_EMPTY$1, values));
                        result = true;
                    }
                    return result;
                }
            },
            _a[_DYN_UNLOAD ] = function (isAsync) {
                unloadHandler && unloadHandler.rm();
                unloadHandler = null;
            },
            _a);
        cookieMgr[strConfigCookieMgr] = cookieMgr;
        return cookieMgr;
    }
    function areCookiesSupported(logger) {
        if (_supportsCookies === null) {
            _supportsCookies = false;
            !_doc && _getDoc();
            try {
                var doc = _doc.v || {};
                _supportsCookies = doc[strCookie] !== undefined;
            }
            catch (e) {
                _throwInternal(logger, 2 , 68 , "Cannot access document.cookie - " + getExceptionName(e), { exception: dumpObj(e) });
            }
        }
        return _supportsCookies;
    }
    function _extractParts(theValue) {
        var values = {};
        if (theValue && theValue[_DYN_LENGTH$2 ]) {
            var parts = strTrim(theValue)[_DYN_SPLIT$1 ](";");
            arrForEach(parts, function (thePart) {
                thePart = strTrim(thePart || STR_EMPTY$1);
                if (thePart) {
                    var idx = strIndexOf(thePart, "=");
                    if (idx === -1) {
                        values[thePart] = null;
                    }
                    else {
                        values[strTrim(strLeft(thePart, idx))] = strTrim(strSubstring(thePart, idx + 1));
                    }
                }
            });
        }
        return values;
    }
    function _formatDate(theDate, func) {
        if (isFunction(theDate[func])) {
            return theDate[func]();
        }
        return null;
    }
    function _formatCookieValue(value, values) {
        var cookieValue = value || STR_EMPTY$1;
        objForEachKey(values, function (name, theValue) {
            cookieValue += "; " + name + (!isNullOrUndefined(theValue) ? "=" + theValue : STR_EMPTY$1);
        });
        return cookieValue;
    }
    function _getCookieValue(name) {
        var cookieValue = STR_EMPTY$1;
        !_doc && _getDoc();
        if (_doc.v) {
            var theCookie = _doc.v[strCookie] || STR_EMPTY$1;
            if (_parsedCookieValue !== theCookie) {
                _cookieCache = _extractParts(theCookie);
                _parsedCookieValue = theCookie;
            }
            cookieValue = strTrim(_cookieCache[name] || STR_EMPTY$1);
        }
        return cookieValue;
    }
    function _setCookieValue(name, cookieValue) {
        !_doc && _getDoc();
        if (_doc.v) {
            _doc.v[strCookie] = name + "=" + cookieValue;
        }
    }
    function uaDisallowsSameSiteNone(userAgent) {
        if (!isString(userAgent)) {
            return false;
        }
        if (strContains(userAgent, "CPU iPhone OS 12") || strContains(userAgent, "iPad; CPU OS 12")) {
            return true;
        }
        if (strContains(userAgent, "Macintosh; Intel Mac OS X 10_14") && strContains(userAgent, "Version/") && strContains(userAgent, "Safari")) {
            return true;
        }
        if (strContains(userAgent, "Macintosh; Intel Mac OS X 10_14") && strEndsWith(userAgent, "AppleWebKit/605.1.15 (KHTML, like Gecko)")) {
            return true;
        }
        if (strContains(userAgent, "Chrome/5") || strContains(userAgent, "Chrome/6")) {
            return true;
        }
        if (strContains(userAgent, "UnrealEngine") && !strContains(userAgent, "Chrome")) {
            return true;
        }
        if (strContains(userAgent, "UCBrowser/12") || strContains(userAgent, "UCBrowser/11")) {
            return true;
        }
        return false;
    }

    var defaultValues$1 = {
        perfEvtsSendAll: false
    };
    function _runScheduledListeners(asyncNotifications) {
        asyncNotifications.h = null;
        var callbacks = asyncNotifications.cb;
        asyncNotifications.cb = [];
        arrForEach(callbacks, function (cb) {
            safe(cb.fn, [cb.arg]);
        });
    }
    function _runListeners(listeners, name, asyncNotifications, callback) {
        arrForEach(listeners, function (listener) {
            if (listener && listener[name]) {
                if (asyncNotifications) {
                    asyncNotifications.cb[_DYN_PUSH$2 ]({
                        fn: callback,
                        arg: listener
                    });
                    asyncNotifications.h = asyncNotifications.h || scheduleTimeout(_runScheduledListeners, 0, asyncNotifications);
                }
                else {
                    safe(callback, [listener]);
                }
            }
        });
    }
    var NotificationManager = /** @class */ (function () {
        function NotificationManager(config) {
            this.listeners = [];
            var perfEvtsSendAll;
            var unloadHandler;
            var _listeners = [];
            var _asyncNotifications = {
                h: null,
                cb: []
            };
            var cfgHandler = createDynamicConfig(config, defaultValues$1);
            unloadHandler = cfgHandler[_DYN_WATCH ](function (details) {
                perfEvtsSendAll = !!details.cfg.perfEvtsSendAll;
            });
            dynamicProto(NotificationManager, this, function (_self) {
                objDefine(_self, "listeners", {
                    g: function () { return _listeners; }
                });
                _self[_DYN_ADD_NOTIFICATION_LIS1 ] = function (listener) {
                    _listeners[_DYN_PUSH$2 ](listener);
                };
                _self[_DYN_REMOVE_NOTIFICATION_0 ] = function (listener) {
                    var index = arrIndexOf(_listeners, listener);
                    while (index > -1) {
                        _listeners[_DYN_SPLICE ](index, 1);
                        index = arrIndexOf(_listeners, listener);
                    }
                };
                _self[STR_EVENTS_SENT ] = function (events) {
                    _runListeners(_listeners, STR_EVENTS_SENT, _asyncNotifications, function (listener) {
                        listener[STR_EVENTS_SENT ](events);
                    });
                };
                _self[STR_EVENTS_DISCARDED ] = function (events, reason) {
                    _runListeners(_listeners, STR_EVENTS_DISCARDED, _asyncNotifications, function (listener) {
                        listener[STR_EVENTS_DISCARDED ](events, reason);
                    });
                };
                _self[STR_EVENTS_SEND_REQUEST ] = function (sendReason, isAsync) {
                    _runListeners(_listeners, STR_EVENTS_SEND_REQUEST, isAsync ? _asyncNotifications : null, function (listener) {
                        listener[STR_EVENTS_SEND_REQUEST ](sendReason, isAsync);
                    });
                };
                _self[STR_PERF_EVENT ] = function (perfEvent) {
                    if (perfEvent) {
                        if (perfEvtsSendAll || !perfEvent[_DYN_IS_CHILD_EVT ]()) {
                            _runListeners(_listeners, STR_PERF_EVENT, null, function (listener) {
                                if (perfEvent[_DYN_IS_ASYNC ]) {
                                    scheduleTimeout(function () { return listener[STR_PERF_EVENT ](perfEvent); }, 0);
                                }
                                else {
                                    listener[STR_PERF_EVENT ](perfEvent);
                                }
                            });
                        }
                    }
                };
                _self[STR_OFFLINE_STORE ] = function (events) {
                    if (events && events[_DYN_LENGTH$2 ]) {
                        _runListeners(_listeners, STR_OFFLINE_STORE, _asyncNotifications, function (listener) {
                            listener[STR_OFFLINE_STORE ](events);
                        });
                    }
                };
                _self[STR_OFFLINE_SENT ] = function (batch) {
                    if (batch && batch[_DYN_DATA$1 ]) {
                        _runListeners(_listeners, STR_OFFLINE_SENT, _asyncNotifications, function (listener) {
                            listener[STR_OFFLINE_SENT ](batch);
                        });
                    }
                };
                _self[STR_OFFLINE_DROP ] = function (cnt, reason) {
                    if (cnt > 0) {
                        var rn_1 = reason || 0;
                        _runListeners(_listeners, STR_OFFLINE_DROP, _asyncNotifications, function (listener) {
                            listener[STR_OFFLINE_DROP ](cnt, rn_1);
                        });
                    }
                };
                _self[_DYN_UNLOAD ] = function (isAsync) {
                    var _finishUnload = function () {
                        unloadHandler && unloadHandler.rm();
                        unloadHandler = null;
                        _listeners = [];
                        _asyncNotifications.h && _asyncNotifications.h[_DYN_CANCEL ]();
                        _asyncNotifications.h = null;
                        _asyncNotifications.cb = [];
                    };
                    var waiting;
                    _runListeners(_listeners, "unload", null, function (listener) {
                        var asyncUnload = listener[_DYN_UNLOAD ](isAsync);
                        if (asyncUnload) {
                            if (!waiting) {
                                waiting = [];
                            }
                            waiting[_DYN_PUSH$2 ](asyncUnload);
                        }
                    });
                    if (waiting) {
                        return createPromise(function (resolve) {
                            return doAwaitResponse(createAllPromise(waiting), function () {
                                _finishUnload();
                                resolve();
                            });
                        });
                    }
                    else {
                        _finishUnload();
                    }
                };
            });
        }
        NotificationManager.__ieDyn=1;
        return NotificationManager;
    }());

    var strExecutionContextKey = "ctx";
    var strParentContextKey = "ParentContextKey";
    var strChildrenContextKey = "ChildrenContextKey";
    var _defaultPerfManager = null;
    var PerfEvent = /** @class */ (function () {
        function PerfEvent(name, payloadDetails, isAsync) {
            var _self = this;
            _self.start = utcNow();
            _self[_DYN_NAME$2 ] = name;
            _self[_DYN_IS_ASYNC ] = isAsync;
            _self[_DYN_IS_CHILD_EVT ] = function () { return false; };
            if (isFunction(payloadDetails)) {
                var theDetails_1;
                objDefine(_self, "payload", {
                    g: function () {
                        if (!theDetails_1 && isFunction(payloadDetails)) {
                            theDetails_1 = payloadDetails();
                            payloadDetails = null;
                        }
                        return theDetails_1;
                    }
                });
            }
            _self[_DYN_GET_CTX ] = function (key) {
                if (key) {
                    if (key === PerfEvent[strParentContextKey] || key === PerfEvent[strChildrenContextKey]) {
                        return _self[key];
                    }
                    return (_self[strExecutionContextKey] || {})[key];
                }
                return null;
            };
            _self[_DYN_SET_CTX ] = function (key, value) {
                if (key) {
                    if (key === PerfEvent[strParentContextKey]) {
                        if (!_self[key]) {
                            _self[_DYN_IS_CHILD_EVT ] = function () { return true; };
                        }
                        _self[key] = value;
                    }
                    else if (key === PerfEvent[strChildrenContextKey]) {
                        _self[key] = value;
                    }
                    else {
                        var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};
                        ctx[key] = value;
                    }
                }
            };
            _self[_DYN_COMPLETE ] = function () {
                var childTime = 0;
                var childEvts = _self[_DYN_GET_CTX ](PerfEvent[strChildrenContextKey]);
                if (isArray(childEvts)) {
                    for (var lp = 0; lp < childEvts[_DYN_LENGTH$2 ]; lp++) {
                        var childEvt = childEvts[lp];
                        if (childEvt) {
                            childTime += childEvt[_DYN_TIME ];
                        }
                    }
                }
                _self[_DYN_TIME ] = utcNow() - _self.start;
                _self.exTime = _self[_DYN_TIME ] - childTime;
                _self[_DYN_COMPLETE ] = function () { };
            };
        }
        PerfEvent.ParentContextKey = "parent";
        PerfEvent.ChildrenContextKey = "childEvts";
        return PerfEvent;
    }());
    var PerfManager = /** @class */ (function () {
        function PerfManager(manager) {
            this.ctx = {};
            dynamicProto(PerfManager, this, function (_self) {
                _self.create = function (src, payloadDetails, isAsync) {
                    return new PerfEvent(src, payloadDetails, isAsync);
                };
                _self.fire = function (perfEvent) {
                    if (perfEvent) {
                        perfEvent[_DYN_COMPLETE ]();
                        if (manager && isFunction(manager[STR_PERF_EVENT ])) {
                            manager[STR_PERF_EVENT ](perfEvent);
                        }
                    }
                };
                _self[_DYN_SET_CTX ] = function (key, value) {
                    if (key) {
                        var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};
                        ctx[key] = value;
                    }
                };
                _self[_DYN_GET_CTX ] = function (key) {
                    return (_self[strExecutionContextKey] || {})[key];
                };
            });
        }
        PerfManager.__ieDyn=1;
        return PerfManager;
    }());
    var doPerfActiveKey = "CoreUtils.doPerf";
    function doPerf(mgrSource, getSource, func, details, isAsync) {
        if (mgrSource) {
            var perfMgr = mgrSource;
            if (perfMgr[STR_GET_PERF_MGR]) {
                perfMgr = perfMgr[STR_GET_PERF_MGR]();
            }
            if (perfMgr) {
                var perfEvt = void 0;
                var currentActive = perfMgr[_DYN_GET_CTX ](doPerfActiveKey);
                try {
                    perfEvt = perfMgr.create(getSource(), details, isAsync);
                    if (perfEvt) {
                        if (currentActive && perfEvt[_DYN_SET_CTX ]) {
                            perfEvt[_DYN_SET_CTX ](PerfEvent[strParentContextKey], currentActive);
                            if (currentActive[_DYN_GET_CTX ] && currentActive[_DYN_SET_CTX ]) {
                                var children = currentActive[_DYN_GET_CTX ](PerfEvent[strChildrenContextKey]);
                                if (!children) {
                                    children = [];
                                    currentActive[_DYN_SET_CTX ](PerfEvent[strChildrenContextKey], children);
                                }
                                children[_DYN_PUSH$2 ](perfEvt);
                            }
                        }
                        perfMgr[_DYN_SET_CTX ](doPerfActiveKey, perfEvt);
                        return func(perfEvt);
                    }
                }
                catch (ex) {
                    if (perfEvt && perfEvt[_DYN_SET_CTX ]) {
                        perfEvt[_DYN_SET_CTX ]("exception", ex);
                    }
                }
                finally {
                    if (perfEvt) {
                        perfMgr.fire(perfEvt);
                    }
                    perfMgr[_DYN_SET_CTX ](doPerfActiveKey, currentActive);
                }
            }
        }
        return func();
    }
    function getGblPerfMgr() {
        return _defaultPerfManager;
    }

    var INVALID_TRACE_ID = "00000000000000000000000000000000";
    var INVALID_SPAN_ID = "0000000000000000";
    function _isValid(value, len, invalidValue) {
        if (value && value[_DYN_LENGTH$2 ] === len && value !== invalidValue) {
            return !!value.match(/^[\da-f]*$/i);
        }
        return false;
    }
    function isValidTraceId(value) {
        return _isValid(value, 32, INVALID_TRACE_ID);
    }
    function isValidSpanId(value) {
        return _isValid(value, 16, INVALID_SPAN_ID);
    }

    var pluginStateData = createElmNodeData("plugin");
    function _getPluginState(plugin) {
        return pluginStateData.get(plugin, "state", {}, true);
    }
    function initializePlugins(processContext, extensions) {
        var initPlugins = [];
        var lastPlugin = null;
        var proxy = processContext[_DYN_GET_NEXT ]();
        var pluginState;
        while (proxy) {
            var thePlugin = proxy[_DYN_GET_PLUGIN ]();
            if (thePlugin) {
                if (lastPlugin && lastPlugin[_DYN_SET_NEXT_PLUGIN ] && thePlugin[STR_PROCESS_TELEMETRY ]) {
                    lastPlugin[_DYN_SET_NEXT_PLUGIN ](thePlugin);
                }
                pluginState = _getPluginState(thePlugin);
                var isInitialized = !!pluginState[_DYN_IS_INITIALIZED ];
                if (thePlugin[_DYN_IS_INITIALIZED ]) {
                    isInitialized = thePlugin[_DYN_IS_INITIALIZED ]();
                }
                if (!isInitialized) {
                    initPlugins[_DYN_PUSH$2 ](thePlugin);
                }
                lastPlugin = thePlugin;
                proxy = proxy[_DYN_GET_NEXT ]();
            }
        }
        arrForEach(initPlugins, function (thePlugin) {
            var core = processContext[STR_CORE ]();
            thePlugin[_DYN_INITIALIZE$1 ](processContext.getCfg(), core, extensions, processContext[_DYN_GET_NEXT ]());
            pluginState = _getPluginState(thePlugin);
            if (!thePlugin[STR_CORE] && !pluginState[STR_CORE]) {
                pluginState[STR_CORE] = core;
            }
            pluginState[_DYN_IS_INITIALIZED ] = true;
            delete pluginState[_DYN_TEARDOWN ];
        });
    }
    function sortPlugins(plugins) {
        return plugins.sort(function (extA, extB) {
            var result = 0;
            if (extB) {
                var bHasProcess = extB[STR_PROCESS_TELEMETRY];
                if (extA[STR_PROCESS_TELEMETRY]) {
                    result = bHasProcess ? extA[STR_PRIORITY] - extB[STR_PRIORITY] : 1;
                }
                else if (bHasProcess) {
                    result = -1;
                }
            }
            else {
                result = extA ? 1 : -1;
            }
            return result;
        });
    }
    function createDistributedTraceContext(parentCtx) {
        var trace = {};
        return {
            getName: function () {
                return trace[_DYN_NAME$2 ];
            },
            setName: function (newValue) {
                parentCtx && parentCtx.setName(newValue);
                trace[_DYN_NAME$2 ] = newValue;
            },
            getTraceId: function () {
                return trace[_DYN_TRACE_ID$1 ];
            },
            setTraceId: function (newValue) {
                parentCtx && parentCtx.setTraceId(newValue);
                if (isValidTraceId(newValue)) {
                    trace[_DYN_TRACE_ID$1 ] = newValue;
                }
            },
            getSpanId: function () {
                return trace[_DYN_SPAN_ID ];
            },
            setSpanId: function (newValue) {
                parentCtx && parentCtx.setSpanId(newValue);
                if (isValidSpanId(newValue)) {
                    trace[_DYN_SPAN_ID ] = newValue;
                }
            },
            getTraceFlags: function () {
                return trace[_DYN_TRACE_FLAGS ];
            },
            setTraceFlags: function (newTraceFlags) {
                parentCtx && parentCtx.setTraceFlags(newTraceFlags);
                trace[_DYN_TRACE_FLAGS ] = newTraceFlags;
            }
        };
    }

    var strTelemetryPluginChain = "TelemetryPluginChain";
    var strHasRunFlags = "_hasRun";
    var strGetTelCtx = "_getTelCtx";
    var _chainId = 0;
    function _getNextProxyStart(proxy, core, startAt) {
        while (proxy) {
            if (proxy[_DYN_GET_PLUGIN ]() === startAt) {
                return proxy;
            }
            proxy = proxy[_DYN_GET_NEXT ]();
        }
        return createTelemetryProxyChain([startAt], core.config || {}, core);
    }
    function _createInternalContext(telemetryChain, dynamicHandler, core, startAt) {
        var _nextProxy = null;
        var _onComplete = [];
        if (!dynamicHandler) {
            dynamicHandler = createDynamicConfig({}, null, core[_DYN_LOGGER ]);
        }
        if (startAt !== null) {
            _nextProxy = startAt ? _getNextProxyStart(telemetryChain, core, startAt) : telemetryChain;
        }
        var context = {
            _next: _moveNext,
            ctx: {
                core: function () {
                    return core;
                },
                diagLog: function () {
                    return safeGetLogger(core, dynamicHandler.cfg);
                },
                getCfg: function () {
                    return dynamicHandler.cfg;
                },
                getExtCfg: _resolveExtCfg,
                getConfig: _getConfig,
                hasNext: function () {
                    return !!_nextProxy;
                },
                getNext: function () {
                    return _nextProxy;
                },
                setNext: function (nextPlugin) {
                    _nextProxy = nextPlugin;
                },
                iterate: _iterateChain,
                onComplete: _addOnComplete
            }
        };
        function _addOnComplete(onComplete, that) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            if (onComplete) {
                _onComplete[_DYN_PUSH$2 ]({
                    func: onComplete,
                    self: !isUndefined(that) ? that : context.ctx,
                    args: args
                });
            }
        }
        function _moveNext() {
            var nextProxy = _nextProxy;
            _nextProxy = nextProxy ? nextProxy[_DYN_GET_NEXT ]() : null;
            if (!nextProxy) {
                var onComplete = _onComplete;
                if (onComplete && onComplete[_DYN_LENGTH$2 ] > 0) {
                    arrForEach(onComplete, function (completeDetails) {
                        try {
                            completeDetails.func.call(completeDetails.self, completeDetails.args);
                        }
                        catch (e) {
                            _throwInternal(core[_DYN_LOGGER ], 2 , 73 , "Unexpected Exception during onComplete - " + dumpObj(e));
                        }
                    });
                    _onComplete = [];
                }
            }
            return nextProxy;
        }
        function _getExtCfg(identifier, createIfMissing) {
            var idCfg = null;
            var cfg = dynamicHandler.cfg;
            if (cfg && identifier) {
                var extCfg = cfg[STR_EXTENSION_CONFIG ];
                if (!extCfg && createIfMissing) {
                    extCfg = {};
                }
                cfg[STR_EXTENSION_CONFIG] = extCfg;
                extCfg = dynamicHandler.ref(cfg, STR_EXTENSION_CONFIG);
                if (extCfg) {
                    idCfg = extCfg[identifier];
                    if (!idCfg && createIfMissing) {
                        idCfg = {};
                    }
                    extCfg[identifier] = idCfg;
                    idCfg = dynamicHandler.ref(extCfg, identifier);
                }
            }
            return idCfg;
        }
        function _resolveExtCfg(identifier, defaultValues) {
            var newConfig = _getExtCfg(identifier, true);
            if (defaultValues) {
                objForEachKey(defaultValues, function (field, defaultValue) {
                    if (isNullOrUndefined(newConfig[field])) {
                        var cfgValue = dynamicHandler.cfg[field];
                        if (cfgValue || !isNullOrUndefined(cfgValue)) {
                            newConfig[field] = cfgValue;
                        }
                    }
                    _applyDefaultValue(dynamicHandler, newConfig, field, defaultValue);
                });
            }
            return dynamicHandler[_DYN_SET_DF ](newConfig, defaultValues);
        }
        function _getConfig(identifier, field, defaultValue) {
            if (defaultValue === void 0) { defaultValue = false; }
            var theValue;
            var extConfig = _getExtCfg(identifier, false);
            var rootConfig = dynamicHandler.cfg;
            if (extConfig && (extConfig[field] || !isNullOrUndefined(extConfig[field]))) {
                theValue = extConfig[field];
            }
            else if (rootConfig[field] || !isNullOrUndefined(rootConfig[field])) {
                theValue = rootConfig[field];
            }
            return (theValue || !isNullOrUndefined(theValue)) ? theValue : defaultValue;
        }
        function _iterateChain(cb) {
            var nextPlugin;
            while (!!(nextPlugin = context._next())) {
                var plugin = nextPlugin[_DYN_GET_PLUGIN ]();
                if (plugin) {
                    cb(plugin);
                }
            }
        }
        return context;
    }
    function createProcessTelemetryContext(telemetryChain, cfg, core, startAt) {
        var config = createDynamicConfig(cfg);
        var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
        var context = internalContext.ctx;
        function _processNext(env) {
            var nextPlugin = internalContext._next();
            if (nextPlugin) {
                nextPlugin[STR_PROCESS_TELEMETRY ](env, context);
            }
            return !nextPlugin;
        }
        function _createNew(plugins, startAt) {
            if (plugins === void 0) { plugins = null; }
            if (isArray(plugins)) {
                plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt);
            }
            return createProcessTelemetryContext(plugins || context[_DYN_GET_NEXT ](), config.cfg, core, startAt);
        }
        context[_DYN_PROCESS_NEXT ] = _processNext;
        context[_DYN_CREATE_NEW$1 ] = _createNew;
        return context;
    }
    function createProcessTelemetryUnloadContext(telemetryChain, core, startAt) {
        var config = createDynamicConfig(core.config);
        var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
        var context = internalContext.ctx;
        function _processNext(unloadState) {
            var nextPlugin = internalContext._next();
            nextPlugin && nextPlugin[_DYN_UNLOAD ](context, unloadState);
            return !nextPlugin;
        }
        function _createNew(plugins, startAt) {
            if (plugins === void 0) { plugins = null; }
            if (isArray(plugins)) {
                plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt);
            }
            return createProcessTelemetryUnloadContext(plugins || context[_DYN_GET_NEXT ](), core, startAt);
        }
        context[_DYN_PROCESS_NEXT ] = _processNext;
        context[_DYN_CREATE_NEW$1 ] = _createNew;
        return context;
    }
    function createProcessTelemetryUpdateContext(telemetryChain, core, startAt) {
        var config = createDynamicConfig(core.config);
        var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
        var context = internalContext.ctx;
        function _processNext(updateState) {
            return context.iterate(function (plugin) {
                if (isFunction(plugin[_DYN_UPDATE ])) {
                    plugin[_DYN_UPDATE ](context, updateState);
                }
            });
        }
        function _createNew(plugins, startAt) {
            if (plugins === void 0) { plugins = null; }
            if (isArray(plugins)) {
                plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt);
            }
            return createProcessTelemetryUpdateContext(plugins || context[_DYN_GET_NEXT ](), core, startAt);
        }
        context[_DYN_PROCESS_NEXT ] = _processNext;
        context[_DYN_CREATE_NEW$1 ] = _createNew;
        return context;
    }
    function createTelemetryProxyChain(plugins, config, core, startAt) {
        var firstProxy = null;
        var add = startAt ? false : true;
        if (isArray(plugins) && plugins[_DYN_LENGTH$2 ] > 0) {
            var lastProxy_1 = null;
            arrForEach(plugins, function (thePlugin) {
                if (!add && startAt === thePlugin) {
                    add = true;
                }
                if (add && thePlugin && isFunction(thePlugin[STR_PROCESS_TELEMETRY ])) {
                    var newProxy = createTelemetryPluginProxy(thePlugin, config, core);
                    if (!firstProxy) {
                        firstProxy = newProxy;
                    }
                    if (lastProxy_1) {
                        lastProxy_1._setNext(newProxy);
                    }
                    lastProxy_1 = newProxy;
                }
            });
        }
        if (startAt && !firstProxy) {
            return createTelemetryProxyChain([startAt], config, core);
        }
        return firstProxy;
    }
    function createTelemetryPluginProxy(plugin, config, core) {
        var nextProxy = null;
        var hasProcessTelemetry = isFunction(plugin[STR_PROCESS_TELEMETRY ]);
        var hasSetNext = isFunction(plugin[_DYN_SET_NEXT_PLUGIN ]);
        var chainId;
        if (plugin) {
            chainId = plugin[_DYN_IDENTIFIER ] + "-" + plugin[STR_PRIORITY ] + "-" + _chainId++;
        }
        else {
            chainId = "Unknown-0-" + _chainId++;
        }
        var proxyChain = {
            getPlugin: function () {
                return plugin;
            },
            getNext: function () {
                return nextProxy;
            },
            processTelemetry: _processTelemetry,
            unload: _unloadPlugin,
            update: _updatePlugin,
            _id: chainId,
            _setNext: function (nextPlugin) {
                nextProxy = nextPlugin;
            }
        };
        function _getTelCtx() {
            var itemCtx;
            if (plugin && isFunction(plugin[strGetTelCtx])) {
                itemCtx = plugin[strGetTelCtx]();
            }
            if (!itemCtx) {
                itemCtx = createProcessTelemetryContext(proxyChain, config, core);
            }
            return itemCtx;
        }
        function _processChain(itemCtx, processPluginFn, name, details, isAsync) {
            var hasRun = false;
            var identifier = plugin ? plugin[_DYN_IDENTIFIER ] : strTelemetryPluginChain;
            var hasRunContext = itemCtx[strHasRunFlags];
            if (!hasRunContext) {
                hasRunContext = itemCtx[strHasRunFlags] = {};
            }
            itemCtx.setNext(nextProxy);
            if (plugin) {
                doPerf(itemCtx[STR_CORE ](), function () { return identifier + ":" + name; }, function () {
                    hasRunContext[chainId] = true;
                    try {
                        var nextId = nextProxy ? nextProxy._id : STR_EMPTY$1;
                        if (nextId) {
                            hasRunContext[nextId] = false;
                        }
                        hasRun = processPluginFn(itemCtx);
                    }
                    catch (error) {
                        var hasNextRun = nextProxy ? hasRunContext[nextProxy._id] : true;
                        if (hasNextRun) {
                            hasRun = true;
                        }
                        if (!nextProxy || !hasNextRun) {
                            _throwInternal(itemCtx[_DYN_DIAG_LOG$1 ](), 1 , 73 , "Plugin [" + identifier + "] failed during " + name + " - " + dumpObj(error) + ", run flags: " + dumpObj(hasRunContext));
                        }
                    }
                }, details, isAsync);
            }
            return hasRun;
        }
        function _processTelemetry(env, itemCtx) {
            itemCtx = itemCtx || _getTelCtx();
            function _callProcessTelemetry(itemCtx) {
                if (!plugin || !hasProcessTelemetry) {
                    return false;
                }
                var pluginState = _getPluginState(plugin);
                if (pluginState[_DYN_TEARDOWN ] || pluginState[STR_DISABLED]) {
                    return false;
                }
                if (hasSetNext) {
                    plugin[_DYN_SET_NEXT_PLUGIN ](nextProxy);
                }
                plugin[STR_PROCESS_TELEMETRY ](env, itemCtx);
                return true;
            }
            if (!_processChain(itemCtx, _callProcessTelemetry, "processTelemetry", function () { return ({ item: env }); }, !(env.sync))) {
                itemCtx[_DYN_PROCESS_NEXT ](env);
            }
        }
        function _unloadPlugin(unloadCtx, unloadState) {
            function _callTeardown() {
                var hasRun = false;
                if (plugin) {
                    var pluginState = _getPluginState(plugin);
                    var pluginCore = plugin[STR_CORE] || pluginState[STR_CORE ];
                    if (plugin && (!pluginCore || pluginCore === unloadCtx.core()) && !pluginState[_DYN_TEARDOWN ]) {
                        pluginState[STR_CORE ] = null;
                        pluginState[_DYN_TEARDOWN ] = true;
                        pluginState[_DYN_IS_INITIALIZED ] = false;
                        if (plugin[_DYN_TEARDOWN ] && plugin[_DYN_TEARDOWN ](unloadCtx, unloadState) === true) {
                            hasRun = true;
                        }
                    }
                }
                return hasRun;
            }
            if (!_processChain(unloadCtx, _callTeardown, "unload", function () { }, unloadState[_DYN_IS_ASYNC ])) {
                unloadCtx[_DYN_PROCESS_NEXT ](unloadState);
            }
        }
        function _updatePlugin(updateCtx, updateState) {
            function _callUpdate() {
                var hasRun = false;
                if (plugin) {
                    var pluginState = _getPluginState(plugin);
                    var pluginCore = plugin[STR_CORE] || pluginState[STR_CORE ];
                    if (plugin && (!pluginCore || pluginCore === updateCtx.core()) && !pluginState[_DYN_TEARDOWN ]) {
                        if (plugin[_DYN_UPDATE ] && plugin[_DYN_UPDATE ](updateCtx, updateState) === true) {
                            hasRun = true;
                        }
                    }
                }
                return hasRun;
            }
            if (!_processChain(updateCtx, _callUpdate, "update", function () { }, false)) {
                updateCtx[_DYN_PROCESS_NEXT ](updateState);
            }
        }
        return objFreeze(proxyChain);
    }

    function createUnloadHandlerContainer() {
        var handlers = [];
        function _addHandler(handler) {
            if (handler) {
                handlers[_DYN_PUSH$2 ](handler);
            }
        }
        function _runHandlers(unloadCtx, unloadState) {
            arrForEach(handlers, function (handler) {
                try {
                    handler(unloadCtx, unloadState);
                }
                catch (e) {
                    _throwInternal(unloadCtx[_DYN_DIAG_LOG$1 ](), 2 , 73 , "Unexpected error calling unload handler - " + dumpObj(e));
                }
            });
            handlers = [];
        }
        return {
            add: _addHandler,
            run: _runHandlers
        };
    }

    function createUnloadHookContainer() {
        var _hooks = [];
        function _doUnload(logger) {
            var oldHooks = _hooks;
            _hooks = [];
            arrForEach(oldHooks, function (fn) {
                try {
                    (fn.rm || fn.remove).call(fn);
                }
                catch (e) {
                    _throwInternal(logger, 2 , 73 , "Unloading:" + dumpObj(e));
                }
            });
        }
        function _addHook(hooks) {
            if (hooks) {
                arrAppend(_hooks, hooks);
            }
        }
        return {
            run: _doUnload,
            add: _addHook
        };
    }

    var _a$2;
    var strGetPlugin = "getPlugin";
    var defaultValues = (_a$2 = {},
        _a$2[STR_EXTENSION_CONFIG] = { isVal: isNotNullOrUndefined, v: {} },
        _a$2);
    var BaseTelemetryPlugin = /** @class */ (function () {
        function BaseTelemetryPlugin() {
            var _self = this;
            var _isinitialized;
            var _rootCtx;
            var _nextPlugin;
            var _unloadHandlerContainer;
            var _hookContainer;
            _initDefaults();
            dynamicProto(BaseTelemetryPlugin, _self, function (_self) {
                _self[_DYN_INITIALIZE$1 ] = function (config, core, extensions, pluginChain) {
                    _setDefaults(config, core, pluginChain);
                    _isinitialized = true;
                };
                _self[_DYN_TEARDOWN ] = function (unloadCtx, unloadState) {
                    var _a;
                    var core = _self[STR_CORE ];
                    if (!core || (unloadCtx && core !== unloadCtx[STR_CORE ]())) {
                        return;
                    }
                    var result;
                    var unloadDone = false;
                    var theUnloadCtx = unloadCtx || createProcessTelemetryUnloadContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);
                    var theUnloadState = unloadState || (_a = {
                            reason: 0
                        },
                        _a[_DYN_IS_ASYNC ] = false,
                        _a);
                    function _unloadCallback() {
                        if (!unloadDone) {
                            unloadDone = true;
                            _unloadHandlerContainer.run(theUnloadCtx, unloadState);
                            _hookContainer.run(theUnloadCtx[_DYN_DIAG_LOG$1 ]());
                            if (result === true) {
                                theUnloadCtx[_DYN_PROCESS_NEXT ](theUnloadState);
                            }
                            _initDefaults();
                        }
                    }
                    if (!_self[_DYN__DO_TEARDOWN ] || _self[_DYN__DO_TEARDOWN ](theUnloadCtx, theUnloadState, _unloadCallback) !== true) {
                        _unloadCallback();
                    }
                    else {
                        result = true;
                    }
                    return result;
                };
                _self[_DYN_UPDATE ] = function (updateCtx, updateState) {
                    var core = _self[STR_CORE ];
                    if (!core || (updateCtx && core !== updateCtx[STR_CORE ]())) {
                        return;
                    }
                    var result;
                    var updateDone = false;
                    var theUpdateCtx = updateCtx || createProcessTelemetryUpdateContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);
                    var theUpdateState = updateState || {
                        reason: 0
                    };
                    function _updateCallback() {
                        if (!updateDone) {
                            updateDone = true;
                            _setDefaults(theUpdateCtx.getCfg(), theUpdateCtx.core(), theUpdateCtx[_DYN_GET_NEXT ]());
                        }
                    }
                    if (!_self._doUpdate || _self._doUpdate(theUpdateCtx, theUpdateState, _updateCallback) !== true) {
                        _updateCallback();
                    }
                    else {
                        result = true;
                    }
                    return result;
                };
                proxyFunctionAs(_self, "_addUnloadCb", function () { return _unloadHandlerContainer; }, "add");
                proxyFunctionAs(_self, "_addHook", function () { return _hookContainer; }, "add");
                objDefine(_self, "_unloadHooks", { g: function () { return _hookContainer; } });
            });
            _self[_DYN_DIAG_LOG$1 ] = function (itemCtx) {
                return _getTelCtx(itemCtx)[_DYN_DIAG_LOG$1 ]();
            };
            _self[_DYN_IS_INITIALIZED ] = function () {
                return _isinitialized;
            };
            _self.setInitialized = function (isInitialized) {
                _isinitialized = isInitialized;
            };
            _self[_DYN_SET_NEXT_PLUGIN ] = function (next) {
                _nextPlugin = next;
            };
            _self[_DYN_PROCESS_NEXT ] = function (env, itemCtx) {
                if (itemCtx) {
                    itemCtx[_DYN_PROCESS_NEXT ](env);
                }
                else if (_nextPlugin && isFunction(_nextPlugin[STR_PROCESS_TELEMETRY ])) {
                    _nextPlugin[STR_PROCESS_TELEMETRY ](env, null);
                }
            };
            _self._getTelCtx = _getTelCtx;
            function _getTelCtx(currentCtx) {
                if (currentCtx === void 0) { currentCtx = null; }
                var itemCtx = currentCtx;
                if (!itemCtx) {
                    var rootCtx = _rootCtx || createProcessTelemetryContext(null, {}, _self[STR_CORE ]);
                    if (_nextPlugin && _nextPlugin[strGetPlugin]) {
                        itemCtx = rootCtx[_DYN_CREATE_NEW$1 ](null, _nextPlugin[strGetPlugin]);
                    }
                    else {
                        itemCtx = rootCtx[_DYN_CREATE_NEW$1 ](null, _nextPlugin);
                    }
                }
                return itemCtx;
            }
            function _setDefaults(config, core, pluginChain) {
                createDynamicConfig(config, defaultValues, safeGetLogger(core));
                if (!pluginChain && core) {
                    pluginChain = core[_DYN_GET_PROCESS_TEL_CONT2 ]()[_DYN_GET_NEXT ]();
                }
                var nextPlugin = _nextPlugin;
                if (_nextPlugin && _nextPlugin[strGetPlugin]) {
                    nextPlugin = _nextPlugin[strGetPlugin]();
                }
                _self[STR_CORE ] = core;
                _rootCtx = createProcessTelemetryContext(pluginChain, config, core, nextPlugin);
            }
            function _initDefaults() {
                _isinitialized = false;
                _self[STR_CORE ] = null;
                _rootCtx = null;
                _nextPlugin = null;
                _hookContainer = createUnloadHookContainer();
                _unloadHandlerContainer = createUnloadHandlerContainer();
            }
        }
        BaseTelemetryPlugin.__ieDyn=1;
        return BaseTelemetryPlugin;
    }());

    function _addInitializer(_initializers, id, telemetryInitializer) {
        var theInitializer = {
            id: id,
            fn: telemetryInitializer
        };
        arrAppend(_initializers, theInitializer);
        var handler = {
            remove: function () {
                arrForEach(_initializers, function (initializer, idx) {
                    if (initializer.id === theInitializer.id) {
                        _initializers[_DYN_SPLICE ](idx, 1);
                        return -1;
                    }
                });
            }
        };
        return handler;
    }
    function _runInitializers(_initializers, item, logger) {
        var doNotSendItem = false;
        var telemetryInitializersCount = _initializers[_DYN_LENGTH$2 ];
        for (var i = 0; i < telemetryInitializersCount; ++i) {
            var telemetryInitializer = _initializers[i];
            if (telemetryInitializer) {
                try {
                    if (telemetryInitializer.fn[_DYN_APPLY ](null, [item]) === false) {
                        doNotSendItem = true;
                        break;
                    }
                }
                catch (e) {
                    _throwInternal(logger, 2 , 64 , "Telemetry initializer failed: " + getExceptionName(e), { exception: dumpObj(e) }, true);
                }
            }
        }
        return !doNotSendItem;
    }
    var TelemetryInitializerPlugin = /** @class */ (function (_super) {
        __extendsFn(TelemetryInitializerPlugin, _super);
        function TelemetryInitializerPlugin() {
            var _this = _super.call(this) || this;
            _this.identifier = "TelemetryInitializerPlugin";
            _this.priority = 199;
            var _id;
            var _initializers;
            _initDefaults();
            dynamicProto(TelemetryInitializerPlugin, _this, function (_self, _base) {
                _self.addTelemetryInitializer = function (telemetryInitializer) {
                    return _addInitializer(_initializers, _id++, telemetryInitializer);
                };
                _self[STR_PROCESS_TELEMETRY ] = function (item, itemCtx) {
                    if (_runInitializers(_initializers, item, itemCtx ? itemCtx[_DYN_DIAG_LOG$1 ]() : _self[_DYN_DIAG_LOG$1 ]())) {
                        _self[_DYN_PROCESS_NEXT ](item, itemCtx);
                    }
                };
                _self[_DYN__DO_TEARDOWN ] = function () {
                    _initDefaults();
                };
            });
            function _initDefaults() {
                _id = 0;
                _initializers = [];
            }
            return _this;
        }
        TelemetryInitializerPlugin.__ieDyn=1;
        return TelemetryInitializerPlugin;
    }(BaseTelemetryPlugin));

    var _a$1;
    var strValidationError = "Plugins must provide initialize method";
    var strNotificationManager = "_notificationManager";
    var strSdkUnloadingError = "SDK is still unloading...";
    var strSdkNotInitialized = "SDK is not initialized";
    var defaultConfig = objDeepFreeze((_a$1 = {
            cookieCfg: {}
        },
        _a$1[STR_EXTENSIONS] = { rdOnly: true, ref: true, v: [] },
        _a$1[STR_CHANNELS] = { rdOnly: true, ref: true, v: [] },
        _a$1[STR_EXTENSION_CONFIG] = { ref: true, v: {} },
        _a$1[STR_CREATE_PERF_MGR] = UNDEFINED_VALUE$1,
        _a$1.loggingLevelConsole = 0 ,
        _a$1.diagnosticLogInterval = UNDEFINED_VALUE$1,
        _a$1));
    function _createPerfManager(core, notificationMgr) {
        return new PerfManager(notificationMgr);
    }
    function _validateExtensions(logger, channelPriority, allExtensions) {
        var _a;
        var coreExtensions = [];
        var channels = [];
        var extPriorities = {};
        arrForEach(allExtensions, function (ext) {
            if (isNullOrUndefined(ext) || isNullOrUndefined(ext[_DYN_INITIALIZE$1 ])) {
                throwError(strValidationError);
            }
            var extPriority = ext[STR_PRIORITY ];
            var identifier = ext[_DYN_IDENTIFIER ];
            if (ext && extPriority) {
                if (!isNullOrUndefined(extPriorities[extPriority])) {
                    _warnToConsole(logger, "Two extensions have same priority #" + extPriority + " - " + extPriorities[extPriority] + ", " + identifier);
                }
                else {
                    extPriorities[extPriority] = identifier;
                }
            }
            if (!extPriority || extPriority < channelPriority) {
                coreExtensions[_DYN_PUSH$2 ](ext);
            }
            else {
                channels[_DYN_PUSH$2 ](ext);
            }
        });
        return _a = {},
            _a[STR_CORE ] = coreExtensions,
            _a[STR_CHANNELS ] = channels,
            _a;
    }
    function _isPluginPresent(thePlugin, plugins) {
        var exists = false;
        arrForEach(plugins, function (plugin) {
            if (plugin === thePlugin) {
                exists = true;
                return -1;
            }
        });
        return exists;
    }
    function _deepMergeConfig(details, target, newValues, merge) {
        if (newValues) {
            objForEachKey(newValues, function (key, value) {
                if (merge) {
                    if (isPlainObject(value) && isPlainObject(target[key])) {
                        _deepMergeConfig(details, target[key], value, merge);
                    }
                }
                if (merge && isPlainObject(value) && isPlainObject(target[key])) {
                    _deepMergeConfig(details, target[key], value, merge);
                }
                else {
                    details.set(target, key, value);
                }
            });
        }
    }
    function _findWatcher(listeners, newWatcher) {
        var theListener = null;
        var idx = -1;
        arrForEach(listeners, function (listener, lp) {
            if (listener.w === newWatcher) {
                theListener = listener;
                idx = lp;
                return -1;
            }
        });
        return { i: idx, l: theListener };
    }
    function _addDelayedCfgListener(listeners, newWatcher) {
        var theListener = _findWatcher(listeners, newWatcher).l;
        if (!theListener) {
            theListener = {
                w: newWatcher,
                rm: function () {
                    var fnd = _findWatcher(listeners, newWatcher);
                    if (fnd.i !== -1) {
                        listeners[_DYN_SPLICE ](fnd.i, 1);
                    }
                }
            };
            listeners[_DYN_PUSH$2 ](theListener);
        }
        return theListener;
    }
    function _registerDelayedCfgListener(config, listeners, logger) {
        arrForEach(listeners, function (listener) {
            var unloadHdl = onConfigChange(config, listener.w, logger);
            delete listener.w;
            listener.rm = function () {
                unloadHdl.rm();
            };
        });
    }
    function _initDebugListener(configHandler, unloadContainer, notificationManager, debugListener) {
        unloadContainer.add(configHandler[_DYN_WATCH ](function (details) {
            var disableDbgExt = details.cfg.disableDbgExt;
            if (disableDbgExt === true && debugListener) {
                notificationManager[_DYN_REMOVE_NOTIFICATION_0 ](debugListener);
                debugListener = null;
            }
            if (notificationManager && !debugListener && disableDbgExt !== true) {
                debugListener = getDebugListener(details.cfg);
                notificationManager[_DYN_ADD_NOTIFICATION_LIS1 ](debugListener);
            }
        }));
        return debugListener;
    }
    function _createUnloadHook(unloadHook) {
        return objDefine({
            rm: function () {
                unloadHook.rm();
            }
        }, "toJSON", { v: function () { return "aicore::onCfgChange<" + JSON.stringify(unloadHook) + ">"; } });
    }
    var AppInsightsCore = /** @class */ (function () {
        function AppInsightsCore() {
            var _configHandler;
            var _isInitialized;
            var _logger;
            var _eventQueue;
            var _notificationManager;
            var _perfManager;
            var _cfgPerfManager;
            var _cookieManager;
            var _pluginChain;
            var _configExtensions;
            var _channelConfig;
            var _channels;
            var _isUnloading;
            var _telemetryInitializerPlugin;
            var _internalLogsEventName;
            var _evtNamespace;
            var _unloadHandlers;
            var _hookContainer;
            var _debugListener;
            var _traceCtx;
            var _instrumentationKey;
            var _cfgListeners;
            var _extensions;
            var _pluginVersionStringArr;
            var _pluginVersionString;
            var _internalLogPoller;
            var _internalLogPollerListening;
            var _forceStopInternalLogPoller;
            dynamicProto(AppInsightsCore, this, function (_self) {
                _initDefaults();
                _self["_getDbgPlgTargets"] = function () {
                    return [_extensions];
                };
                _self[_DYN_IS_INITIALIZED ] = function () { return _isInitialized; };
                _self[_DYN_INITIALIZE$1 ] = function (config, extensions, logger, notificationManager) {
                    if (_isUnloading) {
                        throwError(strSdkUnloadingError);
                    }
                    if (_self[_DYN_IS_INITIALIZED ]()) {
                        throwError("Core cannot be initialized more than once");
                    }
                    _configHandler = createDynamicConfig(config, defaultConfig, logger || _self[_DYN_LOGGER ], false);
                    config = _configHandler.cfg;
                    _addUnloadHook(_configHandler[_DYN_WATCH ](function (details) {
                        _instrumentationKey = details.cfg.instrumentationKey;
                        var extCfg = details.ref(details.cfg, STR_EXTENSION_CONFIG);
                        objForEachKey(extCfg, function (key) {
                            details.ref(extCfg, key);
                        });
                        if (isNullOrUndefined(_instrumentationKey)) {
                            throwError("Please provide instrumentation key");
                        }
                    }));
                    _notificationManager = notificationManager;
                    _debugListener = _initDebugListener(_configHandler, _hookContainer, _notificationManager && _self[_DYN_GET_NOTIFY_MGR ](), _debugListener);
                    _initPerfManager();
                    _self[_DYN_LOGGER ] = logger;
                    var cfgExtensions = config[STR_EXTENSIONS ];
                    _configExtensions = [];
                    _configExtensions[_DYN_PUSH$2 ].apply(_configExtensions, __spreadArrayFn(__spreadArrayFn([], extensions, false), cfgExtensions));
                    _channelConfig = config[STR_CHANNELS ];
                    _initPluginChain(null);
                    if (!_channels || _channels[_DYN_LENGTH$2 ] === 0) {
                        throwError("No " + STR_CHANNELS + " available");
                    }
                    if (_channelConfig && _channelConfig[_DYN_LENGTH$2 ] > 1) {
                        var teeController = _self[_DYN_GET_PLUGIN ]("TeeChannelController");
                        if (!teeController || !teeController.plugin) {
                            _throwInternal(_logger, 1 , 28 , "TeeChannel required");
                        }
                    }
                    _registerDelayedCfgListener(config, _cfgListeners, _logger);
                    _cfgListeners = null;
                    _isInitialized = true;
                    _self.releaseQueue();
                    _self[_DYN_POLL_INTERNAL_LOGS ]();
                };
                _self.getChannels = function () {
                    var controls = [];
                    if (_channels) {
                        arrForEach(_channels, function (channel) {
                            controls[_DYN_PUSH$2 ](channel);
                        });
                    }
                    return objFreeze(controls);
                };
                _self.track = function (telemetryItem) {
                    doPerf(_self[STR_GET_PERF_MGR ](), function () { return "AppInsightsCore:track"; }, function () {
                        if (telemetryItem === null) {
                            _notifyInvalidEvent(telemetryItem);
                            throwError("Invalid telemetry item");
                        }
                        if (!telemetryItem[_DYN_NAME$2 ] && isNullOrUndefined(telemetryItem[_DYN_NAME$2 ])) {
                            _notifyInvalidEvent(telemetryItem);
                            throwError("telemetry name required");
                        }
                        telemetryItem.iKey = telemetryItem.iKey || _instrumentationKey;
                        telemetryItem[_DYN_TIME ] = telemetryItem[_DYN_TIME ] || toISOString(new Date());
                        telemetryItem.ver = telemetryItem.ver || "4.0";
                        if (!_isUnloading && _self[_DYN_IS_INITIALIZED ]()) {
                            _createTelCtx()[_DYN_PROCESS_NEXT ](telemetryItem);
                        }
                        else {
                            _eventQueue[_DYN_PUSH$2 ](telemetryItem);
                        }
                    }, function () { return ({ item: telemetryItem }); }, !(telemetryItem.sync));
                };
                _self[_DYN_GET_PROCESS_TEL_CONT2 ] = _createTelCtx;
                _self[_DYN_GET_NOTIFY_MGR ] = function () {
                    if (!_notificationManager) {
                        _notificationManager = new NotificationManager(_configHandler.cfg);
                        _self[strNotificationManager] = _notificationManager;
                    }
                    return _notificationManager;
                };
                _self[_DYN_ADD_NOTIFICATION_LIS1 ] = function (listener) {
                    _self.getNotifyMgr()[_DYN_ADD_NOTIFICATION_LIS1 ](listener);
                };
                _self[_DYN_REMOVE_NOTIFICATION_0 ] = function (listener) {
                    if (_notificationManager) {
                        _notificationManager[_DYN_REMOVE_NOTIFICATION_0 ](listener);
                    }
                };
                _self.getCookieMgr = function () {
                    if (!_cookieManager) {
                        _cookieManager = createCookieMgr(_configHandler.cfg, _self[_DYN_LOGGER ]);
                    }
                    return _cookieManager;
                };
                _self.setCookieMgr = function (cookieMgr) {
                    if (_cookieManager !== cookieMgr) {
                        runTargetUnload(_cookieManager, false);
                        _cookieManager = cookieMgr;
                    }
                };
                _self[STR_GET_PERF_MGR ] = function () {
                    return _perfManager || _cfgPerfManager || getGblPerfMgr();
                };
                _self.setPerfMgr = function (perfMgr) {
                    _perfManager = perfMgr;
                };
                _self.eventCnt = function () {
                    return _eventQueue[_DYN_LENGTH$2 ];
                };
                _self.releaseQueue = function () {
                    if (_isInitialized && _eventQueue[_DYN_LENGTH$2 ] > 0) {
                        var eventQueue = _eventQueue;
                        _eventQueue = [];
                        arrForEach(eventQueue, function (event) {
                            _createTelCtx()[_DYN_PROCESS_NEXT ](event);
                        });
                    }
                };
                _self[_DYN_POLL_INTERNAL_LOGS ] = function (eventName) {
                    _internalLogsEventName = eventName || null;
                    _forceStopInternalLogPoller = false;
                    _internalLogPoller && _internalLogPoller[_DYN_CANCEL ]();
                    return _startLogPoller(true);
                };
                function _startLogPoller(alwaysStart) {
                    if ((!_internalLogPoller || !_internalLogPoller[_DYN_ENABLED ]) && !_forceStopInternalLogPoller) {
                        var shouldStart = alwaysStart || (_logger && _logger.queue[_DYN_LENGTH$2 ] > 0);
                        if (shouldStart) {
                            if (!_internalLogPollerListening) {
                                _internalLogPollerListening = true;
                                _addUnloadHook(_configHandler[_DYN_WATCH ](function (details) {
                                    var interval = details.cfg.diagnosticLogInterval;
                                    if (!interval || !(interval > 0)) {
                                        interval = 10000;
                                    }
                                    var isRunning = false;
                                    if (_internalLogPoller) {
                                        isRunning = _internalLogPoller[_DYN_ENABLED ];
                                        _internalLogPoller[_DYN_CANCEL ]();
                                    }
                                    _internalLogPoller = createTimeout(_flushInternalLogs, interval);
                                    _internalLogPoller.unref();
                                    _internalLogPoller[_DYN_ENABLED ] = isRunning;
                                }));
                            }
                            _internalLogPoller[_DYN_ENABLED ] = true;
                        }
                    }
                    return _internalLogPoller;
                }
                _self[_DYN_STOP_POLLING_INTERNA3 ] = function () {
                    _forceStopInternalLogPoller = true;
                    _internalLogPoller && _internalLogPoller[_DYN_CANCEL ]();
                    _flushInternalLogs();
                };
                proxyFunctions(_self, function () { return _telemetryInitializerPlugin; }, ["addTelemetryInitializer"]);
                _self[_DYN_UNLOAD ] = function (isAsync, unloadComplete, cbTimeout) {
                    var _a;
                    if (isAsync === void 0) { isAsync = true; }
                    if (!_isInitialized) {
                        throwError(strSdkNotInitialized);
                    }
                    if (_isUnloading) {
                        throwError(strSdkUnloadingError);
                    }
                    var unloadState = (_a = {
                            reason: 50
                        },
                        _a[_DYN_IS_ASYNC ] = isAsync,
                        _a.flushComplete = false,
                        _a);
                    var result;
                    if (isAsync && !unloadComplete) {
                        result = createPromise(function (resolve) {
                            unloadComplete = resolve;
                        });
                    }
                    var processUnloadCtx = createProcessTelemetryUnloadContext(_getPluginChain(), _self);
                    processUnloadCtx[_DYN_ON_COMPLETE ](function () {
                        _hookContainer.run(_self[_DYN_LOGGER ]);
                        doUnloadAll([_cookieManager, _notificationManager, _logger], isAsync, function () {
                            _initDefaults();
                            unloadComplete && unloadComplete(unloadState);
                        });
                    }, _self);
                    function _doUnload(flushComplete) {
                        unloadState.flushComplete = flushComplete;
                        _isUnloading = true;
                        _unloadHandlers.run(processUnloadCtx, unloadState);
                        _self[_DYN_STOP_POLLING_INTERNA3 ]();
                        processUnloadCtx[_DYN_PROCESS_NEXT ](unloadState);
                    }
                    _flushInternalLogs();
                    if (!_flushChannels(isAsync, _doUnload, 6 , cbTimeout)) ;
                    return result;
                };
                _self[_DYN_GET_PLUGIN ] = _getPlugin;
                _self.addPlugin = function (plugin, replaceExisting, isAsync, addCb) {
                    if (!plugin) {
                        addCb && addCb(false);
                        _logOrThrowError(strValidationError);
                        return;
                    }
                    var existingPlugin = _getPlugin(plugin[_DYN_IDENTIFIER ]);
                    if (existingPlugin && !replaceExisting) {
                        addCb && addCb(false);
                        _logOrThrowError("Plugin [" + plugin[_DYN_IDENTIFIER ] + "] is already loaded!");
                        return;
                    }
                    var updateState = {
                        reason: 16
                    };
                    function _addPlugin(removed) {
                        _configExtensions[_DYN_PUSH$2 ](plugin);
                        updateState.added = [plugin];
                        _initPluginChain(updateState);
                        addCb && addCb(true);
                    }
                    if (existingPlugin) {
                        var removedPlugins_1 = [existingPlugin.plugin];
                        var unloadState = {
                            reason: 2 ,
                            isAsync: !!isAsync
                        };
                        _removePlugins(removedPlugins_1, unloadState, function (removed) {
                            if (!removed) {
                                addCb && addCb(false);
                            }
                            else {
                                updateState.removed = removedPlugins_1;
                                updateState.reason |= 32 ;
                                _addPlugin();
                            }
                        });
                    }
                    else {
                        _addPlugin();
                    }
                };
                _self.updateCfg = function (newConfig, mergeExisting) {
                    if (mergeExisting === void 0) { mergeExisting = true; }
                    var updateState;
                    if (_self[_DYN_IS_INITIALIZED ]()) {
                        updateState = {
                            reason: 1 ,
                            cfg: _configHandler.cfg,
                            oldCfg: deepExtend({}, _configHandler.cfg),
                            newConfig: deepExtend({}, newConfig),
                            merge: mergeExisting
                        };
                        newConfig = updateState.newConfig;
                        var cfg = _configHandler.cfg;
                        newConfig[STR_EXTENSIONS ] = cfg[STR_EXTENSIONS ];
                        newConfig[STR_CHANNELS ] = cfg[STR_CHANNELS ];
                    }
                    _configHandler._block(function (details) {
                        var theConfig = details.cfg;
                        _deepMergeConfig(details, theConfig, newConfig, mergeExisting);
                        if (!mergeExisting) {
                            objForEachKey(theConfig, function (key) {
                                if (!objHasOwn(newConfig, key)) {
                                    details.set(theConfig, key, UNDEFINED_VALUE$1);
                                }
                            });
                        }
                        details[_DYN_SET_DF ](theConfig, defaultConfig);
                    }, true);
                    _configHandler[_DYN_NOTIFY ]();
                    if (updateState) {
                        _doUpdate(updateState);
                    }
                };
                _self.evtNamespace = function () {
                    return _evtNamespace;
                };
                _self.flush = _flushChannels;
                _self.getTraceCtx = function (createNew) {
                    if (!_traceCtx) {
                        _traceCtx = createDistributedTraceContext();
                    }
                    return _traceCtx;
                };
                _self.setTraceCtx = function (traceCtx) {
                    _traceCtx = traceCtx || null;
                };
                _self.addUnloadHook = _addUnloadHook;
                proxyFunctionAs(_self, "addUnloadCb", function () { return _unloadHandlers; }, "add");
                _self.onCfgChange = function (handler) {
                    var unloadHook;
                    if (!_isInitialized) {
                        unloadHook = _addDelayedCfgListener(_cfgListeners, handler);
                    }
                    else {
                        unloadHook = onConfigChange(_configHandler.cfg, handler, _self[_DYN_LOGGER ]);
                    }
                    return _createUnloadHook(unloadHook);
                };
                _self.getWParam = function () {
                    return (hasDocument() || !!_configHandler.cfg.enableWParam) ? 0 : -1;
                };
                function _setPluginVersions() {
                    var thePlugins = {};
                    _pluginVersionStringArr = [];
                    var _addPluginVersions = function (plugins) {
                        if (plugins) {
                            arrForEach(plugins, function (plugin) {
                                if (plugin[_DYN_IDENTIFIER ] && plugin[_DYN_VERSION ] && !thePlugins[plugin.identifier]) {
                                    var ver = plugin[_DYN_IDENTIFIER ] + "=" + plugin[_DYN_VERSION ];
                                    _pluginVersionStringArr[_DYN_PUSH$2 ](ver);
                                    thePlugins[plugin.identifier] = plugin;
                                }
                            });
                        }
                    };
                    _addPluginVersions(_channels);
                    if (_channelConfig) {
                        arrForEach(_channelConfig, function (channels) {
                            _addPluginVersions(channels);
                        });
                    }
                    _addPluginVersions(_configExtensions);
                }
                function _initDefaults() {
                    _isInitialized = false;
                    _configHandler = createDynamicConfig({}, defaultConfig, _self[_DYN_LOGGER ]);
                    _configHandler.cfg[_DYN_LOGGING_LEVEL_CONSOL4 ] = 1 ;
                    objDefine(_self, "config", {
                        g: function () { return _configHandler.cfg; },
                        s: function (newValue) {
                            _self.updateCfg(newValue, false);
                        }
                    });
                    objDefine(_self, "pluginVersionStringArr", {
                        g: function () {
                            if (!_pluginVersionStringArr) {
                                _setPluginVersions();
                            }
                            return _pluginVersionStringArr;
                        }
                    });
                    objDefine(_self, "pluginVersionString", {
                        g: function () {
                            if (!_pluginVersionString) {
                                if (!_pluginVersionStringArr) {
                                    _setPluginVersions();
                                }
                                _pluginVersionString = _pluginVersionStringArr.join(";");
                            }
                            return _pluginVersionString || STR_EMPTY$1;
                        }
                    });
                    objDefine(_self, "logger", {
                        g: function () {
                            if (!_logger) {
                                _logger = new DiagnosticLogger(_configHandler.cfg);
                                _configHandler[_DYN_LOGGER ] = _logger;
                            }
                            return _logger;
                        },
                        s: function (newLogger) {
                            _configHandler[_DYN_LOGGER ] = newLogger;
                            if (_logger !== newLogger) {
                                runTargetUnload(_logger, false);
                                _logger = newLogger;
                            }
                        }
                    });
                    _self[_DYN_LOGGER ] = new DiagnosticLogger(_configHandler.cfg);
                    _extensions = [];
                    var cfgExtensions = _self.config[STR_EXTENSIONS ] || [];
                    cfgExtensions.splice(0, cfgExtensions[_DYN_LENGTH$2 ]);
                    arrAppend(cfgExtensions, _extensions);
                    _telemetryInitializerPlugin = new TelemetryInitializerPlugin();
                    _eventQueue = [];
                    runTargetUnload(_notificationManager, false);
                    _notificationManager = null;
                    _perfManager = null;
                    _cfgPerfManager = null;
                    runTargetUnload(_cookieManager, false);
                    _cookieManager = null;
                    _pluginChain = null;
                    _configExtensions = [];
                    _channelConfig = null;
                    _channels = null;
                    _isUnloading = false;
                    _internalLogsEventName = null;
                    _evtNamespace = createUniqueNamespace("AIBaseCore", true);
                    _unloadHandlers = createUnloadHandlerContainer();
                    _traceCtx = null;
                    _instrumentationKey = null;
                    _hookContainer = createUnloadHookContainer();
                    _cfgListeners = [];
                    _pluginVersionString = null;
                    _pluginVersionStringArr = null;
                    _forceStopInternalLogPoller = false;
                    _internalLogPoller = null;
                    _internalLogPollerListening = false;
                }
                function _createTelCtx() {
                    var theCtx = createProcessTelemetryContext(_getPluginChain(), _configHandler.cfg, _self);
                    theCtx[_DYN_ON_COMPLETE ](_startLogPoller);
                    return theCtx;
                }
                function _initPluginChain(updateState) {
                    var theExtensions = _validateExtensions(_self[_DYN_LOGGER ], ChannelControllerPriority, _configExtensions);
                    _pluginChain = null;
                    _pluginVersionString = null;
                    _pluginVersionStringArr = null;
                    _channels = (_channelConfig || [])[0] || [];
                    _channels = sortPlugins(arrAppend(_channels, theExtensions[STR_CHANNELS ]));
                    var allExtensions = arrAppend(sortPlugins(theExtensions[STR_CORE ]), _channels);
                    _extensions = objFreeze(allExtensions);
                    var cfgExtensions = _self.config[STR_EXTENSIONS ] || [];
                    cfgExtensions.splice(0, cfgExtensions[_DYN_LENGTH$2 ]);
                    arrAppend(cfgExtensions, _extensions);
                    var rootCtx = _createTelCtx();
                    if (_channels && _channels[_DYN_LENGTH$2 ] > 0) {
                        initializePlugins(rootCtx[_DYN_CREATE_NEW$1 ](_channels), allExtensions);
                    }
                    initializePlugins(rootCtx, allExtensions);
                    if (updateState) {
                        _doUpdate(updateState);
                    }
                }
                function _getPlugin(pluginIdentifier) {
                    var theExt = null;
                    var thePlugin = null;
                    var channelHosts = [];
                    arrForEach(_extensions, function (ext) {
                        if (ext[_DYN_IDENTIFIER ] === pluginIdentifier && ext !== _telemetryInitializerPlugin) {
                            thePlugin = ext;
                            return -1;
                        }
                        if (ext.getChannel) {
                            channelHosts[_DYN_PUSH$2 ](ext);
                        }
                    });
                    if (!thePlugin && channelHosts[_DYN_LENGTH$2 ] > 0) {
                        arrForEach(channelHosts, function (host) {
                            thePlugin = host.getChannel(pluginIdentifier);
                            if (!thePlugin) {
                                return -1;
                            }
                        });
                    }
                    if (thePlugin) {
                        theExt = {
                            plugin: thePlugin,
                            setEnabled: function (enabled) {
                                _getPluginState(thePlugin)[STR_DISABLED] = !enabled;
                            },
                            isEnabled: function () {
                                var pluginState = _getPluginState(thePlugin);
                                return !pluginState[_DYN_TEARDOWN ] && !pluginState[STR_DISABLED];
                            },
                            remove: function (isAsync, removeCb) {
                                var _a;
                                if (isAsync === void 0) { isAsync = true; }
                                var pluginsToRemove = [thePlugin];
                                var unloadState = (_a = {
                                        reason: 1
                                    },
                                    _a[_DYN_IS_ASYNC ] = isAsync,
                                    _a);
                                _removePlugins(pluginsToRemove, unloadState, function (removed) {
                                    if (removed) {
                                        _initPluginChain({
                                            reason: 32 ,
                                            removed: pluginsToRemove
                                        });
                                    }
                                    removeCb && removeCb(removed);
                                });
                            }
                        };
                    }
                    return theExt;
                }
                function _getPluginChain() {
                    if (!_pluginChain) {
                        var extensions = (_extensions || []).slice();
                        if (arrIndexOf(extensions, _telemetryInitializerPlugin) === -1) {
                            extensions[_DYN_PUSH$2 ](_telemetryInitializerPlugin);
                        }
                        _pluginChain = createTelemetryProxyChain(sortPlugins(extensions), _configHandler.cfg, _self);
                    }
                    return _pluginChain;
                }
                function _removePlugins(thePlugins, unloadState, removeComplete) {
                    if (thePlugins && thePlugins[_DYN_LENGTH$2 ] > 0) {
                        var unloadChain = createTelemetryProxyChain(thePlugins, _configHandler.cfg, _self);
                        var unloadCtx = createProcessTelemetryUnloadContext(unloadChain, _self);
                        unloadCtx[_DYN_ON_COMPLETE ](function () {
                            var removed = false;
                            var newConfigExtensions = [];
                            arrForEach(_configExtensions, function (plugin, idx) {
                                if (!_isPluginPresent(plugin, thePlugins)) {
                                    newConfigExtensions[_DYN_PUSH$2 ](plugin);
                                }
                                else {
                                    removed = true;
                                }
                            });
                            _configExtensions = newConfigExtensions;
                            _pluginVersionString = null;
                            _pluginVersionStringArr = null;
                            var newChannelConfig = [];
                            if (_channelConfig) {
                                arrForEach(_channelConfig, function (queue, idx) {
                                    var newQueue = [];
                                    arrForEach(queue, function (channel) {
                                        if (!_isPluginPresent(channel, thePlugins)) {
                                            newQueue[_DYN_PUSH$2 ](channel);
                                        }
                                        else {
                                            removed = true;
                                        }
                                    });
                                    newChannelConfig[_DYN_PUSH$2 ](newQueue);
                                });
                                _channelConfig = newChannelConfig;
                            }
                            removeComplete && removeComplete(removed);
                            _startLogPoller();
                        });
                        unloadCtx[_DYN_PROCESS_NEXT ](unloadState);
                    }
                    else {
                        removeComplete(false);
                    }
                }
                function _flushInternalLogs() {
                    if (_logger && _logger.queue) {
                        var queue = _logger.queue.slice(0);
                        _logger.queue[_DYN_LENGTH$2 ] = 0;
                        arrForEach(queue, function (logMessage) {
                            var _a;
                            var item = (_a = {},
                                _a[_DYN_NAME$2 ] = _internalLogsEventName ? _internalLogsEventName : "InternalMessageId: " + logMessage[_DYN_MESSAGE_ID ],
                                _a.iKey = _instrumentationKey,
                                _a[_DYN_TIME ] = toISOString(new Date()),
                                _a.baseType = _InternalLogMessage.dataType,
                                _a.baseData = { message: logMessage[_DYN_MESSAGE$1 ] },
                                _a);
                            _self.track(item);
                        });
                    }
                }
                function _flushChannels(isAsync, callBack, sendReason, cbTimeout) {
                    var waiting = 1;
                    var doneIterating = false;
                    var cbTimer = null;
                    cbTimeout = cbTimeout || 5000;
                    function doCallback() {
                        waiting--;
                        if (doneIterating && waiting === 0) {
                            cbTimer && cbTimer[_DYN_CANCEL ]();
                            cbTimer = null;
                            callBack && callBack(doneIterating);
                            callBack = null;
                        }
                    }
                    if (_channels && _channels[_DYN_LENGTH$2 ] > 0) {
                        var flushCtx = _createTelCtx()[_DYN_CREATE_NEW$1 ](_channels);
                        flushCtx.iterate(function (plugin) {
                            if (plugin.flush) {
                                waiting++;
                                var handled_1 = false;
                                if (!plugin.flush(isAsync, function () {
                                    handled_1 = true;
                                    doCallback();
                                }, sendReason)) {
                                    if (!handled_1) {
                                        if (isAsync && cbTimer == null) {
                                            cbTimer = scheduleTimeout(function () {
                                                cbTimer = null;
                                                doCallback();
                                            }, cbTimeout);
                                        }
                                        else {
                                            doCallback();
                                        }
                                    }
                                }
                            }
                        });
                    }
                    doneIterating = true;
                    doCallback();
                    return true;
                }
                function _initPerfManager() {
                    var prevCfgPerfMgr;
                    _addUnloadHook(_configHandler[_DYN_WATCH ](function (details) {
                        var enablePerfMgr = details.cfg.enablePerfMgr;
                        if (enablePerfMgr) {
                            var createPerfMgr = details.cfg[STR_CREATE_PERF_MGR ];
                            if (prevCfgPerfMgr !== createPerfMgr) {
                                if (!createPerfMgr) {
                                    createPerfMgr = _createPerfManager;
                                }
                                getSetValue(details.cfg, STR_CREATE_PERF_MGR, createPerfMgr);
                                prevCfgPerfMgr = createPerfMgr;
                                _cfgPerfManager = null;
                            }
                            if (!_perfManager && !_cfgPerfManager && isFunction(createPerfMgr)) {
                                _cfgPerfManager = createPerfMgr(_self, _self[_DYN_GET_NOTIFY_MGR ]());
                            }
                        }
                        else {
                            _cfgPerfManager = null;
                            prevCfgPerfMgr = null;
                        }
                    }));
                }
                function _doUpdate(updateState) {
                    var updateCtx = createProcessTelemetryUpdateContext(_getPluginChain(), _self);
                    updateCtx[_DYN_ON_COMPLETE ](_startLogPoller);
                    if (!_self._updateHook || _self._updateHook(updateCtx, updateState) !== true) {
                        updateCtx[_DYN_PROCESS_NEXT ](updateState);
                    }
                }
                function _logOrThrowError(message) {
                    var logger = _self[_DYN_LOGGER ];
                    if (logger) {
                        _throwInternal(logger, 2 , 73 , message);
                        _startLogPoller();
                    }
                    else {
                        throwError(message);
                    }
                }
                function _notifyInvalidEvent(telemetryItem) {
                    var manager = _self[_DYN_GET_NOTIFY_MGR ]();
                    if (manager) {
                        manager[STR_EVENTS_DISCARDED ]([telemetryItem], 2 );
                    }
                }
                function _addUnloadHook(hooks) {
                    _hookContainer.add(hooks);
                }
            });
        }
        AppInsightsCore.__ieDyn=1;
        return AppInsightsCore;
    }());

    function parseResponse(response, diagLog) {
        try {
            if (response && response !== "") {
                var result = getJSON().parse(response);
                if (result && result[_DYN_ITEMS_RECEIVED$1 ] && result[_DYN_ITEMS_RECEIVED$1 ] >= result.itemsAccepted &&
                    result.itemsReceived - result.itemsAccepted === result.errors[_DYN_LENGTH$2 ]) {
                    return result;
                }
            }
        }
        catch (e) {
            _throwInternal(diagLog, 1 , 43 , "Cannot parse the response. " + (e[_DYN_NAME$2 ] || dumpObj(e)), {
                response: response
            });
        }
        return null;
    }

    var STR_EMPTY = "";
    var STR_NO_RESPONSE_BODY = "NoResponseBody";
    var _noResponseQs = "&" + STR_NO_RESPONSE_BODY + "=true";
    var STR_POST_METHOD = "POST";
    var SenderPostManager = /** @class */ (function () {
        function SenderPostManager() {
            var _syncFetchPayload = 0;
            var _enableSendPromise;
            var _isInitialized;
            var _diagLog;
            var _isOneDs;
            var _onCompleteFuncs;
            var _disableCredentials;
            var _fallbackInst;
            var _disableXhr;
            var _disableBeacon;
            var _disableBeaconSync;
            var _disableFetchKeepAlive;
            var _addNoResponse;
            var _timeoutWrapper;
            dynamicProto(SenderPostManager, this, function (_self, _base) {
                var _sendCredentials = true;
                _initDefaults();
                _self[_DYN_INITIALIZE$1 ] = function (config, diagLog) {
                    _diagLog = diagLog;
                    if (_isInitialized) {
                        _throwInternal(_diagLog, 1 , 28 , "Sender is already initialized");
                    }
                    _self.SetConfig(config);
                    _isInitialized = true;
                };
                _self["_getDbgPlgTargets"] = function () {
                    return [_isInitialized, _isOneDs, _disableCredentials, _enableSendPromise];
                };
                _self.SetConfig = function (config) {
                    try {
                        _onCompleteFuncs = config.senderOnCompleteCallBack || {};
                        _disableCredentials = !!config.disableCredentials;
                        _isOneDs = !!config.isOneDs;
                        _enableSendPromise = !!config.enableSendPromise;
                        _disableXhr = !!config.disableXhr;
                        _disableBeacon = !!config.disableBeacon;
                        _disableBeaconSync = !!config.disableBeaconSync;
                        _timeoutWrapper = config.timeWrapper;
                        _addNoResponse = !!config.addNoResponse;
                        _disableFetchKeepAlive = !!config.disableFetchKeepAlive;
                        _fallbackInst = { sendPOST: _xhrSender };
                        if (!_isOneDs) {
                            _sendCredentials = false;
                        }
                        if (_disableCredentials) {
                            var location_1 = getLocation();
                            if (location_1 && location_1.protocol && location_1.protocol[_DYN_TO_LOWER_CASE$1 ]() === "file:") {
                                _sendCredentials = false;
                            }
                        }
                        return true;
                    }
                    catch (e) {
                    }
                    return false;
                };
                _self.getSyncFetchPayload = function () {
                    return _syncFetchPayload;
                };
                _self.getSenderInst = function (transports, sync) {
                    if (transports && transports[_DYN_LENGTH$2 ]) {
                        return _getSenderInterface(transports, sync);
                    }
                    return null;
                };
                _self.getFallbackInst = function () {
                    return _fallbackInst;
                };
                _self[_DYN__DO_TEARDOWN ] = function (unloadCtx, unloadState) {
                    _initDefaults();
                };
                function _onSuccess(res, onComplete) {
                    _doOnComplete(onComplete, 200, {}, res);
                }
                function _onError(message, onComplete) {
                    _throwInternal(_diagLog, 2 , 26 , "Failed to send telemetry.", { message: message });
                    _doOnComplete(onComplete, 400, {});
                }
                function _onNoPayloadUrl(onComplete) {
                    _onError("No endpoint url is provided for the batch", onComplete);
                }
                function _getSenderInterface(transports, syncSupport) {
                    var _a;
                    var transportType = 0 ;
                    var sendPostFunc = null;
                    var lp = 0;
                    while (sendPostFunc == null && lp < transports[_DYN_LENGTH$2 ]) {
                        transportType = transports[lp];
                        if (!_disableXhr && transportType === 1 ) {
                            if (useXDomainRequest()) {
                                sendPostFunc = _xdrSender;
                            }
                            else if (isXhrSupported()) {
                                sendPostFunc = _xhrSender;
                            }
                        }
                        else if (transportType === 2  && isFetchSupported(syncSupport) && (!syncSupport || !_disableFetchKeepAlive)) {
                            sendPostFunc = _doFetchSender;
                        }
                        else if (transportType === 3  && isBeaconsSupported() && (syncSupport ? !_disableBeaconSync : !_disableBeacon)) {
                            sendPostFunc = _beaconSender;
                        }
                        lp++;
                    }
                    if (sendPostFunc) {
                        return _a = {
                                _transport: transportType,
                                _isSync: syncSupport
                            },
                            _a[_DYN_SEND_POST ] = sendPostFunc,
                            _a;
                    }
                    return null;
                }
                function _doOnComplete(oncomplete, status, headers, response) {
                    try {
                        oncomplete && oncomplete(status, headers, response);
                    }
                    catch (e) {
                    }
                }
                function _doBeaconSend(payload, oncomplete) {
                    var nav = getNavigator();
                    var url = payload[_DYN_URL_STRING ];
                    if (!url) {
                        _onNoPayloadUrl(oncomplete);
                        return true;
                    }
                    url = payload[_DYN_URL_STRING ] + (_addNoResponse ? _noResponseQs : STR_EMPTY);
                    var data = payload[_DYN_DATA$1 ];
                    var plainTextBatch = _isOneDs ? data : new Blob([data], { type: "text/plain;charset=UTF-8" });
                    var queued = nav.sendBeacon(url, plainTextBatch);
                    return queued;
                }
                function _beaconSender(payload, oncomplete, sync) {
                    var data = payload[_DYN_DATA$1 ];
                    try {
                        if (data) {
                            if (!_doBeaconSend(payload, oncomplete)) {
                                var onRetry = _onCompleteFuncs && _onCompleteFuncs.beaconOnRetry;
                                if (onRetry && isFunction(onRetry)) {
                                    onRetry(payload, oncomplete, _doBeaconSend);
                                }
                                else {
                                    _fallbackInst && _fallbackInst[_DYN_SEND_POST ](payload, oncomplete, true);
                                    _throwInternal(_diagLog, 2 , 40 , ". " + "Failed to send telemetry with Beacon API, retried with normal sender.");
                                }
                            }
                            else {
                                _onSuccess(STR_EMPTY, oncomplete);
                            }
                        }
                    }
                    catch (e) {
                        _isOneDs && _warnToConsole(_diagLog, "Failed to send telemetry using sendBeacon API. Ex:" + dumpObj(e));
                        _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, STR_EMPTY);
                    }
                    return;
                }
                function _xhrSender(payload, oncomplete, sync) {
                    var thePromise;
                    var resolveFunc;
                    var rejectFunc;
                    var headers = payload[_DYN_HEADERS ] || {};
                    if (!sync && _enableSendPromise) {
                        thePromise = createPromise(function (resolve, reject) {
                            resolveFunc = resolve;
                            rejectFunc = reject;
                        });
                    }
                    if (_isOneDs && sync && payload.disableXhrSync) {
                        sync = false;
                    }
                    var endPointUrl = payload[_DYN_URL_STRING ];
                    if (!endPointUrl) {
                        _onNoPayloadUrl(oncomplete);
                        resolveFunc && resolveFunc(false);
                        return;
                    }
                    var xhr = openXhr(STR_POST_METHOD, endPointUrl, _sendCredentials, true, sync, payload[_DYN_TIMEOUT ]);
                    if (!_isOneDs) {
                        xhr[_DYN_SET_REQUEST_HEADER ]("Content-type", "application/json");
                    }
                    arrForEach(objKeys(headers), function (headerName) {
                        xhr[_DYN_SET_REQUEST_HEADER ](headerName, headers[headerName]);
                    });
                    xhr.onreadystatechange = function () {
                        if (!_isOneDs) {
                            _doOnReadyFunc(xhr);
                            if (xhr.readyState === 4) {
                                resolveFunc && resolveFunc(true);
                            }
                        }
                    };
                    xhr.onload = function () {
                        if (_isOneDs) {
                            _doOnReadyFunc(xhr);
                        }
                    };
                    function _doOnReadyFunc(xhr) {
                        var onReadyFunc = _onCompleteFuncs && _onCompleteFuncs.xhrOnComplete;
                        var onReadyFuncExist = onReadyFunc && isFunction(onReadyFunc);
                        if (onReadyFuncExist) {
                            onReadyFunc(xhr, oncomplete, payload);
                        }
                        else {
                            var response = getResponseText(xhr);
                            _doOnComplete(oncomplete, xhr[_DYN_STATUS ], _getAllResponseHeaders(xhr, _isOneDs), response);
                        }
                    }
                    xhr.onerror = function (event) {
                        _doOnComplete(oncomplete, _isOneDs ? xhr[_DYN_STATUS ] : 400, _getAllResponseHeaders(xhr, _isOneDs), _isOneDs ? STR_EMPTY : formatErrorMessageXhr(xhr));
                        rejectFunc && rejectFunc(event);
                    };
                    xhr.ontimeout = function () {
                        _doOnComplete(oncomplete, _isOneDs ? xhr[_DYN_STATUS ] : 500, _getAllResponseHeaders(xhr, _isOneDs), _isOneDs ? STR_EMPTY : formatErrorMessageXhr(xhr));
                        resolveFunc && resolveFunc(false);
                    };
                    xhr.send(payload[_DYN_DATA$1 ]);
                    return thePromise;
                }
                function _doFetchSender(payload, oncomplete, sync) {
                    var _a;
                    var endPointUrl = payload[_DYN_URL_STRING ];
                    var batch = payload[_DYN_DATA$1 ];
                    var plainTextBatch = _isOneDs ? batch : new Blob([batch], { type: "application/json" });
                    var thePromise;
                    var resolveFunc;
                    var rejectFunc;
                    var requestHeaders = new Headers();
                    var batchLength = batch[_DYN_LENGTH$2 ];
                    var ignoreResponse = false;
                    var responseHandled = false;
                    var headers = payload[_DYN_HEADERS ] || {};
                    var init = (_a = {
                            method: STR_POST_METHOD,
                            body: plainTextBatch
                        },
                        _a[DisabledPropertyName] = true
                    ,
                        _a);
                    if (payload.headers && objKeys(payload.headers)[_DYN_LENGTH$2 ] > 0) {
                        arrForEach(objKeys(headers), function (headerName) {
                            requestHeaders.append(headerName, headers[headerName]);
                        });
                        init[_DYN_HEADERS ] = requestHeaders;
                    }
                    if (_sendCredentials && _isOneDs) {
                        init.credentials = "include";
                    }
                    if (sync) {
                        init.keepalive = true;
                        _syncFetchPayload += batchLength;
                        if (_isOneDs) {
                            if (payload["_sendReason"] === 2 ) {
                                ignoreResponse = true;
                                if (_addNoResponse) {
                                    endPointUrl += _noResponseQs;
                                }
                            }
                        }
                        else {
                            ignoreResponse = true;
                        }
                    }
                    var request = new Request(endPointUrl, init);
                    try {
                        request[DisabledPropertyName] = true;
                    }
                    catch (e) {
                    }
                    if (!sync && _enableSendPromise) {
                        thePromise = createPromise(function (resolve, reject) {
                            resolveFunc = resolve;
                            rejectFunc = reject;
                        });
                    }
                    if (!endPointUrl) {
                        _onNoPayloadUrl(oncomplete);
                        resolveFunc && resolveFunc(false);
                        return;
                    }
                    function _handleError(res) {
                        _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, _isOneDs ? STR_EMPTY : res);
                    }
                    function _onFetchComplete(response, payload, value) {
                        var status = response[_DYN_STATUS ];
                        var onCompleteFunc = _onCompleteFuncs.fetchOnComplete;
                        if (onCompleteFunc && isFunction(onCompleteFunc)) {
                            onCompleteFunc(response, oncomplete, value || STR_EMPTY, payload);
                        }
                        else {
                            _doOnComplete(oncomplete, status, {}, value || STR_EMPTY);
                        }
                    }
                    try {
                        doAwaitResponse(fetch(_isOneDs ? endPointUrl : request, _isOneDs ? init : null), function (result) {
                            if (sync) {
                                _syncFetchPayload -= batchLength;
                                batchLength = 0;
                            }
                            if (!responseHandled) {
                                responseHandled = true;
                                if (!result.rejected) {
                                    var response_1 = result.value;
                                    try {
                                        if (!_isOneDs && !response_1.ok) {
                                            _handleError(response_1.statusText);
                                            resolveFunc && resolveFunc(false);
                                        }
                                        else {
                                            if (_isOneDs && !response_1.body) {
                                                _onFetchComplete(response_1, null, STR_EMPTY);
                                                resolveFunc && resolveFunc(true);
                                            }
                                            else {
                                                doAwaitResponse(response_1.text(), function (resp) {
                                                    _onFetchComplete(response_1, payload, resp.value);
                                                    resolveFunc && resolveFunc(true);
                                                });
                                            }
                                        }
                                    }
                                    catch (e) {
                                        _handleError(dumpObj(e));
                                        rejectFunc && rejectFunc(e);
                                    }
                                }
                                else {
                                    _handleError(result.reason && result.reason[_DYN_MESSAGE$1 ]);
                                    rejectFunc && rejectFunc(result.reason);
                                }
                            }
                        });
                    }
                    catch (e) {
                        if (!responseHandled) {
                            _handleError(dumpObj(e));
                            rejectFunc && rejectFunc(e);
                        }
                    }
                    if (ignoreResponse && !responseHandled) {
                        responseHandled = true;
                        _doOnComplete(oncomplete, 200, {});
                        resolveFunc && resolveFunc(true);
                    }
                    if (_isOneDs && !responseHandled && payload[_DYN_TIMEOUT ] > 0) {
                        _timeoutWrapper && _timeoutWrapper.set(function () {
                            if (!responseHandled) {
                                responseHandled = true;
                                _doOnComplete(oncomplete, 500, {});
                                resolveFunc && resolveFunc(true);
                            }
                        }, payload[_DYN_TIMEOUT ]);
                    }
                    return thePromise;
                }
                function _xdrSender(payload, oncomplete, sync) {
                    var _window = getWindow();
                    var xdr = new XDomainRequest();
                    var data = payload[_DYN_DATA$1 ];
                    xdr.onload = function () {
                        var response = getResponseText(xdr);
                        var onloadFunc = _onCompleteFuncs && _onCompleteFuncs.xdrOnComplete;
                        if (onloadFunc && isFunction(onloadFunc)) {
                            onloadFunc(xdr, oncomplete, payload);
                        }
                        else {
                            _doOnComplete(oncomplete, 200, {}, response);
                        }
                    };
                    xdr.onerror = function () {
                        _doOnComplete(oncomplete, 400, {}, _isOneDs ? STR_EMPTY : formatErrorMessageXdr(xdr));
                    };
                    xdr.ontimeout = function () {
                        _doOnComplete(oncomplete, 500, {});
                    };
                    xdr.onprogress = function () { };
                    var hostingProtocol = _window && _window.location && _window.location[_DYN_PROTOCOL ] || "";
                    var endpoint = payload[_DYN_URL_STRING ];
                    if (!endpoint) {
                        _onNoPayloadUrl(oncomplete);
                        return;
                    }
                    if (!_isOneDs && endpoint.lastIndexOf(hostingProtocol, 0) !== 0) {
                        var msg = "Cannot send XDomain request. The endpoint URL protocol doesn't match the hosting page protocol.";
                        _throwInternal(_diagLog, 2 , 40 , ". " + msg);
                        _onError(msg, oncomplete);
                        return;
                    }
                    var endpointUrl = _isOneDs ? endpoint : endpoint[_DYN_REPLACE ](/^(https?:)/, "");
                    xdr.open(STR_POST_METHOD, endpointUrl);
                    if (payload[_DYN_TIMEOUT ]) {
                        xdr[_DYN_TIMEOUT ] = payload[_DYN_TIMEOUT ];
                    }
                    xdr.send(data);
                    if (_isOneDs && sync) {
                        _timeoutWrapper && _timeoutWrapper.set(function () {
                            xdr.send(data);
                        }, 0);
                    }
                    else {
                        xdr.send(data);
                    }
                }
                function _initDefaults() {
                    _syncFetchPayload = 0;
                    _isInitialized = false;
                    _enableSendPromise = false;
                    _diagLog = null;
                    _isOneDs = null;
                    _onCompleteFuncs = null;
                    _disableCredentials = null;
                    _fallbackInst = null;
                    _disableXhr = false;
                    _disableBeacon = false;
                    _disableBeaconSync = false;
                    _disableFetchKeepAlive = false;
                    _addNoResponse = false;
                    _timeoutWrapper = null;
                }
            });
        }
        SenderPostManager.__ieDyn=1;
        return SenderPostManager;
    }());

    var strOnPrefix = "on";
    var strAttachEvent = "attachEvent";
    var strAddEventHelper = "addEventListener";
    var strDetachEvent = "detachEvent";
    var strRemoveEventListener = "removeEventListener";
    var strEvents = "events";
    createUniqueNamespace("aiEvtPageHide");
    createUniqueNamespace("aiEvtPageShow");
    var rRemoveEmptyNs = /\.[\.]+/g;
    var rRemoveTrailingEmptyNs = /[\.]+$/;
    var _guid = 1;
    var elmNodeData = createElmNodeData("events");
    var eventNamespace = /^([^.]*)(?:\.(.+)|)/;
    function _normalizeNamespace(name) {
        if (name && name[_DYN_REPLACE ]) {
            return name[_DYN_REPLACE ](/^[\s\.]+|(?=[\s\.])[\.\s]+$/g, STR_EMPTY$1);
        }
        return name;
    }
    function _getEvtNamespace(eventName, evtNamespace) {
        var _a;
        if (evtNamespace) {
            var theNamespace_1 = STR_EMPTY$1;
            if (isArray(evtNamespace)) {
                theNamespace_1 = STR_EMPTY$1;
                arrForEach(evtNamespace, function (name) {
                    name = _normalizeNamespace(name);
                    if (name) {
                        if (name[0] !== ".") {
                            name = "." + name;
                        }
                        theNamespace_1 += name;
                    }
                });
            }
            else {
                theNamespace_1 = _normalizeNamespace(evtNamespace);
            }
            if (theNamespace_1) {
                if (theNamespace_1[0] !== ".") {
                    theNamespace_1 = "." + theNamespace_1;
                }
                eventName = (eventName || STR_EMPTY$1) + theNamespace_1;
            }
        }
        var parsedEvent = (eventNamespace.exec(eventName || STR_EMPTY$1) || []);
        return _a = {},
            _a[_DYN_TYPE ] = parsedEvent[1],
            _a.ns = ((parsedEvent[2] || STR_EMPTY$1).replace(rRemoveEmptyNs, ".").replace(rRemoveTrailingEmptyNs, STR_EMPTY$1)[_DYN_SPLIT$1 ](".").sort()).join("."),
            _a;
    }
    function _getRegisteredEvents(target, evtName, addDefault) {
        if (addDefault === void 0) { addDefault = true; }
        var aiEvts = elmNodeData.get(target, strEvents, {}, addDefault);
        var registeredEvents = aiEvts[evtName];
        if (!registeredEvents) {
            registeredEvents = aiEvts[evtName] = [];
        }
        return registeredEvents;
    }
    function _doDetach(obj, evtName, handlerRef, useCapture) {
        if (obj && evtName && evtName[_DYN_TYPE ]) {
            if (obj[strRemoveEventListener]) {
                obj[strRemoveEventListener](evtName[_DYN_TYPE ], handlerRef, useCapture);
            }
            else if (obj[strDetachEvent]) {
                obj[strDetachEvent](strOnPrefix + evtName[_DYN_TYPE ], handlerRef);
            }
        }
    }
    function _doAttach(obj, evtName, handlerRef, useCapture) {
        var result = false;
        if (obj && evtName && evtName[_DYN_TYPE ] && handlerRef) {
            if (obj[strAddEventHelper]) {
                obj[strAddEventHelper](evtName[_DYN_TYPE ], handlerRef, useCapture);
                result = true;
            }
            else if (obj[strAttachEvent]) {
                obj[strAttachEvent](strOnPrefix + evtName[_DYN_TYPE ], handlerRef);
                result = true;
            }
        }
        return result;
    }
    function _doUnregister(target, events, evtName, unRegFn) {
        var idx = events[_DYN_LENGTH$2 ];
        while (idx--) {
            var theEvent = events[idx];
            if (theEvent) {
                if (!evtName.ns || evtName.ns === theEvent.evtName.ns) {
                    if (!unRegFn || unRegFn(theEvent)) {
                        _doDetach(target, theEvent.evtName, theEvent[_DYN_HANDLER ], theEvent.capture);
                        events[_DYN_SPLICE ](idx, 1);
                    }
                }
            }
        }
    }
    function _unregisterEvents(target, evtName, unRegFn) {
        if (evtName[_DYN_TYPE ]) {
            _doUnregister(target, _getRegisteredEvents(target, evtName[_DYN_TYPE ]), evtName, unRegFn);
        }
        else {
            var eventCache = elmNodeData.get(target, strEvents, {});
            objForEachKey(eventCache, function (evtType, events) {
                _doUnregister(target, events, evtName, unRegFn);
            });
            if (objKeys(eventCache)[_DYN_LENGTH$2 ] === 0) {
                elmNodeData.kill(target, strEvents);
            }
        }
    }
    function mergeEvtNamespace(theNamespace, namespaces) {
        var newNamespaces;
        if (namespaces) {
            if (isArray(namespaces)) {
                newNamespaces = [theNamespace].concat(namespaces);
            }
            else {
                newNamespaces = [theNamespace, namespaces];
            }
            newNamespaces = (_getEvtNamespace("xx", newNamespaces).ns)[_DYN_SPLIT$1 ](".");
        }
        else {
            newNamespaces = theNamespace;
        }
        return newNamespaces;
    }
    function eventOn(target, eventName, handlerRef, evtNamespace, useCapture) {
        var _a;
        if (useCapture === void 0) { useCapture = false; }
        var result = false;
        if (target) {
            try {
                var evtName = _getEvtNamespace(eventName, evtNamespace);
                result = _doAttach(target, evtName, handlerRef, useCapture);
                if (result && elmNodeData.accept(target)) {
                    var registeredEvent = (_a = {
                            guid: _guid++,
                            evtName: evtName
                        },
                        _a[_DYN_HANDLER ] = handlerRef,
                        _a.capture = useCapture,
                        _a);
                    _getRegisteredEvents(target, evtName.type)[_DYN_PUSH$2 ](registeredEvent);
                }
            }
            catch (e) {
            }
        }
        return result;
    }
    function eventOff(target, eventName, handlerRef, evtNamespace, useCapture) {
        if (useCapture === void 0) { useCapture = false; }
        if (target) {
            try {
                var evtName_1 = _getEvtNamespace(eventName, evtNamespace);
                var found_1 = false;
                _unregisterEvents(target, evtName_1, function (regEvent) {
                    if ((evtName_1.ns && !handlerRef) || regEvent[_DYN_HANDLER ] === handlerRef) {
                        found_1 = true;
                        return true;
                    }
                    return false;
                });
                if (!found_1) {
                    _doDetach(target, evtName_1, handlerRef, useCapture);
                }
            }
            catch (e) {
            }
        }
    }

    var SampleRate = "sampleRate";
    var ProcessLegacy = "ProcessLegacy";
    var HttpMethod = "http.method";
    var DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com";
    var DEFAULT_BREEZE_PATH = "/v2/track";
    var strNotSpecified = "not_specified";

    var RequestHeaders = createValueMap({
        requestContextHeader: [0 , "Request-Context"],
        requestContextTargetKey: [1 , "appId"],
        requestContextAppIdFormat: [2 , "appId=cid-v1:"],
        requestIdHeader: [3 , "Request-Id"],
        traceParentHeader: [4 , "traceparent"],
        traceStateHeader: [5 , "tracestate"],
        sdkContextHeader: [6 , "Sdk-Context"],
        sdkContextHeaderAppIdRequest: [7 , "appId"],
        requestContextHeaderLowerCase: [8 , "request-context"]
    });

    var _DYN_SPLIT = "split";
    var _DYN_LENGTH$1 = "length";
    var _DYN_TO_LOWER_CASE = "toLowerCase";
    var _DYN_INGESTIONENDPOINT = "ingestionendpoint";
    var _DYN_TO_STRING$1 = "toString";
    var _DYN_PUSH$1 = "push";
    var _DYN_REMOVE_ITEM = "removeItem";
    var _DYN_NAME$1 = "name";
    var _DYN_MESSAGE = "message";
    var _DYN_COUNT$1 = "count";
    var _DYN_STRINGIFY$1 = "stringify";
    var _DYN_PATHNAME = "pathname";
    var _DYN_EXCEPTIONS = "exceptions";
    var _DYN_PARSED_STACK = "parsedStack";
    var _DYN_PROPERTIES = "properties";
    var _DYN_MEASUREMENTS$1 = "measurements";
    var _DYN_SIZE_IN_BYTES = "sizeInBytes";
    var _DYN_TYPE_NAME = "typeName";
    var _DYN_SEVERITY_LEVEL = "severityLevel";
    var _DYN_PROBLEM_GROUP = "problemGroup";
    var _DYN_IS_MANUAL = "isManual";
    var _DYN__CREATE_FROM_INTERFA1 = "CreateFromInterface";
    var _DYN_ASSEMBLY = "assembly";
    var _DYN_FILE_NAME = "fileName";
    var _DYN_HAS_FULL_STACK = "hasFullStack";
    var _DYN_LEVEL = "level";
    var _DYN_METHOD = "method";
    var _DYN_LINE = "line";
    var _DYN_DURATION = "duration";
    var _DYN_RECEIVED_RESPONSE = "receivedResponse";

    function dataSanitizeKeyAndAddUniqueness(logger, key, map) {
        var origLength = key[_DYN_LENGTH$1 ];
        var field = dataSanitizeKey(logger, key);
        if (field[_DYN_LENGTH$1 ] !== origLength) {
            var i = 0;
            var uniqueField = field;
            while (map[uniqueField] !== undefined) {
                i++;
                uniqueField = strSubstring(field, 0, 150  - 3) + dsPadNumber(i);
            }
            field = uniqueField;
        }
        return field;
    }
    function dataSanitizeKey(logger, name) {
        var nameTrunc;
        if (name) {
            name = strTrim(asString(name));
            if (name[_DYN_LENGTH$1 ] > 150 ) {
                nameTrunc = strSubstring(name, 0, 150 );
                _throwInternal(logger, 2 , 57 , "name is too long.  It has been truncated to " + 150  + " characters.", { name: name }, true);
            }
        }
        return nameTrunc || name;
    }
    function dataSanitizeString(logger, value, maxLength) {
        if (maxLength === void 0) { maxLength = 1024 ; }
        var valueTrunc;
        if (value) {
            maxLength = maxLength ? maxLength : 1024 ;
            value = strTrim(asString(value));
            if (value[_DYN_LENGTH$1 ] > maxLength) {
                valueTrunc = strSubstring(value, 0, maxLength);
                _throwInternal(logger, 2 , 61 , "string value is too long. It has been truncated to " + maxLength + " characters.", { value: value }, true);
            }
        }
        return valueTrunc || value;
    }
    function dataSanitizeUrl(logger, url) {
        return dataSanitizeInput(logger, url, 2048 , 66 );
    }
    function dataSanitizeMessage(logger, message) {
        var messageTrunc;
        if (message) {
            if (message[_DYN_LENGTH$1 ] > 32768 ) {
                messageTrunc = strSubstring(message, 0, 32768 );
                _throwInternal(logger, 2 , 56 , "message is too long, it has been truncated to " + 32768  + " characters.", { message: message }, true);
            }
        }
        return messageTrunc || message;
    }
    function dataSanitizeException(logger, exception) {
        var exceptionTrunc;
        if (exception) {
            var value = "" + exception;
            if (value[_DYN_LENGTH$1 ] > 32768 ) {
                exceptionTrunc = strSubstring(value, 0, 32768 );
                _throwInternal(logger, 2 , 52 , "exception is too long, it has been truncated to " + 32768  + " characters.", { exception: exception }, true);
            }
        }
        return exceptionTrunc || exception;
    }
    function dataSanitizeProperties(logger, properties) {
        if (properties) {
            var tempProps_1 = {};
            objForEachKey(properties, function (prop, value) {
                if (isObject(value) && hasJSON()) {
                    try {
                        value = getJSON()[_DYN_STRINGIFY$1 ](value);
                    }
                    catch (e) {
                        _throwInternal(logger, 2 , 49 , "custom property is not valid", { exception: e }, true);
                    }
                }
                value = dataSanitizeString(logger, value, 8192 );
                prop = dataSanitizeKeyAndAddUniqueness(logger, prop, tempProps_1);
                tempProps_1[prop] = value;
            });
            properties = tempProps_1;
        }
        return properties;
    }
    function dataSanitizeMeasurements(logger, measurements) {
        if (measurements) {
            var tempMeasurements_1 = {};
            objForEachKey(measurements, function (measure, value) {
                measure = dataSanitizeKeyAndAddUniqueness(logger, measure, tempMeasurements_1);
                tempMeasurements_1[measure] = value;
            });
            measurements = tempMeasurements_1;
        }
        return measurements;
    }
    function dataSanitizeId(logger, id) {
        return id ? dataSanitizeInput(logger, id, 128 , 69 )[_DYN_TO_STRING$1 ]() : id;
    }
    function dataSanitizeInput(logger, input, maxLength, _msgId) {
        var inputTrunc;
        if (input) {
            input = strTrim(asString(input));
            if (input[_DYN_LENGTH$1 ] > maxLength) {
                inputTrunc = strSubstring(input, 0, maxLength);
                _throwInternal(logger, 2 , _msgId, "input is too long, it has been truncated to " + maxLength + " characters.", { data: input }, true);
            }
        }
        return inputTrunc || input;
    }
    function dsPadNumber(num) {
        var s = "00" + num;
        return strSubstr(s, s[_DYN_LENGTH$1 ] - 3);
    }

    var _document = getDocument() || {};
    var _htmlAnchorIdx = 0;
    var _htmlAnchorElement = [null, null, null, null, null];
    function urlParseUrl(url) {
        var anchorIdx = _htmlAnchorIdx;
        var anchorCache = _htmlAnchorElement;
        var tempAnchor = anchorCache[anchorIdx];
        if (!_document.createElement) {
            tempAnchor = { host: urlParseHost(url, true) };
        }
        else if (!anchorCache[anchorIdx]) {
            tempAnchor = anchorCache[anchorIdx] = _document.createElement("a");
        }
        tempAnchor.href = url;
        anchorIdx++;
        if (anchorIdx >= anchorCache[_DYN_LENGTH$1 ]) {
            anchorIdx = 0;
        }
        _htmlAnchorIdx = anchorIdx;
        return tempAnchor;
    }
    function urlParseHost(url, inclPort) {
        var fullHost = urlParseFullHost(url, inclPort) || "";
        if (fullHost) {
            var match = fullHost.match(/(www\d{0,5}\.)?([^\/:]{1,256})(:\d{1,20})?/i);
            if (match != null && match[_DYN_LENGTH$1 ] > 3 && isString(match[2]) && match[2][_DYN_LENGTH$1 ] > 0) {
                return match[2] + (match[3] || "");
            }
        }
        return fullHost;
    }
    function urlParseFullHost(url, inclPort) {
        var result = null;
        if (url) {
            var match = url.match(/(\w{1,150}):\/\/([^\/:]{1,256})(:\d{1,20})?/i);
            if (match != null && match[_DYN_LENGTH$1 ] > 2 && isString(match[2]) && match[2][_DYN_LENGTH$1 ] > 0) {
                result = match[2] || "";
                if (inclPort && match[_DYN_LENGTH$1 ] > 2) {
                    var protocol = (match[1] || "")[_DYN_TO_LOWER_CASE ]();
                    var port = match[3] || "";
                    if (protocol === "http" && port === ":80") {
                        port = "";
                    }
                    else if (protocol === "https" && port === ":443") {
                        port = "";
                    }
                    result += port;
                }
            }
        }
        return result;
    }

    var _internalEndpoints = [
        DEFAULT_BREEZE_ENDPOINT + DEFAULT_BREEZE_PATH,
        "https://breeze.aimon.applicationinsights.io" + DEFAULT_BREEZE_PATH,
        "https://dc-int.services.visualstudio.com" + DEFAULT_BREEZE_PATH
    ];
    function isInternalApplicationInsightsEndpoint(endpointUrl) {
        return arrIndexOf(_internalEndpoints, endpointUrl[_DYN_TO_LOWER_CASE ]()) !== -1;
    }
    function AjaxHelperParseDependencyPath(logger, absoluteUrl, method, commandName) {
        var target, name = commandName, data = commandName;
        if (absoluteUrl && absoluteUrl[_DYN_LENGTH$1 ] > 0) {
            var parsedUrl = urlParseUrl(absoluteUrl);
            target = parsedUrl.host;
            if (!name) {
                if (parsedUrl[_DYN_PATHNAME ] != null) {
                    var pathName = (parsedUrl.pathname[_DYN_LENGTH$1 ] === 0) ? "/" : parsedUrl[_DYN_PATHNAME ];
                    if (pathName.charAt(0) !== "/") {
                        pathName = "/" + pathName;
                    }
                    data = parsedUrl[_DYN_PATHNAME ];
                    name = dataSanitizeString(logger, method ? method + " " + pathName : pathName);
                }
                else {
                    name = dataSanitizeString(logger, absoluteUrl);
                }
            }
        }
        else {
            target = commandName;
            name = commandName;
        }
        return {
            target: target,
            name: name,
            data: data
        };
    }

    var StorageType = createEnumStyle({
        LocalStorage: 0 ,
        SessionStorage: 1
    });

    var _canUseSessionStorage = undefined;
    var _storagePrefix = "";
    function _getVerifiedStorageObject(storageType) {
        try {
            if (isNullOrUndefined(getGlobal())) {
                return null;
            }
            var uid = (new Date)[_DYN_TO_STRING$1 ]();
            var storage = getInst(storageType === StorageType.LocalStorage ? "localStorage" : "sessionStorage");
            var name_1 = _storagePrefix + uid;
            storage.setItem(name_1, uid);
            var fail = storage.getItem(name_1) !== uid;
            storage[_DYN_REMOVE_ITEM ](name_1);
            if (!fail) {
                return storage;
            }
        }
        catch (exception) {
        }
        return null;
    }
    function _getSessionStorageObject() {
        if (utlCanUseSessionStorage()) {
            return _getVerifiedStorageObject(StorageType.SessionStorage);
        }
        return null;
    }
    function utlSetStoragePrefix(storagePrefix) {
        _storagePrefix = storagePrefix || "";
    }
    function utlCanUseSessionStorage(reset) {
        if (reset || _canUseSessionStorage === undefined) {
            _canUseSessionStorage = !!_getVerifiedStorageObject(StorageType.SessionStorage);
        }
        return _canUseSessionStorage;
    }
    function utlGetSessionStorage(logger, name) {
        var storage = _getSessionStorageObject();
        if (storage !== null) {
            try {
                return storage.getItem(name);
            }
            catch (e) {
                _canUseSessionStorage = false;
                _throwInternal(logger, 2 , 2 , "Browser failed read of session storage. " + getExceptionName(e), { exception: dumpObj(e) });
            }
        }
        return null;
    }
    function utlSetSessionStorage(logger, name, data) {
        var storage = _getSessionStorageObject();
        if (storage !== null) {
            try {
                storage.setItem(name, data);
                return true;
            }
            catch (e) {
                _canUseSessionStorage = false;
                _throwInternal(logger, 2 , 4 , "Browser failed write to session storage. " + getExceptionName(e), { exception: dumpObj(e) });
            }
        }
        return false;
    }
    function utlRemoveSessionStorage(logger, name) {
        var storage = _getSessionStorageObject();
        if (storage !== null) {
            try {
                storage[_DYN_REMOVE_ITEM ](name);
                return true;
            }
            catch (e) {
                _canUseSessionStorage = false;
                _throwInternal(logger, 2 , 6 , "Browser failed removal of session storage item. " + getExceptionName(e), { exception: dumpObj(e) });
            }
        }
        return false;
    }

    var _FIELDS_SEPARATOR = ";";
    var _FIELD_KEY_VALUE_SEPARATOR = "=";
    function parseConnectionString(connectionString) {
        if (!connectionString) {
            return {};
        }
        var kvPairs = connectionString[_DYN_SPLIT ](_FIELDS_SEPARATOR);
        var result = arrReduce(kvPairs, function (fields, kv) {
            var kvParts = kv[_DYN_SPLIT ](_FIELD_KEY_VALUE_SEPARATOR);
            if (kvParts[_DYN_LENGTH$1 ] === 2) {
                var key = kvParts[0][_DYN_TO_LOWER_CASE ]();
                var value = kvParts[1];
                fields[key] = value;
            }
            return fields;
        }, {});
        if (objKeys(result)[_DYN_LENGTH$1 ] > 0) {
            if (result.endpointsuffix) {
                var locationPrefix = result.location ? result.location + "." : "";
                result[_DYN_INGESTIONENDPOINT ] = result[_DYN_INGESTIONENDPOINT ] || ("https://" + locationPrefix + "dc." + result.endpointsuffix);
            }
            result[_DYN_INGESTIONENDPOINT ] = result[_DYN_INGESTIONENDPOINT ] || DEFAULT_BREEZE_ENDPOINT;
            if (strEndsWith(result[_DYN_INGESTIONENDPOINT ], "/")) {
                result[_DYN_INGESTIONENDPOINT ] = result[_DYN_INGESTIONENDPOINT ].slice(0, -1);
            }
        }
        return result;
    }

    var Envelope = /** @class */ (function () {
        function Envelope(logger, data, name) {
            var _this = this;
            var _self = this;
            _self.ver = 1;
            _self.sampleRate = 100.0;
            _self.tags = {};
            _self[_DYN_NAME$1 ] = dataSanitizeString(logger, name) || strNotSpecified;
            _self.data = data;
            _self.time = toISOString(new Date());
            _self.aiDataContract = {
                time: 1 ,
                iKey: 1 ,
                name: 1 ,
                sampleRate: function () {
                    return (_this.sampleRate === 100) ? 4  : 1 ;
                },
                tags: 1 ,
                data: 1
            };
        }
        return Envelope;
    }());

    var Event$1 = /** @class */ (function () {
        function Event(logger, name, properties, measurements) {
            this.aiDataContract = {
                ver: 1 ,
                name: 1 ,
                properties: 0 ,
                measurements: 0
            };
            var _self = this;
            _self.ver = 2;
            _self[_DYN_NAME$1 ] = dataSanitizeString(logger, name) || strNotSpecified;
            _self[_DYN_PROPERTIES ] = dataSanitizeProperties(logger, properties);
            _self[_DYN_MEASUREMENTS$1 ] = dataSanitizeMeasurements(logger, measurements);
        }
        Event.envelopeType = "Microsoft.ApplicationInsights.{0}.Event";
        Event.dataType = "EventData";
        return Event;
    }());

    var NoMethod = "<no_method>";
    var strError = "error";
    var strStack = "stack";
    var strStackDetails = "stackDetails";
    var strErrorSrc = "errorSrc";
    var strMessage = "message";
    var strDescription = "description";
    function _stringify(value, convertToString) {
        var result = value;
        if (result && !isString(result)) {
            if (JSON && JSON[_DYN_STRINGIFY$1 ]) {
                result = JSON[_DYN_STRINGIFY$1 ](value);
                if (convertToString && (!result || result === "{}")) {
                    if (isFunction(value[_DYN_TO_STRING$1 ])) {
                        result = value[_DYN_TO_STRING$1 ]();
                    }
                    else {
                        result = "" + value;
                    }
                }
            }
            else {
                result = "" + value + " - (Missing JSON.stringify)";
            }
        }
        return result || "";
    }
    function _formatMessage(theEvent, errorType) {
        var evtMessage = theEvent;
        if (theEvent) {
            if (evtMessage && !isString(evtMessage)) {
                evtMessage = theEvent[strMessage] || theEvent[strDescription] || evtMessage;
            }
            if (evtMessage && !isString(evtMessage)) {
                evtMessage = _stringify(evtMessage, true);
            }
            if (theEvent["filename"]) {
                evtMessage = evtMessage + " @" + (theEvent["filename"] || "") + ":" + (theEvent["lineno"] || "?") + ":" + (theEvent["colno"] || "?");
            }
        }
        if (errorType && errorType !== "String" && errorType !== "Object" && errorType !== "Error" && strIndexOf(evtMessage || "", errorType) === -1) {
            evtMessage = errorType + ": " + evtMessage;
        }
        return evtMessage || "";
    }
    function _isExceptionDetailsInternal(value) {
        try {
            if (isObject(value)) {
                return "hasFullStack" in value && "typeName" in value;
            }
        }
        catch (e) {
        }
        return false;
    }
    function _isExceptionInternal(value) {
        try {
            if (isObject(value)) {
                return ("ver" in value && "exceptions" in value && "properties" in value);
            }
        }
        catch (e) {
        }
        return false;
    }
    function _isStackDetails(details) {
        return details && details.src && isString(details.src) && details.obj && isArray(details.obj);
    }
    function _convertStackObj(errorStack) {
        var src = errorStack || "";
        if (!isString(src)) {
            if (isString(src[strStack])) {
                src = src[strStack];
            }
            else {
                src = "" + src;
            }
        }
        var items = src[_DYN_SPLIT ]("\n");
        return {
            src: src,
            obj: items
        };
    }
    function _getOperaStack(errorMessage) {
        var stack = [];
        var lines = errorMessage[_DYN_SPLIT ]("\n");
        for (var lp = 0; lp < lines[_DYN_LENGTH$1 ]; lp++) {
            var entry = lines[lp];
            if (lines[lp + 1]) {
                entry += "@" + lines[lp + 1];
                lp++;
            }
            stack[_DYN_PUSH$1 ](entry);
        }
        return {
            src: errorMessage,
            obj: stack
        };
    }
    function _getStackFromErrorObj(errorObj) {
        var details = null;
        if (errorObj) {
            try {
                if (errorObj[strStack]) {
                    details = _convertStackObj(errorObj[strStack]);
                }
                else if (errorObj[strError] && errorObj[strError][strStack]) {
                    details = _convertStackObj(errorObj[strError][strStack]);
                }
                else if (errorObj["exception"] && errorObj.exception[strStack]) {
                    details = _convertStackObj(errorObj.exception[strStack]);
                }
                else if (_isStackDetails(errorObj)) {
                    details = errorObj;
                }
                else if (_isStackDetails(errorObj[strStackDetails])) {
                    details = errorObj[strStackDetails];
                }
                else if (getWindow() && getWindow()["opera"] && errorObj[strMessage]) {
                    details = _getOperaStack(errorObj[_DYN_MESSAGE ]);
                }
                else if (errorObj["reason"] && errorObj.reason[strStack]) {
                    details = _convertStackObj(errorObj.reason[strStack]);
                }
                else if (isString(errorObj)) {
                    details = _convertStackObj(errorObj);
                }
                else {
                    var evtMessage = errorObj[strMessage] || errorObj[strDescription] || "";
                    if (isString(errorObj[strErrorSrc])) {
                        if (evtMessage) {
                            evtMessage += "\n";
                        }
                        evtMessage += " from " + errorObj[strErrorSrc];
                    }
                    if (evtMessage) {
                        details = _convertStackObj(evtMessage);
                    }
                }
            }
            catch (e) {
                details = _convertStackObj(e);
            }
        }
        return details || {
            src: "",
            obj: null
        };
    }
    function _formatStackTrace(stackDetails) {
        var stack = "";
        if (stackDetails) {
            if (stackDetails.obj) {
                arrForEach(stackDetails.obj, function (entry) {
                    stack += entry + "\n";
                });
            }
            else {
                stack = stackDetails.src || "";
            }
        }
        return stack;
    }
    function _parseStack(stack) {
        var parsedStack;
        var frames = stack.obj;
        if (frames && frames[_DYN_LENGTH$1 ] > 0) {
            parsedStack = [];
            var level_1 = 0;
            var totalSizeInBytes_1 = 0;
            arrForEach(frames, function (frame) {
                var theFrame = frame[_DYN_TO_STRING$1 ]();
                if (_StackFrame.regex.test(theFrame)) {
                    var parsedFrame = new _StackFrame(theFrame, level_1++);
                    totalSizeInBytes_1 += parsedFrame[_DYN_SIZE_IN_BYTES ];
                    parsedStack[_DYN_PUSH$1 ](parsedFrame);
                }
            });
            var exceptionParsedStackThreshold = 32 * 1024;
            if (totalSizeInBytes_1 > exceptionParsedStackThreshold) {
                var left = 0;
                var right = parsedStack[_DYN_LENGTH$1 ] - 1;
                var size = 0;
                var acceptedLeft = left;
                var acceptedRight = right;
                while (left < right) {
                    var lSize = parsedStack[left][_DYN_SIZE_IN_BYTES ];
                    var rSize = parsedStack[right][_DYN_SIZE_IN_BYTES ];
                    size += lSize + rSize;
                    if (size > exceptionParsedStackThreshold) {
                        var howMany = acceptedRight - acceptedLeft + 1;
                        parsedStack.splice(acceptedLeft, howMany);
                        break;
                    }
                    acceptedLeft = left;
                    acceptedRight = right;
                    left++;
                    right--;
                }
            }
        }
        return parsedStack;
    }
    function _getErrorType(errorType) {
        var typeName = "";
        if (errorType) {
            typeName = errorType.typeName || errorType[_DYN_NAME$1 ] || "";
            if (!typeName) {
                try {
                    var funcNameRegex = /function (.{1,200})\(/;
                    var results = (funcNameRegex).exec((errorType).constructor[_DYN_TO_STRING$1 ]());
                    typeName = (results && results[_DYN_LENGTH$1 ] > 1) ? results[1] : "";
                }
                catch (e) {
                }
            }
        }
        return typeName;
    }
    function _formatErrorCode(errorObj) {
        if (errorObj) {
            try {
                if (!isString(errorObj)) {
                    var errorType = _getErrorType(errorObj);
                    var result = _stringify(errorObj, false);
                    if (!result || result === "{}") {
                        if (errorObj[strError]) {
                            errorObj = errorObj[strError];
                            errorType = _getErrorType(errorObj);
                        }
                        result = _stringify(errorObj, true);
                    }
                    if (strIndexOf(result, errorType) !== 0 && errorType !== "String") {
                        return errorType + ":" + result;
                    }
                    return result;
                }
            }
            catch (e) {
            }
        }
        return "" + (errorObj || "");
    }
    var Exception = /** @class */ (function () {
        function Exception(logger, exception, properties, measurements, severityLevel, id) {
            this.aiDataContract = {
                ver: 1 ,
                exceptions: 1 ,
                severityLevel: 0 ,
                properties: 0 ,
                measurements: 0
            };
            var _self = this;
            _self.ver = 2;
            if (!_isExceptionInternal(exception)) {
                if (!properties) {
                    properties = {};
                }
                if (id) {
                    properties.id = id;
                }
                _self[_DYN_EXCEPTIONS ] = [new _ExceptionDetails(logger, exception, properties)];
                _self[_DYN_PROPERTIES ] = dataSanitizeProperties(logger, properties);
                _self[_DYN_MEASUREMENTS$1 ] = dataSanitizeMeasurements(logger, measurements);
                if (severityLevel) {
                    _self[_DYN_SEVERITY_LEVEL ] = severityLevel;
                }
                if (id) {
                    _self.id = id;
                }
            }
            else {
                _self[_DYN_EXCEPTIONS ] = exception[_DYN_EXCEPTIONS ] || [];
                _self[_DYN_PROPERTIES ] = exception[_DYN_PROPERTIES ];
                _self[_DYN_MEASUREMENTS$1 ] = exception[_DYN_MEASUREMENTS$1 ];
                if (exception[_DYN_SEVERITY_LEVEL ]) {
                    _self[_DYN_SEVERITY_LEVEL ] = exception[_DYN_SEVERITY_LEVEL ];
                }
                if (exception.id) {
                    _self.id = exception.id;
                    exception[_DYN_PROPERTIES ].id = exception.id;
                }
                if (exception[_DYN_PROBLEM_GROUP ]) {
                    _self[_DYN_PROBLEM_GROUP ] = exception[_DYN_PROBLEM_GROUP ];
                }
                if (!isNullOrUndefined(exception[_DYN_IS_MANUAL ])) {
                    _self[_DYN_IS_MANUAL ] = exception[_DYN_IS_MANUAL ];
                }
            }
        }
        Exception.CreateAutoException = function (message, url, lineNumber, columnNumber, error, evt, stack, errorSrc) {
            var _a;
            var errorType = _getErrorType(error || evt || message);
            return _a = {},
                _a[_DYN_MESSAGE ] = _formatMessage(message, errorType),
                _a.url = url,
                _a.lineNumber = lineNumber,
                _a.columnNumber = columnNumber,
                _a.error = _formatErrorCode(error || evt || message),
                _a.evt = _formatErrorCode(evt || message),
                _a[_DYN_TYPE_NAME ] = errorType,
                _a.stackDetails = _getStackFromErrorObj(stack || error || evt),
                _a.errorSrc = errorSrc,
                _a;
        };
        Exception.CreateFromInterface = function (logger, exception, properties, measurements) {
            var exceptions = exception[_DYN_EXCEPTIONS ]
                && arrMap(exception[_DYN_EXCEPTIONS ], function (ex) { return _ExceptionDetails[_DYN__CREATE_FROM_INTERFA1 ](logger, ex); });
            var exceptionData = new Exception(logger, __assignFn(__assignFn({}, exception), { exceptions: exceptions }), properties, measurements);
            return exceptionData;
        };
        Exception.prototype.toInterface = function () {
            var _a;
            var _b = this, exceptions = _b.exceptions, properties = _b.properties, measurements = _b.measurements, severityLevel = _b.severityLevel, problemGroup = _b.problemGroup, id = _b.id, isManual = _b.isManual;
            var exceptionDetailsInterface = exceptions instanceof Array
                && arrMap(exceptions, function (exception) { return exception.toInterface(); })
                || undefined;
            return _a = {
                    ver: "4.0"
                },
                _a[_DYN_EXCEPTIONS ] = exceptionDetailsInterface,
                _a.severityLevel = severityLevel,
                _a.properties = properties,
                _a.measurements = measurements,
                _a.problemGroup = problemGroup,
                _a.id = id,
                _a.isManual = isManual,
                _a;
        };
        Exception.CreateSimpleException = function (message, typeName, assembly, fileName, details, line) {
            var _a;
            return {
                exceptions: [
                    (_a = {},
                        _a[_DYN_HAS_FULL_STACK ] = true,
                        _a.message = message,
                        _a.stack = details,
                        _a.typeName = typeName,
                        _a)
                ]
            };
        };
        Exception.envelopeType = "Microsoft.ApplicationInsights.{0}.Exception";
        Exception.dataType = "ExceptionData";
        Exception.formatError = _formatErrorCode;
        return Exception;
    }());
    var _ExceptionDetails = /** @class */ (function () {
        function _ExceptionDetails(logger, exception, properties) {
            this.aiDataContract = {
                id: 0 ,
                outerId: 0 ,
                typeName: 1 ,
                message: 1 ,
                hasFullStack: 0 ,
                stack: 0 ,
                parsedStack: 2
            };
            var _self = this;
            if (!_isExceptionDetailsInternal(exception)) {
                var error = exception;
                var evt = error && error.evt;
                if (!isError(error)) {
                    error = error[strError] || evt || error;
                }
                _self[_DYN_TYPE_NAME ] = dataSanitizeString(logger, _getErrorType(error)) || strNotSpecified;
                _self[_DYN_MESSAGE ] = dataSanitizeMessage(logger, _formatMessage(exception || error, _self[_DYN_TYPE_NAME ])) || strNotSpecified;
                var stack = exception[strStackDetails] || _getStackFromErrorObj(exception);
                _self[_DYN_PARSED_STACK ] = _parseStack(stack);
                if (isArray(_self[_DYN_PARSED_STACK ])) {
                    arrMap(_self[_DYN_PARSED_STACK ], function (frame) {
                        frame[_DYN_ASSEMBLY ] = dataSanitizeString(logger, frame[_DYN_ASSEMBLY ]);
                        frame[_DYN_FILE_NAME ] = dataSanitizeString(logger, frame[_DYN_FILE_NAME ]);
                    });
                }
                _self[strStack] = dataSanitizeException(logger, _formatStackTrace(stack));
                _self.hasFullStack = isArray(_self.parsedStack) && _self.parsedStack[_DYN_LENGTH$1 ] > 0;
                if (properties) {
                    properties[_DYN_TYPE_NAME ] = properties[_DYN_TYPE_NAME ] || _self[_DYN_TYPE_NAME ];
                }
            }
            else {
                _self[_DYN_TYPE_NAME ] = exception[_DYN_TYPE_NAME ];
                _self[_DYN_MESSAGE ] = exception[_DYN_MESSAGE ];
                _self[strStack] = exception[strStack];
                _self[_DYN_PARSED_STACK ] = exception[_DYN_PARSED_STACK ] || [];
                _self[_DYN_HAS_FULL_STACK ] = exception[_DYN_HAS_FULL_STACK ];
            }
        }
        _ExceptionDetails.prototype.toInterface = function () {
            var _a;
            var _self = this;
            var parsedStack = _self[_DYN_PARSED_STACK ] instanceof Array
                && arrMap(_self[_DYN_PARSED_STACK ], function (frame) { return frame.toInterface(); });
            var exceptionDetailsInterface = (_a = {
                    id: _self.id,
                    outerId: _self.outerId,
                    typeName: _self[_DYN_TYPE_NAME ],
                    message: _self[_DYN_MESSAGE ],
                    hasFullStack: _self[_DYN_HAS_FULL_STACK ],
                    stack: _self[strStack]
                },
                _a[_DYN_PARSED_STACK ] = parsedStack || undefined,
                _a);
            return exceptionDetailsInterface;
        };
        _ExceptionDetails.CreateFromInterface = function (logger, exception) {
            var parsedStack = (exception[_DYN_PARSED_STACK ] instanceof Array
                && arrMap(exception[_DYN_PARSED_STACK ], function (frame) { return _StackFrame[_DYN__CREATE_FROM_INTERFA1 ](frame); }))
                || exception[_DYN_PARSED_STACK ];
            var exceptionDetails = new _ExceptionDetails(logger, __assignFn(__assignFn({}, exception), { parsedStack: parsedStack }));
            return exceptionDetails;
        };
        return _ExceptionDetails;
    }());
    var _StackFrame = /** @class */ (function () {
        function _StackFrame(sourceFrame, level) {
            this.aiDataContract = {
                level: 1 ,
                method: 1 ,
                assembly: 0 ,
                fileName: 0 ,
                line: 0
            };
            var _self = this;
            _self[_DYN_SIZE_IN_BYTES ] = 0;
            if (typeof sourceFrame === "string") {
                var frame = sourceFrame;
                _self[_DYN_LEVEL ] = level;
                _self[_DYN_METHOD ] = NoMethod;
                _self[_DYN_ASSEMBLY ] = strTrim(frame);
                _self[_DYN_FILE_NAME ] = "";
                _self[_DYN_LINE ] = 0;
                var matches = frame.match(_StackFrame.regex);
                if (matches && matches[_DYN_LENGTH$1 ] >= 5) {
                    _self[_DYN_METHOD ] = strTrim(matches[2]) || _self[_DYN_METHOD ];
                    _self[_DYN_FILE_NAME ] = strTrim(matches[4]);
                    _self[_DYN_LINE ] = parseInt(matches[5]) || 0;
                }
            }
            else {
                _self[_DYN_LEVEL ] = sourceFrame[_DYN_LEVEL ];
                _self[_DYN_METHOD ] = sourceFrame[_DYN_METHOD ];
                _self[_DYN_ASSEMBLY ] = sourceFrame[_DYN_ASSEMBLY ];
                _self[_DYN_FILE_NAME ] = sourceFrame[_DYN_FILE_NAME ];
                _self[_DYN_LINE ] = sourceFrame[_DYN_LINE ];
                _self[_DYN_SIZE_IN_BYTES ] = 0;
            }
            _self.sizeInBytes += _self.method[_DYN_LENGTH$1 ];
            _self.sizeInBytes += _self.fileName[_DYN_LENGTH$1 ];
            _self.sizeInBytes += _self.assembly[_DYN_LENGTH$1 ];
            _self[_DYN_SIZE_IN_BYTES ] += _StackFrame.baseSize;
            _self.sizeInBytes += _self.level.toString()[_DYN_LENGTH$1 ];
            _self.sizeInBytes += _self.line.toString()[_DYN_LENGTH$1 ];
        }
        _StackFrame.CreateFromInterface = function (frame) {
            return new _StackFrame(frame, null );
        };
        _StackFrame.prototype.toInterface = function () {
            var _self = this;
            return {
                level: _self[_DYN_LEVEL ],
                method: _self[_DYN_METHOD ],
                assembly: _self[_DYN_ASSEMBLY ],
                fileName: _self[_DYN_FILE_NAME ],
                line: _self[_DYN_LINE ]
            };
        };
        _StackFrame.regex = /^([\s]+at)?[\s]{0,50}([^\@\()]+?)[\s]{0,50}(\@|\()([^\(\n]+):([0-9]+):([0-9]+)(\)?)$/;
        _StackFrame.baseSize = 58;
        return _StackFrame;
    }());

    var DataPoint = /** @class */ (function () {
        function DataPoint() {
            this.aiDataContract = {
                name: 1 ,
                kind: 0 ,
                value: 1 ,
                count: 0 ,
                min: 0 ,
                max: 0 ,
                stdDev: 0
            };
            this.kind = 0 ;
        }
        return DataPoint;
    }());

    var Metric = /** @class */ (function () {
        function Metric(logger, name, value, count, min, max, stdDev, properties, measurements) {
            this.aiDataContract = {
                ver: 1 ,
                metrics: 1 ,
                properties: 0
            };
            var _self = this;
            _self.ver = 2;
            var dataPoint = new DataPoint();
            dataPoint[_DYN_COUNT$1 ] = count > 0 ? count : undefined;
            dataPoint.max = isNaN(max) || max === null ? undefined : max;
            dataPoint.min = isNaN(min) || min === null ? undefined : min;
            dataPoint[_DYN_NAME$1 ] = dataSanitizeString(logger, name) || strNotSpecified;
            dataPoint.value = value;
            dataPoint.stdDev = isNaN(stdDev) || stdDev === null ? undefined : stdDev;
            _self.metrics = [dataPoint];
            _self[_DYN_PROPERTIES ] = dataSanitizeProperties(logger, properties);
            _self[_DYN_MEASUREMENTS$1 ] = dataSanitizeMeasurements(logger, measurements);
        }
        Metric.envelopeType = "Microsoft.ApplicationInsights.{0}.Metric";
        Metric.dataType = "MetricData";
        return Metric;
    }());

    var strEmpty = "";
    function msToTimeSpan(totalms) {
        if (isNaN(totalms) || totalms < 0) {
            totalms = 0;
        }
        totalms = Math.round(totalms);
        var ms = strEmpty + totalms % 1000;
        var sec = strEmpty + Math.floor(totalms / 1000) % 60;
        var min = strEmpty + Math.floor(totalms / (1000 * 60)) % 60;
        var hour = strEmpty + Math.floor(totalms / (1000 * 60 * 60)) % 24;
        var days = Math.floor(totalms / (1000 * 60 * 60 * 24));
        ms = ms[_DYN_LENGTH$1 ] === 1 ? "00" + ms : ms[_DYN_LENGTH$1 ] === 2 ? "0" + ms : ms;
        sec = sec[_DYN_LENGTH$1 ] < 2 ? "0" + sec : sec;
        min = min[_DYN_LENGTH$1 ] < 2 ? "0" + min : min;
        hour = hour[_DYN_LENGTH$1 ] < 2 ? "0" + hour : hour;
        return (days > 0 ? days + "." : strEmpty) + hour + ":" + min + ":" + sec + "." + ms;
    }

    var PageView = /** @class */ (function () {
        function PageView(logger, name, url, durationMs, properties, measurements, id) {
            this.aiDataContract = {
                ver: 1 ,
                name: 0 ,
                url: 0 ,
                duration: 0 ,
                properties: 0 ,
                measurements: 0 ,
                id: 0
            };
            var _self = this;
            _self.ver = 2;
            _self.id = dataSanitizeId(logger, id);
            _self.url = dataSanitizeUrl(logger, url);
            _self[_DYN_NAME$1 ] = dataSanitizeString(logger, name) || strNotSpecified;
            if (!isNaN(durationMs)) {
                _self[_DYN_DURATION ] = msToTimeSpan(durationMs);
            }
            _self[_DYN_PROPERTIES ] = dataSanitizeProperties(logger, properties);
            _self[_DYN_MEASUREMENTS$1 ] = dataSanitizeMeasurements(logger, measurements);
        }
        PageView.envelopeType = "Microsoft.ApplicationInsights.{0}.Pageview";
        PageView.dataType = "PageviewData";
        return PageView;
    }());

    var RemoteDependencyData = /** @class */ (function () {
        function RemoteDependencyData(logger, id, absoluteUrl, commandName, value, success, resultCode, method, requestAPI, correlationContext, properties, measurements) {
            if (requestAPI === void 0) { requestAPI = "Ajax"; }
            this.aiDataContract = {
                id: 1 ,
                ver: 1 ,
                name: 0 ,
                resultCode: 0 ,
                duration: 0 ,
                success: 0 ,
                data: 0 ,
                target: 0 ,
                type: 0 ,
                properties: 0 ,
                measurements: 0 ,
                kind: 0 ,
                value: 0 ,
                count: 0 ,
                min: 0 ,
                max: 0 ,
                stdDev: 0 ,
                dependencyKind: 0 ,
                dependencySource: 0 ,
                commandName: 0 ,
                dependencyTypeName: 0
            };
            var _self = this;
            _self.ver = 2;
            _self.id = id;
            _self[_DYN_DURATION ] = msToTimeSpan(value);
            _self.success = success;
            _self.resultCode = resultCode + "";
            _self.type = dataSanitizeString(logger, requestAPI);
            var dependencyFields = AjaxHelperParseDependencyPath(logger, absoluteUrl, method, commandName);
            _self.data = dataSanitizeUrl(logger, commandName) || dependencyFields.data;
            _self.target = dataSanitizeString(logger, dependencyFields.target);
            if (correlationContext) {
                _self.target = "".concat(_self.target, " | ").concat(correlationContext);
            }
            _self[_DYN_NAME$1 ] = dataSanitizeString(logger, dependencyFields[_DYN_NAME$1 ]);
            _self[_DYN_PROPERTIES ] = dataSanitizeProperties(logger, properties);
            _self[_DYN_MEASUREMENTS$1 ] = dataSanitizeMeasurements(logger, measurements);
        }
        RemoteDependencyData.envelopeType = "Microsoft.ApplicationInsights.{0}.RemoteDependency";
        RemoteDependencyData.dataType = "RemoteDependencyData";
        return RemoteDependencyData;
    }());

    var Trace = /** @class */ (function () {
        function Trace(logger, message, severityLevel, properties, measurements) {
            this.aiDataContract = {
                ver: 1 ,
                message: 1 ,
                severityLevel: 0 ,
                properties: 0
            };
            var _self = this;
            _self.ver = 2;
            message = message || strNotSpecified;
            _self[_DYN_MESSAGE ] = dataSanitizeMessage(logger, message);
            _self[_DYN_PROPERTIES ] = dataSanitizeProperties(logger, properties);
            _self[_DYN_MEASUREMENTS$1 ] = dataSanitizeMeasurements(logger, measurements);
            if (severityLevel) {
                _self[_DYN_SEVERITY_LEVEL ] = severityLevel;
            }
        }
        Trace.envelopeType = "Microsoft.ApplicationInsights.{0}.Message";
        Trace.dataType = "MessageData";
        return Trace;
    }());

    var PageViewPerformance = /** @class */ (function () {
        function PageViewPerformance(logger, name, url, unused, properties, measurements, cs4BaseData) {
            this.aiDataContract = {
                ver: 1 ,
                name: 0 ,
                url: 0 ,
                duration: 0 ,
                perfTotal: 0 ,
                networkConnect: 0 ,
                sentRequest: 0 ,
                receivedResponse: 0 ,
                domProcessing: 0 ,
                properties: 0 ,
                measurements: 0
            };
            var _self = this;
            _self.ver = 2;
            _self.url = dataSanitizeUrl(logger, url);
            _self[_DYN_NAME$1 ] = dataSanitizeString(logger, name) || strNotSpecified;
            _self[_DYN_PROPERTIES ] = dataSanitizeProperties(logger, properties);
            _self[_DYN_MEASUREMENTS$1 ] = dataSanitizeMeasurements(logger, measurements);
            if (cs4BaseData) {
                _self.domProcessing = cs4BaseData.domProcessing;
                _self[_DYN_DURATION ] = cs4BaseData[_DYN_DURATION ];
                _self.networkConnect = cs4BaseData.networkConnect;
                _self.perfTotal = cs4BaseData.perfTotal;
                _self[_DYN_RECEIVED_RESPONSE ] = cs4BaseData[_DYN_RECEIVED_RESPONSE ];
                _self.sentRequest = cs4BaseData.sentRequest;
            }
        }
        PageViewPerformance.envelopeType = "Microsoft.ApplicationInsights.{0}.PageviewPerformance";
        PageViewPerformance.dataType = "PageviewPerformanceData";
        return PageViewPerformance;
    }());

    var Data = /** @class */ (function () {
        function Data(baseType, data) {
            this.aiDataContract = {
                baseType: 1 ,
                baseData: 1
            };
            this.baseType = baseType;
            this.baseData = data;
        }
        return Data;
    }());

    var SeverityLevel = createEnumStyle({
        Verbose: 0 ,
        Information: 1 ,
        Warning: 2 ,
        Error: 3 ,
        Critical: 4
    });

    function _aiNameFunc(baseName) {
        var aiName = "ai." + baseName + ".";
        return function (name) {
            return aiName + name;
        };
    }
    var _aiApplication = _aiNameFunc("application");
    var _aiDevice = _aiNameFunc("device");
    var _aiLocation = _aiNameFunc("location");
    var _aiOperation = _aiNameFunc("operation");
    var _aiSession = _aiNameFunc("session");
    var _aiUser = _aiNameFunc("user");
    var _aiCloud = _aiNameFunc("cloud");
    var _aiInternal = _aiNameFunc("internal");
    var ContextTagKeys = /** @class */ (function (_super) {
        __extendsFn(ContextTagKeys, _super);
        function ContextTagKeys() {
            return _super.call(this) || this;
        }
        return ContextTagKeys;
    }(createClassFromInterface({
        applicationVersion: _aiApplication("ver"),
        applicationBuild: _aiApplication("build"),
        applicationTypeId: _aiApplication("typeId"),
        applicationId: _aiApplication("applicationId"),
        applicationLayer: _aiApplication("layer"),
        deviceId: _aiDevice("id"),
        deviceIp: _aiDevice("ip"),
        deviceLanguage: _aiDevice("language"),
        deviceLocale: _aiDevice("locale"),
        deviceModel: _aiDevice("model"),
        deviceFriendlyName: _aiDevice("friendlyName"),
        deviceNetwork: _aiDevice("network"),
        deviceNetworkName: _aiDevice("networkName"),
        deviceOEMName: _aiDevice("oemName"),
        deviceOS: _aiDevice("os"),
        deviceOSVersion: _aiDevice("osVersion"),
        deviceRoleInstance: _aiDevice("roleInstance"),
        deviceRoleName: _aiDevice("roleName"),
        deviceScreenResolution: _aiDevice("screenResolution"),
        deviceType: _aiDevice("type"),
        deviceMachineName: _aiDevice("machineName"),
        deviceVMName: _aiDevice("vmName"),
        deviceBrowser: _aiDevice("browser"),
        deviceBrowserVersion: _aiDevice("browserVersion"),
        locationIp: _aiLocation("ip"),
        locationCountry: _aiLocation("country"),
        locationProvince: _aiLocation("province"),
        locationCity: _aiLocation("city"),
        operationId: _aiOperation("id"),
        operationName: _aiOperation("name"),
        operationParentId: _aiOperation("parentId"),
        operationRootId: _aiOperation("rootId"),
        operationSyntheticSource: _aiOperation("syntheticSource"),
        operationCorrelationVector: _aiOperation("correlationVector"),
        sessionId: _aiSession("id"),
        sessionIsFirst: _aiSession("isFirst"),
        sessionIsNew: _aiSession("isNew"),
        userAccountAcquisitionDate: _aiUser("accountAcquisitionDate"),
        userAccountId: _aiUser("accountId"),
        userAgent: _aiUser("userAgent"),
        userId: _aiUser("id"),
        userStoreRegion: _aiUser("storeRegion"),
        userAuthUserId: _aiUser("authUserId"),
        userAnonymousUserAcquisitionDate: _aiUser("anonUserAcquisitionDate"),
        userAuthenticatedUserAcquisitionDate: _aiUser("authUserAcquisitionDate"),
        cloudName: _aiCloud("name"),
        cloudRole: _aiCloud("role"),
        cloudRoleVer: _aiCloud("roleVer"),
        cloudRoleInstance: _aiCloud("roleInstance"),
        cloudEnvironment: _aiCloud("environment"),
        cloudLocation: _aiCloud("location"),
        cloudDeploymentUnit: _aiCloud("deploymentUnit"),
        internalNodeName: _aiInternal("nodeName"),
        internalSdkVersion: _aiInternal("sdkVersion"),
        internalAgentVersion: _aiInternal("agentVersion"),
        internalSnippet: _aiInternal("snippet"),
        internalSdkSrc: _aiInternal("sdkSrc")
    })));

    var CtxTagKeys = new ContextTagKeys();

    function _disableEvents(target, evtNamespace) {
        eventOff(target, null, null, evtNamespace);
    }
    function createOfflineListener(parentEvtNamespace) {
        var _document = getDocument();
        var _navigator = getNavigator();
        var _isListening = false;
        var listenerList = [];
        var rState = 1 ;
        if (_navigator && !isNullOrUndefined(_navigator.onLine) && !_navigator.onLine) {
            rState = 2 ;
        }
        var uState = 0 ;
        var _currentState = calCurrentState();
        var _evtNamespace = mergeEvtNamespace(createUniqueNamespace("OfflineListener"), parentEvtNamespace);
        try {
            if (_enableEvents(getWindow())) {
                _isListening = true;
            }
            if (_document) {
                var target = _document.body || _document;
                if (target.ononline) {
                    if (_enableEvents(target)) {
                        _isListening = true;
                    }
                }
            }
        }
        catch (e) {
            _isListening = false;
        }
        function _enableEvents(target) {
            var enabled = false;
            if (target) {
                enabled = eventOn(target, "online", _setOnline, _evtNamespace);
                if (enabled) {
                    eventOn(target, "offline", _setOffline, _evtNamespace);
                }
            }
            return enabled;
        }
        function _isOnline() {
            return _currentState;
        }
        function calCurrentState() {
            if (uState === 2  || rState === 2 ) {
                return false;
            }
            return true;
        }
        function listnerNoticeCheck() {
            var newState = calCurrentState();
            if (_currentState !== newState) {
                _currentState = newState;
                arrForEach(listenerList, function (callback) {
                    var offlineState = {
                        isOnline: _currentState,
                        rState: rState,
                        uState: uState
                    };
                    try {
                        callback(offlineState);
                    }
                    catch (e) {
                    }
                });
            }
        }
        function setOnlineState(newState) {
            uState = newState;
            listnerNoticeCheck();
        }
        function _setOnline() {
            rState = 1 ;
            listnerNoticeCheck();
        }
        function _setOffline() {
            rState = 2 ;
            listnerNoticeCheck();
        }
        function _unload() {
            var win = getWindow();
            if (win && _isListening) {
                _disableEvents(win, _evtNamespace);
                if (_document) {
                    var target = _document.body || _document;
                    if (!isUndefined(target.ononline)) {
                        _disableEvents(target, _evtNamespace);
                    }
                }
                _isListening = false;
            }
        }
        function addListener(callback) {
            listenerList[_DYN_PUSH$1 ](callback);
            return {
                rm: function () {
                    var index = listenerList.indexOf(callback);
                    if (index > -1) {
                        return listenerList.splice(index, 1);
                    }
                    else {
                        return;
                    }
                }
            };
        }
        return {
            isOnline: _isOnline,
            isListening: function () { return _isListening; },
            unload: _unload,
            addListener: addListener,
            setOnlineState: setOnlineState
        };
    }

    var BreezeChannelIdentifier = "AppInsightsChannelPlugin";

    var STR_DURATION = "duration";

    var _DYN_TAGS = "tags";
    var _DYN_DEVICE_TYPE = "deviceType";
    var _DYN_DATA = "data";
    var _DYN_NAME = "name";
    var _DYN_TRACE_ID = "traceID";
    var _DYN_LENGTH = "length";
    var _DYN_STRINGIFY = "stringify";
    var _DYN_MEASUREMENTS = "measurements";
    var _DYN_DATA_TYPE = "dataType";
    var _DYN_ENVELOPE_TYPE = "envelopeType";
    var _DYN_TO_STRING = "toString";
    var _DYN__GET = "_get";
    var _DYN_ENQUEUE = "enqueue";
    var _DYN_COUNT = "count";
    var _DYN_EVENTS_LIMIT_IN_MEM = "eventsLimitInMem";
    var _DYN_PUSH = "push";
    var _DYN_ITEM = "item";
    var _DYN_EMIT_LINE_DELIMITED_0 = "emitLineDelimitedJson";
    var _DYN_CLEAR = "clear";
    var _DYN_CREATE_NEW = "createNew";
    var _DYN_MARK_AS_SENT = "markAsSent";
    var _DYN_CLEAR_SENT = "clearSent";
    var _DYN_BUFFER_OVERRIDE = "bufferOverride";
    var _DYN__BUFFER__KEY = "BUFFER_KEY";
    var _DYN__SENT__BUFFER__KEY = "SENT_BUFFER_KEY";
    var _DYN_CONCAT = "concat";
    var _DYN__MAX__BUFFER__SIZE = "MAX_BUFFER_SIZE";
    var _DYN_TRIGGER_SEND = "triggerSend";
    var _DYN_DIAG_LOG = "diagLog";
    var _DYN_INITIALIZE = "initialize";
    var _DYN__SENDER = "_sender";
    var _DYN_CUSTOM_HEADERS = "customHeaders";
    var _DYN_MAX_BATCH_SIZE_IN_BY1 = "maxBatchSizeInBytes";
    var _DYN_ONUNLOAD_DISABLE_BEA2 = "onunloadDisableBeacon";
    var _DYN_IS_BEACON_API_DISABL3 = "isBeaconApiDisabled";
    var _DYN_ALWAYS_USE_XHR_OVERR4 = "alwaysUseXhrOverride";
    var _DYN_DISABLE_XHR = "disableXhr";
    var _DYN_ENABLE_SESSION_STORA5 = "enableSessionStorageBuffer";
    var _DYN__BUFFER = "_buffer";
    var _DYN_ONUNLOAD_DISABLE_FET6 = "onunloadDisableFetch";
    var _DYN_DISABLE_SEND_BEACON_7 = "disableSendBeaconSplit";
    var _DYN_INSTRUMENTATION_KEY$1 = "instrumentationKey";
    var _DYN_ENABLE_SEND_PROMISE = "enableSendPromise";
    var _DYN_GET_SENDER_INST = "getSenderInst";
    var _DYN_UNLOAD_TRANSPORTS = "unloadTransports";
    var _DYN_CONVERT_UNDEFINED = "convertUndefined";
    var _DYN_MAX_BATCH_INTERVAL = "maxBatchInterval";
    var _DYN_SERIALIZE = "serialize";
    var _DYN__ON_ERROR = "_onError";
    var _DYN__ON_PARTIAL_SUCCESS = "_onPartialSuccess";
    var _DYN__ON_SUCCESS = "_onSuccess";
    var _DYN_ITEMS_RECEIVED = "itemsReceived";
    var _DYN_ITEMS_ACCEPTED = "itemsAccepted";
    var _DYN_ORI_PAYLOAD = "oriPayload";
    var _DYN_BASE_TYPE = "baseType";
    var _DYN_SAMPLE_RATE = "sampleRate";
    var _DYN_EVENTS_SEND_REQUEST = "eventsSendRequest";
    var _DYN_GET_SAMPLING_SCORE = "getSamplingScore";
    var _DYN_GET_HASH_CODE_SCORE = "getHashCodeScore";

    var strBaseType = "baseType";
    var strBaseData = "baseData";
    var strProperties = "properties";
    var strTrue = "true";
    function _setValueIf(target, field, value) {
        return setValue(target, field, value, isTruthy);
    }
    function _extractPartAExtensions(logger, item, env) {
        var envTags = env[_DYN_TAGS ] = env[_DYN_TAGS ] || {};
        var itmExt = item.ext = item.ext || {};
        var itmTags = item[_DYN_TAGS ] = item[_DYN_TAGS ] || [];
        var extUser = itmExt.user;
        if (extUser) {
            _setValueIf(envTags, CtxTagKeys.userAuthUserId, extUser.authId);
            _setValueIf(envTags, CtxTagKeys.userId, extUser.id || extUser.localId);
        }
        var extApp = itmExt.app;
        if (extApp) {
            _setValueIf(envTags, CtxTagKeys.sessionId, extApp.sesId);
        }
        var extDevice = itmExt.device;
        if (extDevice) {
            _setValueIf(envTags, CtxTagKeys.deviceId, extDevice.id || extDevice.localId);
            _setValueIf(envTags, CtxTagKeys[_DYN_DEVICE_TYPE ], extDevice.deviceClass);
            _setValueIf(envTags, CtxTagKeys.deviceIp, extDevice.ip);
            _setValueIf(envTags, CtxTagKeys.deviceModel, extDevice.model);
            _setValueIf(envTags, CtxTagKeys[_DYN_DEVICE_TYPE ], extDevice[_DYN_DEVICE_TYPE ]);
        }
        var web = item.ext.web;
        if (web) {
            _setValueIf(envTags, CtxTagKeys.deviceLanguage, web.browserLang);
            _setValueIf(envTags, CtxTagKeys.deviceBrowserVersion, web.browserVer);
            _setValueIf(envTags, CtxTagKeys.deviceBrowser, web.browser);
            var envData = env[_DYN_DATA ] = env[_DYN_DATA ] || {};
            var envBaseData = envData[strBaseData] = envData[strBaseData] || {};
            var envProps = envBaseData[strProperties] = envBaseData[strProperties] || {};
            _setValueIf(envProps, "domain", web.domain);
            _setValueIf(envProps, "isManual", web.isManual ? strTrue : null);
            _setValueIf(envProps, "screenRes", web.screenRes);
            _setValueIf(envProps, "userConsent", web.userConsent ? strTrue : null);
        }
        var extOs = itmExt.os;
        if (extOs) {
            _setValueIf(envTags, CtxTagKeys.deviceOS, extOs[_DYN_NAME ]);
            _setValueIf(envTags, CtxTagKeys.deviceOSVersion, extOs.osVer);
        }
        var extTrace = itmExt.trace;
        if (extTrace) {
            _setValueIf(envTags, CtxTagKeys.operationParentId, extTrace.parentID);
            _setValueIf(envTags, CtxTagKeys.operationName, dataSanitizeString(logger, extTrace[_DYN_NAME ]));
            _setValueIf(envTags, CtxTagKeys.operationId, extTrace[_DYN_TRACE_ID ]);
        }
        var tgs = {};
        for (var i = itmTags[_DYN_LENGTH ] - 1; i >= 0; i--) {
            var tg = itmTags[i];
            objForEachKey(tg, function (key, value) {
                tgs[key] = value;
            });
            itmTags.splice(i, 1);
        }
        objForEachKey(itmTags, function (tg, value) {
            tgs[tg] = value;
        });
        var theTags = __assignFn(__assignFn({}, envTags), tgs);
        if (!theTags[CtxTagKeys.internalSdkVersion]) {
            theTags[CtxTagKeys.internalSdkVersion] = dataSanitizeString(logger, "javascript:".concat(EnvelopeCreator.Version), 64);
        }
        env[_DYN_TAGS ] = optimizeObject(theTags);
    }
    function _extractPropsAndMeasurements(data, properties, measurements) {
        if (!isNullOrUndefined(data)) {
            objForEachKey(data, function (key, value) {
                if (isNumber(value)) {
                    measurements[key] = value;
                }
                else if (isString(value)) {
                    properties[key] = value;
                }
                else if (hasJSON()) {
                    properties[key] = getJSON()[_DYN_STRINGIFY ](value);
                }
            });
        }
    }
    function _convertPropsUndefinedToCustomDefinedValue(properties, customUndefinedValue) {
        if (!isNullOrUndefined(properties)) {
            objForEachKey(properties, function (key, value) {
                properties[key] = value || customUndefinedValue;
            });
        }
    }
    function _createEnvelope(logger, envelopeType, telemetryItem, data) {
        var envelope = new Envelope(logger, data, envelopeType);
        _setValueIf(envelope, "sampleRate", telemetryItem[SampleRate]);
        if ((telemetryItem[strBaseData] || {}).startTime) {
            envelope.time = toISOString(telemetryItem[strBaseData].startTime);
        }
        envelope.iKey = telemetryItem.iKey;
        var iKeyNoDashes = telemetryItem.iKey.replace(/-/g, "");
        envelope[_DYN_NAME ] = envelope[_DYN_NAME ].replace("{0}", iKeyNoDashes);
        _extractPartAExtensions(logger, telemetryItem, envelope);
        telemetryItem[_DYN_TAGS ] = telemetryItem[_DYN_TAGS ] || [];
        return optimizeObject(envelope);
    }
    function EnvelopeCreatorInit(logger, telemetryItem) {
        if (isNullOrUndefined(telemetryItem[strBaseData])) {
            _throwInternal(logger, 1 , 46 , "telemetryItem.baseData cannot be null.");
        }
    }
    var EnvelopeCreator = {
        Version: '3.2.2'
    };
    function DependencyEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
        EnvelopeCreatorInit(logger, telemetryItem);
        var customMeasurements = telemetryItem[strBaseData][_DYN_MEASUREMENTS ] || {};
        var customProperties = telemetryItem[strBaseData][strProperties] || {};
        _extractPropsAndMeasurements(telemetryItem[_DYN_DATA ], customProperties, customMeasurements);
        if (!isNullOrUndefined(customUndefinedValue)) {
            _convertPropsUndefinedToCustomDefinedValue(customProperties, customUndefinedValue);
        }
        var bd = telemetryItem[strBaseData];
        if (isNullOrUndefined(bd)) {
            _warnToConsole(logger, "Invalid input for dependency data");
            return null;
        }
        var method = bd[strProperties] && bd[strProperties][HttpMethod] ? bd[strProperties][HttpMethod] : "GET";
        var remoteDepData = new RemoteDependencyData(logger, bd.id, bd.target, bd[_DYN_NAME ], bd[STR_DURATION ], bd.success, bd.responseCode, method, bd.type, bd.correlationContext, customProperties, customMeasurements);
        var data = new Data(RemoteDependencyData[_DYN_DATA_TYPE ], remoteDepData);
        return _createEnvelope(logger, RemoteDependencyData[_DYN_ENVELOPE_TYPE ], telemetryItem, data);
    }
    function EventEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
        EnvelopeCreatorInit(logger, telemetryItem);
        var customProperties = {};
        var customMeasurements = {};
        if (telemetryItem[strBaseType] !== Event$1[_DYN_DATA_TYPE ]) {
            customProperties["baseTypeSource"] = telemetryItem[strBaseType];
        }
        if (telemetryItem[strBaseType] === Event$1[_DYN_DATA_TYPE ]) {
            customProperties = telemetryItem[strBaseData][strProperties] || {};
            customMeasurements = telemetryItem[strBaseData][_DYN_MEASUREMENTS ] || {};
        }
        else {
            if (telemetryItem[strBaseData]) {
                _extractPropsAndMeasurements(telemetryItem[strBaseData], customProperties, customMeasurements);
            }
        }
        _extractPropsAndMeasurements(telemetryItem[_DYN_DATA ], customProperties, customMeasurements);
        if (!isNullOrUndefined(customUndefinedValue)) {
            _convertPropsUndefinedToCustomDefinedValue(customProperties, customUndefinedValue);
        }
        var eventName = telemetryItem[strBaseData][_DYN_NAME ];
        var eventData = new Event$1(logger, eventName, customProperties, customMeasurements);
        var data = new Data(Event$1[_DYN_DATA_TYPE ], eventData);
        return _createEnvelope(logger, Event$1[_DYN_ENVELOPE_TYPE ], telemetryItem, data);
    }
    function ExceptionEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
        EnvelopeCreatorInit(logger, telemetryItem);
        var customMeasurements = telemetryItem[strBaseData][_DYN_MEASUREMENTS ] || {};
        var customProperties = telemetryItem[strBaseData][strProperties] || {};
        _extractPropsAndMeasurements(telemetryItem[_DYN_DATA ], customProperties, customMeasurements);
        if (!isNullOrUndefined(customUndefinedValue)) {
            _convertPropsUndefinedToCustomDefinedValue(customProperties, customUndefinedValue);
        }
        var bd = telemetryItem[strBaseData];
        var exData = Exception.CreateFromInterface(logger, bd, customProperties, customMeasurements);
        var data = new Data(Exception[_DYN_DATA_TYPE ], exData);
        return _createEnvelope(logger, Exception[_DYN_ENVELOPE_TYPE ], telemetryItem, data);
    }
    function MetricEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
        EnvelopeCreatorInit(logger, telemetryItem);
        var baseData = telemetryItem[strBaseData];
        var props = baseData[strProperties] || {};
        var measurements = baseData[_DYN_MEASUREMENTS ] || {};
        _extractPropsAndMeasurements(telemetryItem[_DYN_DATA ], props, measurements);
        if (!isNullOrUndefined(customUndefinedValue)) {
            _convertPropsUndefinedToCustomDefinedValue(props, customUndefinedValue);
        }
        var baseMetricData = new Metric(logger, baseData[_DYN_NAME ], baseData.average, baseData.sampleCount, baseData.min, baseData.max, baseData.stdDev, props, measurements);
        var data = new Data(Metric[_DYN_DATA_TYPE ], baseMetricData);
        return _createEnvelope(logger, Metric[_DYN_ENVELOPE_TYPE ], telemetryItem, data);
    }
    function PageViewEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
        EnvelopeCreatorInit(logger, telemetryItem);
        var duration;
        var baseData = telemetryItem[strBaseData];
        if (!isNullOrUndefined(baseData) &&
            !isNullOrUndefined(baseData[strProperties]) &&
            !isNullOrUndefined(baseData[strProperties][STR_DURATION])) {
            duration = baseData[strProperties][STR_DURATION];
            delete baseData[strProperties][STR_DURATION];
        }
        else if (!isNullOrUndefined(telemetryItem[_DYN_DATA ]) &&
            !isNullOrUndefined(telemetryItem[_DYN_DATA ][STR_DURATION])) {
            duration = telemetryItem[_DYN_DATA ][STR_DURATION];
            delete telemetryItem[_DYN_DATA ][STR_DURATION];
        }
        var bd = telemetryItem[strBaseData];
        var currentContextId;
        if (((telemetryItem.ext || {}).trace || {})[_DYN_TRACE_ID ]) {
            currentContextId = telemetryItem.ext.trace[_DYN_TRACE_ID ];
        }
        var id = bd.id || currentContextId;
        var name = bd[_DYN_NAME ];
        var url = bd.uri;
        var properties = bd[strProperties] || {};
        var measurements = bd[_DYN_MEASUREMENTS ] || {};
        if (!isNullOrUndefined(bd.refUri)) {
            properties["refUri"] = bd.refUri;
        }
        if (!isNullOrUndefined(bd.pageType)) {
            properties["pageType"] = bd.pageType;
        }
        if (!isNullOrUndefined(bd.isLoggedIn)) {
            properties["isLoggedIn"] = bd.isLoggedIn[_DYN_TO_STRING ]();
        }
        if (!isNullOrUndefined(bd[strProperties])) {
            var pageTags = bd[strProperties];
            objForEachKey(pageTags, function (key, value) {
                properties[key] = value;
            });
        }
        _extractPropsAndMeasurements(telemetryItem[_DYN_DATA ], properties, measurements);
        if (!isNullOrUndefined(customUndefinedValue)) {
            _convertPropsUndefinedToCustomDefinedValue(properties, customUndefinedValue);
        }
        var pageViewData = new PageView(logger, name, url, duration, properties, measurements, id);
        var data = new Data(PageView[_DYN_DATA_TYPE ], pageViewData);
        return _createEnvelope(logger, PageView[_DYN_ENVELOPE_TYPE ], telemetryItem, data);
    }
    function PageViewPerformanceEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
        EnvelopeCreatorInit(logger, telemetryItem);
        var bd = telemetryItem[strBaseData];
        var name = bd[_DYN_NAME ];
        var url = bd.uri || bd.url;
        var properties = bd[strProperties] || {};
        var measurements = bd[_DYN_MEASUREMENTS ] || {};
        _extractPropsAndMeasurements(telemetryItem[_DYN_DATA ], properties, measurements);
        if (!isNullOrUndefined(customUndefinedValue)) {
            _convertPropsUndefinedToCustomDefinedValue(properties, customUndefinedValue);
        }
        var baseData = new PageViewPerformance(logger, name, url, undefined, properties, measurements, bd);
        var data = new Data(PageViewPerformance[_DYN_DATA_TYPE ], baseData);
        return _createEnvelope(logger, PageViewPerformance[_DYN_ENVELOPE_TYPE ], telemetryItem, data);
    }
    function TraceEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
        EnvelopeCreatorInit(logger, telemetryItem);
        var message = telemetryItem[strBaseData].message;
        var severityLevel = telemetryItem[strBaseData].severityLevel;
        var props = telemetryItem[strBaseData][strProperties] || {};
        var measurements = telemetryItem[strBaseData][_DYN_MEASUREMENTS ] || {};
        _extractPropsAndMeasurements(telemetryItem[_DYN_DATA ], props, measurements);
        if (!isNullOrUndefined(customUndefinedValue)) {
            _convertPropsUndefinedToCustomDefinedValue(props, customUndefinedValue);
        }
        var baseData = new Trace(logger, message, severityLevel, props, measurements);
        var data = new Data(Trace[_DYN_DATA_TYPE ], baseData);
        return _createEnvelope(logger, Trace[_DYN_ENVELOPE_TYPE ], telemetryItem, data);
    }

    var BaseSendBuffer = /** @class */ (function () {
        function BaseSendBuffer(logger, config) {
            var _buffer = [];
            var _bufferFullMessageSent = false;
            var _maxRetryCnt = config.maxRetryCnt;
            this[_DYN__GET ] = function () {
                return _buffer;
            };
            this._set = function (buffer) {
                _buffer = buffer;
                return _buffer;
            };
            dynamicProto(BaseSendBuffer, this, function (_self) {
                _self[_DYN_ENQUEUE ] = function (payload) {
                    if (_self[_DYN_COUNT ]() >= config[_DYN_EVENTS_LIMIT_IN_MEM ]) {
                        if (!_bufferFullMessageSent) {
                            _throwInternal(logger, 2 , 105 , "Maximum in-memory buffer size reached: " + _self[_DYN_COUNT ](), true);
                            _bufferFullMessageSent = true;
                        }
                        return;
                    }
                    payload.cnt = payload.cnt || 0;
                    if (!isNullOrUndefined(_maxRetryCnt)) {
                        if (payload.cnt > _maxRetryCnt) {
                            return;
                        }
                    }
                    _buffer[_DYN_PUSH ](payload);
                    return;
                };
                _self[_DYN_COUNT ] = function () {
                    return _buffer[_DYN_LENGTH ];
                };
                _self.size = function () {
                    var size = _buffer[_DYN_LENGTH ];
                    for (var lp = 0; lp < _buffer[_DYN_LENGTH ]; lp++) {
                        size += (_buffer[lp].item)[_DYN_LENGTH ];
                    }
                    if (!config[_DYN_EMIT_LINE_DELIMITED_0 ]) {
                        size += 2;
                    }
                    return size;
                };
                _self[_DYN_CLEAR ] = function () {
                    _buffer = [];
                    _bufferFullMessageSent = false;
                };
                _self.getItems = function () {
                    return _buffer.slice(0);
                };
                _self.batchPayloads = function (payloads) {
                    if (payloads && payloads[_DYN_LENGTH ] > 0) {
                        var payloadStr_1 = [];
                        arrForEach(payloads, function (payload) {
                            payloadStr_1[_DYN_PUSH ](payload[_DYN_ITEM ]);
                        });
                        var batch = config[_DYN_EMIT_LINE_DELIMITED_0 ] ?
                            payloadStr_1.join("\n") :
                            "[" + payloadStr_1.join(",") + "]";
                        return batch;
                    }
                    return null;
                };
                _self[_DYN_CREATE_NEW ] = function (newLogger, newConfig, canUseSessionStorage) {
                    var items = _buffer.slice(0);
                    newLogger = newLogger || logger;
                    newConfig = newConfig || {};
                    var newBuffer = !!canUseSessionStorage ? new SessionStorageSendBuffer(newLogger, newConfig) : new ArraySendBuffer(newLogger, newConfig);
                    arrForEach(items, function (payload) {
                        newBuffer[_DYN_ENQUEUE ](payload);
                    });
                    return newBuffer;
                };
            });
        }
        BaseSendBuffer.__ieDyn=1;
        return BaseSendBuffer;
    }());
    var ArraySendBuffer = /** @class */ (function (_super) {
        __extendsFn(ArraySendBuffer, _super);
        function ArraySendBuffer(logger, config) {
            var _this = _super.call(this, logger, config) || this;
            dynamicProto(ArraySendBuffer, _this, function (_self, _base) {
                _self[_DYN_MARK_AS_SENT ] = function (payload) {
                    _base[_DYN_CLEAR ]();
                };
                _self[_DYN_CLEAR_SENT ] = function (payload) {
                };
            });
            return _this;
        }
        ArraySendBuffer.__ieDyn=1;
        return ArraySendBuffer;
    }(BaseSendBuffer));
    var PREVIOUS_KEYS = ["AI_buffer", "AI_sentBuffer"];
    var SessionStorageSendBuffer = /** @class */ (function (_super) {
        __extendsFn(SessionStorageSendBuffer, _super);
        function SessionStorageSendBuffer(logger, config) {
            var _this = _super.call(this, logger, config) || this;
            var _bufferFullMessageSent = false;
            var _namePrefix = config === null || config === void 0 ? void 0 : config.namePrefix;
            var _b = config[_DYN_BUFFER_OVERRIDE ] || { getItem: utlGetSessionStorage, setItem: utlSetSessionStorage }, getItem = _b.getItem, setItem = _b.setItem;
            var _maxRetryCnt = config.maxRetryCnt;
            dynamicProto(SessionStorageSendBuffer, _this, function (_self, _base) {
                var bufferItems = _getBuffer(SessionStorageSendBuffer[_DYN__BUFFER__KEY ]);
                var itemsInSentBuffer = _getBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY ]);
                var previousItems = _getPreviousEvents();
                var notDeliveredItems = itemsInSentBuffer[_DYN_CONCAT ](previousItems);
                var buffer = _self._set(bufferItems[_DYN_CONCAT ](notDeliveredItems));
                if (buffer[_DYN_LENGTH ] > SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE ]) {
                    buffer[_DYN_LENGTH ] = SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE ];
                }
                _setBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY ], []);
                _setBuffer(SessionStorageSendBuffer[_DYN__BUFFER__KEY ], buffer);
                _self[_DYN_ENQUEUE ] = function (payload) {
                    if (_self[_DYN_COUNT ]() >= SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE ]) {
                        if (!_bufferFullMessageSent) {
                            _throwInternal(logger, 2 , 67 , "Maximum buffer size reached: " + _self[_DYN_COUNT ](), true);
                            _bufferFullMessageSent = true;
                        }
                        return;
                    }
                    payload.cnt = payload.cnt || 0;
                    if (!isNullOrUndefined(_maxRetryCnt)) {
                        if (payload.cnt > _maxRetryCnt) {
                            return;
                        }
                    }
                    _base[_DYN_ENQUEUE ](payload);
                    _setBuffer(SessionStorageSendBuffer.BUFFER_KEY, _self[_DYN__GET ]());
                };
                _self[_DYN_CLEAR ] = function () {
                    _base[_DYN_CLEAR ]();
                    _setBuffer(SessionStorageSendBuffer.BUFFER_KEY, _self[_DYN__GET ]());
                    _setBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY ], []);
                    _bufferFullMessageSent = false;
                };
                _self[_DYN_MARK_AS_SENT ] = function (payload) {
                    _setBuffer(SessionStorageSendBuffer[_DYN__BUFFER__KEY ], _self._set(_removePayloadsFromBuffer(payload, _self[_DYN__GET ]())));
                    var sentElements = _getBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY ]);
                    if (sentElements instanceof Array && payload instanceof Array) {
                        sentElements = sentElements[_DYN_CONCAT ](payload);
                        if (sentElements[_DYN_LENGTH ] > SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE ]) {
                            _throwInternal(logger, 1 , 67 , "Sent buffer reached its maximum size: " + sentElements[_DYN_LENGTH ], true);
                            sentElements[_DYN_LENGTH ] = SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE ];
                        }
                        _setBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY ], sentElements);
                    }
                };
                _self[_DYN_CLEAR_SENT ] = function (payload) {
                    var sentElements = _getBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY ]);
                    sentElements = _removePayloadsFromBuffer(payload, sentElements);
                    _setBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY ], sentElements);
                };
                _self[_DYN_CREATE_NEW ] = function (newLogger, newConfig, canUseSessionStorage) {
                    canUseSessionStorage = !!canUseSessionStorage;
                    var unsentItems = _self[_DYN__GET ]().slice(0);
                    var sentItems = _getBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY ]).slice(0);
                    newLogger = newLogger || logger;
                    newConfig = newConfig || {};
                    _self[_DYN_CLEAR ]();
                    var newBuffer = canUseSessionStorage ? new SessionStorageSendBuffer(newLogger, newConfig) : new ArraySendBuffer(newLogger, newConfig);
                    arrForEach(unsentItems, function (payload) {
                        newBuffer[_DYN_ENQUEUE ](payload);
                    });
                    if (canUseSessionStorage) {
                        newBuffer[_DYN_MARK_AS_SENT ](sentItems);
                    }
                    return newBuffer;
                };
                function _removePayloadsFromBuffer(payloads, buffer) {
                    var remaining = [];
                    var payloadStr = [];
                    arrForEach(payloads, function (payload) {
                        payloadStr[_DYN_PUSH ](payload[_DYN_ITEM ]);
                    });
                    arrForEach(buffer, function (value) {
                        if (!isFunction(value) && arrIndexOf(payloadStr, value[_DYN_ITEM ]) === -1) {
                            remaining[_DYN_PUSH ](value);
                        }
                    });
                    return remaining;
                }
                function _getBuffer(key) {
                    var prefixedKey = key;
                    prefixedKey = _namePrefix ? _namePrefix + "_" + prefixedKey : prefixedKey;
                    return _getBufferBase(prefixedKey);
                }
                function _getBufferBase(key) {
                    try {
                        var bufferJson = getItem(logger, key);
                        if (bufferJson) {
                            var buffer_1 = getJSON().parse(bufferJson);
                            if (isString(buffer_1)) {
                                buffer_1 = getJSON().parse(buffer_1);
                            }
                            if (buffer_1 && isArray(buffer_1)) {
                                return buffer_1;
                            }
                        }
                    }
                    catch (e) {
                        _throwInternal(logger, 1 , 42 , " storage key: " + key + ", " + getExceptionName(e), { exception: dumpObj(e) });
                    }
                    return [];
                }
                function _setBuffer(key, buffer) {
                    var prefixedKey = key;
                    try {
                        prefixedKey = _namePrefix ? _namePrefix + "_" + prefixedKey : prefixedKey;
                        var bufferJson = JSON[_DYN_STRINGIFY ](buffer);
                        setItem(logger, prefixedKey, bufferJson);
                    }
                    catch (e) {
                        setItem(logger, prefixedKey, JSON[_DYN_STRINGIFY ]([]));
                        _throwInternal(logger, 2 , 41 , " storage key: " + prefixedKey + ", " + getExceptionName(e) + ". Buffer cleared", { exception: dumpObj(e) });
                    }
                }
                function _getPreviousEvents() {
                    var items = [];
                    try {
                        arrForEach(PREVIOUS_KEYS, function (key) {
                            var events = _getItemsFromPreviousKey(key);
                            items = items[_DYN_CONCAT ](events);
                            if (_namePrefix) {
                                var prefixedKey = _namePrefix + "_" + key;
                                var prefixEvents = _getItemsFromPreviousKey(prefixedKey);
                                items = items[_DYN_CONCAT ](prefixEvents);
                            }
                        });
                        return items;
                    }
                    catch (e) {
                        _throwInternal(logger, 2 , 41 , "Transfer events from previous buffers: " + getExceptionName(e) + ". previous Buffer items can not be removed", { exception: dumpObj(e) });
                    }
                    return [];
                }
                function _getItemsFromPreviousKey(key) {
                    try {
                        var items = _getBufferBase(key);
                        var transFormedItems_1 = [];
                        arrForEach(items, function (item) {
                            var internalItem = {
                                item: item,
                                cnt: 0
                            };
                            transFormedItems_1[_DYN_PUSH ](internalItem);
                        });
                        utlRemoveSessionStorage(logger, key);
                        return transFormedItems_1;
                    }
                    catch (e) {
                    }
                    return [];
                }
            });
            return _this;
        }
        var _a;
        _a = SessionStorageSendBuffer;
        SessionStorageSendBuffer.VERSION = "_1";
        SessionStorageSendBuffer.BUFFER_KEY = "AI_buffer" + _a.VERSION;
        SessionStorageSendBuffer.SENT_BUFFER_KEY = "AI_sentBuffer" + _a.VERSION;
        SessionStorageSendBuffer.MAX_BUFFER_SIZE = 2000;
        return SessionStorageSendBuffer;
    }(BaseSendBuffer));

    var Serializer = /** @class */ (function () {
        function Serializer(logger) {
            dynamicProto(Serializer, this, function (_self) {
                _self[_DYN_SERIALIZE ] = function (input) {
                    var output = _serializeObject(input, "root");
                    try {
                        return getJSON()[_DYN_STRINGIFY ](output);
                    }
                    catch (e) {
                        _throwInternal(logger, 1 , 48 , (e && isFunction(e[_DYN_TO_STRING ])) ? e[_DYN_TO_STRING ]() : "Error serializing object", null, true);
                    }
                };
                function _serializeObject(source, name) {
                    var circularReferenceCheck = "__aiCircularRefCheck";
                    var output = {};
                    if (!source) {
                        _throwInternal(logger, 1 , 48 , "cannot serialize object because it is null or undefined", { name: name }, true);
                        return output;
                    }
                    if (source[circularReferenceCheck]) {
                        _throwInternal(logger, 2 , 50 , "Circular reference detected while serializing object", { name: name }, true);
                        return output;
                    }
                    if (!source.aiDataContract) {
                        if (name === "measurements") {
                            output = _serializeStringMap(source, "number", name);
                        }
                        else if (name === "properties") {
                            output = _serializeStringMap(source, "string", name);
                        }
                        else if (name === "tags") {
                            output = _serializeStringMap(source, "string", name);
                        }
                        else if (isArray(source)) {
                            output = _serializeArray(source, name);
                        }
                        else {
                            _throwInternal(logger, 2 , 49 , "Attempting to serialize an object which does not implement ISerializable", { name: name }, true);
                            try {
                                getJSON()[_DYN_STRINGIFY ](source);
                                output = source;
                            }
                            catch (e) {
                                _throwInternal(logger, 1 , 48 , (e && isFunction(e[_DYN_TO_STRING ])) ? e[_DYN_TO_STRING ]() : "Error serializing object", null, true);
                            }
                        }
                        return output;
                    }
                    source[circularReferenceCheck] = true;
                    objForEachKey(source.aiDataContract, function (field, contract) {
                        var isRequired = (isFunction(contract)) ? (contract() & 1 ) : (contract & 1 );
                        var isHidden = (isFunction(contract)) ? (contract() & 4 ) : (contract & 4 );
                        var isArray = contract & 2 ;
                        var isPresent = source[field] !== undefined;
                        var isObj = isObject(source[field]) && source[field] !== null;
                        if (isRequired && !isPresent && !isArray) {
                            _throwInternal(logger, 1 , 24 , "Missing required field specification. The field is required but not present on source", { field: field, name: name });
                        }
                        else if (!isHidden) {
                            var value = void 0;
                            if (isObj) {
                                if (isArray) {
                                    value = _serializeArray(source[field], field);
                                }
                                else {
                                    value = _serializeObject(source[field], field);
                                }
                            }
                            else {
                                value = source[field];
                            }
                            if (value !== undefined) {
                                output[field] = value;
                            }
                        }
                    });
                    delete source[circularReferenceCheck];
                    return output;
                }
                function _serializeArray(sources, name) {
                    var output;
                    if (!!sources) {
                        if (!isArray(sources)) {
                            _throwInternal(logger, 1 , 54 , "This field was specified as an array in the contract but the item is not an array.\r\n", { name: name }, true);
                        }
                        else {
                            output = [];
                            for (var i = 0; i < sources[_DYN_LENGTH ]; i++) {
                                var source = sources[i];
                                var item = _serializeObject(source, name + "[" + i + "]");
                                output[_DYN_PUSH ](item);
                            }
                        }
                    }
                    return output;
                }
                function _serializeStringMap(map, expectedType, name) {
                    var output;
                    if (map) {
                        output = {};
                        objForEachKey(map, function (field, value) {
                            if (expectedType === "string") {
                                if (value === undefined) {
                                    output[field] = "undefined";
                                }
                                else if (value === null) {
                                    output[field] = "null";
                                }
                                else if (!value[_DYN_TO_STRING ]) {
                                    output[field] = "invalid field: toString() is not defined.";
                                }
                                else {
                                    output[field] = value[_DYN_TO_STRING ]();
                                }
                            }
                            else if (expectedType === "number") {
                                if (value === undefined) {
                                    output[field] = "undefined";
                                }
                                else if (value === null) {
                                    output[field] = "null";
                                }
                                else {
                                    var num = parseFloat(value);
                                    output[field] = num;
                                }
                            }
                            else {
                                output[field] = "invalid field: " + name + " is of unknown type.";
                                _throwInternal(logger, 1 , output[field], null, true);
                            }
                        });
                    }
                    return output;
                }
            });
        }
        Serializer.__ieDyn=1;
        return Serializer;
    }());

    var MIN_INPUT_LENGTH = 8;
    var HashCodeScoreGenerator = /** @class */ (function () {
        function HashCodeScoreGenerator() {
        }
        HashCodeScoreGenerator.prototype.getHashCodeScore = function (key) {
            var score = this.getHashCode(key) / HashCodeScoreGenerator.INT_MAX_VALUE;
            return score * 100;
        };
        HashCodeScoreGenerator.prototype.getHashCode = function (input) {
            if (input === "") {
                return 0;
            }
            while (input[_DYN_LENGTH ] < MIN_INPUT_LENGTH) {
                input = input[_DYN_CONCAT ](input);
            }
            var hash = 5381;
            for (var i = 0; i < input[_DYN_LENGTH ]; ++i) {
                hash = ((hash << 5) + hash) + input.charCodeAt(i);
                hash = hash & hash;
            }
            return Math.abs(hash);
        };
        HashCodeScoreGenerator.INT_MAX_VALUE = 2147483647;
        return HashCodeScoreGenerator;
    }());

    var SamplingScoreGenerator = /** @class */ (function () {
        function SamplingScoreGenerator() {
            var _self = this;
            var hashCodeGenerator = new HashCodeScoreGenerator();
            var keys = new ContextTagKeys();
            _self[_DYN_GET_SAMPLING_SCORE ] = function (item) {
                var score = 0;
                if (item[_DYN_TAGS ] && item[_DYN_TAGS ][keys.userId]) {
                    score = hashCodeGenerator.getHashCodeScore(item[_DYN_TAGS ][keys.userId]);
                }
                else if (item.ext && item.ext.user && item.ext.user.id) {
                    score = hashCodeGenerator[_DYN_GET_HASH_CODE_SCORE ](item.ext.user.id);
                }
                else if (item[_DYN_TAGS ] && item[_DYN_TAGS ][keys.operationId]) {
                    score = hashCodeGenerator.getHashCodeScore(item[_DYN_TAGS ][keys.operationId]);
                }
                else if (item.ext && item.ext.telemetryTrace && item.ext.telemetryTrace[_DYN_TRACE_ID ]) {
                    score = hashCodeGenerator.getHashCodeScore(item.ext.telemetryTrace[_DYN_TRACE_ID ]);
                }
                else {
                    score = (Math.random() * 100);
                }
                return score;
            };
        }
        return SamplingScoreGenerator;
    }());

    var Sample = /** @class */ (function () {
        function Sample(sampleRate, logger) {
            this.INT_MAX_VALUE = 2147483647;
            var _logger = logger || safeGetLogger(null);
            if (sampleRate > 100 || sampleRate < 0) {
                _logger.throwInternal(2 , 58 , "Sampling rate is out of range (0..100). Sampling will be disabled, you may be sending too much data which may affect your AI service level.", { samplingRate: sampleRate }, true);
                sampleRate = 100;
            }
            this[_DYN_SAMPLE_RATE ] = sampleRate;
            this.samplingScoreGenerator = new SamplingScoreGenerator();
        }
        Sample.prototype.isSampledIn = function (envelope) {
            var samplingPercentage = this[_DYN_SAMPLE_RATE ];
            var isSampledIn = false;
            if (samplingPercentage === null || samplingPercentage === undefined || samplingPercentage >= 100) {
                return true;
            }
            else if (envelope.baseType === Metric[_DYN_DATA_TYPE ]) {
                return true;
            }
            isSampledIn = this.samplingScoreGenerator[_DYN_GET_SAMPLING_SCORE ](envelope) < samplingPercentage;
            return isSampledIn;
        };
        return Sample;
    }());

    var _a, _b;
    var UNDEFINED_VALUE = undefined;
    var EMPTY_STR = "";
    var FetchSyncRequestSizeLimitBytes = 65000;
    function _getResponseText(xhr) {
        try {
            return xhr.responseText;
        }
        catch (e) {
        }
        return null;
    }
    function isOverrideFn(httpXHROverride) {
        return httpXHROverride && httpXHROverride.sendPOST;
    }
    var defaultAppInsightsChannelConfig = objDeepFreeze((_a = {
            endpointUrl: cfgDfValidate(isTruthy, DEFAULT_BREEZE_ENDPOINT + DEFAULT_BREEZE_PATH)
        },
        _a[_DYN_EMIT_LINE_DELIMITED_0 ] = cfgDfBoolean(),
        _a[_DYN_MAX_BATCH_INTERVAL ] = 15000,
        _a[_DYN_MAX_BATCH_SIZE_IN_BY1 ] = 102400,
        _a.disableTelemetry = cfgDfBoolean(),
        _a[_DYN_ENABLE_SESSION_STORA5 ] = cfgDfBoolean(true),
        _a.isRetryDisabled = cfgDfBoolean(),
        _a[_DYN_IS_BEACON_API_DISABL3 ] = cfgDfBoolean(true),
        _a[_DYN_DISABLE_SEND_BEACON_7 ] = cfgDfBoolean(true),
        _a[_DYN_DISABLE_XHR ] = cfgDfBoolean(),
        _a[_DYN_ONUNLOAD_DISABLE_FET6 ] = cfgDfBoolean(),
        _a[_DYN_ONUNLOAD_DISABLE_BEA2 ] = cfgDfBoolean(),
        _a[_DYN_INSTRUMENTATION_KEY$1 ] = UNDEFINED_VALUE,
        _a.namePrefix = UNDEFINED_VALUE,
        _a.samplingPercentage = cfgDfValidate(_chkSampling, 100),
        _a[_DYN_CUSTOM_HEADERS ] = UNDEFINED_VALUE,
        _a[_DYN_CONVERT_UNDEFINED ] = UNDEFINED_VALUE,
        _a[_DYN_EVENTS_LIMIT_IN_MEM ] = 10000,
        _a[_DYN_BUFFER_OVERRIDE ] = false,
        _a.httpXHROverride = { isVal: isOverrideFn, v: UNDEFINED_VALUE },
        _a[_DYN_ALWAYS_USE_XHR_OVERR4 ] = cfgDfBoolean(),
        _a.transports = UNDEFINED_VALUE,
        _a.retryCodes = UNDEFINED_VALUE,
        _a.maxRetryCnt = { isVal: isNumber, v: 10 },
        _a));
    function _chkSampling(value) {
        return !isNaN(value) && value > 0 && value <= 100;
    }
    var EnvelopeTypeCreator = (_b = {},
        _b[Event$1.dataType] = EventEnvelopeCreator,
        _b[Trace.dataType] = TraceEnvelopeCreator,
        _b[PageView.dataType] = PageViewEnvelopeCreator,
        _b[PageViewPerformance.dataType] = PageViewPerformanceEnvelopeCreator,
        _b[Exception.dataType] = ExceptionEnvelopeCreator,
        _b[Metric.dataType] = MetricEnvelopeCreator,
        _b[RemoteDependencyData.dataType] = DependencyEnvelopeCreator,
        _b);
    var Sender = /** @class */ (function (_super) {
        __extendsFn(Sender, _super);
        function Sender() {
            var _this = _super.call(this) || this;
            _this.priority = 1001;
            _this.identifier = BreezeChannelIdentifier;
            var _consecutiveErrors;
            var _retryAt;
            var _paused;
            var _timeoutHandle;
            var _serializer;
            var _stamp_specific_redirects;
            var _headers;
            var _syncFetchPayload = 0;
            var _syncUnloadSender;
            var _offlineListener;
            var _evtNamespace;
            var _endpointUrl;
            var _orgEndpointUrl;
            var _maxBatchSizeInBytes;
            var _beaconSupported;
            var _beaconOnUnloadSupported;
            var _beaconNormalSupported;
            var _customHeaders;
            var _disableTelemetry;
            var _instrumentationKey;
            var _convertUndefined;
            var _isRetryDisabled;
            var _maxBatchInterval;
            var _sessionStorageUsed;
            var _bufferOverrideUsed;
            var _namePrefix;
            var _enableSendPromise;
            var _alwaysUseCustomSend;
            var _disableXhr;
            var _fetchKeepAlive;
            var _xhrSend;
            var _fallbackSend;
            var _disableBeaconSplit;
            var _sendPostMgr;
            var _retryCodes;
            dynamicProto(Sender, _this, function (_self, _base) {
                _initDefaults();
                _self.pause = function () {
                    _clearScheduledTimer();
                    _paused = true;
                };
                _self.resume = function () {
                    if (_paused) {
                        _paused = false;
                        _retryAt = null;
                        _checkMaxSize();
                        _setupTimer();
                    }
                };
                _self.flush = function (isAsync, callBack, sendReason) {
                    if (isAsync === void 0) { isAsync = true; }
                    if (!_paused) {
                        _clearScheduledTimer();
                        try {
                            return _self[_DYN_TRIGGER_SEND ](isAsync, null, sendReason || 1 );
                        }
                        catch (e) {
                            _throwInternal(_self[_DYN_DIAG_LOG ](), 1 , 22 , "flush failed, telemetry will not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
                        }
                    }
                };
                _self.onunloadFlush = function () {
                    if (!_paused) {
                        if (_beaconSupported || _alwaysUseCustomSend) {
                            try {
                                return _self[_DYN_TRIGGER_SEND ](true, _doUnloadSend, 2 );
                            }
                            catch (e) {
                                _throwInternal(_self[_DYN_DIAG_LOG ](), 1 , 20 , "failed to flush with beacon sender on page unload, telemetry will not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
                            }
                        }
                        else {
                            _self.flush(false);
                        }
                    }
                };
                _self.addHeader = function (name, value) {
                    _headers[name] = value;
                };
                _self[_DYN_INITIALIZE ] = function (config, core, extensions, pluginChain) {
                    if (_self.isInitialized()) {
                        _throwInternal(_self[_DYN_DIAG_LOG ](), 1 , 28 , "Sender is already initialized");
                    }
                    _base[_DYN_INITIALIZE ](config, core, extensions, pluginChain);
                    var identifier = _self.identifier;
                    _serializer = new Serializer(core.logger);
                    _consecutiveErrors = 0;
                    _retryAt = null;
                    _self[_DYN__SENDER ] = null;
                    _stamp_specific_redirects = 0;
                    var diagLog = _self[_DYN_DIAG_LOG ]();
                    _evtNamespace = mergeEvtNamespace(createUniqueNamespace("Sender"), core.evtNamespace && core.evtNamespace());
                    _offlineListener = createOfflineListener(_evtNamespace);
                    _self._addHook(onConfigChange(config, function (details) {
                        var config = details.cfg;
                        if (config.storagePrefix) {
                            utlSetStoragePrefix(config.storagePrefix);
                        }
                        var ctx = createProcessTelemetryContext(null, config, core);
                        var senderConfig = ctx.getExtCfg(identifier, defaultAppInsightsChannelConfig);
                        objDefine(_self, "_senderConfig", {
                            g: function () {
                                return senderConfig;
                            }
                        });
                        if (_orgEndpointUrl !== senderConfig.endpointUrl) {
                            _endpointUrl = _orgEndpointUrl = senderConfig.endpointUrl;
                        }
                        if (_customHeaders && _customHeaders !== senderConfig[_DYN_CUSTOM_HEADERS ]) {
                            arrForEach(_customHeaders, function (customHeader) {
                                delete _headers[customHeader.header];
                            });
                        }
                        _maxBatchSizeInBytes = senderConfig[_DYN_MAX_BATCH_SIZE_IN_BY1 ];
                        _beaconSupported = (senderConfig[_DYN_ONUNLOAD_DISABLE_BEA2 ] === false || senderConfig[_DYN_IS_BEACON_API_DISABL3 ] === false) && isBeaconsSupported();
                        _beaconOnUnloadSupported = senderConfig[_DYN_ONUNLOAD_DISABLE_BEA2 ] === false && isBeaconsSupported();
                        _beaconNormalSupported = senderConfig[_DYN_IS_BEACON_API_DISABL3 ] === false && isBeaconsSupported();
                        _alwaysUseCustomSend = senderConfig[_DYN_ALWAYS_USE_XHR_OVERR4 ];
                        _disableXhr = !!senderConfig[_DYN_DISABLE_XHR ];
                        _retryCodes = senderConfig.retryCodes;
                        var bufferOverride = senderConfig[_DYN_BUFFER_OVERRIDE ];
                        var canUseSessionStorage = !!senderConfig[_DYN_ENABLE_SESSION_STORA5 ] &&
                            (!!bufferOverride || utlCanUseSessionStorage());
                        var namePrefix = senderConfig.namePrefix;
                        var shouldUpdate = (canUseSessionStorage !== _sessionStorageUsed)
                            || (canUseSessionStorage && (_namePrefix !== namePrefix))
                            || (canUseSessionStorage && (_bufferOverrideUsed !== bufferOverride));
                        if (_self[_DYN__BUFFER ]) {
                            if (shouldUpdate) {
                                try {
                                    _self._buffer = _self._buffer[_DYN_CREATE_NEW ](diagLog, senderConfig, canUseSessionStorage);
                                }
                                catch (e) {
                                    _throwInternal(_self[_DYN_DIAG_LOG ](), 1 , 12 , "failed to transfer telemetry to different buffer storage, telemetry will be lost: " + getExceptionName(e), { exception: dumpObj(e) });
                                }
                            }
                            _checkMaxSize();
                        }
                        else {
                            _self[_DYN__BUFFER ] = canUseSessionStorage
                                ? new SessionStorageSendBuffer(diagLog, senderConfig) : new ArraySendBuffer(diagLog, senderConfig);
                        }
                        _namePrefix = namePrefix;
                        _sessionStorageUsed = canUseSessionStorage;
                        _bufferOverrideUsed = bufferOverride;
                        _fetchKeepAlive = !senderConfig[_DYN_ONUNLOAD_DISABLE_FET6 ] && isFetchSupported(true);
                        _disableBeaconSplit = !!senderConfig[_DYN_DISABLE_SEND_BEACON_7 ];
                        _self._sample = new Sample(senderConfig.samplingPercentage, diagLog);
                        _instrumentationKey = senderConfig[_DYN_INSTRUMENTATION_KEY$1 ];
                        if (!_validateInstrumentationKey(_instrumentationKey, config)) {
                            _throwInternal(diagLog, 1 , 100 , "Invalid Instrumentation key " + _instrumentationKey);
                        }
                        _customHeaders = senderConfig[_DYN_CUSTOM_HEADERS ];
                        if (!isInternalApplicationInsightsEndpoint(_endpointUrl) && _customHeaders && _customHeaders[_DYN_LENGTH ] > 0) {
                            arrForEach(_customHeaders, function (customHeader) {
                                _this.addHeader(customHeader.header, customHeader.value);
                            });
                        }
                        else {
                            _customHeaders = null;
                        }
                        _enableSendPromise = senderConfig[_DYN_ENABLE_SEND_PROMISE ];
                        var sendPostConfig = _getSendPostMgrConfig();
                        if (!_sendPostMgr) {
                            _sendPostMgr = new SenderPostManager();
                            _sendPostMgr[_DYN_INITIALIZE ](sendPostConfig, diagLog);
                        }
                        else {
                            _sendPostMgr.SetConfig(sendPostConfig);
                        }
                        var customInterface = senderConfig.httpXHROverride;
                        var httpInterface = null;
                        var syncInterface = null;
                        var theTransports = prependTransports([3 , 1 , 2 ], senderConfig.transports);
                        httpInterface = _sendPostMgr && _sendPostMgr[_DYN_GET_SENDER_INST ](theTransports, false);
                        var xhrInterface = _sendPostMgr && _sendPostMgr.getFallbackInst();
                        _xhrSend = function (payload, isAsync) {
                            return _doSend(xhrInterface, payload, isAsync);
                        };
                        _fallbackSend = function (payload, isAsync) {
                            return _doSend(xhrInterface, payload, isAsync, false);
                        };
                        httpInterface = _alwaysUseCustomSend ? customInterface : (httpInterface || customInterface || xhrInterface);
                        _self[_DYN__SENDER ] = function (payload, isAsync) {
                            return _doSend(httpInterface, payload, isAsync);
                        };
                        if (_fetchKeepAlive) {
                            _syncUnloadSender = _fetchKeepAliveSender;
                        }
                        var syncTransports = prependTransports([3 , 1 ], senderConfig[_DYN_UNLOAD_TRANSPORTS ]);
                        if (!_fetchKeepAlive) {
                            syncTransports = syncTransports.filter(function (transport) { return transport !== 2 ; });
                        }
                        syncInterface = _sendPostMgr && _sendPostMgr[_DYN_GET_SENDER_INST ](syncTransports, true);
                        syncInterface = _alwaysUseCustomSend ? customInterface : (syncInterface || customInterface);
                        if ((_alwaysUseCustomSend || senderConfig[_DYN_UNLOAD_TRANSPORTS ] || !_syncUnloadSender) && syncInterface) {
                            _syncUnloadSender = function (payload, isAsync) {
                                return _doSend(syncInterface, payload, isAsync);
                            };
                        }
                        if (!_syncUnloadSender) {
                            _syncUnloadSender = _xhrSend;
                        }
                        _disableTelemetry = senderConfig.disableTelemetry;
                        _convertUndefined = senderConfig[_DYN_CONVERT_UNDEFINED ] || UNDEFINED_VALUE;
                        _isRetryDisabled = senderConfig.isRetryDisabled;
                        _maxBatchInterval = senderConfig[_DYN_MAX_BATCH_INTERVAL ];
                    }));
                };
                _self.processTelemetry = function (telemetryItem, itemCtx) {
                    var _a;
                    itemCtx = _self._getTelCtx(itemCtx);
                    var diagLogger = itemCtx[_DYN_DIAG_LOG ]();
                    try {
                        var isValidate = _validate(telemetryItem, diagLogger);
                        if (!isValidate) {
                            return;
                        }
                        var aiEnvelope = _getEnvelope(telemetryItem, diagLogger);
                        if (!aiEnvelope) {
                            return;
                        }
                        var payload = _serializer[_DYN_SERIALIZE ](aiEnvelope);
                        var buffer = _self[_DYN__BUFFER ];
                        _checkMaxSize(payload);
                        var payloadItem = (_a = {},
                            _a[_DYN_ITEM ] = payload,
                            _a.cnt = 0
                        ,
                            _a);
                        buffer[_DYN_ENQUEUE ](payloadItem);
                        _setupTimer();
                    }
                    catch (e) {
                        _throwInternal(diagLogger, 2 , 12 , "Failed adding telemetry to the sender's buffer, some telemetry will be lost: " + getExceptionName(e), { exception: dumpObj(e) });
                    }
                    _self.processNext(telemetryItem, itemCtx);
                };
                _self.isCompletelyIdle = function () {
                    return !_paused && _syncFetchPayload === 0 && _self._buffer[_DYN_COUNT ]() === 0;
                };
                _self._xhrReadyStateChange = function (xhr, payload, countOfItemsInPayload) {
                    if (_isStringArr(payload)) {
                        return;
                    }
                    return _xhrReadyStateChange(xhr, payload, countOfItemsInPayload);
                };
                _self[_DYN_TRIGGER_SEND ] = function (async, forcedSender, sendReason) {
                    if (async === void 0) { async = true; }
                    var result;
                    if (!_paused) {
                        try {
                            var buffer = _self[_DYN__BUFFER ];
                            if (!_disableTelemetry) {
                                if (buffer[_DYN_COUNT ]() > 0) {
                                    var payload = buffer.getItems();
                                    _notifySendRequest(sendReason || 0 , async);
                                    if (forcedSender) {
                                        result = forcedSender.call(_self, payload, async);
                                    }
                                    else {
                                        result = _self[_DYN__SENDER ](payload, async);
                                    }
                                }
                            }
                            else {
                                buffer[_DYN_CLEAR ]();
                            }
                            _clearScheduledTimer();
                        }
                        catch (e) {
                            var ieVer = getIEVersion();
                            if (!ieVer || ieVer > 9) {
                                _throwInternal(_self[_DYN_DIAG_LOG ](), 1 , 40 , "Telemetry transmission failed, some telemetry will be lost: " + getExceptionName(e), { exception: dumpObj(e) });
                            }
                        }
                    }
                    return result;
                };
                _self.getOfflineSupport = function () {
                    var _a;
                    return _a = {
                            getUrl: function () {
                                return _endpointUrl;
                            },
                            createPayload: _createPayload
                        },
                        _a[_DYN_SERIALIZE ] = _serialize,
                        _a.batch = _batch,
                        _a.shouldProcess = function (evt) {
                            return !!_validate(evt);
                        },
                        _a;
                };
                _self._doTeardown = function (unloadCtx, unloadState) {
                    _self.onunloadFlush();
                    runTargetUnload(_offlineListener, false);
                    _initDefaults();
                };
                _self[_DYN__ON_ERROR ] = function (payload, message, event) {
                    if (_isStringArr(payload)) {
                        return;
                    }
                    return _onError(payload, message);
                };
                _self[_DYN__ON_PARTIAL_SUCCESS ] = function (payload, results) {
                    if (_isStringArr(payload)) {
                        return;
                    }
                    return _onPartialSuccess(payload, results);
                };
                _self[_DYN__ON_SUCCESS ] = function (payload, countOfItemsInPayload) {
                    if (_isStringArr(payload)) {
                        return;
                    }
                    return _onSuccess(payload);
                };
                _self._xdrOnLoad = function (xdr, payload) {
                    if (_isStringArr(payload)) {
                        return;
                    }
                    return _xdrOnLoad(xdr, payload);
                };
                function _xdrOnLoad(xdr, payload) {
                    var responseText = _getResponseText(xdr);
                    if (xdr && (responseText + "" === "200" || responseText === "")) {
                        _consecutiveErrors = 0;
                        _self[_DYN__ON_SUCCESS ](payload, 0);
                    }
                    else {
                        var results = parseResponse(responseText);
                        if (results && results[_DYN_ITEMS_RECEIVED ] && results[_DYN_ITEMS_RECEIVED ] > results[_DYN_ITEMS_ACCEPTED ]
                            && !_isRetryDisabled) {
                            _self[_DYN__ON_PARTIAL_SUCCESS ](payload, results);
                        }
                        else {
                            _self[_DYN__ON_ERROR ](payload, formatErrorMessageXdr(xdr));
                        }
                    }
                }
                function _getSendPostMgrConfig() {
                    var _a;
                    try {
                        var onCompleteFuncs = {
                            xdrOnComplete: function (xdr, oncomplete, payload) {
                                var data = _getPayloadArr(payload);
                                if (!data) {
                                    return;
                                }
                                return _xdrOnLoad(xdr, data);
                            },
                            fetchOnComplete: function (response, onComplete, resValue, payload) {
                                var data = _getPayloadArr(payload);
                                if (!data) {
                                    return;
                                }
                                return _checkResponsStatus(response.status, data, response.url, data[_DYN_LENGTH ], response.statusText, resValue || "");
                            },
                            xhrOnComplete: function (request, oncomplete, payload) {
                                var data = _getPayloadArr(payload);
                                if (!data) {
                                    return;
                                }
                                return _xhrReadyStateChange(request, data, data[_DYN_LENGTH ]);
                            },
                            beaconOnRetry: function (data, onComplete, canSend) {
                                return _onBeaconRetry(data, onComplete, canSend);
                            }
                        };
                        var config = (_a = {},
                            _a[_DYN_ENABLE_SEND_PROMISE ] = _enableSendPromise,
                            _a.isOneDs = false,
                            _a.disableCredentials = false,
                            _a[_DYN_DISABLE_XHR ] = _disableXhr,
                            _a.disableBeacon = !_beaconNormalSupported,
                            _a.disableBeaconSync = !_beaconOnUnloadSupported,
                            _a.senderOnCompleteCallBack = onCompleteFuncs,
                            _a);
                        return config;
                    }
                    catch (e) {
                    }
                    return null;
                }
                function _xhrReadyStateChange(xhr, payload, countOfItemsInPayload) {
                    if (xhr.readyState === 4) {
                        _checkResponsStatus(xhr.status, payload, xhr.responseURL, countOfItemsInPayload, formatErrorMessageXhr(xhr), _getResponseText(xhr) || xhr.response);
                    }
                }
                function _onError(payload, message, event) {
                    _throwInternal(_self[_DYN_DIAG_LOG ](), 2 , 26 , "Failed to send telemetry.", { message: message });
                    _self._buffer && _self._buffer[_DYN_CLEAR_SENT ](payload);
                }
                function _onPartialSuccess(payload, results) {
                    var failed = [];
                    var retry = [];
                    var errors = results.errors.reverse();
                    for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
                        var error = errors_1[_i];
                        var extracted = payload.splice(error.index, 1)[0];
                        if (_isRetriable(error.statusCode)) {
                            retry[_DYN_PUSH ](extracted);
                        }
                        else {
                            failed[_DYN_PUSH ](extracted);
                        }
                    }
                    if (payload[_DYN_LENGTH ] > 0) {
                        _self[_DYN__ON_SUCCESS ](payload, results[_DYN_ITEMS_ACCEPTED ]);
                    }
                    if (failed[_DYN_LENGTH ] > 0) {
                        _self[_DYN__ON_ERROR ](failed, formatErrorMessageXhr(null, ["partial success", results[_DYN_ITEMS_ACCEPTED ], "of", results.itemsReceived].join(" ")));
                    }
                    if (retry[_DYN_LENGTH ] > 0) {
                        _resendPayload(retry);
                        _throwInternal(_self[_DYN_DIAG_LOG ](), 2 , 40 , "Partial success. " +
                            "Delivered: " + payload[_DYN_LENGTH ] + ", Failed: " + failed[_DYN_LENGTH ] +
                            ". Will retry to send " + retry[_DYN_LENGTH ] + " our of " + results[_DYN_ITEMS_RECEIVED ] + " items");
                    }
                }
                function _onSuccess(payload, countOfItemsInPayload) {
                    _self._buffer && _self._buffer[_DYN_CLEAR_SENT ](payload);
                }
                function _getPayloadArr(payload) {
                    try {
                        if (payload) {
                            var internalPayload = payload;
                            var arr = internalPayload[_DYN_ORI_PAYLOAD ];
                            if (arr && arr[_DYN_LENGTH ]) {
                                return arr;
                            }
                            return null;
                        }
                    }
                    catch (e) {
                    }
                    return null;
                }
                function _validate(telemetryItem, diagLogger) {
                    if (_disableTelemetry) {
                        return false;
                    }
                    if (!telemetryItem) {
                        diagLogger && _throwInternal(diagLogger, 1 , 7 , "Cannot send empty telemetry");
                        return false;
                    }
                    if (telemetryItem.baseData && !telemetryItem[_DYN_BASE_TYPE ]) {
                        diagLogger && _throwInternal(diagLogger, 1 , 70 , "Cannot send telemetry without baseData and baseType");
                        return false;
                    }
                    if (!telemetryItem[_DYN_BASE_TYPE ]) {
                        telemetryItem[_DYN_BASE_TYPE ] = "EventData";
                    }
                    if (!_self[_DYN__SENDER ]) {
                        diagLogger && _throwInternal(diagLogger, 1 , 28 , "Sender was not initialized");
                        return false;
                    }
                    if (!_isSampledIn(telemetryItem)) {
                        diagLogger && _throwInternal(diagLogger, 2 , 33 , "Telemetry item was sampled out and not sent", { SampleRate: _self._sample[_DYN_SAMPLE_RATE ] });
                        return false;
                    }
                    else {
                        telemetryItem[SampleRate] = _self._sample[_DYN_SAMPLE_RATE ];
                    }
                    return true;
                }
                function _getEnvelope(telemetryItem, diagLogger) {
                    var defaultEnvelopeIkey = telemetryItem.iKey || _instrumentationKey;
                    var aiEnvelope = Sender.constructEnvelope(telemetryItem, defaultEnvelopeIkey, diagLogger, _convertUndefined);
                    if (!aiEnvelope) {
                        _throwInternal(diagLogger, 1 , 47 , "Unable to create an AppInsights envelope");
                        return;
                    }
                    var doNotSendItem = false;
                    if (telemetryItem[_DYN_TAGS ] && telemetryItem[_DYN_TAGS ][ProcessLegacy]) {
                        arrForEach(telemetryItem[_DYN_TAGS ][ProcessLegacy], function (callBack) {
                            try {
                                if (callBack && callBack(aiEnvelope) === false) {
                                    doNotSendItem = true;
                                    _warnToConsole(diagLogger, "Telemetry processor check returns false");
                                }
                            }
                            catch (e) {
                                _throwInternal(diagLogger, 1 , 64 , "One of telemetry initializers failed, telemetry item will not be sent: " + getExceptionName(e), { exception: dumpObj(e) }, true);
                            }
                        });
                        delete telemetryItem[_DYN_TAGS ][ProcessLegacy];
                    }
                    if (doNotSendItem) {
                        return;
                    }
                    return aiEnvelope;
                }
                function _serialize(item) {
                    var rlt = EMPTY_STR;
                    var diagLogger = _self[_DYN_DIAG_LOG ]();
                    try {
                        var valid = _validate(item, diagLogger);
                        var envelope = null;
                        if (valid) {
                            envelope = _getEnvelope(item, diagLogger);
                        }
                        if (envelope) {
                            rlt = _serializer[_DYN_SERIALIZE ](envelope);
                        }
                    }
                    catch (e) {
                    }
                    return rlt;
                }
                function _batch(arr) {
                    var rlt = EMPTY_STR;
                    if (arr && arr[_DYN_LENGTH ]) {
                        rlt = "[" + arr.join(",") + "]";
                    }
                    return rlt;
                }
                function _createPayload(data) {
                    var _a;
                    var headers = _getHeaders();
                    return _a = {
                            urlString: _endpointUrl
                        },
                        _a[_DYN_DATA ] = data,
                        _a.headers = headers,
                        _a;
                }
                function _isSampledIn(envelope) {
                    return _self._sample.isSampledIn(envelope);
                }
                function _getOnComplete(payload, status, headers, response) {
                    if (status === 200 && payload) {
                        _self._onSuccess(payload, payload[_DYN_LENGTH ]);
                    }
                    else {
                        response && _self[_DYN__ON_ERROR ](payload, response);
                    }
                }
                function _doSend(sendInterface, payload, isAsync, markAsSent) {
                    if (markAsSent === void 0) { markAsSent = true; }
                    var onComplete = function (status, headers, response) {
                        return _getOnComplete(payload, status, headers, response);
                    };
                    var payloadData = _getPayload(payload);
                    var sendPostFunc = sendInterface && sendInterface.sendPOST;
                    if (sendPostFunc && payloadData) {
                        if (markAsSent) {
                            _self._buffer[_DYN_MARK_AS_SENT ](payload);
                        }
                        return sendPostFunc(payloadData, onComplete, !isAsync);
                    }
                    return null;
                }
                function _getPayload(payload) {
                    var _a;
                    if (isArray(payload) && payload[_DYN_LENGTH ] > 0) {
                        var batch = _self[_DYN__BUFFER ].batchPayloads(payload);
                        var headers = _getHeaders();
                        var payloadData = (_a = {},
                            _a[_DYN_DATA ] = batch,
                            _a.urlString = _endpointUrl,
                            _a.headers = headers,
                            _a.disableXhrSync = _disableXhr,
                            _a.disableFetchKeepAlive = !_fetchKeepAlive,
                            _a[_DYN_ORI_PAYLOAD ] = payload,
                            _a);
                        return payloadData;
                    }
                    return null;
                }
                function _getHeaders() {
                    try {
                        var headers = _headers || {};
                        if (isInternalApplicationInsightsEndpoint(_endpointUrl)) {
                            headers[RequestHeaders[6 ]] = RequestHeaders[7 ];
                        }
                        return headers;
                    }
                    catch (e) {
                    }
                    return null;
                }
                function _checkMaxSize(incomingPayload) {
                    var incomingSize = incomingPayload ? incomingPayload[_DYN_LENGTH ] : 0;
                    if ((_self[_DYN__BUFFER ].size() + incomingSize) > _maxBatchSizeInBytes) {
                        if (!_offlineListener || _offlineListener.isOnline()) {
                            _self[_DYN_TRIGGER_SEND ](true, null, 10 );
                        }
                        return true;
                    }
                    return false;
                }
                function _checkResponsStatus(status, payload, responseUrl, countOfItemsInPayload, errorMessage, res) {
                    var response = null;
                    if (!_self._appId) {
                        response = parseResponse(res);
                        if (response && response.appId) {
                            _self._appId = response.appId;
                        }
                    }
                    if ((status < 200 || status >= 300) && status !== 0) {
                        if (status === 301 || status === 307 || status === 308) {
                            if (!_checkAndUpdateEndPointUrl(responseUrl)) {
                                _self[_DYN__ON_ERROR ](payload, errorMessage);
                                return;
                            }
                        }
                        if (!_isRetryDisabled && _isRetriable(status)) {
                            _resendPayload(payload);
                            _throwInternal(_self[_DYN_DIAG_LOG ](), 2 , 40 , ". " +
                                "Response code " + status + ". Will retry to send " + payload[_DYN_LENGTH ] + " items.");
                        }
                        else {
                            _self[_DYN__ON_ERROR ](payload, errorMessage);
                        }
                    }
                    else if (_offlineListener && !_offlineListener.isOnline()) {
                        if (!_isRetryDisabled) {
                            var offlineBackOffMultiplier = 10;
                            _resendPayload(payload, offlineBackOffMultiplier);
                            _throwInternal(_self[_DYN_DIAG_LOG ](), 2 , 40 , ". Offline - Response Code: ".concat(status, ". Offline status: ").concat(!_offlineListener.isOnline(), ". Will retry to send ").concat(payload.length, " items."));
                        }
                    }
                    else {
                        _checkAndUpdateEndPointUrl(responseUrl);
                        if (status === 206) {
                            if (!response) {
                                response = parseResponse(res);
                            }
                            if (response && !_isRetryDisabled) {
                                _self[_DYN__ON_PARTIAL_SUCCESS ](payload, response);
                            }
                            else {
                                _self[_DYN__ON_ERROR ](payload, errorMessage);
                            }
                        }
                        else {
                            _consecutiveErrors = 0;
                            _self[_DYN__ON_SUCCESS ](payload, countOfItemsInPayload);
                        }
                    }
                }
                function _checkAndUpdateEndPointUrl(responseUrl) {
                    if (_stamp_specific_redirects >= 10) {
                        return false;
                    }
                    if (!isNullOrUndefined(responseUrl) && responseUrl !== "") {
                        if (responseUrl !== _endpointUrl) {
                            _endpointUrl = responseUrl;
                            ++_stamp_specific_redirects;
                            return true;
                        }
                    }
                    return false;
                }
                function _doUnloadSend(payload, isAsync) {
                    if (_syncUnloadSender) {
                        _syncUnloadSender(payload, false);
                    }
                    else {
                        var beaconInst = _sendPostMgr && _sendPostMgr[_DYN_GET_SENDER_INST ]([3 ], true);
                        return _doSend(beaconInst, payload, isAsync);
                    }
                }
                function _onBeaconRetry(payload, onComplete, canSend) {
                    var internalPayload = payload;
                    var data = internalPayload && internalPayload[_DYN_ORI_PAYLOAD ];
                    if (!_disableBeaconSplit) {
                        var droppedPayload = [];
                        for (var lp = 0; lp < data[_DYN_LENGTH ]; lp++) {
                            var thePayload = data[lp];
                            var arr = [thePayload];
                            var item = _getPayload(arr);
                            if (!canSend(item, onComplete)) {
                                droppedPayload[_DYN_PUSH ](thePayload);
                            }
                            else {
                                _self._onSuccess(arr, arr[_DYN_LENGTH ]);
                            }
                        }
                        if (droppedPayload[_DYN_LENGTH ] > 0) {
                            _fallbackSend && _fallbackSend(droppedPayload, true);
                            _throwInternal(_self[_DYN_DIAG_LOG ](), 2 , 40 , ". " + "Failed to send telemetry with Beacon API, retried with normal sender.");
                        }
                    }
                    else {
                        _fallbackSend && _fallbackSend(data, true);
                        _throwInternal(_self[_DYN_DIAG_LOG ](), 2 , 40 , ". " + "Failed to send telemetry with Beacon API, retried with normal sender.");
                    }
                }
                function _isStringArr(arr) {
                    try {
                        if (arr && arr[_DYN_LENGTH ]) {
                            return (isString(arr[0]));
                        }
                    }
                    catch (e) {
                    }
                    return null;
                }
                function _fetchKeepAliveSender(payload, isAsync) {
                    var transport = null;
                    if (isArray(payload)) {
                        var payloadSize = payload[_DYN_LENGTH ];
                        for (var lp = 0; lp < payload[_DYN_LENGTH ]; lp++) {
                            payloadSize += payload[lp].item[_DYN_LENGTH ];
                        }
                        var syncFetchPayload = _sendPostMgr.getSyncFetchPayload();
                        if ((syncFetchPayload + payloadSize) <= FetchSyncRequestSizeLimitBytes) {
                            transport = 2 ;
                        }
                        else if (isBeaconsSupported()) {
                            transport = 3 ;
                        }
                        else {
                            transport = 1 ;
                            _throwInternal(_self[_DYN_DIAG_LOG ](), 2 , 40 , ". " + "Failed to send telemetry with Beacon API, retried with xhrSender.");
                        }
                        var inst = _sendPostMgr && _sendPostMgr[_DYN_GET_SENDER_INST ]([transport], true);
                        return _doSend(inst, payload, isAsync);
                    }
                    return null;
                }
                function _resendPayload(payload, linearFactor) {
                    if (linearFactor === void 0) { linearFactor = 1; }
                    if (!payload || payload[_DYN_LENGTH ] === 0) {
                        return;
                    }
                    var buffer = _self[_DYN__BUFFER ];
                    buffer[_DYN_CLEAR_SENT ](payload);
                    _consecutiveErrors++;
                    for (var _i = 0, payload_1 = payload; _i < payload_1.length; _i++) {
                        var item = payload_1[_i];
                        item.cnt = item.cnt || 0;
                        item.cnt++;
                        buffer[_DYN_ENQUEUE ](item);
                    }
                    _setRetryTime(linearFactor);
                    _setupTimer();
                }
                function _setRetryTime(linearFactor) {
                    var SlotDelayInSeconds = 10;
                    var delayInSeconds;
                    if (_consecutiveErrors <= 1) {
                        delayInSeconds = SlotDelayInSeconds;
                    }
                    else {
                        var backOffSlot = (Math.pow(2, _consecutiveErrors) - 1) / 2;
                        var backOffDelay = Math.floor(Math.random() * backOffSlot * SlotDelayInSeconds) + 1;
                        backOffDelay = linearFactor * backOffDelay;
                        delayInSeconds = Math.max(Math.min(backOffDelay, 3600), SlotDelayInSeconds);
                    }
                    var retryAfterTimeSpan = utcNow() + (delayInSeconds * 1000);
                    _retryAt = retryAfterTimeSpan;
                }
                function _setupTimer() {
                    if (!_timeoutHandle && !_paused) {
                        var retryInterval = _retryAt ? Math.max(0, _retryAt - utcNow()) : 0;
                        var timerValue = Math.max(_maxBatchInterval, retryInterval);
                        _timeoutHandle = scheduleTimeout(function () {
                            _timeoutHandle = null;
                            _self[_DYN_TRIGGER_SEND ](true, null, 1 );
                        }, timerValue);
                    }
                }
                function _clearScheduledTimer() {
                    _timeoutHandle && _timeoutHandle.cancel();
                    _timeoutHandle = null;
                    _retryAt = null;
                }
                function _isRetriable(statusCode) {
                    if (!isNullOrUndefined(_retryCodes)) {
                        return _retryCodes[_DYN_LENGTH ] && _retryCodes.indexOf(statusCode) > -1;
                    }
                    return statusCode === 401
                        || statusCode === 408
                        || statusCode === 429
                        || statusCode === 500
                        || statusCode === 502
                        || statusCode === 503
                        || statusCode === 504;
                }
                function _getNotifyMgr() {
                    var func = "getNotifyMgr";
                    if (_self.core[func]) {
                        return _self.core[func]();
                    }
                    return _self.core["_notificationManager"];
                }
                function _notifySendRequest(sendRequest, isAsync) {
                    var manager = _getNotifyMgr();
                    if (manager && manager[_DYN_EVENTS_SEND_REQUEST ]) {
                        try {
                            manager[_DYN_EVENTS_SEND_REQUEST ](sendRequest, isAsync);
                        }
                        catch (e) {
                            _throwInternal(_self[_DYN_DIAG_LOG ](), 1 , 74 , "send request notification failed: " + getExceptionName(e), { exception: dumpObj(e) });
                        }
                    }
                }
                function _validateInstrumentationKey(instrumentationKey, config) {
                    var disableValidation = config.disableInstrumentationKeyValidation;
                    var disableIKeyValidationFlag = isNullOrUndefined(disableValidation) ? false : disableValidation;
                    if (disableIKeyValidationFlag) {
                        return true;
                    }
                    var UUID_Regex = "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$";
                    var regexp = new RegExp(UUID_Regex);
                    return regexp.test(instrumentationKey);
                }
                function _initDefaults() {
                    _self[_DYN__SENDER ] = null;
                    _self[_DYN__BUFFER ] = null;
                    _self._appId = null;
                    _self._sample = null;
                    _headers = {};
                    _offlineListener = null;
                    _consecutiveErrors = 0;
                    _retryAt = null;
                    _paused = false;
                    _timeoutHandle = null;
                    _serializer = null;
                    _stamp_specific_redirects = 0;
                    _syncFetchPayload = 0;
                    _syncUnloadSender = null;
                    _evtNamespace = null;
                    _endpointUrl = null;
                    _orgEndpointUrl = null;
                    _maxBatchSizeInBytes = 0;
                    _beaconSupported = false;
                    _customHeaders = null;
                    _disableTelemetry = false;
                    _instrumentationKey = null;
                    _convertUndefined = UNDEFINED_VALUE;
                    _isRetryDisabled = false;
                    _sessionStorageUsed = null;
                    _namePrefix = UNDEFINED_VALUE;
                    _disableXhr = false;
                    _fetchKeepAlive = false;
                    _disableBeaconSplit = false;
                    _xhrSend = null;
                    _fallbackSend = null;
                    _sendPostMgr = null;
                    objDefine(_self, "_senderConfig", {
                        g: function () {
                            return objExtend({}, defaultAppInsightsChannelConfig);
                        }
                    });
                }
            });
            return _this;
        }
        Sender.constructEnvelope = function (orig, iKey, logger, convertUndefined) {
            var envelope;
            if (iKey !== orig.iKey && !isNullOrUndefined(iKey)) {
                envelope = __assignFn(__assignFn({}, orig), { iKey: iKey });
            }
            else {
                envelope = orig;
            }
            var creator = EnvelopeTypeCreator[envelope.baseType] || EventEnvelopeCreator;
            return creator(logger, envelope, convertUndefined);
        };
        return Sender;
    }(BaseTelemetryPlugin));

    var _DYN_INSTRUMENTATION_KEY = "instrumentationKey";
    var _DYN_CONNECTION_STRING = "connectionString";
    var _DYN_ENDPOINT_URL = "endpointUrl";
    var _DYN_USER_OVERRIDE_ENDPOI0 = "userOverrideEndpointUrl";

    var defaultConfigValues = {
        diagnosticLogInterval: cfgDfValidate(_chkDiagLevel, 10000)
    };
    function _chkDiagLevel(value) {
        return value && value > 0;
    }
    var ApplicationInsights = /** @class */ (function () {
        function ApplicationInsights(config) {
            var core = new AppInsightsCore();
            var _config;
            if (isNullOrUndefined(config) ||
                (isNullOrUndefined(config[_DYN_INSTRUMENTATION_KEY ]) && isNullOrUndefined(config[_DYN_CONNECTION_STRING ]))) {
                throwError("Invalid input configuration");
            }
            dynamicProto(ApplicationInsights, this, function (_self) {
                objDefine(_self, "config", {
                    g: function () { return _config; }
                });
                _initialize();
                _self.initialize = _initialize;
                _self.track = _track;
                proxyFunctions(_self, core, [
                    "flush",
                    "pollInternalLogs",
                    "stopPollingInternalLogs",
                    "unload",
                    "getPlugin",
                    "addPlugin",
                    "evtNamespace",
                    "addUnloadCb",
                    "onCfgChange"
                ]);
                function _initialize() {
                    var cfgHandler = createDynamicConfig(config || {}, defaultConfigValues);
                    _config = cfgHandler.cfg;
                    core.addUnloadHook(onConfigChange(cfgHandler, function () {
                        if (_config[_DYN_CONNECTION_STRING ]) {
                            var cs = parseConnectionString(_config[_DYN_CONNECTION_STRING ]);
                            var ingest = cs.ingestionendpoint;
                            _config[_DYN_ENDPOINT_URL ] = _config[_DYN_USER_OVERRIDE_ENDPOI0 ] ? _config[_DYN_USER_OVERRIDE_ENDPOI0 ] : (ingest + DEFAULT_BREEZE_PATH);
                            _config[_DYN_INSTRUMENTATION_KEY ] = cs.instrumentationkey || _config[_DYN_INSTRUMENTATION_KEY ];
                        }
                        _config[_DYN_ENDPOINT_URL ] = _config[_DYN_USER_OVERRIDE_ENDPOI0 ] ? _config[_DYN_USER_OVERRIDE_ENDPOI0 ] : _config[_DYN_ENDPOINT_URL ];
                    }));
                    core.initialize(_config, [new Sender()]);
                }
            });
            function _track(item) {
                if (item) {
                    item.baseData = item.baseData || {};
                    item.baseType = item.baseType || "EventData";
                }
                core.track(item);
            }
        }
        ApplicationInsights.__ieDyn=1;
        return ApplicationInsights;
    }());

    exports.AppInsightsCore = AppInsightsCore;
    exports.ApplicationInsights = ApplicationInsights;
    exports.Sender = Sender;
    exports.SeverityLevel = SeverityLevel;
    exports.arrForEach = arrForEach;
    exports.isNullOrUndefined = isNullOrUndefined;
    exports.proxyFunctions = proxyFunctions;
    exports.throwError = throwError;

}));
//# sourceMappingURL=applicationinsights-web-basic.js.map


/***/ }),

/***/ 700:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.oneDataSystemClientFactory = void 0;
/**
 * Configures 1DS properly and returns the core client object
 * @param key The ingestion key
 * @param xhrOverride An optional override to use for requests instead of the XHTMLRequest object. Useful for node environments
 * @returns The AI core object
 */
const getAICore = async (key, vscodeAPI, xhrOverride) => {
    const oneDs = await Promise.resolve().then(() => __importStar(__webpack_require__(/* webpackMode: "eager" */ 908)));
    const postPlugin = await Promise.resolve().then(() => __importStar(__webpack_require__(/* webpackMode: "eager" */ 879)));
    const appInsightsCore = new oneDs.AppInsightsCore();
    const collectorChannelPlugin = new postPlugin.PostChannel();
    // Configure the app insights core to send to collector++ and disable logging of debug info
    const coreConfig = {
        instrumentationKey: key,
        endpointUrl: "https://mobile.events.data.microsoft.com/OneCollector/1.0",
        loggingLevelTelemetry: 0,
        loggingLevelConsole: 0,
        disableCookiesUsage: true,
        disableDbgExt: true,
        disableInstrumentationKeyValidation: true,
        channels: [[
                collectorChannelPlugin
            ]]
    };
    if (xhrOverride) {
        coreConfig.extensionConfig = {};
        // Configure the channel to use a XHR Request override since it's not available in node
        const channelConfig = {
            alwaysUseXhrOverride: true,
            httpXHROverride: xhrOverride
        };
        coreConfig.extensionConfig[collectorChannelPlugin.identifier] = channelConfig;
    }
    const config = vscodeAPI.workspace.getConfiguration("telemetry");
    const internalTesting = config.get("internalTesting");
    appInsightsCore.initialize(coreConfig, []);
    appInsightsCore.addTelemetryInitializer((envelope) => {
        envelope["ext"] = envelope["ext"] ?? {};
        envelope["ext"]["web"] = envelope["ext"]["web"] ?? {};
        envelope["ext"]["web"]["consentDetails"] = "{\"GPC_DataSharingOptIn\":false}";
        // Only add the remaining flags when `telemetry.internalTesting` is enabled
        if (!internalTesting) {
            return;
        }
        envelope["ext"]["utc"] = envelope["ext"]["utc"] ?? {};
        // Sets it to be internal only based on Windows UTC flagging
        envelope["ext"]["utc"]["flags"] = 0x0000811ECD;
    });
    return appInsightsCore;
};
/**
 * Configures and creates a telemetry client using the 1DS sdk
 * @param key The ingestion key
 * @param xhrOverride An optional override to use for requests instead of the XHTMLRequest object. Useful for node environments
 */
const oneDataSystemClientFactory = async (key, vscodeAPI, xhrOverride) => {
    let appInsightsCore = await getAICore(key, vscodeAPI, xhrOverride);
    const flushOneDS = async () => {
        try {
            const flushPromise = new Promise((resolve, reject) => {
                if (!appInsightsCore) {
                    resolve();
                    return;
                }
                appInsightsCore.flush(true, (completedFlush) => {
                    if (!completedFlush) {
                        reject("Failed to flush app 1DS!");
                        return;
                    }
                });
            });
            return flushPromise;
        }
        catch (e) {
            throw new Error("Failed to flush 1DS!\n" + e.message);
        }
    };
    // Shape the app insights core from 1DS into a standard format
    const telemetryClient = {
        logEvent: (eventName, data) => {
            try {
                appInsightsCore?.track({
                    name: eventName,
                    baseData: { name: eventName, properties: data?.properties, measurements: data?.measurements }
                });
            }
            catch (e) {
                throw new Error("Failed to log event to app insights!\n" + e.message);
            }
        },
        flush: flushOneDS,
        dispose: async () => {
            const disposePromise = new Promise((resolve) => {
                if (!appInsightsCore) {
                    resolve();
                    return;
                }
                appInsightsCore.unload(false, () => {
                    resolve();
                    appInsightsCore = undefined;
                    return;
                }, 1000);
            });
            return disposePromise;
        }
    };
    return telemetryClient;
};
exports.oneDataSystemClientFactory = oneDataSystemClientFactory;
//# sourceMappingURL=1dsClientFactory.js.map

/***/ }),

/***/ 980:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.appInsightsClientFactory = void 0;
const applicationinsights_common_1 = __webpack_require__(983);
const util_1 = __webpack_require__(161);
const appInsightsClientFactory = async (key, xhrOverride, replacementOptions) => {
    let appInsightsClient;
    try {
        const basicAISDK = await Promise.resolve().then(() => __importStar(__webpack_require__(569)));
        const extensionConfig = {};
        if (xhrOverride) {
            // Configure the channel to use a XHR Request override since it's not available in node
            const channelConfig = {
                alwaysUseXhrOverride: true,
                httpXHROverride: xhrOverride
            };
            extensionConfig[applicationinsights_common_1.BreezeChannelIdentifier] = channelConfig;
        }
        appInsightsClient = new basicAISDK.ApplicationInsights({
            instrumentationKey: key,
            disableAjaxTracking: true,
            disableExceptionTracking: true,
            disableFetchTracking: true,
            disableCorrelationHeaders: true,
            disableCookiesUsage: true,
            autoTrackPageVisitTime: false,
            emitLineDelimitedJson: false,
            disableInstrumentationKeyValidation: true,
            extensionConfig,
        });
    }
    catch (e) {
        return Promise.reject(e);
    }
    // Sets the appinsights client into a standardized form
    const telemetryClient = {
        logEvent: (eventName, data) => {
            const properties = { ...data?.properties, ...data?.measurements };
            if (replacementOptions?.length) {
                util_1.TelemetryUtil.applyReplacements(properties, replacementOptions);
            }
            appInsightsClient?.track({
                name: eventName,
                data: properties,
                baseType: "EventData",
                baseData: { name: eventName, properties: data?.properties, measurements: data?.measurements }
            });
        },
        flush: async () => {
            appInsightsClient?.flush(false);
        },
        dispose: async () => {
            const unloadPromise = new Promise((resolve) => {
                appInsightsClient?.unload(true, () => {
                    resolve();
                    appInsightsClient = undefined;
                }, 1000);
            });
            return unloadPromise;
        }
    };
    return telemetryClient;
};
exports.appInsightsClientFactory = appInsightsClientFactory;
//# sourceMappingURL=appInsightsClientFactory.js.map

/***/ }),

/***/ 340:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseTelemetryReporter = void 0;
class BaseTelemetryReporter {
    constructor(telemetrySender, vscodeAPI, initializationOptions) {
        this.telemetrySender = telemetrySender;
        this.vscodeAPI = vscodeAPI;
        this.userOptIn = false;
        this.errorOptIn = false;
        this.disposables = [];
        this._onDidChangeTelemetryLevel = new this.vscodeAPI.EventEmitter();
        this.onDidChangeTelemetryLevel = this._onDidChangeTelemetryLevel.event;
        this.telemetryLogger = this.vscodeAPI.env.createTelemetryLogger(this.telemetrySender, initializationOptions);
        // Keep track of the user's opt-in status
        this.updateUserOptIn();
        this.telemetryLogger.onDidChangeEnableStates(() => {
            this.updateUserOptIn();
        });
    }
    /**
     * Updates the user's telemetry opt-in status
     */
    updateUserOptIn() {
        this.errorOptIn = this.telemetryLogger.isErrorsEnabled;
        this.userOptIn = this.telemetryLogger.isUsageEnabled;
        // The sender is lazy loaded so if telemetry is off it's not loaded in
        if (this.telemetryLogger.isErrorsEnabled || this.telemetryLogger.isUsageEnabled) {
            this.telemetrySender.instantiateSender();
        }
        this._onDidChangeTelemetryLevel.fire(this.telemetryLevel);
    }
    get telemetryLevel() {
        if (this.errorOptIn && this.userOptIn) {
            return "all";
        }
        else if (this.errorOptIn) {
            return "error";
        }
        else {
            return "off";
        }
    }
    /**
     * Internal function which logs telemetry events and takes extra options.
     * @param eventName The name of the event
     * @param properties The properties of the event
     * @param measurements The measurements (numeric values) to send with the event
     * @param sanitize Whether or not to sanitize to the properties and measures
     * @param dangerous Whether or not to ignore telemetry level
     */
    internalSendTelemetryEvent(eventName, properties, measurements, dangerous) {
        // If it's dangerous we skip going through the logger as the logger checks opt-in status, etc.
        if (dangerous) {
            this.telemetrySender.sendEventData(eventName, { properties, measurements });
        }
        else {
            this.telemetryLogger.logUsage(eventName, { properties, measurements });
        }
    }
    /**
     * Given an event name, some properties, and measurements sends a telemetry event.
     * Properties are sanitized on best-effort basis to remove sensitive data prior to sending.
     * @param eventName The name of the event
     * @param properties The properties to send with the event
     * @param measurements The measurements (numeric values) to send with the event
     */
    sendTelemetryEvent(eventName, properties, measurements) {
        this.internalSendTelemetryEvent(eventName, properties, measurements, false);
    }
    /**
     * Sends a raw (unsanitized) telemetry event with the given properties and measurements.
     * NOTE: This will not be logged to the output channel due to API limitations.
     * @param eventName The name of the event
     * @param properties The set of properties to add to the event in the form of a string key value pair
     * @param measurements The set of measurements to add to the event in the form of a string key  number value pair
     */
    sendRawTelemetryEvent(eventName, properties, measurements) {
        const modifiedProperties = { ...properties };
        for (const propertyKey of Object.keys(modifiedProperties ?? {})) {
            const propertyValue = modifiedProperties[propertyKey];
            if (typeof propertyKey === "string" && propertyValue !== undefined) {
                // Trusted values are not sanitized, which is what we want for raw telemetry
                modifiedProperties[propertyKey] = new this.vscodeAPI.TelemetryTrustedValue(typeof propertyValue === "string" ? propertyValue : propertyValue.value);
            }
        }
        this.sendTelemetryEvent(eventName, modifiedProperties, measurements);
    }
    /**
     * **DANGEROUS** Given an event name, some properties, and measurements sends a telemetry event without checking telemetry setting
     * Do not use unless in a controlled environment i.e. sending telmetry from a CI pipeline or testing during development
     * @param eventName The name of the event
     * @param properties The properties to send with the event
     * @param measurements The measurements (numeric values) to send with the event
     * @param sanitize Whether or not to sanitize to the properties and measures, defaults to true
     */
    sendDangerousTelemetryEvent(eventName, properties, measurements) {
        // Since telemetry is probably off when sending dangerously, we must start the sender
        this.telemetrySender.instantiateSender();
        this.internalSendTelemetryEvent(eventName, properties, measurements, true);
    }
    /**
     * Internal function which logs telemetry error events and takes extra options.
     * @param eventName The name of the event
     * @param properties The properties of the event
     * @param measurements The measurements (numeric values) to send with the event
     * @param sanitize Whether or not to sanitize to the properties and measures
     * @param dangerous Whether or not to ignore telemetry level
     */
    internalSendTelemetryErrorEvent(eventName, properties, measurements, dangerous) {
        if (dangerous) {
            this.telemetrySender.sendEventData(eventName, { properties, measurements });
        }
        else {
            this.telemetryLogger.logError(eventName, { properties, measurements });
        }
    }
    /**
     * Given an event name, some properties, and measurements sends an error event
     * @param eventName The name of the event
     * @param properties The properties to send with the event
     * @param measurements The measurements (numeric values) to send with the event
     */
    sendTelemetryErrorEvent(eventName, properties, measurements) {
        this.internalSendTelemetryErrorEvent(eventName, properties, measurements, false);
    }
    /**
     * **DANGEROUS** Given an event name, some properties, and measurements sends a telemetry error event without checking telemetry setting
     * Do not use unless in a controlled environment i.e. sending telmetry from a CI pipeline or testing during development
     * @param eventName The name of the event
     * @param properties The properties to send with the event
     * @param measurements The measurements (numeric values) to send with the event
     * @param sanitize Whether or not to run the properties and measures through sanitiziation, defaults to true
     */
    sendDangerousTelemetryErrorEvent(eventName, properties, measurements) {
        // Since telemetry is probably off when sending dangerously, we must start the sender
        this.telemetrySender.instantiateSender();
        this.internalSendTelemetryErrorEvent(eventName, properties, measurements, true);
    }
    /**
     * Disposes of the telemetry reporter
     */
    async dispose() {
        await this.telemetrySender.dispose();
        this.telemetryLogger.dispose();
        return Promise.all(this.disposables.map(d => d.dispose()));
    }
}
exports.BaseTelemetryReporter = BaseTelemetryReporter;
//# sourceMappingURL=baseTelemetryReporter.js.map

/***/ }),

/***/ 252:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseTelemetrySender = void 0;
var InstantiationStatus;
(function (InstantiationStatus) {
    InstantiationStatus[InstantiationStatus["NOT_INSTANTIATED"] = 0] = "NOT_INSTANTIATED";
    InstantiationStatus[InstantiationStatus["INSTANTIATING"] = 1] = "INSTANTIATING";
    InstantiationStatus[InstantiationStatus["INSTANTIATED"] = 2] = "INSTANTIATED";
})(InstantiationStatus || (InstantiationStatus = {}));
class BaseTelemetrySender {
    constructor(key, clientFactory) {
        // Whether or not the client has been instantiated
        this._instantiationStatus = InstantiationStatus.NOT_INSTANTIATED;
        // Queues used to store events until the sender is ready
        this._eventQueue = [];
        this._exceptionQueue = [];
        this._clientFactory = clientFactory;
        this._key = key;
    }
    /**
     * Sends the event to the passed in telemetry client
     * The sender does no telemetry level checks as those are done by the reporter.
     * @param eventName The name of the event to log
     * @param data The data contanied in the event
     */
    sendEventData(eventName, data) {
        if (!this._telemetryClient) {
            if (this._instantiationStatus !== InstantiationStatus.INSTANTIATED) {
                this._eventQueue.push({ eventName, data });
            }
            return;
        }
        this._telemetryClient.logEvent(eventName, data);
    }
    /**
     * Sends an exception to the passed in telemetry client
     * The sender does no telemetry level checks as those are done by the reporter.
     * @param exception The exception to collect
     * @param data Data associated with the exception
     */
    sendErrorData(exception, data) {
        if (!this._telemetryClient) {
            if (this._instantiationStatus !== InstantiationStatus.INSTANTIATED) {
                this._exceptionQueue.push({ exception, data });
            }
            return;
        }
        const errorData = { stack: exception.stack, message: exception.message, name: exception.name };
        if (data) {
            const errorProperties = data.properties || data;
            data.properties = { ...errorProperties, ...errorData };
        }
        else {
            data = { properties: errorData };
        }
        this._telemetryClient.logEvent("unhandlederror", data);
    }
    /**
     * Flushes the buffered telemetry data
     */
    async flush() {
        return this._telemetryClient?.flush();
    }
    async dispose() {
        if (this._telemetryClient) {
            await this._telemetryClient.dispose();
            this._telemetryClient = undefined;
        }
        return;
    }
    /**
     * Flushes the queued events that existed before the client was instantiated
     */
    _flushQueues() {
        this._eventQueue.forEach(({ eventName, data }) => this.sendEventData(eventName, data));
        this._eventQueue = [];
        this._exceptionQueue.forEach(({ exception, data }) => this.sendErrorData(exception, data));
        this._exceptionQueue = [];
    }
    /**
     * Instantiates the telemetry client to make the sender "active"
     */
    instantiateSender() {
        if (this._instantiationStatus !== InstantiationStatus.NOT_INSTANTIATED) {
            return;
        }
        this._instantiationStatus = InstantiationStatus.INSTANTIATING;
        // Call the client factory to get the client and then let it know it's instatntiated
        this._clientFactory(this._key).then(client => {
            this._telemetryClient = client;
            this._instantiationStatus = InstantiationStatus.INSTANTIATED;
            this._flushQueues();
        }).catch(err => {
            console.error(err);
            // If it failed to instntiate, then we don't want to try again.
            // So we mark it as instantiated. See #94
            this._instantiationStatus = InstantiationStatus.INSTANTIATED;
        });
    }
}
exports.BaseTelemetrySender = BaseTelemetrySender;
//# sourceMappingURL=baseTelemetrySender.js.map

/***/ }),

/***/ 161:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TelemetryUtil = void 0;
class TelemetryUtil {
    static applyReplacements(data, replacementOptions) {
        for (const key of Object.keys(data)) {
            for (const option of replacementOptions) {
                if (option.lookup.test(key)) {
                    if (option.replacementString !== undefined) {
                        data[key] = option.replacementString;
                    }
                    else {
                        delete data[key];
                    }
                }
            }
        }
    }
    /**
     * Given a key checks if it is a valid 1DS key
     * @param key The key to check if it's a valid 1DS key
     */
    static shouldUseOneDataSystemSDK(key) {
        // Simple to check to ensure the key is the right length and the dashes are in the right spot
        return (key.length === 74 &&
            key[32] === "-" &&
            key[41] === "-" &&
            key[46] === "-" &&
            key[51] === "-" &&
            key[56] === "-" &&
            key[69] === "-");
    }
    // This also includes the common properties which core mixes in
    // __GDPR__COMMON__ "common.os" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.nodeArch" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.platformversion" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.extname" : { "classification": "PublicNonPersonalData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.extversion" : { "classification": "PublicNonPersonalData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.vscodemachineid" : { "endPoint": "MacAddressHash", "classification": "EndUserPseudonymizedInformation", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.vscodesessionid" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.vscodeversion" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.uikind" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.remotename" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.isnewappinstall" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.product" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.telemetryclientversion" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    static getAdditionalCommonProperties(osShim) {
        return {
            "common.os": osShim.platform,
            "common.nodeArch": osShim.architecture,
            "common.platformversion": (osShim.release || "").replace(/^(\d+)(\.\d+)?(\.\d+)?(.*)/, "$1$2$3"),
            // Do not change this string as it gets found and replaced upon packaging
            "common.telemetryclientversion": "0.9.6"
        };
    }
    // Get singleton instance of TelemetryUtil
    static getInstance() {
        if (!TelemetryUtil._instance) {
            TelemetryUtil._instance = new TelemetryUtil();
        }
        return TelemetryUtil._instance;
    }
}
exports.TelemetryUtil = TelemetryUtil;
//# sourceMappingURL=util.js.map

/***/ }),

/***/ 754:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const os = __importStar(__webpack_require__(857));
const vscode = __importStar(__webpack_require__(398));
const https = __importStar(__webpack_require__(692));
const baseTelemetryReporter_1 = __webpack_require__(340);
const baseTelemetrySender_1 = __webpack_require__(252);
const util_1 = __webpack_require__(161);
const _1dsClientFactory_1 = __webpack_require__(700);
const appInsightsClientFactory_1 = __webpack_require__(980);
/**
 * Create a replacement for the XHTMLRequest object utilizing nodes HTTP module.
 * @returns A XHR override object used to override the XHTMLRequest object in the 1DS SDK
 */
function getXHROverride() {
    // Override the way events get sent since node doesn't have XHTMLRequest
    const customHttpXHROverride = {
        sendPOST: (payload, oncomplete) => {
            const options = {
                method: "POST",
                headers: {
                    ...payload.headers,
                    "Content-Type": "application/json",
                    "Content-Length": Buffer.byteLength(payload.data)
                }
            };
            try {
                const req = https.request(payload.urlString, options, res => {
                    res.on("data", function (responseData) {
                        oncomplete(res.statusCode ?? 200, res.headers, responseData.toString());
                    });
                    // On response with error send status of 0 and a blank response to oncomplete so we can retry events
                    res.on("error", function () {
                        oncomplete(0, {});
                    });
                });
                req.write(payload.data, (err) => {
                    if (err) {
                        oncomplete(0, {});
                    }
                });
                req.end();
            }
            catch {
                // If it errors out, send status of 0 and a blank response to oncomplete so we can retry events
                oncomplete(0, {});
            }
        }
    };
    return customHttpXHROverride;
}
class TelemetryReporter extends baseTelemetryReporter_1.BaseTelemetryReporter {
    constructor(key, replacementOptions) {
        let clientFactory = (key) => (0, appInsightsClientFactory_1.appInsightsClientFactory)(key, getXHROverride(), replacementOptions);
        // If key is usable by 1DS use the 1DS SDk
        if (util_1.TelemetryUtil.shouldUseOneDataSystemSDK(key)) {
            clientFactory = (key) => (0, _1dsClientFactory_1.oneDataSystemClientFactory)(key, vscode, getXHROverride());
        }
        const osShim = {
            release: os.release(),
            platform: os.platform(),
            architecture: os.arch(),
        };
        const sender = new baseTelemetrySender_1.BaseTelemetrySender(key, clientFactory);
        if (key && key.indexOf("AIF-") === 0) {
            throw new Error("AIF keys are no longer supported. Please switch to 1DS keys for 1st party extensions");
        }
        super(sender, vscode, { additionalCommonProperties: util_1.TelemetryUtil.getAdditionalCommonProperties(osShim) });
    }
}
exports["default"] = TelemetryReporter;
//# sourceMappingURL=telemetryReporter.js.map

/***/ }),

/***/ 604:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setAdditionalCompilerNames = exports.getAdditionalCompilerNames = exports.readCompileCommandsPath = exports.setCompileCommandsPath = exports.getCompileCommandsPath = exports.readConfigurationCachePath = exports.setConfigurationCachePath = exports.getConfigurationCachePath = exports.readAlwaysPostConfigure = exports.readAlwaysPreConfigure = exports.setAlwaysPostConfigure = exports.getAlwaysPostConfigure = exports.setAlwaysPreConfigure = exports.getAlwaysPreConfigure = exports.readPostConfigureArgs = exports.readPostConfigureScript = exports.readPreConfigureArgs = exports.readPreConfigureScript = exports.setPostConfigureArgs = exports.getPostConfigureArgs = exports.setPostConfigureScript = exports.getPostConfigureScript = exports.setPreConfigureArgs = exports.getPreConfigureArgs = exports.setPreConfigureScript = exports.getPreConfigureScript = exports.readExtensionLog = exports.setExtensionLog = exports.getExtensionLog = exports.readExtensionOutputFolder = exports.setExtensionOutputFolder = exports.getExtensionOutputFolder = exports.readLoggingLevel = exports.setLoggingLevel = exports.getLoggingLevel = exports.readBuildLog = exports.setBuildLog = exports.getBuildLog = exports.makeBaseDirectory = exports.setMakeDirectory = exports.getMakeDirectory = exports.setMakefilePath = exports.getMakefilePath = exports.setMakePath = exports.getMakePath = exports.disableAllOptionallyVisibleCommands = exports.isOptionalFeatureEnabled = exports.readCurrentMakefileConfiguration = exports.setCurrentMakefileConfiguration = exports.getCurrentMakefileConfiguration = void 0;
exports.getPhonyOnlyTargets = exports.readConfigureAfterCommand = exports.setConfigureAfterCommand = exports.getConfigureAfterCommand = exports.readConfigureOnEdit = exports.setConfigureOnEdit = exports.getConfigureOnEdit = exports.readConfigureOnOpen = exports.setConfigureOnOpen = exports.getConfigureOnOpen = exports.setCurrentTarget = exports.getCurrentTarget = exports.readMakefileConfigurations = exports.setMakefileConfigurations = exports.getMakefileConfigurations = exports.getPostConfigureArgsForConfiguration = exports.getPreConfigureArgsForConfiguration = exports.getBuildLogForConfiguration = exports.getProblemMatchersForConfiguration = exports.getCommandForConfiguration = exports.getMakefileConfiguration = exports.setConfigurationPostConfigureArgs = exports.getConfigurationPostConfigureArgs = exports.setConfigurationPreConfigureArgs = exports.getConfigurationPreConfigureArgs = exports.setConfigurationBuildLog = exports.getConfigurationBuildLog = exports.setConfigurationProblemMatchers = exports.getConfigurationProblemMatchers = exports.setConfigurationMakefile = exports.getConfigurationMakefile = exports.setConfigurationMakeArgs = exports.getConfigurationMakeArgs = exports.setConfigurationMakeCommand = exports.getConfigurationMakeCommand = exports.readDefaultLaunchConfiguration = exports.getDefaultLaunchConfiguration = exports.setCurrentLaunchConfiguration = exports.getCurrentLaunchConfiguration = exports.stringToLaunchConfiguration = exports.launchConfigurationToString = exports.setLaunchConfigurations = exports.getLaunchConfigurations = exports.readDryrunSwitches = exports.setDryrunSwitches = exports.getDryrunSwitches = exports.readExcludeCompilerNames = exports.setExcludeCompilerNames = exports.getExcludeCompilerNames = exports.readAdditionalCompilerNames = void 0;
exports.setLaunchTargets = exports.getLaunchTargets = exports.setBuildTargets = exports.getBuildTargets = exports.selectLaunchConfiguration = exports.setLaunchConfigurationByName = exports.selectTarget = exports.setTargetByName = exports.setNewConfiguration = exports.prepareConfigurationsQuickPick = exports.setConfigurationByName = exports.initFromSettings = exports.initFromState = exports.readIgnoreDirectoryCommands = exports.setIgnoreDirectoryCommands = exports.getIgnoreDirectoryCommands = exports.readClearOutputBeforeBuild = exports.setClearOutputBeforeBuild = exports.getClearOutputBeforeBuild = exports.readBuildBeforeLaunch = exports.setBuildBeforeLaunch = exports.getBuildBeforeLaunch = exports.readSaveBeforeBuildOrConfigure = exports.setSaveBeforeBuildOrConfigure = exports.getSaveBeforeBuildOrConfigure = exports.readPhonyOnlyTargets = exports.setPhonyOnlyTargets = void 0;
// Configuration support
const extension_1 = __webpack_require__(15);
const logger = __webpack_require__(464);
const make = __webpack_require__(970);
const ui = __webpack_require__(846);
const util = __webpack_require__(260);
const vscode = __webpack_require__(398);
const path = __webpack_require__(928);
const telemetry = __webpack_require__(277);
const nls = __webpack_require__(493);
nls.config({
    messageFormat: nls.MessageFormat.bundle,
    bundleFormat: nls.BundleFormat.standalone,
})((__webpack_require__(928).join)(__dirname, 'src\\configuration.ts'));
const localize = nls.loadMessageBundle((__webpack_require__(928).join)(__dirname, 'src\\configuration.ts'));
let statusBar = ui.getUI();
// Last configuration name picked from the set defined in makefile.configurations setting.
// Saved into the workspace state. Also reflected in the configuration status bar button.
// If no particular current configuration is defined in settings, set to 'Default'.
let currentMakefileConfiguration;
function getCurrentMakefileConfiguration() {
    return currentMakefileConfiguration;
}
exports.getCurrentMakefileConfiguration = getCurrentMakefileConfiguration;
async function setCurrentMakefileConfiguration(configuration) {
    currentMakefileConfiguration = configuration;
    statusBar.setConfiguration(currentMakefileConfiguration);
    await analyzeConfigureParams();
}
exports.setCurrentMakefileConfiguration = setCurrentMakefileConfiguration;
// Read the current configuration from workspace state, update status bar item
function readCurrentMakefileConfiguration() {
    let buildConfiguration = extension_1.extension.getState().buildConfiguration;
    if (!buildConfiguration) {
        logger.message(localize(0, null));
        currentMakefileConfiguration = "Default";
    }
    else {
        logger.message(localize(1, null, buildConfiguration));
        currentMakefileConfiguration = buildConfiguration;
    }
    statusBar.setConfiguration(currentMakefileConfiguration);
}
exports.readCurrentMakefileConfiguration = readCurrentMakefileConfiguration;
// To add an optional feature (one that can be enabled/disabled based
// on a property stored in settings.json):
// * define property under makefile.panel.visibility in package.json
// * initialize here the default values
// * if the feature controls the UI via enablement,
// *    make sure enablement is handled in package.json, you are done
// * if not, then add code to check Feature state wherever is needed.
class MakefilePanelVisibilityDescriptions {
    constructor() {
        this.features = [
            {
                propertyName: "debug",
                enablement: "makefile:localDebugFeature",
                default: true,
                value: false,
            },
            {
                propertyName: "run",
                enablement: "makefile:localRunFeature",
                default: true,
                value: false,
            },
        ];
    }
}
let panelVisibility = new MakefilePanelVisibilityDescriptions();
// Set all features to their defaults (enabled or disabled)
function initOptionalFeatures() {
    for (let feature of panelVisibility.features) {
        feature.value = feature.default;
    }
}
function isOptionalFeatureEnabled(propertyName) {
    for (let feature of panelVisibility.features) {
        if (feature.propertyName === propertyName) {
            return feature.value;
        }
    }
    return false;
}
exports.isOptionalFeatureEnabled = isOptionalFeatureEnabled;
// Override default settings for each feature based on workspace current information
async function updateOptionalFeaturesWithWorkspace() {
    // optionalFeatures will be set with default values.
    // override with values from the workspace
    let features = (await util.getExpandedSetting("panel.visibility")) || undefined;
    if (features) {
        if (Object.entries(features).length < panelVisibility.features.length) {
            // At least one feature is missing from the settings, which means we need to use defaults.
            // If we don't refresh defaults here, we won't cover the following scenario:
            //    - default TRUE feature
            //    - which was set to false in the settings, causing knownFeature.value to be false
            //    - just got removed from settings now, meaning it won't be included in the features varibale and the FOR won't loop through it
            //    giving it no opportunity to switch .value back to the default of TRUE.
            initOptionalFeatures();
        }
        for (let propEntry of Object.entries(features)) {
            for (let knownFeature of panelVisibility.features) {
                if (propEntry[0] === knownFeature.propertyName) {
                    knownFeature.value = propEntry[1];
                }
            }
        }
    }
    else {
        initOptionalFeatures(); // no info in workspace, use defaults
    }
}
function disableAllOptionallyVisibleCommands() {
    for (let feature of panelVisibility.features) {
        if (feature.enablement) {
            vscode.commands.executeCommand("setContext", feature.enablement, false);
        }
    }
}
exports.disableAllOptionallyVisibleCommands = disableAllOptionallyVisibleCommands;
function enableOptionallyVisibleCommands() {
    for (let feature of panelVisibility.features) {
        if (feature.enablement) {
            vscode.commands.executeCommand("setContext", feature.enablement, feature.value);
        }
    }
}
async function readFeaturesVisibility() {
    await updateOptionalFeaturesWithWorkspace();
}
let makePath;
function getMakePath() {
    return makePath;
}
exports.getMakePath = getMakePath;
function setMakePath(path) {
    makePath = path;
}
exports.setMakePath = setMakePath;
// Read the path (full or directory only) of the make tool if defined in settings.
// It represents a default to look for if no other path is already included
// in "makefile.configurations.makePath".
async function readMakePath() {
    makePath = await util.getExpandedSetting("makePath");
    if (!makePath) {
        logger.message(localize(2, null));
    }
}
let makefilePath;
function getMakefilePath() {
    return makefilePath;
}
exports.getMakefilePath = getMakefilePath;
function setMakefilePath(path) {
    makefilePath = path;
}
exports.setMakefilePath = setMakefilePath;
// Read the full path to the makefile if defined in settings.
// It represents a default to look for if no other makefile is already provided
// in makefile.configurations.makefilePath.
// TODO: validate and integrate with "-f [Makefile]" passed in makefile.configurations.makeArgs.
async function readMakefilePath() {
    makefilePath = await util.getExpandedSetting("makefilePath");
    if (!makefilePath) {
        logger.message(localize(3, null));
    }
    else {
        makefilePath = util.resolvePathToRoot(makefilePath);
    }
}
let makeDirectory;
function getMakeDirectory() {
    return makeDirectory;
}
exports.getMakeDirectory = getMakeDirectory;
function setMakeDirectory(dir) {
    makeDirectory = dir;
}
exports.setMakeDirectory = setMakeDirectory;
// Read the make working directory path if defined in settings.
// It represents a default to look for if no other makeDirectory is already provided
// in makefile.configurations.makeDirectory.
// TODO: validate and integrate with "-C [DIR_PATH]" passed in makefile.configurations.makeArgs.
async function readMakeDirectory() {
    makeDirectory = await util.getExpandedSetting("makeDirectory");
    if (!makeDirectory) {
        logger.message(localize(4, null));
    }
    else {
        makeDirectory = util.resolvePathToRoot(makeDirectory);
    }
}
// Command property accessible from launch.json:
// the folder in which the current "make" invocation operates:
// passed with -C (otherwise it is the workspace folder).
// Note: -f does not change the current working directory. It only points to a makefile somewhere else.
function makeBaseDirectory() {
    // In case more than one -C arguments are given to "make", it will chose the last one.
    // getConfigurationMakeArgs will contain the final command we calculate for the "make" executable.
    // We don't need to know here which -C gets pushed last (global makeDirectory,
    // configuration local makeDirectory or one in makeArgs). Just reverse to easily get the last one.
    const makeArgs = getConfigurationMakeArgs().concat().reverse();
    let prevArg = "";
    for (const arg of makeArgs) {
        if (arg === "-C") {
            return prevArg;
        }
        else if (arg.startsWith("--directory")) {
            const eqIdx = arg.indexOf("=");
            return arg.substring(eqIdx + 1, arg.length);
        }
        // Since we reversed the "make" command line arguments, the path of a -C will be seen before the switch.
        // Remember every previous argument to have it available in case we find the first -C.
        prevArg = arg;
    }
    return util.getWorkspaceRoot();
}
exports.makeBaseDirectory = makeBaseDirectory;
let buildLog;
function getBuildLog() {
    return buildLog;
}
exports.getBuildLog = getBuildLog;
function setBuildLog(path) {
    buildLog = path;
}
exports.setBuildLog = setBuildLog;
// Read from settings the path of the build log that is desired to be parsed
// instead of a dry-run command output.
// Useful for complex, tricky and corner case repos for which make --dry-run
// is not working as the extension expects.
// Example: --dry-run actually running configure commands, instead of only displaying them,
// possibly changing unexpectedly a previous configuration set by the repo developer.
// This scenario may also result in infinite loop, depending on how the makefile
// and the configuring process are written, thus making the extension unusable.
// Defining a build log to be parsed instead of a dry-run output represents a good alternative.
// Also useful for developing unit tests based on real world code,
// that would not clone a whole repo for testing.
// It is recommended to produce the build log with all the following commands,
// so that the extension has the best content to operate on.
//    --always-make (to make sure no target is skipped because it is up to date)
//    --keep-going (to not stumble on the first error)
//    --print-data-base (special verbose printing which this extension is using for parsing the makefile targets)
// If any of the above switches is missing, the extension may have less log to parse from,
// therefore offering less intellisense information for source files,
// identifying less possible binaries to debug or not providing any makefile targets (other than the 'all' default).
async function readBuildLog() {
    buildLog = await util.getExpandedSetting("buildLog");
    if (buildLog) {
        buildLog = util.resolvePathToRoot(buildLog);
        logger.message(localize(5, null, buildLog));
        if (!util.checkFileExistsSync(buildLog)) {
            logger.message(localize(6, null));
            return false;
        }
    }
    return true;
}
exports.readBuildLog = readBuildLog;
let loggingLevel;
function getLoggingLevel() {
    return loggingLevel;
}
exports.getLoggingLevel = getLoggingLevel;
function setLoggingLevel(logLevel) {
    loggingLevel = logLevel;
}
exports.setLoggingLevel = setLoggingLevel;
// Read from settings the desired logging level for the Makefile Tools extension.
async function readLoggingLevel() {
    loggingLevel =
        (await util.getExpandedSetting("loggingLevel")) || "Normal";
    logger.message(localize(7, null, loggingLevel));
}
exports.readLoggingLevel = readLoggingLevel;
let extensionOutputFolder;
function getExtensionOutputFolder() {
    return extensionOutputFolder;
}
exports.getExtensionOutputFolder = getExtensionOutputFolder;
function setExtensionOutputFolder(folder) {
    extensionOutputFolder = folder;
}
exports.setExtensionOutputFolder = setExtensionOutputFolder;
// Read from settings the path to a folder where the extension is dropping various output files
// (like extension.log, dry-run.log, targets.log).
// Useful to control where such potentially large files should reside.
async function readExtensionOutputFolder() {
    extensionOutputFolder = await util.getExpandedSetting("extensionOutputFolder");
    if (extensionOutputFolder) {
        extensionOutputFolder = util.resolvePathToRoot(extensionOutputFolder);
    }
    else {
        extensionOutputFolder = extension_1.extension.extensionContext.storagePath;
    }
    // Check one more time because the value can still be undefined if no folder was opened.
    if (extensionOutputFolder) {
        if (!util.checkDirectoryExistsSync(extensionOutputFolder)) {
            if (!util.createDirectorySync(extensionOutputFolder)) {
                extensionOutputFolder = extension_1.extension.extensionContext.storagePath;
                logger.message(localize(8, null, extensionOutputFolder));
                logger.message(localize(9, null, extensionOutputFolder));
                return;
            }
        }
        logger.message(localize(10, null, extensionOutputFolder));
    }
}
exports.readExtensionOutputFolder = readExtensionOutputFolder;
let extensionLog;
function getExtensionLog() {
    return extensionLog;
}
exports.getExtensionLog = getExtensionLog;
function setExtensionLog(path) {
    extensionLog = path;
}
exports.setExtensionLog = setExtensionLog;
// Read from settings the path to a log file capturing all the "Makefile Tools" output channel content.
// Useful for very large repos, which would produce with a single command a log larger
// than the "Makefile Tools" output channel capacity.
// Also useful for developing unit tests based on real world code,
// that would not clone a whole repo for testing.
// If an extension log is specified, its content is cleared during activation.
// Any messages that are being logged throughout the lifetime of the extension
// are going to be appended to this file.
async function readExtensionLog() {
    extensionLog = await util.getExpandedSetting("extensionLog");
    if (extensionLog) {
        // If there is a directory defined within the extension log path,
        // honor it and don't append to extensionOutputFolder.
        let parsePath = path.parse(extensionLog);
        if (extensionOutputFolder && !parsePath.dir) {
            extensionLog = path.join(extensionOutputFolder, extensionLog);
        }
        else {
            extensionLog = util.resolvePathToRoot(extensionLog);
        }
        logger.message(localize(11, null, extensionLog));
    }
}
exports.readExtensionLog = readExtensionLog;
let preConfigureScript;
function getPreConfigureScript() {
    return preConfigureScript;
}
exports.getPreConfigureScript = getPreConfigureScript;
function setPreConfigureScript(path) {
    preConfigureScript = path;
}
exports.setPreConfigureScript = setPreConfigureScript;
let preConfigureArgs = [];
function getPreConfigureArgs() {
    return preConfigureArgs;
}
exports.getPreConfigureArgs = getPreConfigureArgs;
function setPreConfigureArgs(args) {
    preConfigureArgs = args;
}
exports.setPreConfigureArgs = setPreConfigureArgs;
let postConfigureScript;
function getPostConfigureScript() {
    return postConfigureScript;
}
exports.getPostConfigureScript = getPostConfigureScript;
function setPostConfigureScript(path) {
    postConfigureScript = path;
}
exports.setPostConfigureScript = setPostConfigureScript;
let postConfigureArgs = [];
function getPostConfigureArgs() {
    return postConfigureArgs;
}
exports.getPostConfigureArgs = getPostConfigureArgs;
function setPostConfigureArgs(args) {
    postConfigureArgs = args;
}
exports.setPostConfigureArgs = setPostConfigureArgs;
// Read from settings the path to a script file that needs to have been run at least once
// before a sucessful configure of this project.
async function readPreConfigureScript() {
    preConfigureScript = await util.getExpandedSetting("preConfigureScript");
    if (preConfigureScript) {
        preConfigureScript = util.resolvePathToRoot(preConfigureScript);
        logger.message(localize(12, null, preConfigureScript));
        if (!util.checkFileExistsSync(preConfigureScript)) {
            logger.message(localize(13, null));
        }
    }
}
exports.readPreConfigureScript = readPreConfigureScript;
async function readPreConfigureArgs() {
    var _a;
    preConfigureArgs =
        (_a = (await util.getExpandedSetting("preConfigureArgs"))) !== null && _a !== void 0 ? _a : [];
    if (preConfigureArgs && preConfigureArgs.length > 0) {
        logger.message(localize(14, null, preConfigureArgs.join("', '")));
    }
}
exports.readPreConfigureArgs = readPreConfigureArgs;
async function readPostConfigureScript() {
    postConfigureScript = await util.getExpandedSetting("postConfigureScript");
    if (postConfigureScript) {
        postConfigureScript = util.resolvePathToRoot(postConfigureScript);
        logger.message(localize(15, null, postConfigureScript));
        if (!util.checkFileExistsSync(postConfigureScript)) {
            logger.message(localize(16, null));
        }
    }
}
exports.readPostConfigureScript = readPostConfigureScript;
async function readPostConfigureArgs() {
    var _a;
    postConfigureArgs =
        (_a = (await util.getExpandedSetting("postConfigureArgs"))) !== null && _a !== void 0 ? _a : [];
    if (postConfigureArgs && postConfigureArgs.length > 0) {
        logger.message(localize(17, null, postConfigureArgs.join("', '")));
    }
}
exports.readPostConfigureArgs = readPostConfigureArgs;
let alwaysPreConfigure;
function getAlwaysPreConfigure() {
    return alwaysPreConfigure;
}
exports.getAlwaysPreConfigure = getAlwaysPreConfigure;
function setAlwaysPreConfigure(path) {
    alwaysPreConfigure = path;
}
exports.setAlwaysPreConfigure = setAlwaysPreConfigure;
let alwaysPostConfigure;
function getAlwaysPostConfigure() {
    return alwaysPostConfigure;
}
exports.getAlwaysPostConfigure = getAlwaysPostConfigure;
function setAlwaysPostConfigure(path) {
    alwaysPostConfigure = path;
}
exports.setAlwaysPostConfigure = setAlwaysPostConfigure;
// Read from settings whether the pre-configure step is supposed to be executed
// always before the configure operation.
async function readAlwaysPreConfigure() {
    alwaysPreConfigure = await util.getExpandedSetting("alwaysPreConfigure");
    logger.message(localize(18, null, alwaysPreConfigure));
}
exports.readAlwaysPreConfigure = readAlwaysPreConfigure;
async function readAlwaysPostConfigure() {
    alwaysPostConfigure = await util.getExpandedSetting("alwaysPostConfigure");
    logger.message(localize(19, null, alwaysPostConfigure));
}
exports.readAlwaysPostConfigure = readAlwaysPostConfigure;
let configurationCachePath;
function getConfigurationCachePath() {
    return configurationCachePath;
}
exports.getConfigurationCachePath = getConfigurationCachePath;
function setConfigurationCachePath(path) {
    configurationCachePath = path;
}
exports.setConfigurationCachePath = setConfigurationCachePath;
// Read from settings the path to a cache file containing the output of the last dry-run make command.
// This file is recreated when opening a project, when changing the build configuration or the build target
// and when the settings watcher detects a change of any properties that may impact the dryrun output.
async function readConfigurationCachePath() {
    let oldConfigurationCachePath = configurationCachePath;
    configurationCachePath = await util.getExpandedSetting("configurationCachePath");
    if (!configurationCachePath && extensionOutputFolder) {
        configurationCachePath = path.join(extensionOutputFolder, "configurationCache.log");
    }
    if (configurationCachePath) {
        // If there is a directory defined within the configuration cache path,
        // honor it and don't append to extensionOutputFolder.
        let parsePath = path.parse(configurationCachePath);
        if (extensionOutputFolder && !parsePath.dir) {
            configurationCachePath = path.join(extensionOutputFolder, configurationCachePath);
        }
        else {
            configurationCachePath = util.resolvePathToRoot(configurationCachePath);
        }
        if (oldConfigurationCachePath !== configurationCachePath) {
            logger.message(localize(20, null, configurationCachePath));
        }
    }
}
exports.readConfigurationCachePath = readConfigurationCachePath;
let compileCommandsPath;
function getCompileCommandsPath() {
    return compileCommandsPath;
}
exports.getCompileCommandsPath = getCompileCommandsPath;
function setCompileCommandsPath(path) {
    compileCommandsPath = path;
}
exports.setCompileCommandsPath = setCompileCommandsPath;
async function readCompileCommandsPath() {
    compileCommandsPath = await util.getExpandedSetting("compileCommandsPath");
    if (compileCommandsPath) {
        compileCommandsPath = util.resolvePathToRoot(compileCommandsPath);
    }
    logger.message(localize(21, null, compileCommandsPath));
}
exports.readCompileCommandsPath = readCompileCommandsPath;
let additionalCompilerNames;
function getAdditionalCompilerNames() {
    return additionalCompilerNames;
}
exports.getAdditionalCompilerNames = getAdditionalCompilerNames;
function setAdditionalCompilerNames(compilerNames) {
    additionalCompilerNames = compilerNames;
}
exports.setAdditionalCompilerNames = setAdditionalCompilerNames;
async function readAdditionalCompilerNames() {
    additionalCompilerNames = await util.getExpandedSetting("additionalCompilerNames");
    if (additionalCompilerNames && additionalCompilerNames.length > 0) {
        logger.message(localize(22, null, additionalCompilerNames === null || additionalCompilerNames === void 0 ? void 0 : additionalCompilerNames.join("', '")));
    }
}
exports.readAdditionalCompilerNames = readAdditionalCompilerNames;
let excludeCompilerNames;
function getExcludeCompilerNames() {
    return excludeCompilerNames;
}
exports.getExcludeCompilerNames = getExcludeCompilerNames;
function setExcludeCompilerNames(compilerNames) {
    excludeCompilerNames = compilerNames;
}
exports.setExcludeCompilerNames = setExcludeCompilerNames;
async function readExcludeCompilerNames() {
    excludeCompilerNames = await util.getExpandedSetting("excludeCompilerNames");
    if (excludeCompilerNames && excludeCompilerNames.length > 0) {
        logger.message(localize(23, null, excludeCompilerNames === null || excludeCompilerNames === void 0 ? void 0 : excludeCompilerNames.join("', '")));
    }
}
exports.readExcludeCompilerNames = readExcludeCompilerNames;
let dryrunSwitches;
function getDryrunSwitches() {
    return dryrunSwitches;
}
exports.getDryrunSwitches = getDryrunSwitches;
function setDryrunSwitches(switches) {
    dryrunSwitches = switches;
}
exports.setDryrunSwitches = setDryrunSwitches;
// Read from settings the dry-run switches array. If there is no user definition, the defaults are:
//   --always-make: to not skip over up-to-date targets
//   --keep-going: to not stop at the first error that is encountered
//   --print-data-base: to generate verbose log output that can be parsed to identify all the makefile targets
// Some code bases have various issues with the above make parameters: infrastructure (not build) errors,
// infinite reconfiguration loops, resulting in the extension being unusable.
// To work around this, the setting makefile.dryrunSwitches is providing a way to skip over the problematic make arguments,
// even if this results in not ideal behavior: less information available to be parsed, which leads to incomplete IntelliSense or missing targets.
async function readDryrunSwitches() {
    dryrunSwitches = await util.getExpandedSetting("dryrunSwitches");
    if (dryrunSwitches && dryrunSwitches.length > 0) {
        logger.message(localize(24, null, dryrunSwitches === null || dryrunSwitches === void 0 ? void 0 : dryrunSwitches.join("', '")));
    }
}
exports.readDryrunSwitches = readDryrunSwitches;
let launchConfigurations = [];
function getLaunchConfigurations() {
    return launchConfigurations;
}
exports.getLaunchConfigurations = getLaunchConfigurations;
function setLaunchConfigurations(configurations) {
    launchConfigurations = configurations;
}
exports.setLaunchConfigurations = setLaunchConfigurations;
// Read launch configurations defined by the user in settings: makefile.launchConfigurations[]
async function readLaunchConfigurations() {
    launchConfigurations =
        (await util.getExpandedSetting("launchConfigurations")) || [];
}
// Helper used to fill the launch configurations quick pick.
// The input object for this method is either read from the settings or it is an object
// constructed by the parser while analyzing the dry-run output (or the build log),
// when the extension is trying to determine if and how (from what folder, with what arguments)
// the makefile is invoking any of the programs that are built by the current target.
// Properties other than cwd, binary path and args could be manually defined by the user
// in settings (after the extension creates a first minimal launch configuration object) and are not relevant
// for the strings being used to populate the quick pick.
// Syntax:
//    [CWD path]>[binaryPath]([binaryArg1,binaryArg2,binaryArg3,...])
function launchConfigurationToString(configuration) {
    let binPath = util.makeRelPath(configuration.binaryPath, configuration.cwd);
    let binArgs = configuration.binaryArgs.join(",");
    return `${configuration.cwd}>${binPath}(${binArgs})`;
}
exports.launchConfigurationToString = launchConfigurationToString;
// Helper used to construct a minimal launch configuration object
// (only cwd, binary path and arguments) from a string that respects
// the syntax of its quick pick.
async function stringToLaunchConfiguration(str) {
    let regexp = /(.*)\>(.*)\((.*)\)/gm;
    let match = regexp.exec(str);
    if (match) {
        let fullPath = await util.makeFullPath(match[2], match[1]);
        let splitArgs = match[3] === "" ? [] : match[3].split(",");
        return {
            cwd: match[1],
            binaryPath: fullPath,
            binaryArgs: splitArgs,
        };
    }
    else {
        return undefined;
    }
}
exports.stringToLaunchConfiguration = stringToLaunchConfiguration;
let currentLaunchConfiguration;
function getCurrentLaunchConfiguration() {
    return currentLaunchConfiguration;
}
exports.getCurrentLaunchConfiguration = getCurrentLaunchConfiguration;
async function setCurrentLaunchConfiguration(configuration) {
    currentLaunchConfiguration = configuration;
    let launchConfigStr = currentLaunchConfiguration
        ? launchConfigurationToString(currentLaunchConfiguration)
        : "";
    statusBar.setLaunchConfiguration(launchConfigStr);
    await extension_1.extension._projectOutlineProvider.updateLaunchTarget(launchConfigStr);
}
exports.setCurrentLaunchConfiguration = setCurrentLaunchConfiguration;
function getLaunchConfiguration(name) {
    return launchConfigurations.find((k) => {
        if (launchConfigurationToString(k) === name) {
            return { ...k, keep: true };
        }
    });
}
// Construct the current launch configuration object:
// Read the identifier from workspace state storage, then find the corresponding object
// in the launch configurations array from settings.
// Also update the status bar item.
async function readCurrentLaunchConfiguration() {
    await readLaunchConfigurations();
    let currentLaunchConfigurationName = extension_1.extension.getState().launchConfiguration;
    if (currentLaunchConfigurationName) {
        currentLaunchConfiguration = getLaunchConfiguration(currentLaunchConfigurationName);
    }
    let launchConfigStr = "No launch configuration set.";
    if (currentLaunchConfiguration) {
        launchConfigStr = launchConfigurationToString(currentLaunchConfiguration);
        logger.message(localize(25, null, launchConfigStr));
    }
    else {
        // A null launch configuration after a non empty launch configuration string name
        // means that the name stored in the project state does not match any of the entries in settings.
        // This typically happens after the user modifies manually "makefile.launchConfigurations"
        // in the .vscode/settings.json, specifically the entry that corresponds to the current launch configuration.
        // Make sure to unset the launch configuration in this scenario.
        if (currentLaunchConfigurationName !== undefined &&
            currentLaunchConfigurationName !== "") {
            logger.message(localize(26, null, currentLaunchConfigurationName));
            await setLaunchConfigurationByName("");
        }
        else {
            logger.message(localize(27, null));
        }
    }
    statusBar.setLaunchConfiguration(launchConfigStr);
    await extension_1.extension._projectOutlineProvider.updateLaunchTarget(launchConfigStr);
}
let defaultLaunchConfiguration;
function getDefaultLaunchConfiguration() {
    return defaultLaunchConfiguration;
}
exports.getDefaultLaunchConfiguration = getDefaultLaunchConfiguration;
// No setter needed. Currently only the user can define makefile.defaultLaunchConfiguration
async function readDefaultLaunchConfiguration() {
    defaultLaunchConfiguration =
        await util.getExpandedSetting("defaultLaunchConfiguration");
    logger.message(localize(28, null, defaultLaunchConfiguration === null || defaultLaunchConfiguration === void 0 ? void 0 : defaultLaunchConfiguration.MIMode, defaultLaunchConfiguration === null || defaultLaunchConfiguration === void 0 ? void 0 : defaultLaunchConfiguration.miDebuggerPath, defaultLaunchConfiguration === null || defaultLaunchConfiguration === void 0 ? void 0 : defaultLaunchConfiguration.stopAtEntry, defaultLaunchConfiguration === null || defaultLaunchConfiguration === void 0 ? void 0 : defaultLaunchConfiguration.symbolSearchPath));
}
exports.readDefaultLaunchConfiguration = readDefaultLaunchConfiguration;
// Command name and args are used when building from within the VS Code Makefile Tools Extension,
// when parsing all the targets that exist and when updating the cpptools configuration provider
// for IntelliSense.
let configurationMakeCommand;
function getConfigurationMakeCommand() {
    return configurationMakeCommand;
}
exports.getConfigurationMakeCommand = getConfigurationMakeCommand;
function setConfigurationMakeCommand(name) {
    configurationMakeCommand = name;
}
exports.setConfigurationMakeCommand = setConfigurationMakeCommand;
let configurationMakeArgs = [];
function getConfigurationMakeArgs() {
    return configurationMakeArgs;
}
exports.getConfigurationMakeArgs = getConfigurationMakeArgs;
function setConfigurationMakeArgs(args) {
    configurationMakeArgs = args;
}
exports.setConfigurationMakeArgs = setConfigurationMakeArgs;
// The following (makefile, problem matchers, build log), same as command&args above
// are deduced via a set of rules of defaults and overrides that we calculate only when necessary
// and access the last result otherwise.
let configurationMakefile;
function getConfigurationMakefile() {
    return configurationMakefile;
}
exports.getConfigurationMakefile = getConfigurationMakefile;
function setConfigurationMakefile(makefilePath) {
    configurationMakefile = makefilePath;
}
exports.setConfigurationMakefile = setConfigurationMakefile;
let configurationProblemMatchers = [];
function getConfigurationProblemMatchers() {
    return configurationProblemMatchers;
}
exports.getConfigurationProblemMatchers = getConfigurationProblemMatchers;
function setConfigurationProblemMatchers(problemMatchers) {
    configurationProblemMatchers = problemMatchers;
}
exports.setConfigurationProblemMatchers = setConfigurationProblemMatchers;
let configurationBuildLog;
function getConfigurationBuildLog() {
    return configurationBuildLog;
}
exports.getConfigurationBuildLog = getConfigurationBuildLog;
function setConfigurationBuildLog(name) {
    configurationBuildLog = name;
}
exports.setConfigurationBuildLog = setConfigurationBuildLog;
let configurationPreConfigureArgs = [];
function getConfigurationPreConfigureArgs() {
    return configurationPreConfigureArgs;
}
exports.getConfigurationPreConfigureArgs = getConfigurationPreConfigureArgs;
function setConfigurationPreConfigureArgs(args) {
    configurationPreConfigureArgs = args;
}
exports.setConfigurationPreConfigureArgs = setConfigurationPreConfigureArgs;
let configurationPostConfigureArgs = [];
function getConfigurationPostConfigureArgs() {
    return configurationPostConfigureArgs;
}
exports.getConfigurationPostConfigureArgs = getConfigurationPostConfigureArgs;
function setConfigurationPostConfigureArgs(args) {
    configurationPostConfigureArgs = args;
}
exports.setConfigurationPostConfigureArgs = setConfigurationPostConfigureArgs;
// Analyze the settings of the current makefile configuration and the global workspace settings,
// according to various merging rules and decide what make command and build log
// apply to the current makefile configuration.
async function analyzeConfigureParams() {
    getBuildLogForConfiguration(currentMakefileConfiguration);
    await getCommandForConfiguration(currentMakefileConfiguration);
    getProblemMatchersForConfiguration(currentMakefileConfiguration);
    getPreConfigureArgsForConfiguration(currentMakefileConfiguration);
    getPostConfigureArgsForConfiguration(currentMakefileConfiguration);
}
function getMakefileConfiguration(configuration) {
    return makefileConfigurations.find((k) => {
        if (k.name === configuration) {
            return k;
        }
    });
}
exports.getMakefileConfiguration = getMakefileConfiguration;
// Helper to find in the array of MakefileConfiguration which command/args correspond to a configuration name.
// Higher level settings (like makefile.makePath, makefile.makefilePath or makefile.makeDirectory)
// also have an additional effect on the final command.
async function getCommandForConfiguration(configuration) {
    let makefileConfiguration = getMakefileConfiguration(configuration);
    let makeParsedPathSettings = makePath
        ? path.parse(makePath)
        : undefined;
    let makeParsedPathConfigurations = (makefileConfiguration === null || makefileConfiguration === void 0 ? void 0 : makefileConfiguration.makePath)
        ? path.parse(makefileConfiguration === null || makefileConfiguration === void 0 ? void 0 : makefileConfiguration.makePath)
        : undefined;
    configurationMakeArgs = [];
    // Name of the make tool can be defined as makePath in makefile.configurations or as makefile.makePath.
    // When none defined, default to "make".
    configurationMakeCommand =
        (makeParsedPathConfigurations === null || makeParsedPathConfigurations === void 0 ? void 0 : makeParsedPathConfigurations.base) ||
            (makeParsedPathSettings === null || makeParsedPathSettings === void 0 ? void 0 : makeParsedPathSettings.base) ||
            "make";
    let configurationMakeCommandExtension = (makeParsedPathConfigurations === null || makeParsedPathConfigurations === void 0 ? void 0 : makeParsedPathConfigurations.ext) || (makeParsedPathSettings === null || makeParsedPathSettings === void 0 ? void 0 : makeParsedPathSettings.ext);
    // Prepend the directory path, if defined in either makefile.configurations or makefile.makePath (first has priority).
    let configurationCommandPath = (makeParsedPathConfigurations === null || makeParsedPathConfigurations === void 0 ? void 0 : makeParsedPathConfigurations.dir) || (makeParsedPathSettings === null || makeParsedPathSettings === void 0 ? void 0 : makeParsedPathSettings.dir) || "";
    configurationMakeCommand = path.join(configurationCommandPath, configurationMakeCommand);
    // Add "make" when only a directory path was specified.
    if (util.checkDirectoryExistsSync(configurationMakeCommand)) {
        configurationMakeCommand = path.join(configurationMakeCommand, "make");
    }
    // Add the ".exe" extension on windows if no extension was specified, otherwise the file search APIs don't find it.
    if (process.platform === "win32" &&
        configurationMakeCommandExtension === "") {
        configurationMakeCommand += ".exe";
    }
    // Add the makefile path via the -f make switch.
    // makefile.configurations.makefilePath overwrites makefile.makefilePath.
    configurationMakefile = (makefileConfiguration === null || makefileConfiguration === void 0 ? void 0 : makefileConfiguration.makefilePath)
        ? util.resolvePathToRoot(makefileConfiguration === null || makefileConfiguration === void 0 ? void 0 : makefileConfiguration.makefilePath)
        : makefilePath;
    if (configurationMakefile) {
        // check if the makefile path is a directory. If so, try adding `Makefile` or `makefile`
        if (util.checkDirectoryExistsSync(configurationMakefile)) {
            let makeFileTest = path.join(configurationMakefile, "Makefile");
            if (!util.checkFileExistsSync(makeFileTest)) {
                makeFileTest = path.join(configurationMakefile, "makefile");
            }
            // if we found the makefile in the directory, set the `configurationMakefile` to the found file path.
            if (util.checkFileExistsSync(makeFileTest)) {
                configurationMakefile = makeFileTest;
            }
        }
        configurationMakeArgs.push("-f");
        configurationMakeArgs.push(`${configurationMakefile}`);
        // Need to rethink this (GitHub 59).
        // Some repos don't work when we automatically add -C, others don't work when we don't.
        // configurationMakeArgs.push("-C");
        // configurationMakeArgs.push(path.parse(configurationMakefile).dir);
    }
    // Add the working directory path via the -C switch.
    // makefile.configurations.makeDirectory overwrites makefile.makeDirectory.
    let makeDirectoryUsed = (makefileConfiguration === null || makefileConfiguration === void 0 ? void 0 : makefileConfiguration.makeDirectory)
        ? util.resolvePathToRoot(makefileConfiguration === null || makefileConfiguration === void 0 ? void 0 : makefileConfiguration.makeDirectory)
        : makeDirectory;
    if (makeDirectoryUsed) {
        configurationMakeArgs.push("-C");
        configurationMakeArgs.push(`${makeDirectoryUsed}`);
    }
    // Make sure we append "makefile.configurations[].makeArgs" last, in case the developer wants to overwrite any arguments that the extension
    // deduces from the settings. Additionally, for -f/-C, resolve path to root.
    if (makefileConfiguration === null || makefileConfiguration === void 0 ? void 0 : makefileConfiguration.makeArgs) {
        let prevArg = "";
        makefileConfiguration.makeArgs.forEach((arg) => {
            if (prevArg === "-C") {
                configurationMakeArgs.push(util.resolvePathToRoot(arg));
            }
            else if (arg.startsWith("--directory")) {
                const eqIdx = arg.indexOf("=");
                const folderStr = arg.substring(eqIdx + 1, arg.length);
                configurationMakeArgs.push(`--directory=${util.resolvePathToRoot(folderStr)}`);
            }
            else {
                configurationMakeArgs.push(arg);
            }
            prevArg = arg;
        });
    }
    if (configurationMakeCommand) {
        logger.message(localize(29, null, `${configurationMakeCommand} ${configurationMakeArgs.join(" ")}`, configuration));
    }
    // Check for makefile path on disk: we search first for any makefile specified via the makefilePath setting,
    // then via the makeDirectory setting and then in the root of the workspace. On linux/mac, it often is 'Makefile', so verify that we default to the right filename.
    if (!configurationMakefile) {
        if (makeDirectoryUsed) {
            configurationMakefile = util.resolvePathToRoot(path.join(makeDirectoryUsed, "Makefile"));
            if (!util.checkFileExistsSync(configurationMakefile)) {
                configurationMakefile = util.resolvePathToRoot(path.join(makeDirectoryUsed, "makefile"));
            }
        }
        else {
            configurationMakefile = util.resolvePathToRoot("./Makefile");
            if (!util.checkFileExistsSync(configurationMakefile)) {
                configurationMakefile = util.resolvePathToRoot("./makefile");
            }
        }
    }
    // Validation and warnings about properly defining the makefile and make tool.
    // These are not needed if the current configuration reads from a build log instead of dry-run output.
    let buildLog = getConfigurationBuildLog();
    let buildLogContent = buildLog
        ? util.readFile(buildLog)
        : undefined;
    if (!buildLogContent) {
        if ((!makeParsedPathSettings || makeParsedPathSettings.name === "") &&
            (!makeParsedPathConfigurations ||
                makeParsedPathConfigurations.name === "")) {
            logger.message(localize(30, null));
        }
        // If configuration command has a path (absolute or relative), check if it exists on disk and error if not.
        // If no path is given to the make tool, search all paths in the environment and error if make is not on the path.
        if (configurationCommandPath !== "") {
            if (!util.checkFileExistsSync(configurationMakeCommand)) {
                logger.message(localize(31, null));
                // How often location settings don't work (maybe because not yet expanding variables)?
                const telemetryProperties = {
                    reason: "not found at path given in settings",
                };
                telemetry.logEvent("makeNotFound", telemetryProperties);
            }
        }
        else {
            const makeBaseName = path.parse(configurationMakeCommand).base;
            const makePathInEnv = util.toolPathInEnv(makeBaseName);
            if (!makePathInEnv) {
                logger.message(localize(32, null));
                // Do the users need an environment automatically set by the extension?
                // With a kits feature or expanding on the pre-configure script.
                const telemetryProperties = {
                    reason: "not found in environment path",
                };
                telemetry.logEvent("makeNotFound", telemetryProperties);
            }
        }
        if (!util.checkFileExistsSync(configurationMakefile)) {
            logger.message(localize(33, null));
            // we may need more advanced ability to process settings
            // insight into different project structures
            const telemetryProperties = {
                reason: (makefileConfiguration === null || makefileConfiguration === void 0 ? void 0 : makefileConfiguration.makefilePath) || makefilePath
                    ? "not found at path given in settings"
                    : makeDirectoryUsed
                        ? "not found in -C provided make directory"
                        : "not found in workspace root",
            };
            telemetry.logEvent("makefileNotFound", telemetryProperties);
            await extension_1.extension.setFullFeatureSet(false);
            disableAllOptionallyVisibleCommands();
        }
        else {
            if (vscode.workspace.isTrusted) {
                // full feature set ON only for trusted workspaces
                await extension_1.extension.setFullFeatureSet(true);
                enableOptionallyVisibleCommands();
            }
        }
    }
    else {
        // If we have a build log, then we want Makefile Tools to be fully active and the UI visible,
        // unless the workspace is untrusted.
        if (vscode.workspace.isTrusted) {
            await extension_1.extension.setFullFeatureSet(true);
            enableOptionallyVisibleCommands();
        }
    }
}
exports.getCommandForConfiguration = getCommandForConfiguration;
// Helper to find in the array of MakefileConfiguration which problemMatchers correspond to a configuration name
function getProblemMatchersForConfiguration(configuration) {
    let makefileConfiguration = getMakefileConfiguration(configuration);
    configurationProblemMatchers = (makefileConfiguration === null || makefileConfiguration === void 0 ? void 0 : makefileConfiguration.problemMatchers) || [];
}
exports.getProblemMatchersForConfiguration = getProblemMatchersForConfiguration;
// Helper to find in the array of MakefileConfiguration which buildLog correspond to a configuration name
function getBuildLogForConfiguration(configuration) {
    let makefileConfiguration = getMakefileConfiguration(configuration);
    configurationBuildLog = makefileConfiguration === null || makefileConfiguration === void 0 ? void 0 : makefileConfiguration.buildLog;
    if (configurationBuildLog) {
        logger.message(localize(34, null, configurationBuildLog, configuration));
        if (!path.isAbsolute(configurationBuildLog)) {
            configurationBuildLog = path.join(util.getWorkspaceRoot(), configurationBuildLog);
            logger.message(localize(35, null, configurationBuildLog));
        }
        if (!util.checkFileExistsSync(configurationBuildLog)) {
            logger.message(localize(36, null));
        }
    }
    else {
        // Default to an eventual build log defined in settings
        // If that one is not found on disk, the setting reader already warned about it.
        configurationBuildLog = buildLog;
    }
}
exports.getBuildLogForConfiguration = getBuildLogForConfiguration;
function getPreConfigureArgsForConfiguration(configuration) {
    let makefileConfiguration = getMakefileConfiguration(configuration);
    const localPreConfigArgs = makefileConfiguration === null || makefileConfiguration === void 0 ? void 0 : makefileConfiguration.preConfigureArgs;
    if (localPreConfigArgs) {
        configurationPreConfigureArgs = localPreConfigArgs;
    }
    else {
        configurationPreConfigureArgs = preConfigureArgs;
    }
}
exports.getPreConfigureArgsForConfiguration = getPreConfigureArgsForConfiguration;
function getPostConfigureArgsForConfiguration(configuration) {
    let makefileConfiguration = getMakefileConfiguration(configuration);
    const localPostConfigArgs = makefileConfiguration === null || makefileConfiguration === void 0 ? void 0 : makefileConfiguration.postConfigureArgs;
    if (localPostConfigArgs) {
        configurationPostConfigureArgs = localPostConfigArgs;
    }
    else {
        configurationPostConfigureArgs = postConfigureArgs;
    }
}
exports.getPostConfigureArgsForConfiguration = getPostConfigureArgsForConfiguration;
let makefileConfigurations = [];
function getMakefileConfigurations() {
    return makefileConfigurations;
}
exports.getMakefileConfigurations = getMakefileConfigurations;
function setMakefileConfigurations(configurations) {
    makefileConfigurations = configurations;
}
exports.setMakefileConfigurations = setMakefileConfigurations;
// Read make configurations optionally defined by the user in settings: makefile.configurations.
async function readMakefileConfigurations() {
    // We need to read "makefile.configurations" unexpanded first, because we may write back into these settings
    // in case we indentify "name" missing. We'll expand later, see end of function.
    let workspaceConfiguration = vscode.workspace.getConfiguration("makefile");
    makefileConfigurations =
        workspaceConfiguration.get("configurations") || [];
    let detectedUnnamedConfigurations = false;
    let unnamedConfigurationId = 0;
    // Collect unnamed configurations (probably) defined by the extension earlier,
    // to make sure we avoid duplicates in case any new configuration is in need of a name.
    let unnamedConfigurationNames = makefileConfigurations.map((k) => {
        return k.name;
    });
    unnamedConfigurationNames = unnamedConfigurationNames.filter((item) => item && item.startsWith("Unnamed configuration"));
    makefileConfigurations.forEach((element) => {
        if (!element.name) {
            detectedUnnamedConfigurations = true;
            // Just considering the possibility that there are already unnamed configurations
            // defined with IDs other than the rule we assume (like not consecutive numbers, but not only).
            // This may happen when the user deletes configurations at some point without updating the IDs.
            unnamedConfigurationId++;
            let autoGeneratedName = `Unnamed configuration ${unnamedConfigurationId}`;
            while (unnamedConfigurationNames.includes(autoGeneratedName)) {
                unnamedConfigurationId++;
                autoGeneratedName = `Unnamed configuration ${unnamedConfigurationId}`;
            }
            element.name = autoGeneratedName;
            logger.message(localize(37, null, autoGeneratedName, element.name));
        }
    });
    if (detectedUnnamedConfigurations) {
        logger.message(localize(38, null));
        await workspaceConfiguration.update("configurations", makefileConfigurations);
    }
    // Now read "makefile.configurations" again and expand as needed.
    makefileConfigurations =
        (await util.getExpandedSetting("configurations")) || [];
    // Log the updated list of configuration names
    const makefileConfigurationNames = makefileConfigurations.map((k) => {
        return k.name;
    });
    if (makefileConfigurationNames.length > 0) {
        logger.message(localize(39, null, makefileConfigurationNames.join(";")));
    }
    // Verify if the current makefile configuration (check against the expanded values)
    // is still part of the list and unset otherwise.
    // Exception: "Default" which means the user didn't set it and relies on whatever default
    // the current set of makefiles support. "Default" is not going to be part of the list
    // but we shouldn't log about it.
    if (currentMakefileConfiguration !== "Default" &&
        !makefileConfigurationNames.includes(currentMakefileConfiguration)) {
        logger.message(localize(40, null, currentMakefileConfiguration));
        await setConfigurationByName("Default");
    }
}
exports.readMakefileConfigurations = readMakefileConfigurations;
// Last target picked from the set of targets that are run by the makefiles
// when building for the current configuration.
// Saved into the settings storage. Also reflected in the configuration status bar button
let currentTarget;
function getCurrentTarget() {
    return currentTarget;
}
exports.getCurrentTarget = getCurrentTarget;
function setCurrentTarget(target) {
    currentTarget = target;
}
exports.setCurrentTarget = setCurrentTarget;
// Read current target from workspace state, update status bar item
function readCurrentTarget() {
    let buildTarget = extension_1.extension.getState().buildTarget;
    if (!buildTarget) {
        logger.message(localize(41, null));
        statusBar.setTarget("Default");
        // If no particular target is defined in settings, use 'Default' for the button
        // but keep the variable empty, to not append it to the make command.
        currentTarget = "";
    }
    else {
        currentTarget = buildTarget;
        logger.message(localize(42, null, currentTarget));
        statusBar.setTarget(currentTarget);
    }
}
let configureOnOpen;
function getConfigureOnOpen() {
    return configureOnOpen;
}
exports.getConfigureOnOpen = getConfigureOnOpen;
function setConfigureOnOpen(configure) {
    configureOnOpen = configure;
}
exports.setConfigureOnOpen = setConfigureOnOpen;
async function readConfigureOnOpen() {
    configureOnOpen = await util.getExpandedSetting("configureOnOpen");
    logger.message(localize(43, null, configureOnOpen));
}
exports.readConfigureOnOpen = readConfigureOnOpen;
let configureOnEdit;
function getConfigureOnEdit() {
    return configureOnEdit;
}
exports.getConfigureOnEdit = getConfigureOnEdit;
function setConfigureOnEdit(configure) {
    configureOnEdit = configure;
}
exports.setConfigureOnEdit = setConfigureOnEdit;
async function readConfigureOnEdit() {
    configureOnEdit = await util.getExpandedSetting("configureOnEdit");
    logger.message(localize(44, null, configureOnEdit));
}
exports.readConfigureOnEdit = readConfigureOnEdit;
let configureAfterCommand;
function getConfigureAfterCommand() {
    return configureAfterCommand;
}
exports.getConfigureAfterCommand = getConfigureAfterCommand;
function setConfigureAfterCommand(configure) {
    configureAfterCommand = configure;
}
exports.setConfigureAfterCommand = setConfigureAfterCommand;
async function readConfigureAfterCommand() {
    configureAfterCommand = await util.getExpandedSetting("configureAfterCommand");
    logger.message(localize(45, null, configureAfterCommand));
}
exports.readConfigureAfterCommand = readConfigureAfterCommand;
let phonyOnlyTargets;
function getPhonyOnlyTargets() {
    return phonyOnlyTargets;
}
exports.getPhonyOnlyTargets = getPhonyOnlyTargets;
function setPhonyOnlyTargets(phony) {
    phonyOnlyTargets = phony;
}
exports.setPhonyOnlyTargets = setPhonyOnlyTargets;
async function readPhonyOnlyTargets() {
    phonyOnlyTargets = await util.getExpandedSetting("phonyOnlyTargets");
    logger.message(localize(46, null, phonyOnlyTargets));
}
exports.readPhonyOnlyTargets = readPhonyOnlyTargets;
let saveBeforeBuildOrConfigure;
function getSaveBeforeBuildOrConfigure() {
    return saveBeforeBuildOrConfigure;
}
exports.getSaveBeforeBuildOrConfigure = getSaveBeforeBuildOrConfigure;
function setSaveBeforeBuildOrConfigure(save) {
    saveBeforeBuildOrConfigure = save;
}
exports.setSaveBeforeBuildOrConfigure = setSaveBeforeBuildOrConfigure;
async function readSaveBeforeBuildOrConfigure() {
    saveBeforeBuildOrConfigure = await util.getExpandedSetting("saveBeforeBuildOrConfigure");
    logger.message(localize(47, null, saveBeforeBuildOrConfigure));
}
exports.readSaveBeforeBuildOrConfigure = readSaveBeforeBuildOrConfigure;
let buildBeforeLaunch;
function getBuildBeforeLaunch() {
    return buildBeforeLaunch;
}
exports.getBuildBeforeLaunch = getBuildBeforeLaunch;
function setBuildBeforeLaunch(build) {
    buildBeforeLaunch = build;
}
exports.setBuildBeforeLaunch = setBuildBeforeLaunch;
async function readBuildBeforeLaunch() {
    buildBeforeLaunch = await util.getExpandedSetting("buildBeforeLaunch");
    logger.message(localize(48, null, buildBeforeLaunch));
}
exports.readBuildBeforeLaunch = readBuildBeforeLaunch;
let clearOutputBeforeBuild;
function getClearOutputBeforeBuild() {
    return clearOutputBeforeBuild;
}
exports.getClearOutputBeforeBuild = getClearOutputBeforeBuild;
function setClearOutputBeforeBuild(clear) {
    clearOutputBeforeBuild = clear;
}
exports.setClearOutputBeforeBuild = setClearOutputBeforeBuild;
async function readClearOutputBeforeBuild() {
    clearOutputBeforeBuild = await util.getExpandedSetting("clearOutputBeforeBuild");
    logger.message(localize(49, null, clearOutputBeforeBuild));
}
exports.readClearOutputBeforeBuild = readClearOutputBeforeBuild;
// This setting is useful for some repos where directory changing commands (cd, push, pop)
// are missing or printed more than once, resulting in associating some IntelliSense information
// with the wrong file or even with a non existent URL.
// When this is set, the current path deduction relies only on --print-directory
// (which prints the messages regarding "Entering direcory" and "Leaving directory"),
// which is not perfect either for all repos.
let ignoreDirectoryCommands;
function getIgnoreDirectoryCommands() {
    return ignoreDirectoryCommands;
}
exports.getIgnoreDirectoryCommands = getIgnoreDirectoryCommands;
function setIgnoreDirectoryCommands(ignore) {
    ignoreDirectoryCommands = ignore;
}
exports.setIgnoreDirectoryCommands = setIgnoreDirectoryCommands;
async function readIgnoreDirectoryCommands() {
    ignoreDirectoryCommands = await util.getExpandedSetting("ignoreDirectoryCommands");
    logger.message(localize(50, null, ignoreDirectoryCommands));
}
exports.readIgnoreDirectoryCommands = readIgnoreDirectoryCommands;
// Initialization from the state of the workspace.
// The user does not have direct access to this data.
// The extension sets state variables via user actions like:
// set configuration, set build target, set launch target.
// At activation time we read from state, update UI accordingly
// and commands become available to be run in settings via expansion.
// These can also be resetted via the makefile.resetState command.
function initFromState() {
    readCurrentMakefileConfiguration();
    readCurrentTarget();
}
exports.initFromState = initFromState;
// Initialization from settings (or backup default rules).
// This is called at activation time (with activation boolean being passed as true explicitly)
// or after any change in the configuration/build-target workspace state variables, in which case
// we need a refresh of all settings expanding ${configuration} or ${buildTarget}.
async function initFromSettings(activation = false) {
    // Read first anything related to the output folder and the extension log,
    // to be able to document any upcoming reads.
    await readExtensionOutputFolder();
    await readExtensionLog();
    // Delete the extension log file, if exists, even if we lose what we logged earlier
    // about reading the output folder and extension log.
    // The deletion should happen only at activation time (to not allow the log file to grow indefinitely),
    // while reading the settings is done at activation time  and also anytime later,
    // after changing a makefile configuration, a build or a launch target.
    let extensionLog = getExtensionLog();
    if (extensionLog && activation && util.checkFileExistsSync(extensionLog)) {
        util.deleteFileSync(extensionLog);
    }
    await readLoggingLevel();
    await readConfigurationCachePath();
    await readMakePath();
    await readMakefilePath();
    await readMakeDirectory();
    extension_1.extension.updateBuildLogPresent(await readBuildLog());
    await readPreConfigureScript();
    await readPreConfigureArgs();
    await readAlwaysPreConfigure();
    await readPostConfigureScript();
    await readPostConfigureArgs();
    await readAlwaysPostConfigure();
    await readDryrunSwitches();
    await readAdditionalCompilerNames();
    await readExcludeCompilerNames();
    await readMakefileConfigurations();
    await readCurrentLaunchConfiguration();
    await readDefaultLaunchConfiguration();
    await readConfigureOnOpen();
    await readConfigureOnEdit();
    await readConfigureAfterCommand();
    await readPhonyOnlyTargets();
    await readSaveBeforeBuildOrConfigure();
    await readBuildBeforeLaunch();
    await readClearOutputBeforeBuild();
    await readIgnoreDirectoryCommands();
    await readCompileCommandsPath();
    initOptionalFeatures();
    await readFeaturesVisibility();
    await analyzeConfigureParams();
    await extension_1.extension._projectOutlineProvider.update(extension_1.extension.getState().buildConfiguration, extension_1.extension.getState().buildTarget, extension_1.extension.getState().launchConfiguration, getConfigurationMakefile(), getConfigurationMakeCommand(), getConfigurationBuildLog());
    // Listen to the workspace trust change event
    vscode.workspace.onDidGrantWorkspaceTrust(async (e) => {
        await getCommandForConfiguration(currentMakefileConfiguration); // this refreshes fullFeatureSet and enables visible features
    });
    // Verify the dirty state of the IntelliSense config provider and update accordingly.
    // The makefile.configureOnEdit setting can be set to false when this behavior is inconvenient.
    vscode.window.onDidChangeActiveTextEditor(async (e) => {
        let language = "";
        if (e) {
            language = e.document.languageId;
        }
        // It is too annoying to generate a configure on any kind of editor focus change
        // (for example even searching in the logging window generates this event).
        // Since all the operations are guarded by the configureDirty state,
        // the only "operation" left that we need to make sure it's up to date
        // is IntelliSense, so trigger a configure when we switch editor focus
        // into C/C++ source code.
        switch (language) {
            case "c":
            case "cpp":
                // If configureDirty is already set from a previous VSCode session,
                // at workspace load this event (onDidChangeActiveTextEditor) is triggered automatically
                // and if makefile.configureOnOpen is true, there is a race between two configure operations,
                // one of which being unnecessary. If configureOnOpen is false, there is no race
                // but still we don't want to override the behavior desired by the user.
                // Additionally, if anything dirtied the configure state during a (pre)configure or build,
                // skip this clean configure, to avoid annoying "blocked operation" notifications.
                // The configure state remains dirty and a new configure will be triggered eventually:
                // (selecting a new configuration, target or launch, build, editor focus change).
                // Guarding only for not being blocked is not enough. For example,
                // in the first scenario explained above, the race happens when nothing looks blocked
                // here, but leading to a block notification soon.
                if (extension_1.extension.getState().configureDirty && configureOnEdit) {
                    if (extension_1.extension.getCompletedConfigureInSession() &&
                        !make.blockedByOp(make.Operations.configure, false)) {
                        logger.message(localize(51, null));
                        await make.configure(make.TriggeredBy.configureAfterEditorFocusChange); // this sets configureDirty back to false if it succeeds
                    }
                }
                break;
            default:
                break;
        }
    });
    // Modifying any makefile should trigger an IntelliSense config provider update,
    // so make the dirty state true.
    // TODO: limit to makefiles relevant to this project, instead of any random makefile anywhere.
    //       We can't listen only to the makefile pointed to by makefile.makefilePath or makefile.makeDirectory,
    //       because that is only the entry point and can refer to other relevant makefiles.
    // TODO: don't trigger an update for any dummy save, verify how the content changed.
    vscode.workspace.onDidSaveTextDocument((e) => {
        if (e.uri.fsPath.toLowerCase().endsWith("makefile")) {
            extension_1.extension.getState().configureDirty = true;
        }
    });
    // Watch for Makefile Tools setting updates that can change the IntelliSense config provider dirty state.
    // More than one setting may be updated on one settings.json save,
    // so make sure to OR the dirty state when it's calculated by a formula (not a simple TRUE value).
    vscode.workspace.onDidChangeConfiguration(async (e) => {
        if (vscode.workspace.workspaceFolders &&
            e.affectsConfiguration("makefile")) {
            // We are interested in updating only some relevant properties.
            // A subset of these should also trigger an IntelliSense config provider update.
            // Avoid unnecessary updates (for example, when settings are modified via the extension quickPick).
            let telemetryProperties = {};
            let updatedSettingsSubkeys = [];
            const keyRoot = "makefile";
            let subKey = "launchConfigurations";
            let updatedLaunchConfigurations = await util.getExpandedSetting(subKey);
            if (!util.areEqual(updatedLaunchConfigurations, launchConfigurations)) {
                // Changing a launch configuration does not impact the make or compiler tools invocations,
                // so no IntelliSense update is needed.
                await readCurrentLaunchConfiguration(); // this gets a refreshed view of all launch configurations
                // and also updates the current one in case it was affected
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "defaultLaunchConfiguration";
            let updatedDefaultLaunchConfiguration = await util.getExpandedSetting(subKey);
            if (!util.areEqual(updatedDefaultLaunchConfiguration, defaultLaunchConfiguration)) {
                // Changing a global debug configuration does not impact the make or compiler tools invocations,
                // so no IntelliSense update is needed.
                await readDefaultLaunchConfiguration();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "loggingLevel";
            let updatedLoggingLevel = await util.getExpandedSetting(subKey);
            if (updatedLoggingLevel !== loggingLevel) {
                await readLoggingLevel();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "buildLog";
            let updatedBuildLog = await util.getExpandedSetting(subKey);
            if (updatedBuildLog) {
                updatedBuildLog = util.resolvePathToRoot(updatedBuildLog);
            }
            if (updatedBuildLog !== buildLog) {
                // Configure is dirty only if the current configuration
                // doesn't have already another build log set
                // (which overrides the global one).
                let currentMakefileConfiguration = makefileConfigurations.find((k) => {
                    if (k.name === getCurrentMakefileConfiguration()) {
                        return k;
                    }
                });
                extension_1.extension.getState().configureDirty =
                    extension_1.extension.getState().configureDirty ||
                        !currentMakefileConfiguration ||
                        !currentMakefileConfiguration.buildLog;
                extension_1.extension.updateBuildLogPresent(await readBuildLog());
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "extensionOutputFolder";
            let updatedExtensionOutputFolder = await util.getExpandedSetting(subKey);
            if (updatedExtensionOutputFolder) {
                updatedExtensionOutputFolder = util.resolvePathToRoot(updatedExtensionOutputFolder);
                if (!util.checkDirectoryExistsSync(updatedExtensionOutputFolder) &&
                    !util.createDirectorySync(updatedExtensionOutputFolder)) {
                    // No logging necessary about not being able to create the directory,
                    // readExtensionOutputFolder called below will complain if it's the case.
                    updatedExtensionOutputFolder = undefined;
                }
            }
            if (updatedExtensionOutputFolder !== extensionOutputFolder) {
                // No IntelliSense update needed.
                await readExtensionOutputFolder();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "extensionLog";
            let updatedExtensionLog = await util.getExpandedSetting(subKey);
            if (updatedExtensionLog) {
                // If there is a directory defined within the extension log path,
                // honor it and don't append to extensionOutputFolder.
                let parsePath = path.parse(updatedExtensionLog);
                if (extensionOutputFolder && !parsePath.dir) {
                    updatedExtensionLog = path.join(extensionOutputFolder, updatedExtensionLog);
                }
                else {
                    updatedExtensionLog = util.resolvePathToRoot(updatedExtensionLog);
                }
            }
            if (updatedExtensionLog !== extensionLog) {
                // No IntelliSense update needed.
                await readExtensionLog();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "preConfigureScript";
            let updatedPreConfigureScript = await util.getExpandedSetting(subKey);
            if (updatedPreConfigureScript) {
                updatedPreConfigureScript = util.resolvePathToRoot(updatedPreConfigureScript);
            }
            if (updatedPreConfigureScript !== preConfigureScript) {
                // No IntelliSense update needed.
                await readPreConfigureScript();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "preConfigureArgs";
            let updatedPreConfigureArgs = await util.getExpandedSetting(subKey);
            if (updatedPreConfigureArgs &&
                !util.areEqual(updatedPreConfigureArgs, preConfigureArgs)) {
                await readPreConfigureArgs();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "postConfigureScript";
            let updatedPostConfigureScript = await util.getExpandedSetting(subKey);
            if (updatedPostConfigureScript) {
                updatedPostConfigureScript = util.resolvePathToRoot(updatedPostConfigureScript);
            }
            if (updatedPostConfigureScript !== postConfigureScript) {
                await readPostConfigureScript();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "postConfigureArgs";
            let updatedPostConfigureArgs = await util.getExpandedSetting(subKey);
            if (updatedPostConfigureArgs &&
                !util.areEqual(updatedPostConfigureArgs, postConfigureArgs)) {
                await readPostConfigureArgs();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "alwaysPreConfigure";
            let updatedAlwaysPreConfigure = await util.getExpandedSetting(subKey);
            if (updatedAlwaysPreConfigure !== alwaysPreConfigure) {
                // No IntelliSense update needed.
                await readAlwaysPreConfigure();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "alwaysPostConfigure";
            let updatedAlwaysPostConfigure = await util.getExpandedSetting(subKey);
            if (updatedAlwaysPostConfigure !== alwaysPostConfigure) {
                await readAlwaysPostConfigure();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "configurationCachePath";
            let oldConfigurationCachePath = configurationCachePath;
            await readConfigurationCachePath();
            if (oldConfigurationCachePath !== configurationCachePath) {
                // A change in makefile.configurationCachePath should trigger an IntelliSense update
                // only if the extension is not currently reading from a build log.
                extension_1.extension.getState().configureDirty =
                    extension_1.extension.getState().configureDirty ||
                        !buildLog ||
                        !util.checkFileExistsSync(buildLog);
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "makePath";
            let updatedMakePath = await util.getExpandedSetting(subKey);
            if (updatedMakePath !== makePath) {
                // Not very likely, but it is safe to consider that a different make tool
                // may produce a different dry-run output with potential impact on IntelliSense,
                // so trigger an update (unless we read from a build log).
                extension_1.extension.getState().configureDirty =
                    extension_1.extension.getState().configureDirty ||
                        !buildLog ||
                        !util.checkFileExistsSync(buildLog);
                await readMakePath();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "makefilePath";
            let updatedMakefilePath = await util.getExpandedSetting(subKey);
            if (updatedMakefilePath) {
                updatedMakefilePath = util.resolvePathToRoot(updatedMakefilePath);
            }
            if (updatedMakefilePath !== makefilePath) {
                // A change in makefile.makefilePath should trigger an IntelliSense update
                // only if the extension is not currently reading from a build log.
                extension_1.extension.getState().configureDirty =
                    extension_1.extension.getState().configureDirty ||
                        !buildLog ||
                        !util.checkFileExistsSync(buildLog);
                await readMakefilePath();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "makeDirectory";
            let updatedMakeDirectory = await util.getExpandedSetting(subKey);
            if (updatedMakeDirectory) {
                updatedMakeDirectory = util.resolvePathToRoot(updatedMakeDirectory);
            }
            if (updatedMakeDirectory !== makeDirectory) {
                // A change in makefile.makeDirectory should trigger an IntelliSense update
                // only if the extension is not currently reading from a build log.
                extension_1.extension.getState().configureDirty =
                    extension_1.extension.getState().configureDirty ||
                        !buildLog ||
                        !util.checkFileExistsSync(buildLog);
                await readMakeDirectory();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "configurations";
            let updatedMakefileConfigurations = await util.getExpandedSetting(subKey);
            if (!util.areEqual(updatedMakefileConfigurations, makefileConfigurations)) {
                // todo: skip over updating the IntelliSense configuration provider if the current makefile configuration
                // is not among the subobjects that suffered modifications.
                extension_1.extension.getState().configureDirty = true;
                await readMakefileConfigurations();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "dryrunSwitches";
            let updatedDryrunSwitches = await util.getExpandedSetting(subKey);
            if (!util.areEqual(updatedDryrunSwitches, dryrunSwitches)) {
                // A change in makefile.dryrunSwitches should trigger an IntelliSense update
                // only if the extension is not currently reading from a build log.
                extension_1.extension.getState().configureDirty =
                    extension_1.extension.getState().configureDirty ||
                        !buildLog ||
                        !util.checkFileExistsSync(buildLog);
                await readDryrunSwitches();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "additionalCompilerNames";
            let updatedAdditionalCompilerNames = await util.getExpandedSetting(subKey);
            if (!util.areEqual(updatedAdditionalCompilerNames, additionalCompilerNames)) {
                await readAdditionalCompilerNames();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "excludeCompilerNames";
            let updatedExcludeCompilerNames = await util.getExpandedSetting(subKey);
            if (!util.areEqual(updatedExcludeCompilerNames, excludeCompilerNames)) {
                await readExcludeCompilerNames();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "configureOnOpen";
            let updatedConfigureOnOpen = await util.getExpandedSetting(subKey);
            if (updatedConfigureOnOpen !== configureOnOpen) {
                await readConfigureOnOpen();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "configureOnEdit";
            let updatedConfigureOnEdit = await util.getExpandedSetting(subKey);
            if (updatedConfigureOnEdit !== configureOnEdit) {
                await readConfigureOnEdit();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "configureAfterCommand";
            let updatedConfigureAfterCommand = await util.getExpandedSetting(subKey);
            if (updatedConfigureAfterCommand !== configureAfterCommand) {
                await readConfigureAfterCommand();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "phonyOnlyTargets";
            let updatedPhonyOnlyTargets = await util.getExpandedSetting(subKey);
            if (updatedPhonyOnlyTargets !== phonyOnlyTargets) {
                await readPhonyOnlyTargets();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "saveBeforeBuildOrConfigure";
            let updatedSaveBeforeBuildOrConfigure = await util.getExpandedSetting(subKey);
            if (updatedSaveBeforeBuildOrConfigure !== saveBeforeBuildOrConfigure) {
                await readSaveBeforeBuildOrConfigure();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "buildBeforeLaunch";
            let updatedBuildBeforeLaunch = await util.getExpandedSetting(subKey);
            if (updatedBuildBeforeLaunch !== buildBeforeLaunch) {
                await readBuildBeforeLaunch();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "clearOutputBeforeBuild";
            let updatedClearOutputBeforeBuild = await util.getExpandedSetting(subKey);
            if (updatedClearOutputBeforeBuild !== clearOutputBeforeBuild) {
                await readClearOutputBeforeBuild();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "ignoreDirectoryCommands";
            let updatedIgnoreDirectoryCommands = await util.getExpandedSetting(subKey);
            if (updatedIgnoreDirectoryCommands !== ignoreDirectoryCommands) {
                await readIgnoreDirectoryCommands();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "compileCommandsPath";
            let updatedCompileCommandsPath = await util.getExpandedSetting(subKey);
            if (updatedCompileCommandsPath) {
                updatedCompileCommandsPath = util.resolvePathToRoot(updatedCompileCommandsPath);
            }
            if (updatedCompileCommandsPath !== compileCommandsPath) {
                await readCompileCommandsPath();
                updatedSettingsSubkeys.push(subKey);
            }
            subKey = "panel.visibility";
            let wasLocalDebugEnabled = isOptionalFeatureEnabled("debug");
            let wasLocalRunningEnabled = isOptionalFeatureEnabled("run");
            await readFeaturesVisibility();
            if (vscode.workspace.isTrusted) {
                enableOptionallyVisibleCommands();
            }
            let isLocalDebugEnabled = isOptionalFeatureEnabled("debug");
            let isLocalRunningEnabled = isOptionalFeatureEnabled("run");
            if (wasLocalDebugEnabled !== isLocalDebugEnabled ||
                wasLocalRunningEnabled !== isLocalRunningEnabled) {
                extension_1.extension._projectOutlineProvider.updateTree();
                updatedSettingsSubkeys.push(subKey);
            }
            // Final updates in some constructs that depend on more than one of the above settings.
            await analyzeConfigureParams();
            await extension_1.extension._projectOutlineProvider.updateMakePathInfo(getConfigurationMakeCommand());
            await extension_1.extension._projectOutlineProvider.updateMakefilePathInfo(getConfigurationMakefile());
            await extension_1.extension._projectOutlineProvider.updateBuildLogPathInfo(getConfigurationBuildLog());
            // Report all the settings changes detected by now.
            // TODO: to avoid unnecessary telemetry processing, evaluate whether the changes done
            // in the object makefile.launchConfigurations and makefile.configurations
            // apply exactly to the current launch configuration, since we don't collect and aggregate
            // information from all the array yet.
            updatedSettingsSubkeys.forEach(async (subKey) => {
                let key = keyRoot + "." + subKey;
                logger.message(localize(52, null, key), "Verbose");
                try {
                    // For settings that use "." in their name, make sure we send the right object
                    // to the telemetry function. Currently, the schema for such a setting
                    // is represented differently than the workspace setting value.
                    let settingObj;
                    let workspaceConfiguration = vscode.workspace.getConfiguration(keyRoot);
                    if (subKey.includes(".")) {
                        const subKeys = subKey.split(".");
                        settingObj = workspaceConfiguration;
                        subKeys.forEach((key) => {
                            settingObj = settingObj[key];
                        });
                    }
                    else {
                        settingObj = workspaceConfiguration[subKey];
                    }
                    telemetryProperties = await telemetry.analyzeSettings(settingObj, key, util.thisExtensionPackage().contributes.configuration.properties[key], false, telemetryProperties);
                }
                catch (e) {
                    logger.message(e.message);
                }
            });
            if (telemetryProperties && util.hasProperties(telemetryProperties)) {
                telemetry.logEvent("settingsChanged", telemetryProperties);
            }
        }
    });
}
exports.initFromSettings = initFromSettings;
async function setConfigurationByName(configurationName) {
    extension_1.extension.getState().buildConfiguration = configurationName;
    logger.message(localize(53, null, configurationName));
    logger.message(localize(54, null));
    await setCurrentMakefileConfiguration(configurationName);
    // Refresh settings, they may reference variables or commands reading state configuration var (${configuration}).
    await initFromSettings();
    extension_1.extension._projectOutlineProvider.updateConfiguration(configurationName);
}
exports.setConfigurationByName = setConfigurationByName;
function prepareConfigurationsQuickPick() {
    const items = makefileConfigurations.map((k) => {
        return k.name;
    });
    if (items.length === 0) {
        logger.message("No configurations defined in makefile.configurations setting.");
        items.push("Default");
    }
    return items;
}
exports.prepareConfigurationsQuickPick = prepareConfigurationsQuickPick;
// Fill a drop-down with all the configuration names defined by the user in makefile.configurations setting.
// Triggers a cpptools configuration provider update after selection.
async function setNewConfiguration() {
    // Cannot set a new makefile configuration if the project is currently building or (pre-)configuring.
    if (make.blockedByOp(make.Operations.changeConfiguration)) {
        return;
    }
    const items = prepareConfigurationsQuickPick();
    const chosen = await vscode.window.showQuickPick(items);
    if (chosen &&
        (chosen !== getCurrentMakefileConfiguration() ||
            !extension_1.extension.getState().buildConfiguration)) {
        let telemetryProperties = {
            state: "makefileConfiguration",
        };
        telemetry.logEvent("stateChanged", telemetryProperties);
        await setConfigurationByName(chosen);
        if (configureAfterCommand) {
            logger.message(localize(55, null));
            await make.cleanConfigure(make.TriggeredBy.configureAfterConfigurationChange);
        }
        // Refresh telemetry for this new makefile configuration
        // (this will find the corresponding item in the makefile.configurations array
        // and report all the relevant settings of that object).
        // Because of this, the event name is still "settingsChanged", even if
        // we're doing a state change now.
        let keyRoot = "makefile";
        let subKey = "configurations";
        let key = keyRoot + "." + subKey;
        let workspaceConfiguration = vscode.workspace.getConfiguration(keyRoot);
        telemetryProperties = {};
        // We should have at least one item in the configurations array
        // if the extension changes state for launch configuration,
        // but guard just in case.
        let makefileonfigurationSetting = workspaceConfiguration[subKey];
        if (makefileonfigurationSetting) {
            try {
                telemetryProperties = await telemetry.analyzeSettings(makefileonfigurationSetting, key, util.thisExtensionPackage().contributes.configuration.properties[key], true, telemetryProperties);
            }
            catch (e) {
                logger.message(e.message);
            }
            if (telemetryProperties && util.hasProperties(telemetryProperties)) {
                telemetry.logEvent("settingsChanged", telemetryProperties);
            }
        }
    }
}
exports.setNewConfiguration = setNewConfiguration;
async function setTargetByName(targetName) {
    currentTarget = targetName;
    let displayTarget = targetName ? currentTarget : "Default";
    statusBar.setTarget(displayTarget);
    logger.message(localize(56, null, displayTarget));
    logger.message(localize(57, null));
    // Refresh settings, they may reference variables or commands reading state target var (${buildTarget}).
    extension_1.extension.getState().buildTarget = currentTarget;
    await initFromSettings();
    extension_1.extension._projectOutlineProvider.updateBuildTarget(targetName);
}
exports.setTargetByName = setTargetByName;
// Fill a drop-down with all the target names run by building the makefile for the current configuration
// Triggers a cpptools configuration provider update after selection.
// TODO: change the UI list to multiple selections mode and store an array of current active targets
async function selectTarget() {
    // Cannot select a new target if the project is currently building or (pre-)configuring.
    if (make.blockedByOp(make.Operations.changeBuildTarget)) {
        return;
    }
    // warn about an out of date configure state and configure if makefile.configureAfterCommand allows.
    if (extension_1.extension.getState().configureDirty ||
        // The configure state might not be dirty from the last session but if the project is set to skip
        // configure on open and no configure happened yet we still must warn.
        (configureOnOpen === false && !extension_1.extension.getCompletedConfigureInSession())) {
        logger.message(localize(58, null));
        if (configureAfterCommand) {
            let retc = await make.configure(make.TriggeredBy.configureBeforeTargetChange);
            if (retc !== make.ConfigureBuildReturnCodeTypes.success) {
                logger.message(localize(59, null));
            }
        }
    }
    // Ensure "all" is always available as a target to select.
    // There are scenarios when "all" might not be present in the list of available targets,
    // for example when the extension is using a build log or dryrun cache of a previous state
    // when a particular target was selected and a dryrun applied on that is producing a subset of targets,
    // making it impossible to select "all" back again without resetting the Makefile Tools state
    // or switching to a different makefile configuration or implementing an editable target quick pick.
    // Another situation where "all" would inconveniently miss from the quick pick is when the user is
    // providing a build log without the required verbosity for parsing targets (-p or --print-data-base switches).
    // When the extension is not reading from build log or dryrun cache, we have logic to prevent
    // "all" from getting lost: make sure the target is not appended to the make invocation
    // whose output is used to parse the targets (as opposed to parsing for IntelliSense or launch targets
    // when the current target must be appended to the make command).
    if (!buildTargets.includes("all")) {
        buildTargets.push("all");
    }
    const chosen = await vscode.window.showQuickPick(buildTargets);
    if (chosen && chosen !== getCurrentTarget()) {
        const telemetryProperties = {
            state: "buildTarget",
        };
        telemetry.logEvent("stateChanged", telemetryProperties);
        await setTargetByName(chosen);
        if (configureAfterCommand) {
            // The set of build targets remains the same even if the current target has changed
            logger.message(localize(60, null));
            await make.cleanConfigure(make.TriggeredBy.configureAfterTargetChange, false);
        }
    }
}
exports.selectTarget = selectTarget;
// The 'name' of a launch configuration is a string following this syntax:
//    [cwd]>[binaryPath](binaryArg1,binaryArg2,...)
// These strings are found by the extension while parsing the output of the dry-run or build log,
// which reflect possible different ways of running the binaries built by the makefile.
// TODO: If we find that these strings are not unique (meaning the makefile may invoke
// the given binary in the exact same way more than once), incorporate also the containing target
// name in the syntax (or, since in theory one can write a makefile target to run the same binary
// in the same way more than once, add some number suffix).
async function setLaunchConfigurationByName(launchConfigurationName) {
    // Find the matching entry in the array of launch configurations
    // or generate a new entry in settings if none are found.
    currentLaunchConfiguration = getLaunchConfiguration(launchConfigurationName);
    if (!currentLaunchConfiguration) {
        currentLaunchConfiguration = await stringToLaunchConfiguration(launchConfigurationName);
        if (currentLaunchConfiguration) {
            // Read again all launch configurations from settings, so that we push this incoming into that array as well
            // because we want to persist the original unexpanded content of launch configurations.
            let workspaceConfiguration = vscode.workspace.getConfiguration("makefile");
            let launchConfigAsInSettings = workspaceConfiguration.get("launchConfigurations") || [];
            launchConfigAsInSettings.push(currentLaunchConfiguration);
            // Push into the processed 'in-memory' launch configurations array as well.
            launchConfigurations.push(currentLaunchConfiguration);
            await workspaceConfiguration.update("launchConfigurations", launchConfigAsInSettings);
            logger.message(localize(61, null, launchConfigurationName));
        }
    }
    if (currentLaunchConfiguration) {
        logger.message(localize(62, null, launchConfigurationName));
        extension_1.extension.getState().launchConfiguration = launchConfigurationName;
        statusBar.setLaunchConfiguration(launchConfigurationName);
    }
    else {
        if (launchConfigurationName === "") {
            logger.message(localize(63, null));
        }
        else {
            logger.message(localize(64, null, launchConfigurationName));
        }
        extension_1.extension.getState().launchConfiguration = undefined;
        statusBar.setLaunchConfiguration("No launch configuration set");
    }
    // Refresh settings, they may reference variables or commands reading launch targets commands: ${command:makefile.getLaunchTargetPath} and others...
    logger.message(localize(65, null));
    await initFromSettings();
    await extension_1.extension._projectOutlineProvider.updateLaunchTarget(launchConfigurationName);
}
exports.setLaunchConfigurationByName = setLaunchConfigurationByName;
// Fill a drop-down with all the launch configurations found for binaries built by the makefile
// under the scope of the current build configuration and target
// Selection updates current launch configuration that will be ready for the next debug/run operation
async function selectLaunchConfiguration() {
    // Cannot select a new launch configuration if the project is currently building or (pre-)configuring.
    if (make.blockedByOp(make.Operations.changeLaunchTarget)) {
        return;
    }
    // warn about an out of date configure state and configure if makefile.configureAfterCommand allows.
    if (extension_1.extension.getState().configureDirty ||
        // The configure state might not be dirty from the last session but if the project is set to skip
        // configure on open and no configure happened yet we still must warn.
        (configureOnOpen === false && !extension_1.extension.getCompletedConfigureInSession())) {
        logger.message(localize(66, null));
        if (configureAfterCommand) {
            let retc = await make.configure(make.TriggeredBy.configureBeforeLaunchTargetChange);
            if (retc !== make.ConfigureBuildReturnCodeTypes.success) {
                logger.message(localize(67, null));
            }
        }
    }
    // TODO: create a quick pick with description and details for items
    // to better view the long targets commands
    // In the quick pick, include also any makefile.launchConfigurations entries,
    // as long as they exist on disk and without allowing duplicates.
    let launchTargetsNames = [...launchTargets];
    launchConfigurations.forEach((launchConfiguration) => {
        if (util.checkFileExistsSync(launchConfiguration.binaryPath)) {
            launchTargetsNames.push(launchConfigurationToString(launchConfiguration));
        }
    });
    launchTargetsNames = util.sortAndRemoveDuplicates(launchTargetsNames);
    let options = {};
    if (launchTargets.length === 0) {
        options.placeHolder = "No launch targets identified";
    }
    const chosen = await vscode.window.showQuickPick(launchTargetsNames, options);
    if (chosen) {
        let currentLaunchConfiguration = getCurrentLaunchConfiguration();
        if (!currentLaunchConfiguration ||
            chosen !== launchConfigurationToString(currentLaunchConfiguration)) {
            let telemetryProperties = {
                state: "launchConfiguration",
            };
            telemetry.logEvent("stateChanged", telemetryProperties);
            await setLaunchConfigurationByName(chosen);
            // Refresh telemetry for this new launch configuration
            // (this will find the corresponding item in the makefile.launchConfigurations array
            // and report all the relevant settings of that object).
            // Because of this, the event name is still "settingsChanged", even if
            // we're doing a state change now.
            let keyRoot = "makefile";
            let subKey = "launchConfigurations";
            let key = keyRoot + "." + subKey;
            let workspaceConfiguration = vscode.workspace.getConfiguration(keyRoot);
            telemetryProperties = {};
            // We should have at least one item in the launchConfigurations array
            // if the extension changes state for launch configuration,
            // but guard just in case.
            let launchConfigurationSetting = workspaceConfiguration[subKey];
            if (launchConfigurationSetting) {
                try {
                    telemetryProperties = await telemetry.analyzeSettings(launchConfigurationSetting, key, util.thisExtensionPackage().contributes.configuration.properties[key], true, telemetryProperties);
                }
                catch (e) {
                    logger.message(e.message);
                }
                if (telemetryProperties && util.hasProperties(telemetryProperties)) {
                    telemetry.logEvent("settingsChanged", telemetryProperties);
                }
            }
        }
    }
}
exports.selectLaunchConfiguration = selectLaunchConfiguration;
// List of targets defined in the makefile project.
// Parsed from the build log, configuration cache or live dry-run output at configure time.
// Currently, this list contains any abstract intermediate target
// (like any object produced by the compiler from a source code file).
// TODO: filter only the relevant targets (binaries, libraries, etc...) from this list.
let buildTargets = [];
function getBuildTargets() {
    return buildTargets;
}
exports.getBuildTargets = getBuildTargets;
function setBuildTargets(targets) {
    buildTargets = targets;
}
exports.setBuildTargets = setBuildTargets;
// List of all the binaries built by the current project and all the ways
// they may be invoked (from what cwd, with what arguments).
// This is parsed from the build log, configuration cache or live dry-run output at configure time.
// This is what populates the 'launch targets' quick pick and is different than the
// launch configurations defined in settings.
// A launch configuration extends a launch target with various debugger settings.
// Each launch configuration entry is written in settings by the extension
// when the user actively selects any launch target from the quick pick.
// Then the user can add any of the provided extra attributes (miMode, miDebuggerPath, etc...)
// under that entry. It is possible that not all launch targets have a launch configuration counterpart,
// but if they do it is only one. Technically, we can imagine one launch target may have
// more than one launch configurations defined in settings (same binary, location and arguments debugged
// with different scenarios)) but this is not yet supported because currently the launch configurations
// are uniquely referenced by a string formed by cwd, binary and args (which form a launch target).
// The quick pick is not populated by the launch configurations list because its entries may be
// out of date and most importantly a subset. We want the quick pick to reflect all the possibilities
// that are found available with the current configuration of the project.
let launchTargets = [];
function getLaunchTargets() {
    return launchTargets;
}
exports.getLaunchTargets = getLaunchTargets;
function setLaunchTargets(targets) {
    launchTargets = targets;
}
exports.setLaunchTargets = setLaunchTargets;


/***/ }),

/***/ 328:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CppConfigurationProvider = void 0;
// Support for integration with CppTools Custom Configuration Provider
const configuration = __webpack_require__(604);
const logger = __webpack_require__(464);
const make = __webpack_require__(970);
const path = __webpack_require__(928);
const util = __webpack_require__(260);
const nls = __webpack_require__(493);
nls.config({
    messageFormat: nls.MessageFormat.bundle,
    bundleFormat: nls.BundleFormat.standalone,
})((__webpack_require__(928).join)(__dirname, 'src\\cpptools.ts'));
const localize = nls.loadMessageBundle((__webpack_require__(928).join)(__dirname, 'src\\cpptools.ts'));
class CppConfigurationProvider {
    constructor() {
        this.name = "Makefile Tools";
        this.extensionId = "ms-vscode.makefile-tools";
        this.workspaceBrowseConfiguration = {
            browsePath: [],
        };
        this.fileIndex = new Map();
    }
    getConfiguration(uri) {
        let norm_path = path.normalize(uri.fsPath);
        if (process.platform === "win32") {
            norm_path = norm_path.toUpperCase();
        }
        // First look in the file index computed during the last configure.
        // If nothing is found and there is a configure running right now,
        // try also the temporary index of the current configure.
        let sourceFileConfiguration = this.fileIndex.get(norm_path);
        if (!sourceFileConfiguration && make.getIsConfiguring()) {
            sourceFileConfiguration = make
                .getDeltaCustomConfigurationProvider()
                .fileIndex.get(norm_path);
            logger.message(localize(0, null, norm_path));
        }
        if (!sourceFileConfiguration) {
            logger.message(localize(1, null, norm_path));
        }
        return sourceFileConfiguration;
    }
    async canProvideConfiguration(uri) {
        return !!this.getConfiguration(uri);
    }
    async provideConfigurations(uris) {
        return util.dropNulls(uris.map((u) => this.getConfiguration(u)));
    }
    // Used when saving all the computed configurations into a cache.
    getCustomConfigurationProvider() {
        let provider = {
            fileIndex: this.fileIndex,
            workspaceBrowse: this.workspaceBrowseConfiguration,
        };
        return provider;
    }
    // Used to reset all the configurations with what was previously cached.
    setCustomConfigurationProvider(provider) {
        this.fileIndex = provider.fileIndex;
        this.workspaceBrowseConfiguration = provider.workspaceBrowse;
    }
    // Used to merge a new set of configurations on top of what was calculated during the previous configure.
    // If this is clean configure, clear all the arrays before the merge.
    mergeCustomConfigurationProvider(provider) {
        var _a;
        if (make.getConfigureIsClean()) {
            this.fileIndex.clear();
            this.workspaceBrowseConfiguration = {
                browsePath: [],
                compilerArgs: [],
                compilerPath: undefined,
                standard: undefined,
                windowsSdkVersion: undefined,
            };
        }
        let map = this.fileIndex;
        provider.fileIndex.forEach(function (value, key) {
            map.set(key, value);
        });
        this.workspaceBrowseConfiguration = {
            browsePath: util.sortAndRemoveDuplicates(this.workspaceBrowseConfiguration.browsePath.concat(provider.workspaceBrowse.browsePath)),
            compilerArgs: (_a = this.workspaceBrowseConfiguration.compilerArgs) === null || _a === void 0 ? void 0 : _a.concat(provider.workspaceBrowse.compilerArgs || []),
            compilerPath: provider.workspaceBrowse.compilerPath,
            standard: provider.workspaceBrowse.standard,
            windowsSdkVersion: provider.workspaceBrowse.windowsSdkVersion,
        };
    }
    async canProvideBrowseConfiguration() {
        return this.workspaceBrowseConfiguration.browsePath.length > 0;
    }
    async canProvideBrowseConfigurationsPerFolder() {
        return false;
    }
    async provideFolderBrowseConfiguration(_uri) {
        if (_uri.fsPath !== util.getWorkspaceRoot()) {
            logger.message(localize(2, null));
        }
        return this.workspaceBrowseConfiguration;
    }
    async provideBrowseConfiguration() {
        return this.workspaceBrowseConfiguration;
    }
    setBrowseConfiguration(browseConfiguration) {
        this.workspaceBrowseConfiguration = browseConfiguration;
    }
    dispose() { }
    logConfigurationProviderBrowse() {
        var _a;
        logger.message(localize(3, null), "Verbose");
        logger.message(localize(4, null, this.workspaceBrowseConfiguration.browsePath.join(";")), "Verbose");
        logger.message(localize(5, null, this.workspaceBrowseConfiguration.standard), "Verbose");
        logger.message(localize(6, null, this.workspaceBrowseConfiguration.compilerPath), "Verbose");
        logger.message(localize(7, null, (_a = this.workspaceBrowseConfiguration.compilerArgs) === null || _a === void 0 ? void 0 : _a.join(";")), "Verbose");
        if (process.platform === "win32" &&
            this.workspaceBrowseConfiguration.windowsSdkVersion) {
            logger.message(localize(8, null, this.workspaceBrowseConfiguration.windowsSdkVersion), "Verbose");
        }
        logger.message("----------------------------------------------------------------------------", "Verbose");
    }
    logConfigurationProviderItem(filePath, fromCache = false) {
        var _a;
        let uriObj = filePath.uri;
        const fromCacheString = localize(9, null, uriObj.fsPath);
        const notFromCacheString = localize(10, null, uriObj.fsPath);
        logger.message(fromCache ? fromCacheString : notFromCacheString, "Normal");
        logger.message(localize(11, null, filePath.configuration.defines.join(";")), "Verbose");
        logger.message(localize(12, null, filePath.configuration.includePath.join(";")), "Verbose");
        if (filePath.configuration.forcedInclude) {
            logger.message(localize(13, null, filePath.configuration.forcedInclude.join(";")), "Verbose");
        }
        logger.message(localize(14, null, filePath.configuration.standard), "Verbose");
        logger.message(localize(15, null, filePath.configuration.intelliSenseMode), "Verbose");
        logger.message(localize(16, null, filePath.configuration.compilerPath), "Verbose");
        logger.message(localize(17, null, (_a = filePath.configuration.compilerArgs) === null || _a === void 0 ? void 0 : _a.join(";")), "Verbose");
        if (process.platform === "win32" &&
            filePath.configuration.windowsSdkVersion) {
            logger.message(localize(18, null, filePath.configuration.windowsSdkVersion), "Verbose");
        }
        logger.message("---------------------------------------------------------------------------------------------------", "Verbose");
    }
    logConfigurationProviderComplete() {
        if (configuration.getLoggingLevel() !== "Normal") {
            this.logConfigurationProviderBrowse();
            this.fileIndex.forEach((filePath) => {
                // logConfigurationProviderComplete is called (so far) only after loading
                // the configurations from cache, so mark the boolean to be able to distinguish
                // the log entries in case of interleaved output.
                this.logConfigurationProviderItem(filePath, true);
            });
        }
    }
}
exports.CppConfigurationProvider = CppConfigurationProvider;


/***/ }),

/***/ 15:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deactivate = exports.activate = exports.MakefileToolsExtension = exports.extension = void 0;
// Makefile Tools extension
const configuration = __webpack_require__(604);
const cpptools = __webpack_require__(328);
const launch = __webpack_require__(347);
const fs_1 = __webpack_require__(896);
const make = __webpack_require__(970);
const path = __webpack_require__(928);
const state = __webpack_require__(227);
const telemetry = __webpack_require__(277);
const tree = __webpack_require__(24);
const ui = __webpack_require__(846);
const util = __webpack_require__(260);
const vscode = __webpack_require__(398);
const cpp = __webpack_require__(545);
const nls = __webpack_require__(493);
nls.config({
    messageFormat: nls.MessageFormat.bundle,
    bundleFormat: nls.BundleFormat.standalone,
})((__webpack_require__(928).join)(__dirname, 'src\\extension.ts'));
const localize = nls.loadMessageBundle((__webpack_require__(928).join)(__dirname, 'src\\extension.ts'));
let statusBar = ui.getUI();
let launcher = launch.getLauncher();
class MakefileToolsExtension {
    getCppConfigurationProvider() {
        return this.cppConfigurationProvider;
    }
    constructor(extensionContext) {
        this.extensionContext = extensionContext;
        this._projectOutlineProvider = new tree.ProjectOutlineProvider();
        this._projectOutlineTreeView = vscode.window.createTreeView("makefile.outline", {
            treeDataProvider: this._projectOutlineProvider,
            showCollapseAll: false,
        });
        this.cppConfigurationProvider = new cpptools.CppConfigurationProvider();
        this.mementoState = new state.StateManager(this.extensionContext);
        this.fullFeatureSet = false;
        // Used for calling cppToolsAPI.notifyReady only once in a VSCode session.
        this.ranNotifyReadyInSession = false;
        // Similar to state.ranConfigureInCodebaseLifetime, but at the scope of a VSCode session
        this.completedConfigureInSession = false;
        this.cummulativeBrowsePath = [];
    }
    updateBuildLogPresent(newValue) {
        vscode.commands.executeCommand("setContext", "makefile.buildLogFilePresent", newValue);
    }
    updateMakefileFilePresent(newValue) {
        vscode.commands.executeCommand("setContext", "makefile.makefileFilePresent", newValue);
    }
    getState() {
        return this.mementoState;
    }
    dispose() {
        this._projectOutlineTreeView.dispose();
        if (this.cppToolsAPI) {
            this.cppToolsAPI.dispose();
        }
    }
    getFullFeatureSet() {
        return this.fullFeatureSet;
    }
    async setFullFeatureSet(newValue) {
        await vscode.commands.executeCommand("setContext", "makefile:fullFeatureSet", newValue);
        this.fullFeatureSet = newValue;
    }
    getRanNotifyReadyInSession() {
        return this.ranNotifyReadyInSession;
    }
    setRanNotifyReadyInSession(ran) {
        this.ranNotifyReadyInSession = ran;
    }
    getCompletedConfigureInSession() {
        return this.completedConfigureInSession;
    }
    setCompletedConfigureInSession(completed) {
        this.completedConfigureInSession = completed;
    }
    // Register this extension as a new provider or request an update
    async registerCppToolsProvider() {
        await this.ensureCppToolsProviderRegistered();
        // Call notifyReady earlier than when the provider is updated,
        // as soon as we know that we are going to actually parse for IntelliSense.
        // This allows CppTools to ask earlier about source files in use
        // and Makefile Tools may return a targeted source file configuration
        // if it was already computed in our internal arrays (make.ts: customConfigProviderItems).
        // If the requested file isn't yet processed, it will get updated when configure is finished.
        // TODO: remember all requests that are coming and send an update as soon as we detect
        // any of them being pushed into make.customConfigProviderItems.
        if (this.cppToolsAPI) {
            if (!this.ranNotifyReadyInSession && this.cppToolsAPI.notifyReady) {
                this.cppToolsAPI.notifyReady(this.cppConfigurationProvider);
                this.setRanNotifyReadyInSession(true);
            }
        }
    }
    // Request a custom config provider update.
    updateCppToolsProvider() {
        this.cppConfigurationProvider.logConfigurationProviderBrowse();
        if (this.cppToolsAPI) {
            this.cppToolsAPI.didChangeCustomConfiguration(this.cppConfigurationProvider);
        }
    }
    ensureCppToolsProviderRegistered() {
        // make sure this extension is registered as provider only once
        if (!this.cppConfigurationProviderRegister) {
            this.cppConfigurationProviderRegister = this.registerCppTools();
        }
        return this.cppConfigurationProviderRegister;
    }
    getCppToolsVersion() {
        var _a;
        return (_a = this.cppToolsAPI) === null || _a === void 0 ? void 0 : _a.getVersion();
    }
    async registerCppTools() {
        if (!this.cppToolsAPI) {
            this.cppToolsAPI = await cpp.getCppToolsApi(cpp.Version.v6);
        }
        if (this.cppToolsAPI) {
            this.cppToolsAPI.registerCustomConfigurationProvider(this.cppConfigurationProvider);
        }
    }
    clearCummulativeBrowsePath() {
        this.cummulativeBrowsePath = [];
    }
    buildCustomConfigurationProvider(customConfigProviderItem) {
        this.compilerFullPath = customConfigProviderItem.compilerFullPath;
        let provider = make.getDeltaCustomConfigurationProvider();
        const configuration = {
            defines: customConfigProviderItem.defines,
            standard: customConfigProviderItem.standard,
            includePath: customConfigProviderItem.includes,
            forcedInclude: customConfigProviderItem.forcedIncludes,
            intelliSenseMode: customConfigProviderItem.intelliSenseMode,
            compilerPath: customConfigProviderItem.compilerFullPath,
            compilerArgs: customConfigProviderItem.compilerArgs,
            windowsSdkVersion: customConfigProviderItem.windowsSDKVersion,
        };
        // cummulativeBrowsePath incorporates all the files and the includes paths
        // of all the compiler invocations of the current configuration
        customConfigProviderItem.files.forEach((filePath) => {
            let uri = vscode.Uri.file(filePath);
            let sourceFileConfigurationItem = {
                uri,
                configuration,
                compileCommand: {
                    command: customConfigProviderItem.line,
                    directory: customConfigProviderItem.currentPath,
                    file: filePath,
                },
            };
            // These are the configurations processed during the current configure.
            // Store them in the 'delta' file index instead of the final one.
            provider.fileIndex.set(path.normalize(process.platform === "win32" ? uri.fsPath.toUpperCase() : uri.fsPath), sourceFileConfigurationItem);
            exports.extension
                .getCppConfigurationProvider()
                .logConfigurationProviderItem(sourceFileConfigurationItem);
            let folder = path.dirname(filePath);
            if (!this.cummulativeBrowsePath.includes(folder)) {
                this.cummulativeBrowsePath.push(folder);
            }
        });
        customConfigProviderItem.includes.forEach((incl) => {
            if (!this.cummulativeBrowsePath.includes(incl)) {
                this.cummulativeBrowsePath.push(incl);
            }
        });
        customConfigProviderItem.forcedIncludes.forEach((fincl) => {
            let folder = path.dirname(fincl);
            if (!this.cummulativeBrowsePath.includes(folder)) {
                this.cummulativeBrowsePath.push(fincl);
            }
        });
        provider.workspaceBrowse = {
            browsePath: this.cummulativeBrowsePath,
            standard: customConfigProviderItem.standard,
            compilerPath: customConfigProviderItem.compilerFullPath,
            compilerArgs: customConfigProviderItem.compilerArgs,
            windowsSdkVersion: customConfigProviderItem.windowsSDKVersion,
        };
        make.setCustomConfigurationProvider(provider);
    }
    getCompilerFullPath() {
        return this.compilerFullPath;
    }
}
exports.MakefileToolsExtension = MakefileToolsExtension;
async function activate(context) {
    if (process.env["MAKEFILE_TOOLS_TESTING"] === "1") {
        await vscode.commands.executeCommand("setContext", "makefile:testing", true);
    }
    else {
        await vscode.commands.executeCommand("setContext", "makefile:testing", false);
    }
    statusBar = ui.getUI();
    exports.extension = new MakefileToolsExtension(context);
    configuration.disableAllOptionallyVisibleCommands();
    await exports.extension.setFullFeatureSet(false);
    telemetry.activate();
    context.subscriptions.push(vscode.commands.registerCommand("makefile.setBuildConfiguration", async () => {
        await configuration.setNewConfiguration();
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.getConfiguration", async () => {
        telemetry.logEvent("getConfiguration");
        return configuration.getCurrentMakefileConfiguration();
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.setBuildTarget", async () => {
        await configuration.selectTarget();
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.getBuildTarget", async () => {
        telemetry.logEvent("getBuildTarget");
        return configuration.getCurrentTarget() || "";
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.buildTarget", async () => {
        await make.buildTarget(make.TriggeredBy.buildTarget, configuration.getCurrentTarget() || "", false);
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.buildCleanTarget", async () => {
        await make.buildTarget(make.TriggeredBy.buildCleanTarget, configuration.getCurrentTarget() || "", true);
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.buildAll", async () => {
        await make.buildTarget(make.TriggeredBy.buildAll, "all", false);
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.buildCleanAll", async () => {
        await make.buildTarget(make.TriggeredBy.buildCleanAll, "all", true);
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.setLaunchConfiguration", async () => {
        await configuration.selectLaunchConfiguration();
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.launchDebug", async () => {
        await launcher.debugCurrentTarget();
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.launchRun", async () => {
        await launcher.runCurrentTarget();
    }));
    /** Start of commands that shouldn't be exposed in package.json, they are used for command substitution in launch.json and tasks.json.  */
    context.subscriptions.push(vscode.commands.registerCommand("makefile.getLaunchTargetPath", () => {
        telemetry.logEvent("getLaunchTargetPath");
        return launcher.getLaunchTargetPath();
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.launchTargetPath", () => {
        telemetry.logEvent("launchTargetPath");
        return launcher.launchTargetPath();
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.getLaunchTargetDirectory", () => {
        telemetry.logEvent("getLaunchTargetDirectory");
        return launcher.getLaunchTargetDirectory();
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.getLaunchTargetFileName", () => {
        telemetry.logEvent("getLaunchTargetFileName");
        return launcher.getLaunchTargetFileName();
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.launchTargetFileName", () => {
        telemetry.logEvent("launchTargetFileName");
        return launcher.launchTargetFileName();
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.getLaunchTargetArgs", () => {
        telemetry.logEvent("getLaunchTargetArgs");
        return launcher.getLaunchTargetArgs();
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.getLaunchTargetArgsConcat", () => {
        telemetry.logEvent("getLaunchTargetArgsConcat");
        return launcher.getLaunchTargetArgsConcat();
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.makeBaseDirectory", () => {
        telemetry.logEvent("makeBaseDirectory");
        return configuration.makeBaseDirectory();
    }));
    /** End of commands that shouldn't be exposed in package.json, they are used for command substitution in launch.json and tasks.json. */
    context.subscriptions.push(vscode.commands.registerCommand("makefile.configure", async () => {
        await make.configure(make.TriggeredBy.configure);
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.cleanConfigure", async () => {
        await make.cleanConfigure(make.TriggeredBy.cleanConfigure);
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.preConfigure", async () => {
        await make.preConfigure(make.TriggeredBy.preconfigure);
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.postConfigure", async () => {
        await make.postConfigure(make.TriggeredBy.postConfigure);
    }));
    // Reset state - useful for troubleshooting.
    context.subscriptions.push(vscode.commands.registerCommand("makefile.resetState", (reload) => {
        telemetry.logEvent("commandResetState");
        exports.extension.getState().reset(reload);
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.outline.configure", () => {
        return vscode.commands.executeCommand("makefile.configure");
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.outline.cleanConfigure", () => {
        return vscode.commands.executeCommand("makefile.cleanConfigure");
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.outline.preConfigure", () => {
        return vscode.commands.executeCommand("makefile.preConfigure");
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.outline.postConfigure", () => {
        return vscode.commands.executeCommand("makefile.postConfigure");
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.outline.setLaunchConfiguration", () => {
        return vscode.commands.executeCommand("makefile.setLaunchConfiguration");
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.outline.launchDebug", () => {
        return vscode.commands.executeCommand("makefile.launchDebug");
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.outline.launchRun", () => {
        return vscode.commands.executeCommand("makefile.launchRun");
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.outline.setBuildTarget", () => {
        return vscode.commands.executeCommand("makefile.setBuildTarget");
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.outline.buildTarget", () => {
        return vscode.commands.executeCommand("makefile.buildTarget");
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.outline.buildCleanTarget", () => {
        return vscode.commands.executeCommand("makefile.buildCleanTarget");
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.outline.setBuildConfiguration", () => {
        return vscode.commands.executeCommand("makefile.setBuildConfiguration");
    }));
    // Read from the workspace state before reading from settings,
    // becase the latter may use state info in variable expansion.
    configuration.initFromState();
    await configuration.initFromSettings(true);
    const openSettings = async (setting) => {
        await vscode.commands.executeCommand("workbench.action.openSettings", setting);
        await vscode.commands.executeCommand("workbench.action.openWorkspaceSettings");
    };
    const openFile = async (fileUri) => {
        await vscode.commands.executeCommand("vscode.open", fileUri);
        await vscode.commands.executeCommand("workbench.files.action.showActiveFileInExplorer");
    };
    context.subscriptions.push(vscode.commands.registerCommand("makefile.outline.openMakefilePathSetting", async () => {
        await openSettings("makefile.makefilePath");
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.outline.openMakefileFile", async () => {
        const makefile = configuration.getConfigurationMakefile();
        if (makefile) {
            if (util.checkFileExistsSync(makefile)) {
                await openFile(vscode.Uri.file(makefile));
            }
            else {
                exports.extension.updateMakefileFilePresent(false);
                vscode.window.showErrorMessage(localize(0, null));
            }
        }
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.outline.openMakePathSetting", async () => {
        await openSettings("makefile.makePath");
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.outline.openBuildLogSetting", async () => {
        await openSettings("makefile.buildLog");
    }));
    context.subscriptions.push(vscode.commands.registerCommand("makefile.outline.openBuildLogFile", async () => {
        const buildLog = configuration.getBuildLog();
        if (buildLog) {
            if (util.checkFileExistsSync(buildLog)) {
                await openFile(vscode.Uri.file(buildLog));
            }
            else {
                exports.extension.updateBuildLogPresent(false);
                vscode.window.showErrorMessage(localize(1, null));
            }
        }
    }));
    // === Commands only for testing ===
    // commands that are not exposed via package.json and are used only for testing.
    // TODO: In the future, we should refactor such that our tests can use already exposed commands, and/or refactor so
    // that some of our tests that are more unit-like tests can be done with direct dependencies on the code.
    if (process.env["MAKEFILE_TOOLS_TESTING"] === "1") {
        context.subscriptions.push(vscode.commands.registerCommand("makefile.setBuildConfigurationByName", async (name) => {
            await configuration.setConfigurationByName(name);
        }));
        context.subscriptions.push(vscode.commands.registerCommand("makefile.setPreconfigureScriptByPath", async (path) => {
            await configuration.setPreConfigureScript(path);
        }));
        context.subscriptions.push(vscode.commands.registerCommand("makefile.setTargetByName", async (name) => {
            await configuration.setTargetByName(name);
        }));
        context.subscriptions.push(vscode.commands.registerCommand("makefile.setLaunchConfigurationByName", async (name) => {
            await configuration.setLaunchConfigurationByName(name);
        }));
        context.subscriptions.push(vscode.commands.registerCommand("makefile.validateLaunchConfiguration", async () => {
            return await launch
                .getLauncher()
                .validateLaunchConfiguration(make.Operations.debug);
        }));
        context.subscriptions.push(vscode.commands.registerCommand("makefile.getCurrentLaunchConfiguration", async () => {
            return configuration.getCurrentLaunchConfiguration();
        }));
        context.subscriptions.push(vscode.commands.registerCommand("makefile.prepareDebugAndRunCurrentTarget", async (launchConfiguration) => {
            launch.getLauncher().prepareDebugCurrentTarget(launchConfiguration);
            launch.getLauncher().prepareRunCurrentTarget();
        }));
        context.subscriptions.push(vscode.commands.registerCommand("makefile.prepareBuildTarget", async (target) => {
            make.prepareBuildTarget(target);
        }));
        context.subscriptions.push(vscode.commands.registerCommand("makefile.testResetState", async () => {
            await configuration.setCurrentLaunchConfiguration(undefined);
            await configuration.setCurrentMakefileConfiguration("Default");
            configuration.setCurrentTarget(undefined);
            configuration.initFromState();
            await configuration.initFromSettings();
        }));
        context.subscriptions.push(vscode.commands.registerCommand("makefile.getExpandedSettingValue", async (key, value) => {
            await util.getExpandedSettingVal(key, value);
        }));
        context.subscriptions.push(vscode.commands.registerCommand("makefile.expandVariablesInSetting", async (key, value) => {
            return util.expandVariablesInSetting(key, value);
        }));
    }
    // === End of commands only for testing ===
    const parseCompilerArgsScript = util.parseCompilerArgsScriptFile();
    // The extension VSIX stripped the executable bit, so we need to set it.
    // 0x755 means rwxr-xr-x (read and execute for everyone, write for owner).
    await fs_1.promises.chmod(parseCompilerArgsScript, 0o755);
    if (exports.extension.getFullFeatureSet()) {
        let shouldConfigure = configuration.getConfigureOnOpen();
        if (shouldConfigure === null) {
            vscode.window
                .showInformationMessage(localize(2, null), {}, { title: localize(3, null), doConfigure: true }, { title: localize(4, null), doConfigure: false })
                .then(async (chosen) => {
                if (!chosen) {
                    // User cancelled, they don't want to configure.
                    shouldConfigure = false;
                    telemetry.logConfigureOnOpenTelemetry(false);
                }
                else {
                    // ask them if they always want to configure on open.
                    // TODO: More work to do here to have the right flow.
                    const persistMessage = chosen.doConfigure
                        ? localize(5, null)
                        : localize(6, null);
                    const buttonMessages = chosen.doConfigure
                        ? [localize(7, null), localize(8, null)]
                        : [
                            localize(9, null),
                            localize(10, null),
                        ];
                    vscode.window
                        .showInformationMessage(persistMessage, {}, { title: buttonMessages[0], persistMode: "user" }, { title: buttonMessages[1], persistMode: "workspace" })
                        .then(async (choice) => {
                        var _a;
                        if (!choice) {
                            // User cancelled. Do nothing.
                            telemetry.logConfigureOnOpenTelemetry(chosen.doConfigure);
                            return;
                        }
                        let configTarget = vscode.ConfigurationTarget.Global;
                        if (choice.persistMode === "workspace") {
                            configTarget = vscode.ConfigurationTarget.Workspace;
                        }
                        const workspaceFolder = (_a = vscode.workspace.workspaceFolders) === null || _a === void 0 ? void 0 : _a[0];
                        if (workspaceFolder) {
                            await vscode.workspace
                                .getConfiguration(undefined, workspaceFolder)
                                .update("makefile.configureOnOpen", chosen.doConfigure, configTarget);
                        }
                        telemetry.logConfigureOnOpenTelemetry(chosen.doConfigure, choice.persistMode);
                    });
                    shouldConfigure = chosen.doConfigure;
                    if (shouldConfigure === true) {
                        await make.cleanConfigure(make.TriggeredBy.cleanConfigureOnOpen);
                    }
                }
            });
        }
        if (shouldConfigure === true) {
            // We've opened a new workspace folder, and the user wants us to configure it now.
            await make.cleanConfigure(make.TriggeredBy.cleanConfigureOnOpen);
        }
    }
    // Analyze settings for type validation and telemetry
    let workspaceConfiguration = vscode.workspace.getConfiguration("makefile");
    let telemetryProperties = {};
    try {
        telemetryProperties = await telemetry.analyzeSettings(workspaceConfiguration, "makefile", util.thisExtensionPackage().contributes.configuration.properties, true, telemetryProperties);
    }
    catch (e) {
        telemetry.telemetryLogger(e.message);
    }
    if (telemetryProperties && util.hasProperties(telemetryProperties)) {
        telemetry.logEvent("settings", telemetryProperties);
    }
}
exports.activate = activate;
async function deactivate() {
    vscode.window.showInformationMessage(localize(11, null, "'vscode-makefile-tools'"));
    await telemetry.deactivate();
    const items = [exports.extension, launcher, statusBar];
    for (const item of items) {
        if (item) {
            item.dispose();
        }
    }
}
exports.deactivate = deactivate;


/***/ }),

/***/ 347:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLauncher = exports.Launcher = exports.LaunchStatuses = void 0;
// Launch support: debug and run in terminal
const configuration = __webpack_require__(604);
const extension = __webpack_require__(15);
const logger = __webpack_require__(464);
const make = __webpack_require__(970);
const path = __webpack_require__(928);
const telemetry = __webpack_require__(277);
const util = __webpack_require__(260);
const vscode = __webpack_require__(398);
const nls = __webpack_require__(493);
nls.config({
    messageFormat: nls.MessageFormat.bundle,
    bundleFormat: nls.BundleFormat.standalone,
})((__webpack_require__(928).join)(__dirname, 'src\\launch.ts'));
const localize = nls.loadMessageBundle((__webpack_require__(928).join)(__dirname, 'src\\launch.ts'));
var LaunchStatuses;
(function (LaunchStatuses) {
    LaunchStatuses["success"] = "success";
    LaunchStatuses["blocked"] = "blocked by (pre)configure or build";
    LaunchStatuses["noLaunchConfigurationSet"] = "no launch configuration set by the user";
    LaunchStatuses["launchTargetsListEmpty"] = "launch targets list empty";
    LaunchStatuses["buildFailed"] = "build failed";
})(LaunchStatuses = exports.LaunchStatuses || (exports.LaunchStatuses = {}));
let launcher;
class Launcher {
    constructor() {
        // Watch for the user closing our terminal
        this.onTerminalClose = vscode.window.onDidCloseTerminal((term) => {
            if (term === this.launchTerminal) {
                this.launchTerminal = undefined;
            }
        });
    }
    // Command property accessible from launch.json:
    // the full path of the target binary currently set for launch
    getLaunchTargetPath() {
        let launchConfiguration = configuration.getCurrentLaunchConfiguration();
        if (launchConfiguration) {
            return launchConfiguration.binaryPath;
        }
        else {
            return "";
        }
    }
    // Command property accessible from launch.json:
    // calls getLaunchTargetPath after triggering a build of the current target,
    // if makefile.buildBeforeLaunch allows it.
    async launchTargetPath() {
        if (configuration.getBuildBeforeLaunch()) {
            await make.buildTarget(make.TriggeredBy.launch, configuration.getCurrentTarget() || "");
        }
        return this.getLaunchTargetPath();
    }
    // Command property accessible from launch.json:
    // the full path from where the target binary is to be launched
    getLaunchTargetDirectory() {
        let launchConfiguration = configuration.getCurrentLaunchConfiguration();
        if (launchConfiguration) {
            return launchConfiguration.cwd;
        }
        else {
            return util.getWorkspaceRoot();
        }
    }
    // Command property accessible from launch.json:
    // the file name of the current target binary, without path or extension.
    getLaunchTargetFileName() {
        let launchConfiguration = configuration.getCurrentLaunchConfiguration();
        if (launchConfiguration) {
            return path.parse(launchConfiguration.binaryPath).name;
        }
        else {
            return "";
        }
    }
    // Command property accessible from launch.json:
    // calls getLaunchTargetFileName after triggering a build of the current target,
    // if makefile.buildBeforeLaunch allows it.
    async launchTargetFileName() {
        if (configuration.getBuildBeforeLaunch()) {
            await make.buildTarget(make.TriggeredBy.launch, configuration.getCurrentTarget() || "");
        }
        return this.getLaunchTargetFileName();
    }
    // Command property accessible from launch.json:
    // the arguments sent to the target binary, returned as array of string
    // This is used by the debug/terminal VS Code APIs.
    getLaunchTargetArgs() {
        let launchConfiguration = configuration.getCurrentLaunchConfiguration();
        if (launchConfiguration) {
            return launchConfiguration.binaryArgs;
        }
        else {
            return [];
        }
    }
    // Command property accessible from launch.json:
    // the arguments sent to the target binary, returned as one simple string
    // This is an alternative to define the arguments in launch.json,
    // since the string array syntax is not working.
    // This is not a perfect solution, it all depends on how the main entry point
    // is parsing its given arguments.
    // Example: for [CWD>tool arg1 arg2 arg3], the tool will receive
    // 2 arguments: tool and "arg1 arg2 arg3"
    // As opposed to the above case when the tool will receive
    // 4 arguments: tool, arg1, arg2, arg3
    // TODO: investigate how we can define string array arguments
    // for the target binary in launch.json
    getLaunchTargetArgsConcat() {
        return this.getLaunchTargetArgs().join(" ");
    }
    // Invoke a VS Code debugging session passing it all the information
    // from the current launch configuration.
    // Debugger (imperfect) guess logic:
    //    - VS for msvc toolset, lldb for clang toolset, gdb for anything else.
    //    - debugger path is assumed to be the same as the compiler path.
    // Exceptions for miMode:
    //    - if the above logic results in a debugger that is missing, try the other one.
    //      This is needed either because the system might not be equipped
    //      with the preffered debugger that corresponds to the toolset in use,
    //      but also because there might be a compiler alias that is not properly identified
    //      (example: "cc" alias that points to clang but is not identified as clang,
    //       therefore requesting a gdb debugger which may be missing
    //       because there is no gcc toolset installed).
    //       TODO: implement proper detection of aliases and their commands.
    // Exceptions for miDebuggerPath:
    //    - for MacOS, point to the lldb-mi debugger that is installed by CppTools
    //    - if CppTools extension is not installed, intentionally do not provide a miDebuggerPath On MAC,
    //      because the debugger knows how to find automatically the right lldb-mi when miMode is lldb and miDebuggerPath is undefined
    //      (this is true for systems older than Catalina).
    // Additionally, cppvsdbg ignores miMode and miDebuggerPath.
    prepareDebugCurrentTarget(currentLaunchConfiguration) {
        let args = this.getLaunchTargetArgs();
        let compilerPath = extension.extension.getCompilerFullPath();
        let parsedObjPath = compilerPath
            ? path.parse(compilerPath)
            : undefined;
        let isClangCompiler = parsedObjPath === null || parsedObjPath === void 0 ? void 0 : parsedObjPath.name.startsWith("clang");
        let isMsvcCompiler = !isClangCompiler && (parsedObjPath === null || parsedObjPath === void 0 ? void 0 : parsedObjPath.name.startsWith("cl"));
        let dbg = isMsvcCompiler ? "cppvsdbg" : "cppdbg";
        // Initial debugger guess
        let guessMiDebuggerPath = !isMsvcCompiler && parsedObjPath ? parsedObjPath.dir : undefined;
        let guessMiMode;
        if (parsedObjPath === null || parsedObjPath === void 0 ? void 0 : parsedObjPath.name.startsWith("clang")) {
            guessMiMode = "lldb";
        }
        else if (!(parsedObjPath === null || parsedObjPath === void 0 ? void 0 : parsedObjPath.name.startsWith("cl"))) {
            guessMiMode = "gdb";
        }
        // If the first chosen debugger is not installed, try the other one.
        if (guessMiDebuggerPath && guessMiMode) {
            // if the guessMiDebuggerPath is already a file, then go with that. Otherwise, append the guessMiMode.
            let debuggerPath = util.checkFileExistsSync(guessMiDebuggerPath)
                ? guessMiDebuggerPath
                : path.join(guessMiDebuggerPath, guessMiMode);
            if (process.platform === "win32") {
                // On mingw a file is not found if the extension is not part of the path
                debuggerPath = debuggerPath + ".exe";
            }
            if (!util.checkFileExistsSync(debuggerPath)) {
                guessMiMode = guessMiMode === "gdb" ? "lldb" : "gdb";
            }
        }
        // Properties defined by makefile.launchConfigurations override makefile.defaultLaunchConfiguration
        // and they both override the guessed values.
        let defaultLaunchConfiguration = configuration.getDefaultLaunchConfiguration();
        let miMode = currentLaunchConfiguration.MIMode ||
            (defaultLaunchConfiguration === null || defaultLaunchConfiguration === void 0 ? void 0 : defaultLaunchConfiguration.MIMode) ||
            guessMiMode;
        let miDebuggerPath = currentLaunchConfiguration.miDebuggerPath ||
            (defaultLaunchConfiguration === null || defaultLaunchConfiguration === void 0 ? void 0 : defaultLaunchConfiguration.miDebuggerPath) ||
            guessMiDebuggerPath;
        // Exception for MAC-lldb, point to the lldb-mi installed by CppTools or set debugger path to undefined
        // (more details in the comment at the beginning of this function).
        if (miMode === "lldb" && process.platform === "darwin") {
            const cpptoolsExtension = vscode.extensions.getExtension("ms-vscode.cpptools");
            miDebuggerPath = cpptoolsExtension
                ? path.join(cpptoolsExtension.extensionPath, "debugAdapters", "lldb-mi", "bin", "lldb-mi")
                : undefined;
        }
        else if (miDebuggerPath && miMode) {
            // if the miDebuggerPath is already a file, rather than a directory, go with it.
            // Otherwise, append the MiMode.
            miDebuggerPath = util.checkFileExistsSync(miDebuggerPath)
                ? miDebuggerPath
                : path.join(miDebuggerPath, miMode);
            if (process.platform === "win32") {
                miDebuggerPath = miDebuggerPath + ".exe";
            }
        }
        let debugConfig = {
            type: dbg,
            name: `Debug My Program`,
            request: "launch",
            cwd: this.getLaunchTargetDirectory(),
            args,
            env: util.mergeEnvironment(process.env),
            program: this.getLaunchTargetPath(),
            MIMode: miMode,
            miDebuggerPath: miDebuggerPath,
            console: "internalConsole",
            internalConsoleOptions: "openOnSessionStart",
            stopAtEntry: currentLaunchConfiguration.stopAtEntry ||
                (defaultLaunchConfiguration === null || defaultLaunchConfiguration === void 0 ? void 0 : defaultLaunchConfiguration.stopAtEntry),
            symbolSearchPath: currentLaunchConfiguration.symbolSearchPath ||
                (defaultLaunchConfiguration === null || defaultLaunchConfiguration === void 0 ? void 0 : defaultLaunchConfiguration.symbolSearchPath),
        };
        logger.message(localize(0, null, dbg, debugConfig.cwd, this.getLaunchTargetDirectory(), args.join(" "), debugConfig.program, this.getLaunchTargetPath(), debugConfig.MIMode, debugConfig.miDebuggerPath, debugConfig.stopAtEntry, debugConfig.symbolSearchPath));
        return debugConfig;
    }
    async validateLaunchConfiguration(op) {
        // Cannot debug the project if it is currently building or (pre-)configuring.
        if (make.blockedByOp(op)) {
            return LaunchStatuses.blocked;
        }
        if (configuration.getBuildBeforeLaunch()) {
            let currentBuildTarget = configuration.getCurrentTarget() || "";
            logger.message(localize(1, null, currentBuildTarget));
            let buildSuccess = (await make.buildTarget(make.TriggeredBy.buildTarget, currentBuildTarget, false)) === make.ConfigureBuildReturnCodeTypes.success;
            if (!buildSuccess) {
                logger.message(localize(2, null, currentBuildTarget));
                let noButton = localize(3, null);
                let yesButton = localize(4, null);
                const message = localize(5, null);
                const chosen = await vscode.window.showErrorMessage(message, {
                    title: yesButton,
                    isCloseAffordance: false,
                }, {
                    title: noButton,
                    isCloseAffordance: true,
                });
                if (chosen === undefined || chosen.title === noButton) {
                    return LaunchStatuses.buildFailed;
                }
            }
        }
        let currentLaunchConfiguration = configuration.getCurrentLaunchConfiguration();
        if (!currentLaunchConfiguration) {
            // If no launch configuration is set, give the user a chance to select one now from the quick pick
            // (unless we know it's going to be empty).
            if (configuration.getLaunchTargets().length === 0) {
                vscode.window.showErrorMessage(localize(6, null, op));
                return LaunchStatuses.launchTargetsListEmpty;
            }
            else {
                vscode.window.showErrorMessage(localize(7, null, op));
                await configuration.selectLaunchConfiguration();
                // Read again the current launch configuration. If a current launch configuration is stil not set
                // (the user cancelled the quick pick or the parser found zero launch targets) message and fail.
                currentLaunchConfiguration =
                    configuration.getCurrentLaunchConfiguration();
                if (!currentLaunchConfiguration) {
                    vscode.window.showErrorMessage(localize(8, null, op));
                    return LaunchStatuses.noLaunchConfigurationSet;
                }
            }
        }
        return LaunchStatuses.success;
    }
    async debugCurrentTarget() {
        let status = await this.validateLaunchConfiguration(make.Operations.debug);
        let currentLaunchConfiguration;
        if (status === LaunchStatuses.success) {
            currentLaunchConfiguration =
                configuration.getCurrentLaunchConfiguration();
        }
        if (currentLaunchConfiguration) {
            let debugConfig = this.prepareDebugCurrentTarget(currentLaunchConfiguration);
            let startFolder;
            if (vscode.workspace.workspaceFolders) {
                startFolder = vscode.workspace.workspaceFolders[0];
                await vscode.debug.startDebugging(startFolder, debugConfig);
            }
            else {
                await vscode.debug.startDebugging(undefined, debugConfig);
            }
            if (!vscode.debug.activeDebugSession) {
                status = "failed";
            }
        }
        let telemetryProperties = {
            status: status,
        };
        telemetry.logEvent("debug", telemetryProperties);
        return vscode.debug.activeDebugSession;
    }
    // Invoke a VS Code running terminal passing it all the information
    // from the current launch configuration
    prepareRunCurrentTarget() {
        // Add a pair of quotes just in case there is a space in the binary path
        let terminalCommand = '"' + this.getLaunchTargetPath() + '" ';
        terminalCommand += this.getLaunchTargetArgs().join(" ");
        // Log the message for high verbosity only because the output channel will become visible over the terminal,
        // even if the terminal show() is called after the logger show().
        logger.message(localize(9, null, terminalCommand, this.getLaunchTargetDirectory()), "Debug");
        return terminalCommand;
    }
    async runCurrentTarget() {
        const terminalOptions = {
            name: "Make/Launch",
        };
        // Use cmd.exe on Windows
        if (process.platform === "win32") {
            terminalOptions.shellPath = "C:\\Windows\\System32\\cmd.exe";
        }
        terminalOptions.cwd = this.getLaunchTargetDirectory();
        terminalOptions.env = util.mergeEnvironment(process.env);
        if (!this.launchTerminal) {
            this.launchTerminal = vscode.window.createTerminal(terminalOptions);
        }
        let status = await this.validateLaunchConfiguration(make.Operations.run);
        let currentLaunchConfiguration;
        if (status === LaunchStatuses.success) {
            currentLaunchConfiguration =
                configuration.getCurrentLaunchConfiguration();
            let terminalCommand = this.prepareRunCurrentTarget();
            this.launchTerminal.sendText(terminalCommand);
            let telemetryProperties = {
                status: status,
            };
            telemetry.logEvent("run", telemetryProperties);
            this.launchTerminal.show();
        }
        return this.launchTerminal;
    }
    dispose() {
        if (this.launchTerminal) {
            this.launchTerminal.dispose();
        }
        this.onTerminalClose.dispose();
    }
}
exports.Launcher = Launcher;
function getLauncher() {
    if (launcher === undefined) {
        launcher = new Launcher();
    }
    return launcher;
}
exports.getLauncher = getLauncher;


/***/ }),

/***/ 464:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.messageNoCR = exports.message = exports.clearOutputChannel = exports.showOutputChannel = void 0;
// Logging support
const fs = __webpack_require__(896);
const configuration = __webpack_require__(604);
const vscode = __webpack_require__(398);
let makeOutputChannel;
function getOutputChannel() {
    if (!makeOutputChannel) {
        makeOutputChannel = vscode.window.createOutputChannel("Makefile tools");
    }
    return makeOutputChannel;
}
// TODO: process verbosities with enums instead of strings.
// This is a temporary hack.
function loggingLevelApplies(messageVerbosity) {
    let projectVerbosity = configuration.getLoggingLevel();
    if (messageVerbosity === "Debug") {
        return projectVerbosity === "Debug";
    }
    else if (messageVerbosity === "Verbose") {
        return projectVerbosity === "Verbose" || projectVerbosity === "Debug";
    }
    return true;
}
function showOutputChannel() {
    if (makeOutputChannel) {
        makeOutputChannel.show(true);
    }
}
exports.showOutputChannel = showOutputChannel;
function clearOutputChannel() {
    if (makeOutputChannel) {
        makeOutputChannel.clear();
    }
}
exports.clearOutputChannel = clearOutputChannel;
//TODO: implement more verbosity levels for the output log
function message(message, loggingLevel) {
    // Print the message only if the intended logging level matches the settings
    // or if no loggingLevel restriction is provided.
    if (!loggingLevelApplies(loggingLevel)) {
        return;
    }
    let channel = getOutputChannel();
    channel.appendLine(message);
    let extensionLog = configuration.getExtensionLog();
    if (extensionLog) {
        fs.appendFileSync(extensionLog, message);
        fs.appendFileSync(extensionLog, "\n");
    }
}
exports.message = message;
// This is used for a few scenarios where the message already has end of line incorporated.
// Example: stdout/stderr of a child process read before the stream is closed.
function messageNoCR(message, loggingLevel) {
    // Print the message only if the intended logging level matches the settings
    // or if no loggingLevel restriction is provided.
    if (!loggingLevelApplies(loggingLevel)) {
        return;
    }
    let channel = getOutputChannel();
    channel.append(message);
    let extensionLog = configuration.getExtensionLog();
    if (extensionLog) {
        fs.appendFileSync(extensionLog, message);
    }
}
exports.messageNoCR = messageNoCR;


/***/ }),

/***/ 970:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cleanConfigure = exports.doConfigure = exports.loadConfigurationFromCache = exports.preprocessDryRun = exports.configure = exports.runPostConfigureScript = exports.runPreConfigureScript = exports.runPrePostConfigureScript = exports.postConfigure = exports.preConfigure = exports.prePostConfigureHelper = exports.generateParseContent = exports.setParseFile = exports.getParseFile = exports.setParseContent = exports.getParseContent = exports.doBuildTarget = exports.buildTarget = exports.setCurPID = exports.getCurPID = exports.prepareBuildTarget = exports.blockedByOp = exports.setCustomConfigurationProvider = exports.getDeltaCustomConfigurationProvider = exports.TriggeredBy = exports.Operations = exports.ConfigureBuildReturnCodeTypes = exports.setIsPostConfiguring = exports.getIsPostConfiguring = exports.setIsPreConfiguring = exports.getIsPreConfiguring = exports.setConfigureIsClean = exports.getConfigureIsClean = exports.setConfigureIsInBackground = exports.getConfigureIsInBackground = exports.setIsConfiguring = exports.getIsConfiguring = exports.setIsBuilding = exports.getIsBuilding = void 0;
// Support for make operations
const configuration = __webpack_require__(604);
const extension_1 = __webpack_require__(15);
const fs = __webpack_require__(896);
const logger = __webpack_require__(464);
const parser = __webpack_require__(767);
const path = __webpack_require__(928);
const util = __webpack_require__(260);
const telemetry = __webpack_require__(277);
const vscode = __webpack_require__(398);
const uuid_1 = __webpack_require__(874);
const nls = __webpack_require__(493);
nls.config({
    messageFormat: nls.MessageFormat.bundle,
    bundleFormat: nls.BundleFormat.standalone,
})((__webpack_require__(928).join)(__dirname, 'src\\make.ts'));
const localize = nls.loadMessageBundle((__webpack_require__(928).join)(__dirname, 'src\\make.ts'));
const recursiveString = localize(0, null);
let isBuilding = false;
function getIsBuilding() {
    return isBuilding;
}
exports.getIsBuilding = getIsBuilding;
function setIsBuilding(building) {
    isBuilding = building;
}
exports.setIsBuilding = setIsBuilding;
let isConfiguring = false;
function getIsConfiguring() {
    return isConfiguring;
}
exports.getIsConfiguring = getIsConfiguring;
function setIsConfiguring(configuring) {
    isConfiguring = configuring;
}
exports.setIsConfiguring = setIsConfiguring;
let configureIsInBackground = false;
function getConfigureIsInBackground() {
    return configureIsInBackground;
}
exports.getConfigureIsInBackground = getConfigureIsInBackground;
function setConfigureIsInBackground(background) {
    configureIsInBackground = background;
}
exports.setConfigureIsInBackground = setConfigureIsInBackground;
let configureIsClean = false;
function getConfigureIsClean() {
    return configureIsClean;
}
exports.getConfigureIsClean = getConfigureIsClean;
function setConfigureIsClean(clean) {
    configureIsClean = clean;
}
exports.setConfigureIsClean = setConfigureIsClean;
let isPreConfiguring = false;
function getIsPreConfiguring() {
    return isPreConfiguring;
}
exports.getIsPreConfiguring = getIsPreConfiguring;
function setIsPreConfiguring(preConfiguring) {
    isPreConfiguring = preConfiguring;
}
exports.setIsPreConfiguring = setIsPreConfiguring;
let isPostConfiguring = false;
function getIsPostConfiguring() {
    return isPostConfiguring;
}
exports.getIsPostConfiguring = getIsPostConfiguring;
function setIsPostConfiguring(postConfiguring) {
    isPostConfiguring = postConfiguring;
}
exports.setIsPostConfiguring = setIsPostConfiguring;
// Leave positive error codes for make exit values
var ConfigureBuildReturnCodeTypes;
(function (ConfigureBuildReturnCodeTypes) {
    ConfigureBuildReturnCodeTypes[ConfigureBuildReturnCodeTypes["success"] = 0] = "success";
    ConfigureBuildReturnCodeTypes[ConfigureBuildReturnCodeTypes["blocked"] = -1] = "blocked";
    ConfigureBuildReturnCodeTypes[ConfigureBuildReturnCodeTypes["cancelled"] = -2] = "cancelled";
    ConfigureBuildReturnCodeTypes[ConfigureBuildReturnCodeTypes["notFound"] = -3] = "notFound";
    ConfigureBuildReturnCodeTypes[ConfigureBuildReturnCodeTypes["outOfDate"] = -4] = "outOfDate";
    ConfigureBuildReturnCodeTypes[ConfigureBuildReturnCodeTypes["other"] = -5] = "other";
    ConfigureBuildReturnCodeTypes[ConfigureBuildReturnCodeTypes["saveFailed"] = -6] = "saveFailed";
    ConfigureBuildReturnCodeTypes[ConfigureBuildReturnCodeTypes["fullFeatureFalse"] = -7] = "fullFeatureFalse";
    ConfigureBuildReturnCodeTypes[ConfigureBuildReturnCodeTypes["untrusted"] = -8] = "untrusted";
})(ConfigureBuildReturnCodeTypes = exports.ConfigureBuildReturnCodeTypes || (exports.ConfigureBuildReturnCodeTypes = {}));
var Operations;
(function (Operations) {
    Operations["preConfigure"] = "pre-configure";
    Operations["postConfigure"] = "post-configure";
    Operations["configure"] = "configure";
    Operations["build"] = "build";
    Operations["changeConfiguration"] = "change makefile configuration";
    Operations["changeBuildTarget"] = "change build target";
    Operations["changeLaunchTarget"] = "change launch target";
    Operations["debug"] = "debug";
    Operations["run"] = "run";
})(Operations = exports.Operations || (exports.Operations = {}));
var TriggeredBy;
(function (TriggeredBy) {
    TriggeredBy["buildTarget"] = "command pallette (buildTarget)";
    TriggeredBy["buildCleanTarget"] = "command pallette (buildCleanTarget)";
    TriggeredBy["buildAll"] = "command pallette (buildAll)";
    TriggeredBy["buildCleanAll"] = "command pallette (buildCleanAll)";
    TriggeredBy["preconfigure"] = "command pallette (preConfigure)";
    TriggeredBy["alwaysPreconfigure"] = "settings (alwaysPreConfigure)";
    TriggeredBy["postConfigure"] = "command pallette (postConfigure)";
    TriggeredBy["alwaysPostConfigure"] = "settings (alwaysPostConfigure)";
    TriggeredBy["configure"] = "command pallette (configure)";
    TriggeredBy["configureOnOpen"] = "settings (configureOnOpen)";
    TriggeredBy["cleanConfigureOnOpen"] = "configure dirty (on open), settings (configureOnOpen)";
    TriggeredBy["cleanConfigure"] = "command pallette (clean configure)";
    TriggeredBy["configureBeforeBuild"] = "configure dirty (before build), settings (configureAfterCommand)";
    TriggeredBy["configureAfterConfigurationChange"] = "settings (configureAfterCommand), command pallette (setBuildConfiguration)";
    TriggeredBy["configureAfterEditorFocusChange"] = "configure dirty (editor focus change), settings (configureOnEdit)";
    TriggeredBy["configureBeforeTargetChange"] = "configure dirty (before target change), settings (configureAfterCommand)";
    TriggeredBy["configureAfterTargetChange"] = "settings (configureAfterCommand), command pallette (setBuildTarget)";
    TriggeredBy["configureBeforeLaunchTargetChange"] = "configureDirty (before launch target change), settings (configureAfterCommand)";
    TriggeredBy["launch"] = "Launch (debug|run)";
    TriggeredBy["tests"] = "Makefile Tools Regression Tests";
})(TriggeredBy = exports.TriggeredBy || (exports.TriggeredBy = {}));
let fileIndex = new Map();
let workspaceBrowseConfiguration = {
    browsePath: [],
};
function getDeltaCustomConfigurationProvider() {
    let provider = {
        fileIndex: fileIndex,
        workspaceBrowse: workspaceBrowseConfiguration,
    };
    return provider;
}
exports.getDeltaCustomConfigurationProvider = getDeltaCustomConfigurationProvider;
function setCustomConfigurationProvider(provider) {
    fileIndex = provider.fileIndex;
    workspaceBrowseConfiguration = provider.workspaceBrowse;
}
exports.setCustomConfigurationProvider = setCustomConfigurationProvider;
// Identifies and logs whether an operation should be prevented from running.
// So far, the only blocking scenarios are if an ongoing configure, pre-configure or build
// is blocking other new similar operations and setter commands (selection of new configurations, targets, etc...)
// Getter commands are not blocked, even if by the time the (pre-)configure or build operations are completed
// they might be out of date.
// For the moment, the status bar buttons don't change when an operation is blocked
// and cancelling is done only via a button in the bottom right popup.
// Clicking the status bar buttons attempts to run the corresponding operation,
// which triggers a popup and returns early if it should be blocked. Same for pallette commands.
// In future we may enable/disable or change text depending on the blocking state.
function blockedByOp(op, showPopup = true) {
    let blocker;
    if (getIsPreConfiguring()) {
        blocker = Operations.preConfigure;
    }
    if (getIsPostConfiguring()) {
        blocker = Operations.postConfigure;
    }
    if (getIsConfiguring()) {
        // A configure in the background shouldn't block anything except another configure
        if (getConfigureIsInBackground() && op !== Operations.configure) {
            vscode.window.showInformationMessage(localize(1, null, op));
        }
        else {
            blocker = Operations.configure;
        }
    }
    if (getIsBuilding()) {
        blocker = Operations.build;
    }
    if (blocker && showPopup) {
        vscode.window.showErrorMessage(localize(2, null, `'${op}'`, blocker));
    }
    return blocker;
}
exports.blockedByOp = blockedByOp;
async function saveAll() {
    if (configuration.getSaveBeforeBuildOrConfigure()) {
        logger.message(localize(3, null));
        let saveSuccess = await vscode.workspace.saveAll();
        if (saveSuccess) {
            return true;
        }
        else {
            logger.message(localize(4, null));
            let yesButton = localize(5, null);
            let noButton = localize(6, null);
            const chosen = await vscode.window.showErrorMessage("Saving opened files failed. Do you want to continue anyway?", {
                title: yesButton,
                isCloseAffordance: false,
            }, {
                title: noButton,
                isCloseAffordance: true,
            });
            return chosen !== undefined && chosen.title === yesButton;
        }
    }
    else {
        return true;
    }
}
function prepareBuildTarget(target) {
    let makeArgs = [];
    // Prepend the target to the arguments given in the configurations json.
    // If a clean build is desired, "clean" should precede the target.
    if (target) {
        makeArgs.push(target);
    }
    makeArgs = makeArgs.concat(configuration.getConfigurationMakeArgs());
    logger.message(localize(7, null, target, configuration.getConfigurationMakeCommand(), makeArgs.join(" ")));
    return makeArgs;
}
exports.prepareBuildTarget = prepareBuildTarget;
// Build targets allow list for telemetry
function processTargetForTelemetry(target) {
    if (!target || target === "") {
        return "(unset)";
    }
    else if (target === "all" || target === "clean") {
        return target;
    }
    return "..."; // private undisclosed info
}
// PID of the process that may be running currently.
// At any moment, there is either no process or only one process running
// (make for configure, make for build or pre-configure cmd/bash).
// TODO: improve the code regarding curPID and how util.spawnChildProcess is setting it in make.ts unit.
let curPID = -1;
function getCurPID() {
    return curPID;
}
exports.getCurPID = getCurPID;
function setCurPID(pid) {
    curPID = pid;
}
exports.setCurPID = setCurPID;
const makefileBuildTaskName = "Makefile Tools Build Task";
async function buildTarget(triggeredBy, target, clean = false) {
    if (blockedByOp(Operations.build)) {
        return ConfigureBuildReturnCodeTypes.blocked;
    }
    if (!saveAll()) {
        return ConfigureBuildReturnCodeTypes.saveFailed;
    }
    // Same start time for build and an eventual configure.
    let buildStartTime = Date.now();
    // warn about an out of date configure state and configure if makefile.configureAfterCommand allows.
    let configureExitCode; // used for telemetry
    let configureElapsedTime; // used for telemetry
    if (extension_1.extension.getState().configureDirty) {
        logger.message(localize(8, null));
        if (configuration.getConfigureAfterCommand()) {
            configureExitCode = await configure(TriggeredBy.configureBeforeBuild);
            if (configureExitCode !== ConfigureBuildReturnCodeTypes.success) {
                logger.message(localize(9, null));
            }
            configureElapsedTime = util.elapsedTimeSince(buildStartTime);
        }
    }
    // Prepare a notification popup
    let config = configuration.getCurrentMakefileConfiguration();
    let configAndTarget = config;
    if (target) {
        target = target.trimLeft();
        if (target !== "") {
            configAndTarget += "/" + target;
        }
    }
    configAndTarget = `"${configAndTarget}"`;
    const cleanPopup = localize(10, null, configAndTarget);
    const notCleanPopup = localize(11, null, configAndTarget);
    let popupStr = clean ? cleanPopup : notCleanPopup;
    let cancelBuild = false; // when the build was cancelled by the user
    try {
        return await vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: popupStr,
            cancellable: true,
        }, async (progress, cancel) => {
            cancel.onCancellationRequested(async () => {
                progress.report({
                    increment: 1,
                    message: localize(12, null),
                });
                logger.message(localize(13, null));
                cancelBuild = true;
                // Kill the task that is used for building.
                // This will take care of all processes that were spawned.
                let myTask = vscode.tasks.taskExecutions.find((tsk) => {
                    if (tsk.task.name === makefileBuildTaskName) {
                        return tsk;
                    }
                });
                logger.message(localize(14, null, makefileBuildTaskName));
                myTask === null || myTask === void 0 ? void 0 : myTask.terminate();
            });
            setIsBuilding(true);
            // If required by the "makefile.clearOutputBeforeBuild" setting,
            // we need to clear the terminal output when "make"-ing target "clean"
            // (but not when "make"-ing the following intended target, so that we see both together)
            // or when "make"-ing the intended target in case of a not-clean build.
            let clearOutput = configuration.getClearOutputBeforeBuild() || false;
            if (clean) {
                // We don't need to track the return code for 'make "clean"'.
                // We want to proceed with the 'make "target"' step anyway.
                // The relevant return code for telemetry will be the second one.
                // If the clean step fails, doBuildTarget will print an error message in the terminal.
                await doBuildTarget(progress, "clean", clearOutput);
            }
            let retc = await doBuildTarget(progress, target, clearOutput && !clean);
            // We need to know whether this build was cancelled by the user
            // more than the real exit code of the make process in this circumstance.
            if (cancelBuild) {
                retc = ConfigureBuildReturnCodeTypes.cancelled;
            }
            let buildElapsedTime = util.elapsedTimeSince(buildStartTime);
            const telemetryProperties = {
                exitCode: (retc === null || retc === void 0 ? void 0 : retc.toString()) || "undefined",
                target: processTargetForTelemetry(target),
                triggeredBy: triggeredBy,
            };
            const telemetryMeasures = {
                buildTotalElapsedTime: buildElapsedTime,
            };
            // Report if this build ran also a configure and how long it took.
            if (configureExitCode !== undefined) {
                telemetryProperties.configureExitCode = configureExitCode.toString();
            }
            if (configureElapsedTime !== undefined) {
                telemetryMeasures.configureElapsedTime = configureElapsedTime;
            }
            telemetry.logEvent("build", telemetryProperties, telemetryMeasures);
            cancelBuild = false;
            return retc;
        });
    }
    finally {
        setIsBuilding(false);
    }
}
exports.buildTarget = buildTarget;
async function doBuildTarget(progress, target, clearTerminalOutput) {
    let makeArgs = prepareBuildTarget(target);
    try {
        const quotingStlye = vscode.ShellQuoting.Strong;
        const quotingStyleName = "Strong";
        let myTaskCommand = {
            value: configuration.getConfigurationMakeCommand(),
            quoting: quotingStlye,
        };
        let myTaskArgs = makeArgs.map((arg) => {
            return { value: arg, quoting: quotingStlye };
        });
        const cwd = configuration.makeBaseDirectory();
        if (!util.checkDirectoryExistsSync(cwd)) {
            logger.message(localize(15, null, target, cwd));
            return ConfigureBuildReturnCodeTypes.notFound;
        }
        let myTaskOptions = {
            env: util.mergeEnvironment(process.env),
            cwd,
        };
        let shellExec = new vscode.ShellExecution(myTaskCommand, myTaskArgs, myTaskOptions);
        let myTask = new vscode.Task({ type: "shell", group: "build", label: makefileBuildTaskName }, vscode.TaskScope.Workspace, makefileBuildTaskName, "makefile", shellExec);
        myTask.problemMatchers = configuration.getConfigurationProblemMatchers();
        myTask.presentationOptions.clear = clearTerminalOutput;
        myTask.presentationOptions.showReuseMessage = true;
        logger.message(localize(16, null, myTask.name, quotingStyleName, myTaskCommand.value, makeArgs.join()), "Debug");
        await vscode.tasks.executeTask(myTask);
        const result = await new Promise((resolve) => {
            let disposable = vscode.tasks.onDidEndTaskProcess((e) => {
                var _a;
                if (e.execution.task.name === makefileBuildTaskName) {
                    disposable.dispose();
                    resolve((_a = e.exitCode) !== null && _a !== void 0 ? _a : ConfigureBuildReturnCodeTypes.other);
                }
            });
        });
        if (result !== ConfigureBuildReturnCodeTypes.success) {
            logger.message(localize(17, null, target));
        }
        else {
            logger.message(localize(18, null, target));
        }
        return result;
    }
    catch (error) {
        // No need for notification popup, since the build result is visible already in the output channel
        logger.message(error);
        return ConfigureBuildReturnCodeTypes.notFound;
    }
}
exports.doBuildTarget = doBuildTarget;
// Content to be parsed by various operations post configure (like finding all build/launch targets).
// Represents the content of the provided makefile.buildLog or a fresh output of make --dry-run
// (which is also written into makefile.configurationCachePath).
let parseContent;
function getParseContent() {
    return parseContent;
}
exports.getParseContent = getParseContent;
function setParseContent(content) {
    parseContent = content;
}
exports.setParseContent = setParseContent;
// The source file of parseContent (build log or configuration dryrun cache).
let parseFile;
function getParseFile() {
    return parseFile;
}
exports.getParseFile = getParseFile;
function setParseFile(file) {
    parseFile = file;
}
exports.setParseFile = setParseFile;
// Targets need to parse a dryrun make invocation that does not include a target name
// (other than default empty "" or the standard "all"), otherwise it would produce
// a subset of all the targets involved in the makefile (only the ones triggered
// by building the current target).
async function generateParseContent(progress, cancel, forTargets = false, recursive = false) {
    if (cancel.isCancellationRequested) {
        return {
            retc: ConfigureBuildReturnCodeTypes.cancelled,
            elapsed: 0,
        };
    }
    let startTime = Date.now();
    // Rules for parse content and file:
    //     1. makefile.buildLog provided by the user in settings
    //     2. configuration cache (the previous dryrun output): makefile.configurationCachePath
    //     3. the make dryrun output if (2) is missing
    // We do not use buildLog for build targets analysis because
    // we can afford to invoke make -pRrq (very quick even on large projects).
    // We make sure to give the regression tests suite a build log that already contains
    // targets information because we want to avoid invoking make for now.
    let buildLog = configuration.getConfigurationBuildLog();
    if (buildLog &&
        (!forTargets || process.env["MAKEFILE_TOOLS_TESTING"] === "1")) {
        parseContent = util.readFile(buildLog);
        if (parseContent) {
            parseFile = buildLog;
            return {
                retc: ConfigureBuildReturnCodeTypes.success,
                elapsed: util.elapsedTimeSince(startTime),
            };
        }
    }
    const dryRunString = localize(19, null);
    const forTargetsString = localize(20, null);
    progress.report({
        increment: 1,
        message: dryRunString +
            (recursive ? ` ${recursiveString}` : "") +
            (forTargets ? ` ${forTargetsString}` : "" + "..."),
    });
    // Continue with the make dryrun invocation
    let makeArgs = [];
    // Prepend the target to the arguments given in the makefile.configurations object,
    // unless we want to parse for the full set of available targets.
    if (forTargets) {
        makeArgs.push("all");
    }
    else {
        let currentTarget = configuration.getCurrentTarget();
        if (currentTarget) {
            makeArgs.push(currentTarget);
        }
    }
    // Include all the make arguments defined in makefile.configurations.makeArgs
    makeArgs = makeArgs.concat(configuration.getConfigurationMakeArgs());
    // If we are analyzing build targets, we need the following switches:
    //  --print-data-base (which generates verbose output where we parse targets from).
    // --no-builtin-variables and --no-builtin-rules (to reduce the size of the
    // output produced by --print-data-base and also to obtain a list of targets
    // that make sense, skipping over implicit targets like objects from sources
    // or binaries from objects and libs).
    // --question (to not execute anything, for us equivalent of dry-run
    // but without printing commands, which contributes again to a smaller output).
    // If we are analyzing compiler/linker commands for IntelliSense and launch targets,
    // we use --dry-run and anything from makefile.dryrunSwitches.
    const dryrunSwitches = configuration.getDryrunSwitches();
    if (forTargets) {
        makeArgs.push("--print-data-base");
        makeArgs.push("--no-builtin-variables");
        makeArgs.push("--no-builtin-rules");
        makeArgs.push("--question");
        logger.messageNoCR(localize(21, null));
    }
    else {
        makeArgs.push("--dry-run");
        // If this is not a clean configure, remove --always-make from the arguments list.
        // We need to have --always-make in makefile.dryrunSwitches and remove it for not clean configure
        // (as opposed to not having --always-make in makefile.dryrunSwitches and adding it for clean configure)
        // because we want to avoid having 2 dryrun switches settings (one for clean and one for not clean configure)
        // and also because the user needs to be able to remove --always-make from any make --dry-run invocation,
        // if it causes trouble.
        dryrunSwitches === null || dryrunSwitches === void 0 ? void 0 : dryrunSwitches.forEach((sw) => {
            if (getConfigureIsClean() || (sw !== "--always-make" && sw !== "-B")) {
                makeArgs.push(sw);
            }
        });
        logger.messageNoCR(localize(22, null, getConfigureIsInBackground() ? "in the background a new " : ""));
    }
    logger.message(`'${configuration.getConfigurationMakeCommand()} ${makeArgs.join(" ")}'`);
    try {
        let dryrunFile = forTargets ? "./targets.log" : "./dryrun.log";
        let extensionOutputFolder = configuration.getExtensionOutputFolder();
        if (extensionOutputFolder) {
            dryrunFile = path.join(extensionOutputFolder, dryrunFile);
        }
        dryrunFile = util.resolvePathToRoot(dryrunFile);
        logger.message(localize(23, null, dryrunFile));
        const lineEnding = process.platform === "win32" && process.env.MSYSTEM === undefined
            ? "\r\n"
            : "\n";
        util.writeFile(dryrunFile, `${configuration.getConfigurationMakeCommand()} ${makeArgs.join(" ")}${lineEnding}`);
        let completeOutput = "";
        let stderrStr = "";
        let heartBeat = Date.now();
        let stdout = (result) => {
            const appendStr = `${result} ${lineEnding}`;
            completeOutput += appendStr;
            fs.appendFileSync(dryrunFile, appendStr);
            progress.report({
                increment: 1,
                message: dryRunString +
                    (recursive ? ` ${recursiveString}` : "") +
                    (forTargets ? ` ${forTargetsString}` : "" + "..."),
            });
            heartBeat = Date.now();
        };
        let stderr = (result) => {
            // We need this lineEnding to see more clearly the output coming from all these compilers and tools.
            // But there is some unpredictability regarding how much these tools fragment their output, on various
            // OSes and systems. To compare easily against a fix baseline, don't use lineEnding while running tests.
            // So far this has been seen for stderr and not for stdout.
            let appendStr = result;
            if (process.env["MAKEFILE_TOOLS_TESTING"] !== "1") {
                appendStr += lineEnding;
            }
            fs.appendFileSync(dryrunFile, appendStr);
            stderrStr += appendStr;
            // Sometimes there is useful information coming via the stderr
            // (one example is even a bug of the make tool, because it reports
            // "Entering directory" on stderr instead of stdout causing various issues).
            completeOutput += appendStr;
        };
        const heartBeatTimeout = 30; // half minute. TODO: make this a setting
        let timeout = setInterval(function () {
            let elapsedHeartBit = util.elapsedTimeSince(heartBeat);
            if (elapsedHeartBit > heartBeatTimeout) {
                vscode.window.showWarningMessage("Dryrun timeout. See Makefile Tools Output Channel for details.");
                logger.message(localize(24, null));
                logger.message(localize(25, null, dryrunFile));
                // It's enough to show this warning popup once.
                clearInterval(timeout);
            }
        }, 5 * 1000);
        // The dry-run analysis should operate on english.
        const result = await util.spawnChildProcess(configuration.getConfigurationMakeCommand(), makeArgs, util.getWorkspaceRoot(), true, true, stdout, stderr);
        clearInterval(timeout);
        let elapsedTime = util.elapsedTimeSince(startTime);
        logger.message(localize(26, null, elapsedTime));
        parseFile = dryrunFile;
        parseContent = completeOutput;
        // The error codes returned by the targets invocation (make -pRrq) mean something else
        // (for example if targets are out of date). We can ignore the return code for this
        // because it "can't fail". It represents only display of database and no targets are actually run.
        // try syntax error
        if (result.returnCode !== ConfigureBuildReturnCodeTypes.success &&
            !forTargets) {
            logger.message(localize(27, null));
            logger.message(localize(28, null));
            logger.message(stderrStr);
            // Report the standard dry-run error & guide only when the configure was not cancelled
            // by the user (which causes retCode to be null).
            // Also don't write the cache if this operation was cancelled
            // because it may be incomplete and affect a future non clean configure.
            if (result.returnCode !== null) {
                util.reportDryRunError(dryrunFile);
            }
        }
        curPID = -1;
        return {
            retc: result.returnCode,
            elapsed: elapsedTime,
        };
    }
    catch (error) {
        logger.message(error);
        return {
            retc: ConfigureBuildReturnCodeTypes.notFound,
            elapsed: util.elapsedTimeSince(startTime),
        };
    }
}
exports.generateParseContent = generateParseContent;
async function prePostConfigureHelper(titles, configureScriptMethod, setConfigureScriptState, logConfigureScriptTelemetry) {
    // No pre/post configure execution in untrusted workspaces.
    // The check is needed also here in addition to disabling all UI and actions because,
    // depending on settings, this can run automatically at project load.
    if (!vscode.workspace.isTrusted) {
        logger.message(localize(29, null));
        return ConfigureBuildReturnCodeTypes.untrusted;
    }
    // check for being blocked by operations.
    if (blockedByOp(Operations.preConfigure)) {
        return ConfigureBuildReturnCodeTypes.blocked;
    }
    if (blockedByOp(Operations.postConfigure)) {
        return ConfigureBuildReturnCodeTypes.blocked;
    }
    let configureScriptStartTime = Date.now();
    let cancelConfigureScript = false;
    try {
        return await vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: titles.configuringScript,
            cancellable: true,
        }, async (progress, cancel) => {
            cancel.onCancellationRequested(async () => {
                progress.report({
                    increment: 1,
                    message: localize(30, null),
                });
                cancelConfigureScript = true;
                logger.message(localize(31, null, curPID));
                await vscode.window.withProgress({
                    location: vscode.ProgressLocation.Notification,
                    title: titles.cancelling,
                    cancellable: false,
                }, async (progress) => {
                    await util.killTree(progress, curPID);
                });
            });
            setConfigureScriptState(true);
            let retc = await configureScriptMethod(progress);
            if (cancelConfigureScript) {
                retc = ConfigureBuildReturnCodeTypes.cancelled;
            }
            let configureScriptElapsedTime = util.elapsedTimeSince(configureScriptStartTime);
            logConfigureScriptTelemetry(configureScriptElapsedTime, retc);
            cancelConfigureScript = false;
            if (retc !== ConfigureBuildReturnCodeTypes.success) {
                logger.showOutputChannel();
            }
            return retc;
        });
    }
    finally {
        setConfigureScriptState(false);
    }
}
exports.prePostConfigureHelper = prePostConfigureHelper;
async function preConfigure(triggeredBy) {
    let scriptFile = configuration.getPreConfigureScript();
    if (!scriptFile) {
        vscode.window.showErrorMessage(localize(32, null));
        logger.message(localize(33, null));
        return ConfigureBuildReturnCodeTypes.notFound;
    }
    if (!util.checkFileExistsSync(scriptFile)) {
        vscode.window.showErrorMessage(localize(34, null));
        logger.message(localize(35, null, scriptFile));
        return ConfigureBuildReturnCodeTypes.notFound;
    }
    // Assert that scriptFile is not undefined at this point since we've checked above.
    return await prePostConfigureHelper({
        configuringScript: localize(36, null, scriptFile),
        cancelling: localize(37, null),
    }, (progress) => runPreConfigureScript(progress, scriptFile), (value) => setIsPreConfiguring(value), (elapsedTime, exitCode) => {
        const telemetryMeasures = {
            preConfigureElapsedTime: elapsedTime,
        };
        const telemetryProperties = {
            exitCode: exitCode.toString(),
            triggeredBy: triggeredBy,
        };
        telemetry.logEvent("preConfigure", telemetryProperties, telemetryMeasures);
    });
}
exports.preConfigure = preConfigure;
async function postConfigure(triggeredBy) {
    let scriptFile = configuration.getPostConfigureScript();
    if (!scriptFile) {
        const error = localize(38, null);
        vscode.window.showErrorMessage(error);
        const loggerError = localize(39, null);
        logger.message(loggerError);
        return ConfigureBuildReturnCodeTypes.notFound;
    }
    if (!util.checkFileExistsSync(scriptFile)) {
        vscode.window.showErrorMessage(localize(40, null));
        logger.message(localize(41, null, scriptFile));
        return ConfigureBuildReturnCodeTypes.notFound;
    }
    // Assert that scriptFile is not undefined at this point since we've checked above.
    return await prePostConfigureHelper({
        configuringScript: localize(42, null, scriptFile),
        cancelling: localize(43, null),
    }, (progress) => runPostConfigureScript(progress, scriptFile), (value) => setIsPostConfiguring(value), (elapsedTime, exitCode) => {
        const telemetryMeasures = {
            postConfigureElapsedTime: elapsedTime,
        };
        const telemetryProperties = {
            exitCode: exitCode.toString(),
            triggeredBy: triggeredBy,
        };
        telemetry.logEvent("postConfigure", telemetryProperties, telemetryMeasures);
    });
}
exports.postConfigure = postConfigure;
// Applies to the current process all the environment variables that resulted from the pre-configure step.
// The input 'content' represents the output of a command that lists all the environment variables:
// set on windows or printenv on linux/mac.
async function applyEnvironment(content) {
    let lines = (content === null || content === void 0 ? void 0 : content.split(/\r?\n/)) || [];
    lines.forEach((line) => {
        let eqPos = line.search("=");
        // Sometimes we get a "" line and searching for = returns -1. Skip.
        if (eqPos !== -1) {
            let envVarName = line.substring(0, eqPos);
            let envVarValue = line.substring(eqPos + 1, line.length);
            process.env[envVarName] = envVarValue;
        }
    });
}
async function runPrePostConfigureScript(progress, scriptFile, scriptArgs, loggingMessages) {
    // Create a temporary wrapper for the user pre-configure script so that we collect
    // in another temporary output file the environrment variables that were produced.
    // generate a random guid to attach to the `wrapConfigureScript` to ensure we don't have races for the file.
    // We split at the first dash to avoid having excessively long filenames.
    const shortenedUniqueIdentifier = (0, uuid_1.v4)().split("-")[0];
    let wrapScriptFile = path.join(util.tmpDir(), `wrapConfigureScript-${shortenedUniqueIdentifier}`);
    let wrapScriptOutFile = wrapScriptFile + ".out";
    let wrapScriptContent;
    if (process.platform === "win32") {
        wrapScriptContent = `call "${scriptFile}"`;
        wrapScriptContent +=
            scriptArgs.length > 0
                ? ` ${scriptArgs.join(" ").toString()}\r\n`
                : "\r\n";
        wrapScriptContent += `set > "${wrapScriptOutFile}"`;
        wrapScriptFile += ".bat";
    }
    else {
        wrapScriptContent = `source '${scriptFile}' ${scriptArgs.length > 0 ? scriptArgs.join(" ").toString() : ""}\n`;
        wrapScriptContent += `printenv > '${wrapScriptOutFile}'`;
        wrapScriptFile += ".sh";
    }
    util.writeFile(wrapScriptFile, wrapScriptContent);
    let concreteScriptArgs = [];
    let runCommand;
    if (process.platform === "win32") {
        runCommand = "cmd";
        concreteScriptArgs.push("/c");
        concreteScriptArgs.push(`"${wrapScriptFile}"`);
    }
    else {
        runCommand = "/bin/bash";
        concreteScriptArgs.push("-c");
        concreteScriptArgs.push(`"source '${wrapScriptFile}'"`);
    }
    try {
        let stdout = (result) => {
            progress.report({ increment: 1, message: "..." });
            logger.messageNoCR(result, "Normal");
        };
        let someErr = false;
        let stderr = (result) => {
            someErr = true;
            logger.messageNoCR(result, "Normal");
        };
        // The preconfigure invocation should use the system locale.
        const result = await util.spawnChildProcess(runCommand, concreteScriptArgs, util.getWorkspaceRoot(), false, false, stdout, stderr);
        if (result.returnCode === ConfigureBuildReturnCodeTypes.success) {
            if (someErr) {
                // Depending how the preconfigure scripts (and any inner called sub-scripts) are written,
                // it may happen that the final error code returned by them to be succesful even if
                // previous steps reported errors.
                // Until a better error code analysis, simply warn wih a logger message and turn the successful
                // return code into ConfigureBuildReurnCodeTypes.other, which would let us know in telemetry
                // of this specific situation.
                result.returnCode = ConfigureBuildReturnCodeTypes.other;
                logger.message(loggingMessages.successWithSomeError);
            }
            else {
                logger.message(loggingMessages.success);
            }
        }
        else {
            logger.message(loggingMessages.failure);
        }
        // Apply the environment produced by running the pre-configure script.
        await applyEnvironment(util.readFile(wrapScriptOutFile));
        return result.returnCode;
    }
    catch (error) {
        logger.message(error);
        return ConfigureBuildReturnCodeTypes.notFound;
    }
    finally {
        util.deleteFileSync(wrapScriptFile);
        util.deleteFileSync(wrapScriptOutFile);
    }
}
exports.runPrePostConfigureScript = runPrePostConfigureScript;
async function runPreConfigureScript(progress, scriptFile) {
    logger.message(localize(44, null, configuration.getPreConfigureScript()));
    const currentConfigPreConfigureArgs = configuration.getConfigurationPreConfigureArgs();
    return await runPrePostConfigureScript(progress, scriptFile, currentConfigPreConfigureArgs.length > 0
        ? currentConfigPreConfigureArgs
        : configuration.getPreConfigureArgs(), {
        success: localize(45, null),
        successWithSomeError: localize(46, null),
        failure: localize(47, null),
    });
}
exports.runPreConfigureScript = runPreConfigureScript;
async function runPostConfigureScript(progress, scriptFile) {
    logger.message(localize(48, null, configuration.getPostConfigureScript()));
    const currentConfigPostConfigureArgs = configuration.getConfigurationPostConfigureArgs();
    return await runPrePostConfigureScript(progress, scriptFile, currentConfigPostConfigureArgs.length > 0
        ? currentConfigPostConfigureArgs
        : configuration.getPostConfigureArgs(), {
        success: localize(49, null),
        successWithSomeError: localize(50, null),
        failure: localize(51, null),
    });
}
exports.runPostConfigureScript = runPostConfigureScript;
function isConfigurationEmpty(configurationCache) {
    if (configurationCache.buildTargets.length === 0 &&
        configurationCache.launchTargets.length === 0 &&
        configurationCache.customConfigurationProvider.workspaceBrowse.browsePath
            .length === 0) {
        return true;
    }
    return false;
}
// What makes a configure succesful or failed.
// This is not called when there was a cancellation, to simplify the logic and rules.
// Here are some considerations:
// 1.   If generate parse content returns a non successful return code,
// which is very frequent in the case of make --dry-run, we can't consider this
// as a configure failure because it is a problem in the developer environment/code base.
// Most of the times we get valuable output to parse regardless of some minor error
// at the end of the process. The user is notified about the dry-run error
// and is given steps to fix that, in case it is a bug in the extension.
// 2.   Preprocessing the build log or the dryrun output, together with all the parsers
// either succeed or are cancelled. For now there is no other failure scenario.
// Since this analyze helper is never called when configure is cancelled,
// it means that the outcome of these 4 subphases does not affect the total return code.
function analyzeConfigureSubphases(stats) {
    var _a, _b, _c;
    // Generate parse content is a critical phase. Either if it reads from a build log
    // or invokes make --dry-run, a not found means there's nothing to parse.
    // Same applies for the phase that computes the build targets, which always invokes make.
    if (((_a = stats.generateParseContent) === null || _a === void 0 ? void 0 : _a.retc) ===
        ConfigureBuildReturnCodeTypes.notFound ||
        ((_b = stats.dryrunTargets) === null || _b === void 0 ? void 0 : _b.retc) === ConfigureBuildReturnCodeTypes.notFound) {
        // But if a configure was successful from cache, return outOfDate and not failure.
        return ((_c = stats.loadFromCache) === null || _c === void 0 ? void 0 : _c.retc) === ConfigureBuildReturnCodeTypes.success
            ? ConfigureBuildReturnCodeTypes.outOfDate
            : ConfigureBuildReturnCodeTypes.notFound;
    }
    // The outcome of a recursive configure invalidates any other previous returns.
    if (stats.recursiveConfigure) {
        return analyzeConfigureSubphases(stats.recursiveConfigure);
    }
    return ConfigureBuildReturnCodeTypes.success;
}
// Process a list of possible undefined status properties and return an array
// easy to log or send to telemetry.
// The caller of "getRelevantConfigStats" sends "stats" of type "ConfigureSubphasesStatus"
// but we need to declare it here as "any" to be able to index by prop (a string) below.
function getRelevantConfigStats(stats) {
    let relevantStats = [];
    let retCodeProps = Object.getOwnPropertyNames(stats);
    retCodeProps.forEach((prop) => {
        if (prop.toString() === "recursiveConfigure") {
            let recursiveRetCodes = getRelevantConfigStats(stats[prop]);
            recursiveRetCodes.forEach((recursiveRetCode) => {
                relevantStats.push({
                    name: prop.toString() + "." + recursiveRetCode.name,
                    status: {
                        retc: recursiveRetCode.status.retc,
                        elapsed: recursiveRetCode.status.elapsed,
                    },
                });
            });
        }
        else {
            relevantStats.push({
                name: prop.toString(),
                status: {
                    retc: stats[prop].retc,
                    elapsed: stats[prop].elapsed,
                },
            });
        }
    });
    return relevantStats;
}
// A non clean configure loads first any pre-existing cache, so that the user
// has IntelliSense and build/launch targets available earlier.
// Then invokes make dry-run (without --always-make which is used for clean configure only)
// or reads from a provided build log and parses new content to be added to the configuration cache.
// The configuration cache content and the CppTools custom IntelliSense provider are not reset.
// This way we can add incrementally to what has been parsed from the previous clean configure.
// There is the downside that any files that are removed from the makefile
// (thus disappearing from the log with commands) will still have IntelliSense loaded
// until the next clean configure.
async function configure(triggeredBy, updateTargets = true) {
    // Mark that this workspace had at least one attempt at configuring (of any kind: --dry-run or buildLog), before any chance of early return,
    // to accurately identify in telemetry whether this project configured successfully out of the box or not.
    let ranConfigureInCodebaseLifetime = extension_1.extension.getState().ranConfigureInCodebaseLifetime;
    extension_1.extension.getState().ranConfigureInCodebaseLifetime = true;
    // If `fullFeatureSet` is false and it wasn't a manual command invocation, return and `other` return value.
    if (!extension_1.extension.getFullFeatureSet() &&
        !triggeredBy.includes("command pallette")) {
        return ConfigureBuildReturnCodeTypes.fullFeatureFalse;
    }
    if (blockedByOp(Operations.configure)) {
        return ConfigureBuildReturnCodeTypes.blocked;
    }
    if (!saveAll()) {
        return ConfigureBuildReturnCodeTypes.saveFailed;
    }
    // No configure execution in untrusted workspaces.
    // The check is needed also here in addition to disabling all UI and actions because,
    // depending on settings, this can run automatically at project load.
    if (!vscode.workspace.isTrusted) {
        logger.message(localize(52, null));
        return ConfigureBuildReturnCodeTypes.untrusted;
    }
    // Same start time for configure and an eventual pre-configure.
    let configureStartTime = Date.now();
    let preConfigureExitCode; // used for telemetry
    let preConfigureElapsedTime; // used for telemetry
    if (configuration.getAlwaysPreConfigure()) {
        preConfigureExitCode = await preConfigure(TriggeredBy.alwaysPreconfigure);
        if (preConfigureExitCode !== ConfigureBuildReturnCodeTypes.success) {
            logger.message(localize(53, null));
        }
        preConfigureElapsedTime = util.elapsedTimeSince(configureStartTime);
    }
    let postConfigureExitCode; // used for telemetry
    let postConfigureElapsedTime; // used for telemetry
    // Identify for telemetry whether this configure will invoke make --dry-run or will read from a build log
    // If a build log is set and it exists, we are sure make --dry-run is not getting invoked.
    let makeDryRun = true;
    let buildLog = configuration.getConfigurationBuildLog();
    if (buildLog && util.checkFileExistsSync(buildLog)) {
        makeDryRun = false;
    }
    // Identify for telemetry whether this configure will read configuration constructs from cache.
    let readCache = false;
    let configurationCachePath = configuration.getConfigurationCachePath();
    if (configurationCachePath &&
        util.checkFileExistsSync(configurationCachePath)) {
        readCache = true;
    }
    let compileCommandsPath = configuration.getCompileCommandsPath();
    // Identify for telemetry whether:
    //   - this configure will need to double the workload, if it needs to analyze the build targets separately.
    //   - this configure will need to reset the build target to the default, which will need a reconfigure.
    let processTargetsSeparately = false;
    let currentBuildTarget = configuration.getCurrentTarget();
    let oldBuildTarget = currentBuildTarget;
    if (!currentBuildTarget || currentBuildTarget === "") {
        currentBuildTarget = "all";
    }
    if (updateTargets && currentBuildTarget !== "all") {
        processTargetsSeparately = true;
    }
    // Start with the success assumption until later analysis.
    let retc = ConfigureBuildReturnCodeTypes.success;
    let subphaseStats = {};
    try {
        subphaseStats = await vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: localize(54, null),
            cancellable: true,
        }, (progress, cancel) => {
            cancel.onCancellationRequested(async () => {
                if (curPID !== -1) {
                    logger.message(localize(55, null, curPID));
                    await vscode.window.withProgress({
                        location: vscode.ProgressLocation.Notification,
                        title: localize(56, null),
                        cancellable: false,
                    }, async (progress) => {
                        return util.killTree(progress, curPID);
                    });
                }
                else {
                    // The configure process may run make twice (or three times if the build target is reset),
                    // with parsing in between and after. There is also the CppTools IntelliSense custom provider update
                    // awaiting at various points. It is possible that the cancellation may happen when there is no make running.
                    logger.message("curPID is 0, we are in between make invocations.", "Debug");
                }
                logger.message(localize(57, null));
                // We want a successful configure as soon as possible.
                // The dirty state can help with that by triggering a new configure
                // when the next relevant command occurs.
                extension_1.extension.getState().configureDirty = true;
                retc = ConfigureBuildReturnCodeTypes.cancelled;
                setIsConfiguring(false);
                setConfigureIsClean(false);
                setConfigureIsInBackground(false);
            });
            setIsConfiguring(true);
            return doConfigure(progress, cancel, updateTargets);
        });
        // If not cancelled already, analyze all doConfigure subphases
        // to decide how we should look at the final configure outcome.
        // retc is set to cancel in onCancellationRequested
        // and we don't need to look which subphase cancelled.
        if (retc !== ConfigureBuildReturnCodeTypes.cancelled) {
            retc = analyzeConfigureSubphases(subphaseStats);
        }
        if (retc === ConfigureBuildReturnCodeTypes.success) {
            logger.message(localize(58, null));
        }
        else {
            logger.message(localize(59, null));
        }
        return retc;
    }
    catch (e) {
        logger.message(localize(60, null, e.message));
        retc = ConfigureBuildReturnCodeTypes.other;
        return e.errno;
    }
    finally {
        let provider = extension_1.extension
            .getCppConfigurationProvider()
            .getCustomConfigurationProvider();
        let ConfigurationCache = {
            buildTargets: configuration.getBuildTargets(),
            launchTargets: configuration.getLaunchTargets(),
            customConfigurationProvider: {
                workspaceBrowse: provider.workspaceBrowse,
                // trick to serialize a map in a JSON
                fileIndex: Array.from(provider.fileIndex),
            },
        };
        if (!isConfigurationEmpty(ConfigurationCache)) {
            // Rewrite the configuration cache according to the last updates of the internal arrays,
            // but not if the configure was cancelled and not while running regression tests.
            if (configurationCachePath &&
                retc !== ConfigureBuildReturnCodeTypes.cancelled &&
                process.env["MAKEFILE_TOOLS_TESTING"] !== "1") {
                util.writeFile(configurationCachePath, JSON.stringify(ConfigurationCache));
            }
            // Export the compile_commands.json file if the option is enabled.
            if (compileCommandsPath &&
                retc !== ConfigureBuildReturnCodeTypes.cancelled) {
                let compileCommands = ConfigurationCache.customConfigurationProvider.fileIndex.map(([, { compileCommand }]) => compileCommand);
                util.writeFile(compileCommandsPath, JSON.stringify(compileCommands, undefined, 4));
            }
        }
        let newBuildTarget = configuration.getCurrentTarget();
        let configureElapsedTime = util.elapsedTimeSince(configureStartTime);
        const telemetryMeasures = {
            numberBuildTargets: configuration.getBuildTargets().length,
            numberLaunchTargets: configuration.getLaunchTargets().length,
            numberIndexedSourceFiles: provider.fileIndex.size,
            numberMakefileConfigurations: configuration.getMakefileConfigurations().length,
            totalElapsedTime: configureElapsedTime,
        };
        const telemetryProperties = {
            firstTime: (!ranConfigureInCodebaseLifetime).toString(),
            makeDryRun: makeDryRun.toString(),
            readCache: readCache.toString(),
            isClean: getConfigureIsClean().toString(),
            processTargetsSeparately: processTargetsSeparately.toString(),
            resetBuildTarget: (oldBuildTarget !== newBuildTarget).toString(),
            triggeredBy: triggeredBy,
        };
        // Report all relevant exit codes
        telemetryMeasures.exitCode = retc;
        let subphases = getRelevantConfigStats(subphaseStats);
        subphases.forEach((phase) => {
            telemetryMeasures[phase.name + ".exitCode"] = phase.status.retc;
            telemetryMeasures[phase.name + ".elapsed"] = phase.status.elapsed;
        });
        // Report if this configure ran also a pre-configure and how long it took.
        if (preConfigureExitCode !== undefined) {
            telemetryProperties.preConfigureExitCode =
                preConfigureExitCode.toString();
        }
        if (preConfigureElapsedTime !== undefined) {
            telemetryMeasures.preConfigureElapsedTime = preConfigureElapsedTime;
            logger.message(localize(61, null, preConfigureElapsedTime));
        }
        logger.message(localize(62, null, configureElapsedTime));
        setIsConfiguring(false);
        setConfigureIsClean(false);
        setConfigureIsInBackground(false);
        // Let's consider that a cancelled configure is not a complete configure,
        // even if, depending when the cancel happened, the cache may have been loaded already.
        // Cancelled configures reach this point too, because of the finally construct.
        if (retc !== ConfigureBuildReturnCodeTypes.cancelled) {
            extension_1.extension.setCompletedConfigureInSession(true);
        }
        if (retc === ConfigureBuildReturnCodeTypes.success) {
            // Same start time for configure and an eventual pre-configure.
            let postConfigureStartTime = Date.now();
            // do any postConfigureScripts
            if (configuration.getAlwaysPostConfigure()) {
                postConfigureExitCode = await postConfigure(TriggeredBy.alwaysPostConfigure);
                if (postConfigureExitCode !== ConfigureBuildReturnCodeTypes.success) {
                    logger.message(localize(63, null));
                }
                postConfigureElapsedTime = util.elapsedTimeSince(postConfigureStartTime);
            }
        }
        if (postConfigureExitCode !== undefined) {
            telemetryProperties.postConfigureExitCode =
                postConfigureExitCode.toString();
        }
        if (postConfigureElapsedTime !== undefined) {
            telemetryMeasures.postConfigureElapsedTime = postConfigureElapsedTime;
            logger.message(localize(64, null, postConfigureElapsedTime));
        }
        telemetryProperties.buildTarget = processTargetForTelemetry(newBuildTarget);
        telemetry.logEvent("configure", telemetryProperties, telemetryMeasures);
        if (retc !== ConfigureBuildReturnCodeTypes.success) {
            logger.showOutputChannel();
        }
    }
}
exports.configure = configure;
async function parseLaunchConfigurations(progress, cancel, dryRunOutput, recursive = false) {
    if (cancel.isCancellationRequested) {
        return {
            retc: ConfigureBuildReturnCodeTypes.cancelled,
            elapsed: 0,
        };
    }
    let startTime = Date.now();
    let launchConfigurations = [];
    let onStatus = (status) => {
        progress.report({
            increment: 1,
            message: `${status}${recursive ? recursiveString : ""}...`,
        });
    };
    let onFoundLaunchConfiguration = (launchConfiguration) => {
        launchConfigurations.push(launchConfiguration);
    };
    let retc = await parser.parseLaunchConfigurations(cancel, dryRunOutput, onStatus, onFoundLaunchConfiguration);
    if (retc === ConfigureBuildReturnCodeTypes.success) {
        let launchConfigurationsStr = [];
        launchConfigurations.forEach((config) => {
            launchConfigurationsStr.push(configuration.launchConfigurationToString(config));
        });
        if (launchConfigurationsStr.length === 0) {
            const notCleanMessage = localize(65, null);
            const cleanMessage = localize(66, null);
            logger.message(getConfigureIsClean() ? cleanMessage : notCleanMessage);
        }
        else {
            // Sort and remove duplicates that can be created in the following scenarios:
            //    - the same target binary invoked several times with the same arguments and from the same path
            //    - a target binary invoked once with no parameters is still a duplicate
            //      of the entry generated by the linker command which produced the binary
            //    - sometimes the same binary is linked more than once in the same location
            //      (example: instrumentation) but the launch configurations list need only one entry,
            //      corresponding to the final binary, not the intermediate ones.
            launchConfigurationsStr = util.sortAndRemoveDuplicates(launchConfigurationsStr);
            const cleanLaunchTargetsString = localize(67, null, launchConfigurationsStr.length, launchConfigurationsStr.join(";"));
            const notCleanLaunchTargetsString = localize(68, null, launchConfigurationsStr.length, launchConfigurationsStr.join(";"));
            logger.message(getConfigureIsClean()
                ? notCleanLaunchTargetsString
                : cleanLaunchTargetsString);
        }
        if (getConfigureIsClean()) {
            // If configure is clean, delete any old launch targets found previously.
            configuration.setLaunchTargets(launchConfigurationsStr);
        }
        else {
            // If we're merging with a previous set of launch targets,
            // remove duplicates because sometimes, depending how the makefiles are set up,
            // a non --always-make dry-run may still log commands for up to date files.
            // These would be found also in the previous list of launch targets.
            configuration.setLaunchTargets(util.sortAndRemoveDuplicates(configuration.getLaunchTargets().concat(launchConfigurationsStr)));
        }
        logger.message(localize(69, null, configuration.getLaunchTargets().join(";")));
    }
    return {
        retc,
        elapsed: util.elapsedTimeSince(startTime),
    };
}
async function parseTargets(progress, cancel, dryRunOutput, recursive = false) {
    if (cancel.isCancellationRequested) {
        return {
            retc: ConfigureBuildReturnCodeTypes.cancelled,
            elapsed: 0,
        };
    }
    let startTime = Date.now();
    let targets = [];
    let onStatus = (status) => {
        progress.report({
            increment: 1,
            message: `${status}${recursive ? recursiveString : ""}`,
        });
    };
    let onFoundTarget = (target) => {
        targets.push(target);
    };
    let retc = await parser.parseTargets(cancel, dryRunOutput, onStatus, onFoundTarget);
    if (retc === ConfigureBuildReturnCodeTypes.success) {
        if (targets.length === 0) {
            const cleanBuildTargets = localize(70, null);
            const notCleanBuildTargets = localize(71, null);
            logger.message(getConfigureIsClean() ? cleanBuildTargets : notCleanBuildTargets);
        }
        else {
            targets = targets.sort();
            const cleanBuildTargetsDefinedInMakefile = localize(72, null, targets.length, targets.join(";"));
            const notCleanBuildTargetsDefinedInMakefile = localize(73, null, targets.length, targets.join(";"));
            logger.message(getConfigureIsClean()
                ? cleanBuildTargetsDefinedInMakefile
                : notCleanBuildTargetsDefinedInMakefile);
        }
        if (getConfigureIsClean()) {
            // If configure is clean, delete any old build targets found previously.
            configuration.setBuildTargets(targets);
        }
        else {
            // If we're merging with a previous set of build targets,
            // remove duplicates because sometimes, depending how the makefiles are set up,
            // a non --always-make dry-run may still log commands for up to date files.
            // These would be found also in the previous list of build targets.
            configuration.setBuildTargets(util.sortAndRemoveDuplicates(configuration.getBuildTargets().concat(targets)));
        }
        logger.message(localize(74, null, configuration.getBuildTargets().join(";")));
    }
    return {
        retc,
        elapsed: util.elapsedTimeSince(startTime),
    };
}
async function updateProvider(progress, cancel, dryRunOutput, recursive = false) {
    if (cancel.isCancellationRequested) {
        return {
            retc: ConfigureBuildReturnCodeTypes.cancelled,
            elapsed: 0,
        };
    }
    let startTime = Date.now();
    const recursiveString = localize(75, null);
    const nonRecursiveString = localize(76, null);
    logger.message(recursive ? recursiveString : nonRecursiveString);
    let onStatus = (status) => {
        progress.report({
            increment: 1,
            message: `${status}${recursive ? recursiveString : ""} ...`,
        });
    };
    let onFoundCustomConfigProviderItem = (customConfigProviderItem) => {
        // Configurations parsed from dryrun output or build log are saved temporarily in the delta file index
        extension_1.extension.buildCustomConfigurationProvider(customConfigProviderItem);
    };
    // Empty the cummulative browse path before we start a new parse for custom configuration.
    // We can empty even if the configure is not clean, because the new browse paths will be appended
    // to the previous browse paths.
    extension_1.extension.clearCummulativeBrowsePath();
    let retc = await parser.parseCustomConfigProvider(cancel, dryRunOutput, onStatus, onFoundCustomConfigProviderItem);
    if (retc !== ConfigureBuildReturnCodeTypes.cancelled) {
        // If this configure is clean, overwrite the final file index, otherwise merge with it.
        let provider = getDeltaCustomConfigurationProvider();
        extension_1.extension
            .getCppConfigurationProvider()
            .mergeCustomConfigurationProvider(provider);
        // Empty the 'delta' configurations.
        provider.fileIndex.clear();
        provider.workspaceBrowse = {
            browsePath: [],
            compilerArgs: [],
            compilerPath: undefined,
            standard: undefined,
            windowsSdkVersion: undefined,
        };
        setCustomConfigurationProvider(provider);
        extension_1.extension.updateCppToolsProvider();
    }
    return {
        retc,
        elapsed: util.elapsedTimeSince(startTime),
    };
}
async function preprocessDryRun(progress, cancel, dryrunOutput, recursive = false) {
    if (cancel.isCancellationRequested) {
        return {
            retc: ConfigureBuildReturnCodeTypes.cancelled,
            elapsed: 0,
            result: "",
        };
    }
    let onStatus = (status) => {
        progress.report({
            increment: 1,
            message: `${status}${recursive ? recursiveString : ""} ...`,
        });
    };
    return parser.preprocessDryRunOutput(cancel, dryrunOutput, onStatus);
}
exports.preprocessDryRun = preprocessDryRun;
async function loadConfigurationFromCache(progress, cancel) {
    if (cancel.isCancellationRequested) {
        return {
            retc: ConfigureBuildReturnCodeTypes.cancelled,
            elapsed: 0,
        };
    }
    let startTime = Date.now();
    let elapsedTime;
    await util.scheduleAsyncTask(async () => {
        await extension_1.extension.registerCppToolsProvider();
    });
    let cachePath = configuration.getConfigurationCachePath();
    if (cachePath) {
        let content = util.readFile(cachePath);
        if (content) {
            try {
                progress.report({
                    increment: 1,
                    message: localize(77, null),
                });
                logger.message(localize(78, null, cachePath));
                let configurationCache = {
                    buildTargets: [],
                    launchTargets: [],
                    customConfigurationProvider: {
                        workspaceBrowse: {
                            browsePath: [],
                        },
                        fileIndex: [],
                    },
                };
                configurationCache = JSON.parse(content);
                // Trick to get proper URIs after reading from the cache.
                // At the moment of writing into the cache, the URIs have
                // the vscode.Uri.file(string) format.
                // After saving and re-reading, we need the below,
                // otherwise CppTools doesn't get anything.
                await util.scheduleTask(() => {
                    configurationCache.customConfigurationProvider.fileIndex.forEach((i) => {
                        i[1].uri = vscode.Uri.file(i[0]);
                    });
                });
                await util.scheduleTask(() => {
                    configuration.setBuildTargets(configurationCache.buildTargets);
                    configuration.setLaunchTargets(configurationCache.launchTargets);
                });
                await util.scheduleTask(() => {
                    // The configurations saved in the cache are read directly into the final file index.
                    extension_1.extension
                        .getCppConfigurationProvider()
                        .setCustomConfigurationProvider({
                        workspaceBrowse: configurationCache.customConfigurationProvider.workspaceBrowse,
                        // Trick to read a map from json
                        fileIndex: new Map(configurationCache.customConfigurationProvider.fileIndex),
                    });
                });
            }
            catch (e) {
                logger.message(localize(79, null));
                logger.message(localize(80, null));
                setConfigureIsInBackground(false);
                setConfigureIsClean(true);
            }
            elapsedTime = util.elapsedTimeSince(startTime);
            logger.message(localize(81, null, elapsedTime));
            // Log all the files read from cache after elapsed time is calculated.
            // IntelliSense should be available by now for all files.
            // Don't await for this logging step. This may produce some interleaved output
            // but it will still be readable.
            await util.scheduleTask(() => {
                extension_1.extension
                    .getCppConfigurationProvider()
                    .logConfigurationProviderComplete();
            });
        }
        else {
            return {
                retc: ConfigureBuildReturnCodeTypes.notFound,
                elapsed: 0,
            };
        }
    }
    else {
        return {
            retc: ConfigureBuildReturnCodeTypes.notFound,
            elapsed: 0,
        };
    }
    return {
        retc: cancel.isCancellationRequested
            ? ConfigureBuildReturnCodeTypes.cancelled
            : ConfigureBuildReturnCodeTypes.success,
        elapsed: elapsedTime,
    };
}
exports.loadConfigurationFromCache = loadConfigurationFromCache;
// Update IntelliSense and launch targets with information parsed from a user given build log,
// the dryrun cache or make dryrun output if the cache is not present.
// Sometimes the targets do not need an update (for example, when there has been
// a change in the current build target), as requested through the boolean.
// This saves unnecessary parsing which may be signifficant for very big code bases.
async function doConfigure(progress, cancel, updateTargets = true, recursiveDoConfigure = false) {
    let subphaseStats = {};
    // Configure does not start in the background (we have to load a configuration cache first).
    setConfigureIsInBackground(false);
    // If available, load all the configure constructs via json from the cache file.
    // If this doConfigure is in level 1 of recursion, avoid loading the configuration cache again
    // since it's been done at recursion level 0.
    // Also skip if there was at least one completed configure before in this VSCode session,
    // regardless of any other failure error code, because at the end of that last configure,
    // the extension saved this configuration content (that we can skip loading now) into the cache.
    // The loading from cache is cheap, but logging it (for Verbose level) may interfere unnecessarily
    // with the output channel, especially since that logging is not awaited for.
    if (!recursiveDoConfigure && !extension_1.extension.getCompletedConfigureInSession()) {
        subphaseStats.loadFromCache = await loadConfigurationFromCache(progress, cancel);
        if (subphaseStats.loadFromCache.retc ===
            ConfigureBuildReturnCodeTypes.cancelled) {
            return subphaseStats;
        }
        else if (subphaseStats.loadFromCache.retc === ConfigureBuildReturnCodeTypes.success) {
            // In case of success, the following configure steps should not block any other operation
            // and can be performed in the background.
            setConfigureIsInBackground(true);
        }
    }
    else {
        logger.message(localize(82, null), "Verbose");
    }
    // This generates the dryrun output (saving it on disk) or reads an alternative build log.
    // Timings for this sub-phase happen inside.
    subphaseStats.generateParseContent = await generateParseContent(progress, cancel, false, recursiveDoConfigure);
    if (subphaseStats.generateParseContent.retc ===
        ConfigureBuildReturnCodeTypes.cancelled) {
        return subphaseStats;
    }
    // Some initial preprocessing required before any parsing is done.
    logger.message(localize(83, null, parseFile));
    let preprocessedDryrunOutput;
    let preprocessedDryrunOutputResult = await preprocessDryRun(progress, cancel, parseContent || "", recursiveDoConfigure);
    subphaseStats.preprocessParseContent = {
        retc: preprocessedDryrunOutputResult.retc,
        elapsed: preprocessedDryrunOutputResult.retc,
    };
    if (preprocessedDryrunOutputResult.result) {
        preprocessedDryrunOutput = preprocessedDryrunOutputResult.result;
    }
    else {
        return subphaseStats;
    }
    logger.message(localize(84, null, subphaseStats.preprocessParseContent.elapsed));
    // Configure IntelliSense
    // Don't override retc1, since make invocations may fail with errors different than cancel
    // and we still complete the configure process.
    logger.message(localize(85, null));
    subphaseStats.parseIntelliSense = await updateProvider(progress, cancel, preprocessedDryrunOutput, recursiveDoConfigure);
    if (subphaseStats.parseIntelliSense.retc ===
        ConfigureBuildReturnCodeTypes.cancelled) {
        return subphaseStats;
    }
    logger.message(localize(86, null, subphaseStats.parseIntelliSense.elapsed));
    // Configure launch targets as parsed from the makefile
    // (and not as read from settings via makefile.launchConfigurations).
    logger.message(localize(87, null));
    subphaseStats.parseLaunch = await parseLaunchConfigurations(progress, cancel, preprocessedDryrunOutput, recursiveDoConfigure);
    if (subphaseStats.parseLaunch.retc === ConfigureBuildReturnCodeTypes.cancelled) {
        return subphaseStats;
    }
    logger.message(localize(88, null, subphaseStats.parseLaunch.elapsed));
    // Verify if the current launch configuration is still part of the list and unset otherwise.
    // By this point, configuration.getLaunchTargets() contains a complete list (old and new).
    let currentLaunchConfiguration = configuration.getCurrentLaunchConfiguration();
    let currentLaunchConfigurationStr = currentLaunchConfiguration
        ? configuration.launchConfigurationToString(currentLaunchConfiguration)
        : "";
    if (currentLaunchConfigurationStr !== "" &&
        currentLaunchConfiguration &&
        !configuration
            .getLaunchConfigurations()
            .includes(currentLaunchConfiguration)) {
        logger.message(localize(89, null, currentLaunchConfigurationStr));
        await configuration.setLaunchConfigurationByName("");
    }
    // Configure build targets only if necessary:
    // if the caller considers we need a build target update
    // or if the build target array hasn't been populated by now
    // or if it contains only 'all' which we push automatically.
    let buildTargets = configuration.getBuildTargets();
    if (updateTargets ||
        buildTargets.length === 0 ||
        (buildTargets.length === 1 && buildTargets[0] === "all")) {
        logger.message(localize(90, null));
        subphaseStats.dryrunTargets = await generateParseContent(progress, cancel, true, recursiveDoConfigure);
        if (subphaseStats.dryrunTargets.retc ===
            ConfigureBuildReturnCodeTypes.cancelled) {
            return subphaseStats;
        }
        logger.message(localize(91, null, parseFile));
        subphaseStats.parseTargets = await parseTargets(progress, cancel, parseContent || "", recursiveDoConfigure);
        if (subphaseStats.parseTargets.retc ===
            ConfigureBuildReturnCodeTypes.cancelled) {
            return subphaseStats;
        }
        logger.message(localize(92, null, subphaseStats.parseTargets.elapsed));
        // Verify if the current build target is still part of the list and unset otherwise.
        // By this point, configuration.getBuildTargets() contains a comlete list (old and new).
        buildTargets = configuration.getBuildTargets();
        let currentBuildTarget = configuration.getCurrentTarget();
        if (currentBuildTarget &&
            currentBuildTarget !== "" &&
            currentBuildTarget !== "all" &&
            !buildTargets.includes(currentBuildTarget)) {
            logger.message(localize(93, null, currentBuildTarget));
            // Setting a new target by name is not triggering a configure
            // (only its caller setBuildTarget, invoked by its command or status bar button).
            // But we do need to configure again after a build target change,
            // so call doConfigure here and not configure.
            // We don't need to alter yet any dirty or pending states, this being an 'inner' call of configure.
            // We don't need to consider makefile.configureAfterCommand: even if set to false
            // (which would result in changing a build target without a following configure - in the normal scenario)
            // now we need to configure because this build target reset was done under the covers
            // by the extension and as a result of a configure (which can only be triggered by the user
            // if makefile.configureAfterCommand is set to false).
            // Calling doConfigure here will not result in extra telemetry (just extra logging).
            // The recursive call to doConfigure will fall still under the same progress bar and cancel button
            // as the caller and its result will be included into the telemetry information reported by that.
            // There can be only one level of recursivity because once the target is reset to empty,
            // it is impossible to get into the state of having a target that is not found in the available list.
            await configuration.setTargetByName("");
            logger.message(localize(94, null));
            recursiveDoConfigure = true;
            // This one level recursive doConfigure will keep the same clean state as the caller
            // since setConfigureIsClean runs before the caller configure and resets after
            // the eventual recursive configure.
            subphaseStats.recursiveConfigure = await doConfigure(progress, cancel, updateTargets, true);
        }
    }
    // Let the caller collect and log all information regarding the subphases return codes.
    if (!recursiveDoConfigure) {
        logger.message(localize(95, null));
        let subphases = getRelevantConfigStats(subphaseStats);
        subphases.forEach((subphase) => {
            const returnCode = localize(96, null);
            const elapsedTime = localize(97, null);
            logger.message(`${subphase.name}: ${returnCode} = ${subphase.status.retc}, ` +
                `${elapsedTime} = ${subphase.status.elapsed}`);
        });
    }
    extension_1.extension.getState().configureDirty = false;
    return subphaseStats;
}
exports.doConfigure = doConfigure;
// A clean configure = a non clean configure + empty the CppTools custom IntelliSense config provider.
// In the case of a dry-run setting (not a build log) it also means adding --always-make to the make invocation.
// Because we want to first read any existing cache and let the remaining heavy processing run in the background,
// we don't delete the cache here. We just mark it to be later deleted by the non clean configure.
async function cleanConfigure(triggeredBy, updateTargets = true) {
    // Even if the core configure process also checks for blocking operations,
    // verify the same here as well, to make sure that we don't delete the caches
    // only to return early from the core configure.
    if (blockedByOp(Operations.configure)) {
        return ConfigureBuildReturnCodeTypes.blocked;
    }
    setConfigureIsClean(true);
    return configure(triggeredBy, updateTargets);
}
exports.cleanConfigure = cleanConfigure;


/***/ }),

/***/ 767:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseStandard = exports.parseLaunchConfigurations = exports.parseCustomConfigProvider = exports.preprocessDryRunOutput = exports.parseTargets = void 0;
// TODO: support also the scenario of parsing a build log,
// to overcome some of --dry-run limitations
// (like some exceptions to the 'do not execute' rule
// or dependencies on a real build)
const configuration = __webpack_require__(604);
const cpp = __webpack_require__(545);
const ext = __webpack_require__(15);
const logger = __webpack_require__(464);
const make = __webpack_require__(970);
const path = __webpack_require__(928);
const util = __webpack_require__(260);
const nls = __webpack_require__(493);
nls.config({
    messageFormat: nls.MessageFormat.bundle,
    bundleFormat: nls.BundleFormat.standalone,
})((__webpack_require__(928).join)(__dirname, 'src\\parser.ts'));
const localize = nls.loadMessageBundle((__webpack_require__(928).join)(__dirname, 'src\\parser.ts'));
// List of compiler tools plus the most common aliases cc and c++
// ++ needs to be escaped for the regular expression in parseLineAsTool.
// Versioning and cross compilers naming variations dont' need to be included in this list,
// they will be considered in the regular expression.
// If one compiler name is a substring of another, include it after in this list.
// todo: any other scenarios of aliases and symlinks
// that would make parseLineAsTool to not match the regular expression,
// therefore wrongly skipping over compilation lines?
const compilers = [
    "ccache",
    "clang\\+\\+",
    "clang-cl",
    "clang-cpp",
    "clang",
    "gcc",
    "gpp",
    "cpp",
    "icc",
    "cc",
    "icl",
    "cl",
    "g\\+\\+",
    "c\\+\\+",
];
const linkers = [
    "ccache",
    "ilink",
    "link",
    "ld",
    "ccld",
    "gcc",
    "clang\\+\\+",
    "clang",
    "cc",
    "g\\+\\+",
    "c\\+\\+",
];
const sourceFileExtensions = ["cpp", "cc", "cxx", "c"];
const chunkSize = 100;
async function parseTargets(cancel, verboseLog, statusCallback, foundTargetCallback) {
    if (cancel.isCancellationRequested) {
        return make.ConfigureBuildReturnCodeTypes.cancelled;
    }
    // Extract the text between "# Files" and "# Finished Make data base" lines
    // There can be more than one matching section.
    let regexpExtract = /(# Files\n*)([\s\S]*?)(\n# Finished Make data base)/gm;
    let result;
    let extractedLog = "";
    let matches = [];
    let match;
    result = await util.scheduleTask(() => regexpExtract.exec(verboseLog));
    while (result) {
        extractedLog = result[2];
        // Skip lines starting with {#,.} or preceeded by "# Not a target" and extract the target.
        // Additionally, if makefile.phonyOnlyTargets is true, include only targets
        // succeeded by "#  Phony target (prerequisite of .PHONY).".
        let regexpTargetStr = "^(?!\\n?[#\\.])(?<!^\\n?# Not a target:\\s*)\\s*(\\S*[^:]):\\s+";
        if (configuration.getPhonyOnlyTargets()) {
            regexpTargetStr +=
                ".*\\s+(?=#  Phony target \\(prerequisite of \\.PHONY\\)\\.)";
        }
        let regexpTarget = RegExp(regexpTargetStr, "mg");
        match = regexpTarget.exec(extractedLog);
        if (match) {
            let done = false;
            let doParsingChunk = () => {
                let chunkIndex = 0;
                while (match && chunkIndex <= chunkSize) {
                    // Make sure we don't insert duplicates.
                    // They can be caused by the makefile syntax of defining variables for a target.
                    // That creates multiple lines with the same target name followed by :,
                    // which is the pattern parsed here.
                    if (!matches.includes(match[1])) {
                        matches.push(match[1]);
                        foundTargetCallback(match[1]);
                    }
                    statusCallback("Parsing build targets...");
                    match = regexpTarget.exec(extractedLog);
                    if (!match) {
                        done = true;
                    }
                    chunkIndex++;
                }
            };
            while (!done) {
                if (cancel.isCancellationRequested) {
                    return make.ConfigureBuildReturnCodeTypes.cancelled;
                }
                await util.scheduleTask(doParsingChunk);
            }
        } // if match
        result = await util.scheduleTask(() => regexpExtract.exec(verboseLog));
    } // while result
    return cancel.isCancellationRequested
        ? make.ConfigureBuildReturnCodeTypes.cancelled
        : make.ConfigureBuildReturnCodeTypes.success;
}
exports.parseTargets = parseTargets;
// Make various preprocessing transformations on the dry-run output
// TODO: "cmd -c", "start cmd", "exit"
async function preprocessDryRunOutput(cancel, dryRunOutputStr, statusCallback) {
    let preprocessedDryRunOutputStr = dryRunOutputStr;
    if (cancel.isCancellationRequested) {
        return {
            retc: make.ConfigureBuildReturnCodeTypes.cancelled,
            elapsed: 0,
        };
    }
    let startTime = Date.now();
    statusCallback("Preprocessing the dry-run output");
    // Array of tasks required to be executed during the preprocess configure phase
    let preprocessTasks = [];
    // Expand {REPO:VSCODE-MAKEFILE-TOOLS} to the full path of the root of the extension
    // This is used for the pre-created dry-run logs consumed by the tests,
    // in order to be able to have source files and includes for the test repro
    // within the test subfolder of the extension repo, while still exercising full paths for parsing
    // and not generating a different output with every new location where Makefile Tools is enlisted.
    // A real user scenario wouldn't need this construct.
    preprocessTasks.push(function () {
        if (process.env["MAKEFILE_TOOLS_TESTING"] === "1") {
            let extensionRootPath = path.resolve(__dirname, "../");
            preprocessedDryRunOutputStr = preprocessedDryRunOutputStr.replace(/{REPO:VSCODE-MAKEFILE-TOOLS}/gm, extensionRootPath);
        }
    });
    // Some compiler/linker commands are split on multiple lines.
    // At the end of every intermediate line is at least a space, then a \ and end of line.
    // Concatenate all these lines to see clearly each command on one line.
    let regexp = /\s+\\$\n/gm;
    preprocessTasks.push(function () {
        preprocessedDryRunOutputStr = preprocessedDryRunOutputStr.replace(regexp, " ");
    });
    // In case we parse a build log (as opposed to a dryrun log) for a project using libtool,
    // capture the compiler commands reported by the libtool output.
    // They may be redundant with the corresponding line from the dryrun (which is present in the build log as well)
    // but in case of $ variables and commands invoked on the fly, the second time all are resolved/expanded
    // and we can actually send good IntelliSense information for a good source code URL.
    // For such a case, look at MONO (git clone https://github.com/mono/mono.git), for source code cordxtra.c
    // Line with the original command, containing a 'test' command to determine on the fly the source code path.
    // This line is present in the dryrun and also in the build log. Can't easily parse the correct source code path.
    // /bin/bash ./libtool  --tag=CC   --mode=compile gcc -DHAVE_CONFIG_H   -I./include -I./include  -DGC_PTHREAD_START_STANDALONE    -fexceptions -Wall -Wextra -Wpedantic -Wno-long-long -g -O2 -fno-strict-aliasing  -MT cord/libcord_la-cordxtra.lo -MD -MP -MF cord/.deps/libcord_la-cordxtra.Tpo -c -o cord/libcord_la-cordxtra.lo `test -f 'cord/cordxtra.c' || echo './'`cord/cordxtra.c
    // Line with the resolved command, from which the extension can parse a valid source code path.
    // This line is present only in the build log, immediately following the above line.
    // libtool: compile:  gcc -DHAVE_CONFIG_H -I./include -I./include -DGC_PTHREAD_START_STANDALONE -fexceptions -Wall -Wextra -Wpedantic -Wno-long-long -g -O2 -fno-strict-aliasing -MT cord/libcord_la-cordxtra.lo -MD -MP -MF cord/.deps/libcord_la-cordxtra.Tpo -c cord/cordxtra.c  -fPIC -DPIC -o cord/.libs/libcord_la-cordxtra.o
    preprocessTasks.push(function () {
        regexp = /libtool: compile:|libtool: link:/gm;
        preprocessedDryRunOutputStr = preprocessedDryRunOutputStr.replace(regexp, "\nLIBTOOL_PATTERN\n");
    });
    // Process some more makefile output weirdness
    // When --mode=compile or --mode=link are present in a line, we can ignore anything that is before
    // and all that is after is a normal complete compiler or link command.
    // Replace these patterns with end of line so that the parser will see only the right half.
    preprocessTasks.push(function () {
        regexp = /--mode=compile|--mode=link/gm;
        preprocessedDryRunOutputStr = preprocessedDryRunOutputStr.replace(regexp, "\nLIBTOOL_PATTERN\n");
    });
    // Remove lines with $() since they come from unexpanded yet variables. The extension can't do anything yet
    // about them anyway and also there will be a correspondent line in the dryrun with these variables expanded.
    // Don't remove lines with $ without paranthesis, there are valid compilation lines that would be ignored otherwise.
    preprocessTasks.push(function () {
        preprocessedDryRunOutputStr = preprocessedDryRunOutputStr
            .split("\n")
            .map((e) => {
            return e.indexOf("$(") >= 0 ? "" : e;
        })
            .join("\n");
    });
    // Extract the link command
    // Keep the /link switch to the cl command because otherwise we will see compiling without /c
    // and we will deduce some other output binary based on its /Fe or /Fo or first source given,
    // instead of the output binary defined via the link operation (which will be parsed on the next line).
    // TODO: address more accurately the overriding scenarios between output files defined via cl.exe
    // and output files defined via cl.exe /link.
    // For example, "cl.exe source.cpp /Fetest.exe /link /debug" still produces test.exe
    // but cl.exe source.cpp /Fetest.exe /link /out:test2.exe produces only test2.exe.
    // For now, ignore any output binary rules of cl while having the /link switch.
    preprocessTasks.push(function () {
        if (process.platform === "win32") {
            preprocessedDryRunOutputStr = preprocessedDryRunOutputStr.replace(/ \/link /g, "/link \n link.exe ");
        }
    });
    // The splitting of multiple commands is better to be done at the end.
    // Oherwise, this scenario interferes with the line ending '\' in some cases
    // (see MAKE repo, ar.c compiler command, for example).
    // Split multiple commands concatenated by '&&'
    preprocessTasks.push(function () {
        preprocessedDryRunOutputStr = preprocessedDryRunOutputStr.replace(/ && /g, "\n");
    });
    // Split multiple commands concatenated by ";"
    preprocessTasks.push(function () {
        preprocessedDryRunOutputStr = preprocessedDryRunOutputStr.replace(/;/g, "\n");
    });
    // Replace multiple "-" sequence because it hangs the regular expression engine.
    // Strings with this pattern do not contain useful information to parse, they are safe to replace
    // in our internal representation of the dryrun or build log.
    // Replace with "- " instead of remove since this pattern does not cause hang or slow processing
    // and so that we have a similar view of the preprocessed text.
    preprocessTasks.push(function () {
        regexp = /------/gm;
        preprocessedDryRunOutputStr = preprocessedDryRunOutputStr.replace(regexp, "- - - - - - ");
    });
    // Loop through all the configure preprocess tasks, checking for cancel.
    for (const func of preprocessTasks) {
        await util.scheduleTask(func);
        if (cancel.isCancellationRequested) {
            return {
                retc: make.ConfigureBuildReturnCodeTypes.cancelled,
                elapsed: util.elapsedTimeSince(startTime),
            };
        }
    }
    return {
        retc: make.ConfigureBuildReturnCodeTypes.success,
        elapsed: util.elapsedTimeSince(startTime),
        result: preprocessedDryRunOutputStr,
    };
    // TODO: Insert preprocessed files content
    // TODO: Wrappers (example: cl.cmd)
}
exports.preprocessDryRunOutput = preprocessDryRunOutput;
// Helper that parses the given line as a tool invocation.
// The full path that is returned is calculated with the following logic:
//     - make a full path out of the one given in the makefile
//       and the current path that is calculated as of now
//     - if the tool is not found at the full path above and if requested,
//       it will be searched in all the paths of the PATH environment variable
//       and the first one found will be returned
// TODO: handle the following corner cases:
//     - quotes only around directory (file name outside quotes)
//     - path containing "toolName(no extension) " in the middle
async function parseLineAsTool(line, toolNames, currentPath, isCompilerOrLinker = true) {
    var _a;
    // To avoid hard-coding (and ever maintaining) in the tools list
    // the various compilers/linkers that can have versions, prefixes or suffixes
    // in their names, include a crafted regex around each tool name.
    // Any number of prefix or suffix text, separated by '-'.
    let versionedToolNames = [];
    const prefixRegex = isCompilerOrLinker ? "(([a-zA-Z0-9-_.]*-)*" : "";
    const suffixRegex = isCompilerOrLinker ? "(-[a-zA-Z0-9-_.]*)*)" : "";
    toolNames.forEach((tool) => {
        var _a;
        // Check if the user defined this tool as to be excluded
        if (!((_a = configuration.getExcludeCompilerNames()) === null || _a === void 0 ? void 0 : _a.includes(tool))) {
            versionedToolNames.push(`${prefixRegex}${tool}${suffixRegex}`);
        }
    });
    // Add any additional tools specified by the user
    // when we are looking at compilers or linkers,
    // not when we parse for binary targets.
    if (isCompilerOrLinker) {
        (_a = configuration.getAdditionalCompilerNames()) === null || _a === void 0 ? void 0 : _a.forEach((compiler) => {
            if (!toolNames.includes(compiler)) {
                versionedToolNames.push(`${prefixRegex}${compiler}${suffixRegex}`);
            }
        });
    }
    // - any spaces/tabs before the tool invocation
    // - with or without path (relative -to the makefile location- or full)
    // - with or without extension (windows only)
    // - with or without quotes
    // - must have at least one space or tab after the tool invocation
    let regexpStr = '^[\\s\\"]*(.*?)(';
    if (process.platform === "win32") {
        regexpStr += versionedToolNames.join("\\.exe|");
        // ensure to append the extension for the last tool in the array since join didn't.
        if (versionedToolNames.length > 0) {
            regexpStr += "\\.exe";
        }
        regexpStr += "|";
    }
    regexpStr += versionedToolNames.join("|") + ')(\\s|\\"\\s)(.*)$';
    let regexp = RegExp(regexpStr, "mg");
    let match = regexp.exec(line);
    if (!match) {
        return undefined;
    }
    let toolPathInMakefile = match[1];
    let toolNameInMakefile = match[2];
    if (process.platform === "win32" && !path.extname(toolNameInMakefile)) {
        toolNameInMakefile += ".exe";
    }
    // Quotes are not needed either for the compiler path or the current path.
    // checkFileExists works just fine without quotes,
    // but makeFullPath gets confused sometimes for some quotes scenarios.
    currentPath = util.removeQuotes(currentPath);
    toolPathInMakefile = toolPathInMakefile.trimLeft();
    toolPathInMakefile = util.removeQuotes(toolPathInMakefile);
    let toolFullPath = await util.makeFullPath(toolPathInMakefile + toolNameInMakefile, currentPath);
    let toolFound = util.checkFileExistsSync(toolFullPath);
    // Reject a regexp match that doesn't have a real path before the tool invocation,
    // like for example link.exe /out:cl.exe being mistakenly parsed as a compiler command.
    // Basically, only spaces and/or tabs and/or a valid path are allowed before the compiler name.
    // There is no other easy way to eliminate that case via the regexp
    // (it must accept a string before the tool).
    // For now, we consider a path as valid if it can be found on disk.
    // TODO: be able to recognize a string as a valid path even if it doesn't exist on disk,
    // in case the project has a setup phase that is copying/installing stuff (like the toolset)
    // and it does not have yet a build in place, therefore a path or file is not yet found on disk,
    // even if it is valid.
    // In other words, we allow the tool to not be found only if the makefile invokes it without any path,
    // which opens the possibility of searching the tool through all the paths in the PATH environment variable.
    // Note: when searching for execution targets in the makefile, if a binary was not previously built,
    // the extension will not detect it for a launch configuration because of this following return.
    if (toolPathInMakefile !== "" && !toolFound) {
        return undefined;
    }
    return {
        // don't use join and neither paths/filenames processed above if we want to keep the exact text in the makefile
        pathInMakefile: match[1] + match[2],
        fullPath: toolFullPath,
        arguments: match[match.length - 1],
        found: toolFound,
    };
}
// Helper to identify anything that looks like a compiler switch in the given command string.
// The result is passed to IntelliSense custom configuration provider as compilerArgs.
// excludeArgs helps with narrowing down the search, when we know for sure that we're not
// interested in some switches. For example, -D, -I, -FI, -include, -std are treated separately.
// Once we identified what looks to be the switches in the given command line, for each region
// between two consecutive switches we let the shell parse it into arguments via a script invocation
// (instead of us using other parser helpers in this module) to be in sync with how CppTools
// expects the compiler arguments to be passed in.
async function parseAnySwitchFromToolArguments(args, excludeArgs) {
    // Identify the non value part of the switch: prefix, switch name
    // and what may separate this from an eventual switch value
    let switches = [];
    let regExpStr = "(^|\\s+)(--|-" +
        // On Win32 allow '/' as switch prefix as well,
        // otherwise it conflicts with path character
        (process.platform === "win32" ? "|\\/" : "") +
        ")([a-zA-Z0-9_]+)";
    let regexp = RegExp(regExpStr, "mg");
    let match1;
    let match2;
    let index1 = -1;
    let index2 = -1;
    // This contains all the compilation command fragments in between two different consecutive switches
    // (except the ones we plan to ignore, specified by excludeArgs).
    // Once this function is done concatenating into compilerArgRegions,
    // we call the compiler args parsing script once for the whole list of regions
    // (as opposed to invoking it for each fragment separately).
    let compilerArgRegions = "";
    // With every loop iteration we need 2 switch matches so that we analyze the text
    // that is between them. If the current match is the last one, then we will analyze
    // everything until the end of line.
    match1 = regexp.exec(args);
    // Even if we don't find any arguments that have a switch syntax,
    // consider the whole command line to parse into arguments
    // (this case is encountered when we call this helper while we parse launch targets).
    if (!match1) {
        compilerArgRegions = args;
    }
    while (match1) {
        // Marks the beginning of the current switch (prefix + name).
        // The exact switch prefix is needed when we call other parser helpers later
        // and also CppTools expects the compiler arguments to be prefixed
        // when received from the custom providers.
        index1 = regexp.lastIndex - match1[0].length;
        // Marks the beginning of the next switch
        match2 = regexp.exec(args);
        if (match2) {
            index2 = regexp.lastIndex - match2[0].length;
        }
        else {
            index2 = args.length;
        }
        // The substring to analyze for the current switch.
        // It doesn't help to look beyond the next switch match.
        let partialArgs = args.substring(index1, index2);
        let swi = match1[3];
        swi = swi.trim();
        // Skip over any switches that we know we don't need
        let exclude = false;
        for (const arg of excludeArgs) {
            if (swi.startsWith(arg)) {
                exclude = true;
                break;
            }
        }
        if (!exclude) {
            compilerArgRegions += partialArgs;
        }
        match1 = match2;
    }
    let parseCompilerArgsScriptFile = util.parseCompilerArgsScriptFile();
    if (process.platform === "win32") {
        // There is a potential problem with the windows version of the script:
        // A fragment like "-sw1,-sw2,-sw3" gets split by comma and a fragment like
        // "-SwDef=Val" is split by equal. Opened GitHub issue
        // https://github.com/microsoft/vscode-makefile-tools/issues/149.
        // These scenarios don't happen on pure windows but can be encountered in classic linux
        // scenarios run under MSYS/MINGW.
        // Until a better fix is implemented for 149, use a temporary marker that we replace from and into.
        compilerArgRegions = compilerArgRegions.replace(/\,/gm, "DONT_USE_COMMA_AS_SEPARATOR");
        compilerArgRegions = compilerArgRegions.replace(/\=/gm, "DONT_USE_EQUAL_AS_SEPARATOR");
    }
    let scriptArgs = [];
    let runCommand;
    if (process.platform === "win32") {
        runCommand = "cmd";
        scriptArgs.push("/c");
        scriptArgs.push(`""${parseCompilerArgsScriptFile}" ${compilerArgRegions}"`);
    }
    else {
        runCommand = "/bin/bash";
        scriptArgs.push("-c");
        scriptArgs.push(`"source '${parseCompilerArgsScriptFile}' ${compilerArgRegions}"`);
    }
    try {
        let stdout = (result) => {
            if (process.platform === "win32") {
                // Restore the commas and equals that were hidden from the script invocation.
                result = result.replace(/DONT_USE_COMMA_AS_SEPARATOR/gm, ",");
                result = result.replace(/DONT_USE_EQUAL_AS_SEPARATOR/gm, "=");
            }
            let results = result.replace(/\r\n/gm, "\n").split("\n");
            // In case of concatenated separators, the shell sees different empty arguments
            // which we can remove (most common is more spaces not being seen as a single space).
            results.forEach((res) => {
                if (res !== "") {
                    switches.push(res.trim());
                }
            });
        };
        let stderr = (result) => {
            logger.message(localize(0, null, parseCompilerArgsScriptFile, compilerArgRegions, result), "Normal");
        };
        // Running the compiler arguments parsing script can use the system locale.
        const result = await util.spawnChildProcess(runCommand, scriptArgs, util.getWorkspaceRoot(), false, false, stdout, stderr);
        if (result.returnCode !== 0) {
            logger.message(localize(1, null, parseCompilerArgsScriptFile, compilerArgRegions), "Normal");
        }
    }
    catch (error) {
        logger.message(error);
    }
    return switches;
}
// Helper that parses for a particular switch that can occur one or more times
// in the tool command line (example -I or -D for compiler)
// and returns an array of the values passed via that switch
// todo: refactor common parts in parseMultipleSwitchFromToolArguments and parseSingleSwitchFromToolArguments
// removeSurroundingQuotes: needs to be false when called from parseAnySwitchFromToolArguments,
// and true otherwise. We need to analyze more scenarios before setting in stone a particular algorithm
// regarding the decision to remove or not to remove them.
function parseMultipleSwitchFromToolArguments(args, sw, removeSurroundingQuotes = true) {
    // - '-' or '/' or '--' as switch prefix
    // - before each switch, we allow only for one or more spaces/tabs OR begining of line,
    //   to reject a case where a part of a path looks like a switch with its value
    //    (example: "drive:/dir/Ifolder" taking /Ifolder as include switch).
    // - can be wrapped by a pair of ', before the switch prefix and after the switch value
    //    (example: '-DMY_DEFINE=SOMETHING' or '/I drive/folder/subfolder').
    // - one or none or more spaces/tabs or ':' or '=' between the switch and the value
    //    (examples): -Ipath, -I path, -I    path, -std=gnu89
    // - the value can be wrapped by a pair of ", ' or `, even simmetrical combinations ('"..."')
    //   and should be able to not stop at space when inside the quote characters.
    //    (examples): -D'MY_DEFINE', -D "MY_DEFINE=SOME_VALUE", -I`drive:/folder with space/subfolder`
    // - when the switch value contains a '=', the right half can be also quoted by ', ", ` or '"..."'
    //   and should be able to not stop at space when inside the quote characters.
    //    (example): -DMY_DEFINE='"SOME_VALUE"'
    function anythingBetweenQuotes(fullyQuoted) {
        // The basic pattern for anything between quotes accepts equally single quote, double quote or back tick.
        // One pattern that is accepted is to wrap between escaped quotes and allow inside anything (including non-escaped quotes) except escaped quotes.
        // Another pattern that is accepted is to wrap between non-escaped quotes and allow inside anything (including escaped quotes) except non-escaped quotes.
        // One problem with the "..." pattern is that a simple "\" (or anything ending with \") will not know if the backslash is part of the inside of quote-quote
        // or together with the following quote represents a \" and needs to look forward for another ending quote.
        // If there is another quote somewhere else later in the command line (another -D or a file name wrapped in quotes) everything until that first upcoming quote
        // will be included.
        // Example that doesn't work: -DSLASH_DEFINE="\" -DSOME_OTHER_SWITCH "drive:\folder\file.extension"
        //                            SLASH_DEFINE is equal to '\" -DSOME_OTHER_SWITCH '
        // Example that works: -DGIT_VERSION=" \" 1.2.3 \" "
        //                      GIT_VERSION is equal to ' \" 1.2.3 \" '
        // Unfortunately, we also can't identify this to log in the output channel for later analysis of more makefile switch and quoting user scenarios.
        // Fortunately, we didn't encounter the last scenario, only the first.
        function anythingBetweenQuotesBasicPattern(quoteChar) {
            return ("\\\\\\" +
                quoteChar +
                "((?!\\\\\\" +
                quoteChar +
                ").)*\\\\\\" +
                quoteChar +
                "|" + // \" anything(except \") \"
                "\\" +
                quoteChar +
                "(\\\\\\" +
                quoteChar +
                "|[^\\" +
                quoteChar +
                "])*?[^\\\\\\" +
                quoteChar +
                "]?\\" +
                quoteChar); // " anything (except ") "
        }
        // If the switch is fully quoted with ', like ('-DMY_DEFINE="MyValue"'), don't allow single quotes
        // inside the switch value.
        // One example of what can be broken if we don't do this: gcc '-DDEF1=' '-DDef2=val2'
        // in which case DEF1 would be seen as DEF1=' ' instead of empty =
        let str = anythingBetweenQuotesBasicPattern("`") +
            "|" +
            anythingBetweenQuotesBasicPattern('"') +
            (fullyQuoted ? "" : "|" + anythingBetweenQuotesBasicPattern("'"));
        return str;
    }
    function mainPattern(fullyQuoted) {
        let pattern = 
        // prefix and switch name
        "(" +
            "\\/" +
            sw +
            "(:|=|\\s*)|-" +
            sw +
            "(:|=|\\s*)|--" +
            sw +
            "(:|=|\\s*)" +
            ")" +
            // switch value
            "(" +
            anythingBetweenQuotes(fullyQuoted) +
            "|" +
            // not fully quoted switch value scenarios
            "(" +
            // the left side (or whole value if no '=' is following)
            "(" +
            "[^\\s=]+" + // not quoted switch value component
            ")" +
            "(" +
            "=" + // separator between switch value left side and right side
            "(" +
            anythingBetweenQuotes(fullyQuoted) +
            "|" +
            "[^\\s]+" + // not quoted right side of switch value
            // equal is actually allowed (example gcc switch: -fmacro-prefix-map=./= )
            ")?" + // right side of '=' is optional, meaning we can define as nothing, like: -DMyDefine=
            ")?" + // = is also optional (simple define)
            ")" +
            ")";
        return pattern;
    }
    let regexpStr = "(" +
        "^|\\s+" +
        ")" + // start of line or any amount of space character
        "(" +
        "(" +
        "\\'" +
        mainPattern(true) +
        "\\'" +
        ")" +
        "|" + // switch if fully quoted
        "(" +
        mainPattern(false) +
        ")" + // switch if not fully quoted
        ")";
    let regexp = RegExp(regexpStr, "mg");
    let match;
    let results = [];
    match = regexp.exec(args);
    while (match) {
        let matchIndex = match[2].startsWith("'") && match[2].endsWith("'") ? 8 : 26;
        let result = match[matchIndex];
        if (result) {
            if (removeSurroundingQuotes) {
                result = util.removeSurroundingQuotes(result);
            }
            results.push(result);
        }
        match = regexp.exec(args);
    }
    return results;
}
// Helper that parses for any switch from a set that can occur one or more times
// in the tool command line and returns an array of the values passed via all of the identified switches.
// It is based on parseMultipleSwitchFromToolArguments (extends the regex for more switches
// and also accepts a switch without a following value, like -m32 or -m64 are different from -arch:arm).
// This is useful especially when we need the order of these different switches in the command line:
// for example, when we want to know which switch wins (for cancelling pairs or for overriding switches).
// Parsing the switches separately wouldn't give us the order information.
// Also, we don't have yet a function to parse the whole string of arguments into individual arguments,
// so that we anaylze each switch one by one, thus knowing the order.
// TODO: review the regexp for parseMultipleSwitchFromToolArguments to make sure all new capabilities
// are reflected in the regexp here (especially around quoting scenarios and '=').
// For now it's not critical because parseMultipleSwitchesFromToolArguments is called for target
// architecture switches which don't have such complex scenarios.
function parseMultipleSwitchesFromToolArguments(args, simpleSwitches, valueSwitches) {
    // - '-' or '/' or '--' as switch prefix
    // - before each switch, we allow only for one or more spaces/tabs OR begining of line,
    //   to reject a case where a part of a path looks like a switch with its value
    // - can be wrapped by a pair of ', before the switch prefix and after the switch value
    // - the value can be wrapped by a pair of "
    // - one or none or more spaces/tabs between the switch and the value
    let regexpStr = "(^|\\s+)\\'?(";
    valueSwitches.forEach((sw) => {
        regexpStr +=
            "\\/" + sw + "(:|=|\\s*)|-" + sw + "(:|=|\\s*)|--" + sw + "(:|=|\\s*)";
        // Make sure we don't append '|' after the last extension value
        if (sw !== valueSwitches[valueSwitches.length - 1]) {
            regexpStr += "|";
        }
    });
    regexpStr += ')(\\".*?\\"|[^\\\'\\s]+)';
    regexpStr += "|((\\/|-|--)(" + simpleSwitches.join("|") + "))";
    regexpStr += "\\'?";
    let regexp = RegExp(regexpStr, "mg");
    let match;
    let results = [];
    match = regexp.exec(args);
    while (match) {
        // If the current match is a simple switch, find it at index 15, otherwise at 12.
        // In each scenario, only one will have a value while the other is undefined.
        let result = match[12] || match[15];
        if (result) {
            result = result.trim();
            results.push(result);
        }
        match = regexp.exec(args);
    }
    return results;
}
// Helper that parses for a particular switch that can occur once in the tool command line,
// or if it is allowed to be specified more than once, the latter would override the former.
// The switch is an array of strings (as opposed to a simple string)
// representing all the alternative switches in distinct toolsets (cl, versus gcc, versus clang, etc)
// of the same conceptual argument of the given tool.
// The helper returns the value passed via the given switch
// Examples for compiler: -std:c++17, -Fotest.obj, -Fe test.exe
// Example for linker: -out:test.exe versus -o a.out
// TODO: review the regexp for parseMultipleSwitchFromToolArguments to make sure all new capabilities
// are reflected in the regexp here (especially around quoting scenarios and '=').
// For now it's not critical because parseSingleSwitchFromToolArguments is called for switches
// that have simple value scenarios.
function parseSingleSwitchFromToolArguments(args, sw) {
    // - '-' or '/' or '--' as switch prefix
    // - before the switch, we allow only for one or more spaces/tabs OR begining of line,
    //   to reject a case where a part of a path looks like a switch with its value
    // - can be wrapped by a pair of ', before the switch prefix and after the switch value
    // - the value can be wrapped by a pair of "
    // -  ':' or '=' or one/none/more spaces/tabs between the switch and the value
    let regexpStr = "(^|\\s+)\\'?(\\/|-|--)(" +
        sw.join("|") +
        ")(:|=|\\s*)(\\\".*?\\\"|[^\\'\\s]+)\\'?";
    let regexp = RegExp(regexpStr, "mg");
    let match;
    let results = [];
    match = regexp.exec(args);
    while (match) {
        let result = match[5];
        if (result) {
            result = result.trim();
            results.push(result);
        }
        match = regexp.exec(args);
    }
    return results.pop();
}
// Helper that answers whether a particular switch is passed to the tool.
// When calling this helper, we are not interested in obtaining the
// (or there is no) value passed in via the switch.
// There must be at least one space/tab before the switch,
// so that we don't match a path by mistake.
// Same after the switch, in case the given name is a substring
// of another switch name. Or have the switch be the last in the command line.
// Examples: we call this helper for /c compiler switch or /dll linker switch.
// TODO: detect sets of switches that cancel each other to return a more
// accurate result in case of override (example: /TC and /TP)
function isSwitchPassedInArguments(args, sw) {
    // - '-' or '/' or '--' as switch prefix
    // - one or more spaces/tabs after
    let regexpStr = "((\\s+)|^)(\\/|-|--)(" + sw.join("|") + ")((\\s+)|$)";
    let regexp = RegExp(regexpStr, "mg");
    if (regexp.exec(args)) {
        return true;
    }
    return false;
}
// Helper that parses for files (of given extensions) that are given as arguments to a tool
// TODO: consider non standard extensions (or no extension at all) in the presence of TC/TP.
// Attention to obj, pdb or exe files tied to /Fo, /Fd and /Fe
// TODO: consider also ' besides "
function parseFilesFromToolArguments(args, exts) {
    // no switch prefix and no association yet with a preceding switch
    // one or more spaces/tabs before (or beginning of line) and after (or end of line)
    // with or without quotes surrounding the argument
    //    - if surrounding quotes, don't allow another quote in between
    // (todo: handle the scenario when quotes enclose just the directory path, without the file name)
    let regexpStr = "(";
    exts.forEach((ext) => {
        regexpStr += '\\".[^\\"]*?\\.' + ext + '\\"|';
        regexpStr += "\\S+\\." + ext;
        // Make sure we don't append '|' after the last extension value
        if (ext !== exts[exts.length - 1]) {
            regexpStr += "|";
        }
    });
    regexpStr += ")(\\s+|$)";
    let regexp = RegExp(regexpStr, "mg");
    let match;
    let files = [];
    match = regexp.exec(args);
    while (match) {
        let result = match[1];
        // It is quite common to encounter the following pattern:
        //  `test -f 'sourceFile.c' || echo './'`sourceFile.c
        // or `test -f 'sourceFile.c' || echo '../../../libwally-core/src/'`sourceFile.c
        // Until we implement the correct approach (to query live the test command)
        // we can just ignore it and consider the second option of the OR
        // (by removing the quotes while preserving the relative path).
        // This is a short term workaround.
        let idx = args.lastIndexOf(result);
        let echo = "' || echo ";
        let str = args.substring(idx - echo.length, idx);
        if (str === echo) {
            // not to use util.removeQuotes because that also removes double quotes "
            result = result.replace(/\'/gm, "");
            result = result.replace(/\`/gm, "");
        }
        if (result) {
            result = util.removeSurroundingQuotes(result);
            // Debug message to identify easier the scenarios where source files have inner quotes.
            if (result.includes('"')) {
                logger.message(localize(2, null, result), "Debug");
            }
            files.push(result);
        }
        match = regexp.exec(args);
    }
    return files;
}
// Helper that identifies system commands (cd, cd -, pushd, popd) and make.exe change directory switch (-C)
// to calculate the effect on the current path, also remembering the transition in the history stack.
// The current path is always the last one into the history.
async function currentPathAfterCommand(line, currentPathHistory) {
    line = line.trimLeft();
    line = line.trimRight();
    let lastCurrentPath = currentPathHistory.length > 0
        ? currentPathHistory[currentPathHistory.length - 1]
        : "";
    let newCurrentPath = "";
    const analyzeLine = localize(3, null, line);
    if (line.startsWith("cd -") && !configuration.getIgnoreDirectoryCommands()) {
        // Swap the last two current paths in the history.
        if (lastCurrentPath) {
            currentPathHistory.pop();
        }
        let lastCurrentPath2 = currentPathHistory.length > 0
            ? currentPathHistory.pop() || ""
            : lastCurrentPath;
        logger.message(analyzeLine, "Verbose");
        logger.message(localize(4, null, lastCurrentPath, lastCurrentPath2), "Verbose");
        currentPathHistory.push(lastCurrentPath);
        currentPathHistory.push(lastCurrentPath2);
    }
    else if ((line.startsWith("popd") && !configuration.getIgnoreDirectoryCommands()) ||
        line.includes("Leaving directory")) {
        let lastCurrentPath = currentPathHistory.length > 0
            ? currentPathHistory[currentPathHistory.length - 1]
            : "";
        currentPathHistory.pop();
        let lastCurrentPath2 = currentPathHistory.length > 0
            ? currentPathHistory[currentPathHistory.length - 1]
            : "";
        logger.message(analyzeLine, "Verbose");
        logger.message(localize(5, null, lastCurrentPath, lastCurrentPath2), "Verbose");
    }
    else if (line.startsWith("cd") &&
        !configuration.getIgnoreDirectoryCommands()) {
        newCurrentPath = await util.makeFullPath(line.slice(3), lastCurrentPath);
        // For "cd-" (which toggles between the last 2 current paths),
        // we must always keep one previous current path in the history.
        // Don't pop if the history has only one path as of now,
        // even if this wasn't a pushd.
        if (currentPathHistory.length > 1) {
            currentPathHistory = [];
            currentPathHistory.push(lastCurrentPath);
        }
        currentPathHistory.push(newCurrentPath);
        logger.message(analyzeLine, "Verbose");
        logger.message(localize(6, null, newCurrentPath), "Verbose");
    }
    else if (line.startsWith("pushd") &&
        !configuration.getIgnoreDirectoryCommands()) {
        newCurrentPath = await util.makeFullPath(line.slice(6), lastCurrentPath);
        currentPathHistory.push(newCurrentPath);
        logger.message(analyzeLine, "Verbose");
        logger.message(localize(7, null, newCurrentPath), "Verbose");
    }
    else if (line.includes("Entering directory")) {
        // equivalent to pushd
        // The make switch print-directory wraps the folder in various ways.
        let match = line.match("(.*)(Entering directory ['`\"])(.*)['`\"]");
        if (match) {
            newCurrentPath =
                (await util.makeFullPath(match[3], lastCurrentPath)) || "";
        }
        else {
            newCurrentPath = "Could not parse directory";
        }
        logger.message(analyzeLine, "Verbose");
        logger.message(localize(8, null, newCurrentPath), "Verbose");
        currentPathHistory.push(newCurrentPath);
    }
    return currentPathHistory;
}
// Parse the output of the make dry-run command in order to provide CppTools
// with information about includes, defines, compiler path....etc...
// as needed by CustomConfigurationProvider. In addition generate a
// CompileCommand entry for every file with a compiler invocation to build
// a compile_commands.json file.
async function parseCustomConfigProvider(cancel, dryRunOutputStr, statusCallback, onFoundCustomConfigProviderItem) {
    if (cancel.isCancellationRequested) {
        return make.ConfigureBuildReturnCodeTypes.cancelled;
    }
    logger.message(localize(9, null), "Normal");
    // Current path starts with workspace root and can be modified
    // with prompt commands like cd, cd-, pushd/popd or with -C make switch
    let currentPath = util.getWorkspaceRoot();
    let currentPathHistory = [currentPath];
    // Read the dry-run output line by line, searching for compilers and directory changing commands
    // to construct information for the CppTools custom configuration
    let dryRunOutputLines = dryRunOutputStr.split("\n");
    let numberOfLines = dryRunOutputLines.length;
    let index = 0;
    let done = false;
    async function doParsingChunk() {
        let chunkIndex = 0;
        while (index < numberOfLines && chunkIndex <= chunkSize) {
            if (cancel.isCancellationRequested) {
                break;
            }
            let line = dryRunOutputLines[index];
            statusCallback("Parsing for IntelliSense");
            currentPathHistory = await currentPathAfterCommand(line, currentPathHistory);
            currentPath = currentPathHistory[currentPathHistory.length - 1];
            let compilerTool = await parseLineAsTool(line, compilers, currentPath);
            // If ccache wraps the compiler, parse again the remaining command line and we should obtain
            // the real compiler name.
            if (compilerTool &&
                path.parse(compilerTool.pathInMakefile).name.endsWith("ccache")) {
                line = line.replace(`${compilerTool.pathInMakefile}`, "");
                compilerTool = await parseLineAsTool(line, compilers, currentPath);
            }
            if (compilerTool) {
                logger.message(localize(10, null, line), "Verbose");
                // Compiler path is either what the makefile provides or found in the PATH environment variable or empty
                let compilerFullPath = compilerTool.fullPath || "";
                if (!compilerTool.found) {
                    let toolBaseName = path.basename(compilerFullPath);
                    compilerFullPath = path.join(util.toolPathInEnv(toolBaseName) || "", toolBaseName);
                }
                // Exclude switches that are being processed separately (I, FI, include, D, std)
                // and switches that don't affect IntelliSense but are causing errors.
                let compilerArgs = [];
                compilerArgs = await parseAnySwitchFromToolArguments(compilerTool.arguments, ["I", "FI", "include", "D", "std", "MF"]);
                // Parse and log the includes, forced includes and the defines
                let includes = parseMultipleSwitchFromToolArguments(compilerTool.arguments, "I");
                includes = await util.makeFullPaths(includes, currentPath);
                let forcedIncludes = parseMultipleSwitchFromToolArguments(compilerTool.arguments, "FI");
                forcedIncludes = forcedIncludes.concat(parseMultipleSwitchFromToolArguments(compilerTool.arguments, "include"));
                forcedIncludes = await util.makeFullPaths(forcedIncludes, currentPath);
                let defines = parseMultipleSwitchFromToolArguments(compilerTool.arguments, "D");
                // Parse the IntelliSense mode
                // how to deal with aliases and symlinks (CC, C++), which can point to any toolsets
                let targetArchitecture = getTargetArchitecture(compilerTool.arguments);
                let intelliSenseMode = getIntelliSenseMode(ext.extension.getCppToolsVersion(), compilerFullPath, targetArchitecture);
                // For windows, parse the sdk version
                let windowsSDKVersion = "";
                if (process.platform === "win32") {
                    windowsSDKVersion = process.env["WindowsSDKVersion"];
                }
                // Parse the source files
                let files = parseFilesFromToolArguments(compilerTool.arguments, sourceFileExtensions);
                files = await util.makeFullPaths(files, currentPath);
                // The language represented by this compilation command
                let language;
                let hasC = files.filter((file) => file.endsWith(".c")).length > 0;
                let hasCpp = files.filter((file) => file.endsWith(".cpp")).length > 0;
                if (hasC && !hasCpp) {
                    language = "c";
                }
                else if (hasCpp && !hasC) {
                    language = "cpp";
                }
                // /TP and /TC (for cl.exe only) overwrite the meaning of the source files extensions
                if (isSwitchPassedInArguments(compilerTool.arguments, ["TP"])) {
                    language = "cpp";
                }
                else if (isSwitchPassedInArguments(compilerTool.arguments, ["TC"])) {
                    language = "c";
                }
                // Parse the C/C++ standard as given in the compiler command line
                let standardStr = parseSingleSwitchFromToolArguments(compilerTool.arguments, ["std"]);
                // If the command is compiling the same extension or uses -TC/-TP, send all the source files in one batch.
                if (language) {
                    // More standard validation and defaults, in the context of the whole command.
                    let standard = parseStandard(ext.extension.getCppToolsVersion(), standardStr, language);
                    if (ext.extension) {
                        onFoundCustomConfigProviderItem({
                            defines,
                            includes,
                            forcedIncludes,
                            standard,
                            intelliSenseMode,
                            compilerFullPath,
                            compilerArgs,
                            files,
                            windowsSDKVersion,
                            currentPath,
                            line,
                        });
                    }
                }
                else {
                    // If the compiler command is mixing c and c++ source files, send a custom configuration for each of the source files separately,
                    // to be able to accurately validate and calculate the standard based on the correct language.
                    files.forEach((file) => {
                        if (file.endsWith(".cpp")) {
                            language = "cpp";
                        }
                        else if (file.endsWith(".c")) {
                            language = "c";
                        }
                        // More standard validation and defaults, in the context of each source file.
                        let standard = parseStandard(ext.extension.getCppToolsVersion(), standardStr, language);
                        if (ext.extension) {
                            onFoundCustomConfigProviderItem({
                                defines,
                                includes,
                                forcedIncludes,
                                standard,
                                intelliSenseMode,
                                compilerFullPath,
                                compilerArgs,
                                files: [file],
                                windowsSDKVersion,
                                currentPath,
                                line,
                            });
                        }
                    });
                }
            } // if (compilerTool) {
            index++;
            if (index === numberOfLines) {
                done = true;
            }
            chunkIndex++;
        } // while loop
    } // doParsingChunk function
    while (!done) {
        if (cancel.isCancellationRequested) {
            break;
        }
        await util.scheduleAsyncTask(doParsingChunk);
    }
    return cancel.isCancellationRequested
        ? make.ConfigureBuildReturnCodeTypes.cancelled
        : make.ConfigureBuildReturnCodeTypes.success;
}
exports.parseCustomConfigProvider = parseCustomConfigProvider;
// Target binaries arguments special handling
function filterTargetBinaryArgs(args) {
    let processedArgs = [];
    for (const arg of args) {
        // Once we encounter a redirection character (pipe, stdout/stderr) remove it,
        // together with all the arguments that are following,
        // since they are not real parameters of the binary tool that is analyzed.
        if (arg === ">" || arg === "1>" || arg === "2>" || arg === "|") {
            break;
        }
        processedArgs.push(arg);
    }
    return processedArgs;
}
// Parse the output of the make dry-run command in order to provide VS Code debugger
// with information about binaries, their execution paths and arguments
async function parseLaunchConfigurations(cancel, dryRunOutputStr, statusCallback, onFoundLaunchConfiguration) {
    if (cancel.isCancellationRequested) {
        return make.ConfigureBuildReturnCodeTypes.cancelled;
    }
    // Current path starts with workspace root and can be modified
    // with prompt commands like cd, cd-, pushd/popd or with -C make switch
    let currentPath = util.getWorkspaceRoot();
    let currentPathHistory = [currentPath];
    // array of full path executables built by this makefile
    let targetBinaries = [];
    // The first pass of reading the dry-run output, line by line
    // searching for compilers, linkers and directory changing commands
    // to construct information for the launch configuration
    let dryRunOutputLines = dryRunOutputStr.split("\n");
    let numberOfLines = dryRunOutputLines.length;
    let index = 0;
    let done = false;
    let doLinkCommandsParsingChunk = async () => {
        let chunkIndex = 0;
        while (index < numberOfLines && chunkIndex <= chunkSize) {
            if (cancel.isCancellationRequested) {
                break;
            }
            let line = dryRunOutputLines[index];
            statusCallback("Parsing for launch targets: inspecting for link commands");
            currentPathHistory = await currentPathAfterCommand(line, currentPathHistory);
            currentPath = currentPathHistory[currentPathHistory.length - 1];
            // A target binary is usually produced by the linker with the /out or /o switch,
            // but there are several scenarios (for win32 Microsoft cl.exe)
            // when the compiler is producing an output binary directly (via the /Fe switch)
            // or indirectly (based on some naming default rules in the absence of /Fe)
            let linkerTargetBinary;
            let compilerTargetBinary;
            if (process.platform === "win32") {
                let compilerTool = await parseLineAsTool(line, compilers, currentPath);
                if (compilerTool) {
                    // If a cl.exe is not performing only an obj compilation, deduce the output executable if possible
                    // Note: no need to worry about the DLL case that this extension doesn't support yet
                    // since a compiler can produce implicitly only an executable.
                    if (path.basename(compilerTool.fullPath).startsWith("cl")) {
                        if (!isSwitchPassedInArguments(compilerTool.arguments, [
                            "c",
                            "P",
                            "E",
                            "EP",
                        ])) {
                            logger.message(localize(11, null, line), "Verbose");
                            // First read the value of the /Fe switch (for cl.exe)
                            compilerTargetBinary = parseSingleSwitchFromToolArguments(compilerTool.arguments, ["Fe"]);
                            // Then assume first object file base name (defined with /Fo) + exe
                            // The binary is produced in the same folder where the compiling operation takes place,
                            // and not in an eventual different obj path.
                            // Note: /Fo is not allowed on multiple sources compilations so there will be only one if found
                            if (!compilerTargetBinary) {
                                let objFile = parseSingleSwitchFromToolArguments(compilerTool.arguments, [
                                    "Fo",
                                ]);
                                if (objFile) {
                                    let parsedObjPath = path.parse(objFile);
                                    compilerTargetBinary = parsedObjPath.name + ".exe";
                                    logger.message(localize(12, null, compilerTargetBinary), "Verbose");
                                }
                            }
                            else {
                                logger.message(localize(13, null, compilerTargetBinary), "Verbose");
                            }
                            // Then assume first source file base name + exe.
                            // The binary is produced in the same folder where the compiling operation takes place,
                            // and not in an eventual different source path.
                            if (!compilerTargetBinary) {
                                let srcFiles = parseFilesFromToolArguments(compilerTool.arguments, sourceFileExtensions);
                                if (srcFiles.length >= 1) {
                                    let parsedSourcePath = path.parse(srcFiles[0]);
                                    compilerTargetBinary = parsedSourcePath.name + ".exe";
                                    logger.message(localize(14, null, compilerTargetBinary), "Verbose");
                                }
                            }
                        }
                    }
                    if (compilerTargetBinary) {
                        compilerTargetBinary = await util.makeFullPath(compilerTargetBinary, currentPath);
                    }
                }
            }
            let linkerTool = await parseLineAsTool(line, linkers, currentPath);
            if (linkerTool) {
                // TODO: implement launch support for DLLs and LIBs, besides executables.
                if (!isSwitchPassedInArguments(linkerTool.arguments, [
                    "dll",
                    "lib",
                    "shared",
                ])) {
                    // Gcc/Clang tools can also perform linking so don't parse any output binary
                    // if there are switches passed in to cause early stop of compilation: -c, -E, -S
                    // (-o will not point to an executable)
                    // Also, the ld switches -r and -Ur do not produce executables.
                    if (!isSwitchPassedInArguments(linkerTool.arguments, [
                        "c",
                        "E",
                        "S",
                        "r",
                        "Ur",
                    ])) {
                        linkerTargetBinary = parseSingleSwitchFromToolArguments(linkerTool.arguments, ["out", "o"]);
                        logger.message(localize(15, null, line), "Verbose");
                        if (!linkerTargetBinary) {
                            // For Microsoft link.exe, the default output binary takes the base name
                            // of the first file (obj, lib, etc...) that is passed to the linker.
                            // The binary is produced in the same folder where the linking operation takes place,
                            // and not in an eventual different obj/lib path.
                            if (process.platform === "win32" &&
                                path.basename(linkerTool.fullPath).startsWith("link")) {
                                let files = parseFilesFromToolArguments(linkerTool.arguments, ["obj", "lib"]);
                                if (files.length >= 1) {
                                    let parsedPath = path.parse(files[0]);
                                    let targetBinaryFromFirstObjLib = parsedPath.name + ".exe";
                                    logger.message(localize(16, null, targetBinaryFromFirstObjLib), "Verbose");
                                    linkerTargetBinary = targetBinaryFromFirstObjLib;
                                }
                            }
                            else {
                                // The default output binary from a linking operation is usually a.out on linux/mac,
                                // produced in the same folder where the toolset is run.
                                logger.message(localize(17, null), "Verbose");
                                linkerTargetBinary = "a.out";
                            }
                        }
                    }
                    if (linkerTargetBinary) {
                        // Until we implement a more robust link target analysis
                        // (like query-ing for the executable attributes),
                        // we can safely assume that a ".la" file produced by libtool
                        // is a library and not an executable binary.
                        if (linkerTargetBinary.endsWith(".la") &&
                            dryRunOutputLines[index - 1] === "LIBTOOL_PATTERN") {
                            linkerTargetBinary = undefined;
                        }
                        else {
                            linkerTargetBinary =
                                util.removeSurroundingQuotes(linkerTargetBinary);
                            logger.message(localize(18, null, linkerTargetBinary), "Verbose");
                            linkerTargetBinary = await util.makeFullPath(linkerTargetBinary, currentPath);
                        }
                    }
                }
            }
            // It is not possible to have compilerTargetBinary and linkerTargetBinary both defined,
            // because a dry-run output line cannot be a compilation and an explicit link at the same time.
            // (cl.exe with /link switch is split into two lines - cl.exe and link.exe - during dry-run preprocessing).
            // Also for gcc/clang, -o switch or the default output will be a .o in the presence of -c and an executable otherwise.
            let targetBinary = linkerTargetBinary || compilerTargetBinary;
            // Some "$" (without following open paranthesis) are still left in the preprocessed output,
            // because the configuraion provider parser may lose valid compilation lines otherwise.
            // Additionally, for linker commands, ignore any dollar if present in the target binary name.
            // We need to ignore the $ anywhere else in the linker command line so that we don't lose
            // valid target binaries.
            if (targetBinary && !targetBinary.includes("$")) {
                targetBinaries.push(targetBinary);
                // Include limited launch configuration, when only the binary is known,
                // in which case the execution path is defaulting to binary containing folder.
                // It is more likely that an invocation would succeed from that location
                // as opposed from any other (like the root) because of eventual dependencies
                // that very likely to be built in the same place.
                // and there are no args.
                let launchConfiguration = {
                    binaryPath: targetBinary,
                    cwd: path.parse(targetBinary).dir,
                    binaryArgs: [],
                };
                logger.message(localize(19, null, configuration.launchConfigurationToString(launchConfiguration)), "Verbose");
                onFoundLaunchConfiguration(launchConfiguration);
            }
            index++;
            if (index === numberOfLines) {
                done = true;
            }
            chunkIndex++;
        } // while loop
    }; // doLinkCommandsParsingChunk function
    while (!done) {
        if (cancel.isCancellationRequested) {
            return make.ConfigureBuildReturnCodeTypes.cancelled;
        }
        await util.scheduleAsyncTask(doLinkCommandsParsingChunk);
    }
    // If no binaries are found to be built, there is no point in parsing for invoking targets
    if (targetBinaries.length === 0) {
        return cancel.isCancellationRequested
            ? make.ConfigureBuildReturnCodeTypes.cancelled
            : make.ConfigureBuildReturnCodeTypes.success;
    }
    // For each of the built binaries identified in the dry-run pass above,
    // search the makefile for possible targets that are invoking them,
    // to update the launch configuration with their name, full path, execution path and args.
    // If a built binary is not having an execution target defined in the makefile,
    // the launch configuration will be limited to the version having only with their name and path,
    // workspace folder instead of another execution path and zero args.
    // If this is not sufficient, the user can at any time write an execution target
    // in the makefile or write a launch configuration in the settings json.
    // TODO: investigate the scenario when the binary is run relying on path environment variable
    // and attention to on the fly environment changes made by make.
    // Reset the current path since we are going to analyze path transitions again
    // with this second pass through the dry-run output lines,
    // while building the launch custom provider data.
    currentPath = util.getWorkspaceRoot();
    currentPathHistory = [currentPath];
    // Since an executable can be called without its extension,
    // on Windows only and only for extensions 'exe',
    // create a new array with target binaries names
    // to ensure we parse right these binaries invocation right.
    let targetBinariesNames = [];
    targetBinaries.forEach((target) => {
        let parsedPath = path.parse(target);
        if (!targetBinariesNames.includes(parsedPath.name)) {
            if (process.platform === "win32" && parsedPath.ext === "exe") {
                targetBinariesNames.push(util.escapeString(parsedPath.name));
            }
            else {
                targetBinariesNames.push(util.escapeString(parsedPath.base));
            }
        }
    });
    index = 0;
    done = false;
    let doBinaryInvocationsParsingChunk = async () => {
        let chunkIndex = 0;
        while (index < numberOfLines && chunkIndex <= chunkSize) {
            if (cancel.isCancellationRequested) {
                break;
            }
            let line = dryRunOutputLines[index];
            // Some "$" (without following open paranthesis) are still left in the preprocessed output,
            // because the configuraion provider parser may lose valid compilation lines otherwise.
            // But the binary invocations parser should ignore any dollar because the extension can't resolve
            // these anyway, wherever they are (current folder, binary name or arguments).
            if (!line.includes("$")) {
                statusCallback("Parsing for launch targets: inspecting built binary invocations");
                currentPathHistory = await currentPathAfterCommand(line, currentPathHistory);
                currentPath = currentPathHistory[currentPathHistory.length - 1];
                // Currently, the target binary invocation will not be identified if the line does not start with it,
                // because we need to be able to reject matches like "link.exe /out:mybinary.exe".
                // See comment in parseLineAsTool about not understanding well what it is that prepends
                // the target binary tool, unless we treat it as a path and verify its location on disk.
                // Because of this limitation, the extension might not present to the user
                // all the scenarios of arguments defined in the makefile for this target binary.
                // TODO: identify and parse properly all the valid scenarios of invoking a taget binary in a makefile:
                //       - @if (not) exist binary binary arg1 arg2 arg3
                //         (because an "@if exist" is not resolved by the dry-run and appears in the output)
                //       - cmd /c binary arg1 arg2 arg3
                //       - start binary
                let targetBinaryTool = await parseLineAsTool(line, targetBinariesNames, currentPath);
                // If the found target binary invocation does not happen from a location
                // where it was built previously, don't include it as a launch target.
                // We can debug only what was built. Also, it's quite common to run
                // tools from the path during the build and we shouldn't launch those.
                if (targetBinaryTool) {
                    let foundTargetBinary = false;
                    targetBinaries.forEach((target) => {
                        if (target === (targetBinaryTool === null || targetBinaryTool === void 0 ? void 0 : targetBinaryTool.fullPath)) {
                            foundTargetBinary = true;
                        }
                    });
                    if (!foundTargetBinary) {
                        targetBinaryTool = undefined;
                    }
                }
                if (targetBinaryTool) {
                    logger.message(localize(20, null, line), "Verbose");
                    // Include complete launch configuration: binary, execution path and args
                    // are known from parsing the dry-run
                    let splitArgs = targetBinaryTool.arguments
                        ? await parseAnySwitchFromToolArguments(targetBinaryTool.arguments, [])
                        : [];
                    if (splitArgs.length > 0) {
                        splitArgs = filterTargetBinaryArgs(splitArgs);
                    }
                    let launchConfiguration = {
                        binaryPath: targetBinaryTool.fullPath,
                        cwd: currentPath,
                        // TODO: consider optionally quoted arguments
                        binaryArgs: splitArgs,
                    };
                    logger.message(localize(21, null, configuration.launchConfigurationToString(launchConfiguration)), "Verbose");
                    onFoundLaunchConfiguration(launchConfiguration);
                }
            }
            index++;
            if (index === numberOfLines) {
                done = true;
            }
            chunkIndex++;
        } // while loop
    }; // doBinaryInvocationsParsingChunk function
    while (!done) {
        if (cancel.isCancellationRequested) {
            break;
        }
        await util.scheduleAsyncTask(doBinaryInvocationsParsingChunk);
    }
    return cancel.isCancellationRequested
        ? make.ConfigureBuildReturnCodeTypes.cancelled
        : make.ConfigureBuildReturnCodeTypes.success;
}
exports.parseLaunchConfigurations = parseLaunchConfigurations;
/**
 * Determine the IntelliSenseMode based on hints from compiler path
 * and target architecture parsed from compiler flags.
 */
function getIntelliSenseMode(cppVersion, compilerPath, targetArch) {
    if (cppVersion && cppVersion >= cpp.Version.v5 && targetArch === undefined) {
        // IntelliSenseMode is optional for CppTools v5+ and is determined by CppTools.
        return undefined;
    }
    const canUseArm = cppVersion !== undefined && cppVersion >= cpp.Version.v4;
    const compilerName = path
        .basename(compilerPath || "")
        .toLocaleLowerCase();
    if (compilerName === "cl.exe") {
        const clArch = path
            .basename(path.dirname(compilerPath))
            .toLocaleLowerCase();
        switch (clArch) {
            case "arm64":
                return canUseArm ? "msvc-arm64" : "msvc-x64";
            case "arm":
                return canUseArm ? "msvc-arm" : "msvc-x86";
            case "x86":
                return "msvc-x86";
            case "x64":
            default:
                return "msvc-x64";
        }
    }
    else if (compilerName.indexOf("armclang") >= 0) {
        switch (targetArch) {
            case "arm64":
                return canUseArm ? "clang-arm64" : "clang-x64";
            case "arm":
            default:
                return canUseArm ? "clang-arm" : "clang-x86";
        }
    }
    else if (compilerName.indexOf("clang") >= 0) {
        switch (targetArch) {
            case "arm64":
                return canUseArm ? "clang-arm64" : "clang-x64";
            case "arm":
                return canUseArm ? "clang-arm" : "clang-x86";
            case "x86":
                return "clang-x86";
            case "x64":
            default:
                return "clang-x64";
        }
    }
    else if (compilerName.indexOf("aarch64") >= 0) {
        // Compiler with 'aarch64' in its name may also have 'arm', so check for
        // aarch64 compilers before checking for ARM specific compilers.
        return canUseArm ? "gcc-arm64" : "gcc-x64";
    }
    else if (compilerName.indexOf("arm") >= 0) {
        return canUseArm ? "gcc-arm" : "gcc-x86";
    }
    else if (compilerName.indexOf("gcc") >= 0 ||
        compilerName.indexOf("g++") >= 0) {
        switch (targetArch) {
            case "x86":
                return "gcc-x86";
            case "x64":
            default:
                return "gcc-x64";
        }
    }
    else {
        // unknown compiler; pick platform defaults.
        if (process.platform === "win32") {
            return "msvc-x64";
        }
        else if (process.platform === "darwin") {
            return "clang-x64";
        }
        else {
            return "gcc-x64";
        }
    }
}
/**
 * Determine the target architecture from the compiler flags present in the given compilation command.
 */
function getTargetArchitecture(compilerArgs) {
    // Go through all the possible target architecture switches.
    // For each switch, apply a set of rules to identify the target arch.
    // The last switch wins.
    let possibleArchs = parseMultipleSwitchesFromToolArguments(compilerArgs, ["m32", "m64"], ["arch", "march", "target"]);
    let targetArch; // this starts as undefined
    possibleArchs.forEach((arch) => {
        if (arch === "m32") {
            targetArch = "x86";
        }
        else if (arch === "m64") {
            targetArch = "x64";
        }
        else if (arch === "i686") {
            targetArch = "x86";
        }
        else if (arch === "amd64" || arch === "x86_64") {
            targetArch = "x64";
        }
        else if (arch === "aarch64" || arch === "armv8-a" || arch === "armv8.") {
            targetArch = "arm64";
        }
        else if (arch === "arm" || arch === "armv8-r" || arch === "armv8-m") {
            targetArch = "arm";
        }
        else {
            // Check if ARM version is 7 or earlier.
            const verStr = arch === null || arch === void 0 ? void 0 : arch.substr(4, 1);
            if (verStr) {
                const verNum = +verStr;
                if (verNum <= 7) {
                    targetArch = "arm";
                }
            }
        }
    });
    return targetArch;
}
function parseStandard(cppVersion, std, language) {
    let canUseGnu = cppVersion !== undefined && cppVersion >= cpp.Version.v4;
    let canUseCxx23 = cppVersion !== undefined && cppVersion >= cpp.Version.v6;
    let standard;
    if (cppVersion && cppVersion >= cpp.Version.v5 && std === undefined) {
        // C/C++ standard is optional for CppTools v5+ and is determined by CppTools.
        return undefined;
    }
    if (!std) {
        // Standard defaults when no std switch is given
        if (language === "c") {
            return "c11";
        }
        else if (language === "cpp") {
            return "c++17";
        }
    }
    else if (language === "cpp") {
        standard = parseCppStandard(std, canUseGnu, canUseCxx23);
        if (!standard) {
            logger.message(localize(22, null, std), "Normal");
        }
    }
    else if (language === "c") {
        standard = parseCStandard(std, canUseGnu);
        if (!standard) {
            logger.message(localize(23, null, std), "Normal");
        }
    }
    else if (language === undefined) {
        standard = parseCppStandard(std, canUseGnu, canUseCxx23);
        if (!standard) {
            standard = parseCStandard(std, canUseGnu);
        }
        if (!standard) {
            logger.message(localize(24, null, std), "Normal");
        }
    }
    else {
        logger.message(localize(25, null), "Normal");
    }
    return standard;
}
exports.parseStandard = parseStandard;
function parseCppStandard(std, canUseGnu, canUseCxx23) {
    const isGnu = canUseGnu && std.startsWith("gnu");
    if (std.endsWith("++23") ||
        std.endsWith("++2b") ||
        std.endsWith("++latest")) {
        if (canUseCxx23) {
            return isGnu ? "gnu++23" : "c++23";
        }
        else {
            return isGnu ? "gnu++20" : "c++20";
        }
    }
    else if (std.endsWith("++2a") || std.endsWith("++20")) {
        return isGnu ? "gnu++20" : "c++20";
    }
    else if (std.endsWith("++17") || std.endsWith("++1z")) {
        return isGnu ? "gnu++17" : "c++17";
    }
    else if (std.endsWith("++14") || std.endsWith("++1y")) {
        return isGnu ? "gnu++14" : "c++14";
    }
    else if (std.endsWith("++11") || std.endsWith("++0x")) {
        return isGnu ? "gnu++11" : "c++11";
    }
    else if (std.endsWith("++03")) {
        return isGnu ? "gnu++03" : "c++03";
    }
    else if (std.endsWith("++98")) {
        return isGnu ? "gnu++98" : "c++98";
    }
    else {
        return undefined;
    }
}
function parseCStandard(std, canUseGnu) {
    // GNU options from: https://gcc.gnu.org/onlinedocs/gcc/C-Dialect-Options.html#C-Dialect-Options
    const isGnu = canUseGnu && std.startsWith("gnu");
    if (/(c|gnu)(90|89|iso9899:(1990|199409))/.test(std)) {
        return isGnu ? "gnu89" : "c89";
    }
    else if (/(c|gnu)(99|9x|iso9899:(1999|199x))/.test(std)) {
        return isGnu ? "gnu99" : "c99";
    }
    else if (/(c|gnu)(11|1x|iso9899:2011)/.test(std)) {
        return isGnu ? "gnu11" : "c11";
    }
    else if (/(c|gnu)(17|18|iso9899:(2017|2018))/.test(std)) {
        if (canUseGnu) {
            // cpptools supports 'c17' in same version it supports GNU std.
            return isGnu ? "gnu17" : "c17";
        }
        else {
            return "c11";
        }
    }
    else {
        return undefined;
    }
}


/***/ }),

/***/ 227:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StateManager = void 0;
// state.ts
const vscode = __webpack_require__(398);
// Class for the management of all the workspace state variables
class StateManager {
    constructor(extensionContext) {
        this.extensionContext = extensionContext;
    }
    _get(key) {
        return this.extensionContext.workspaceState.get(key);
    }
    _update(key, value) {
        return this.extensionContext.workspaceState.update(key, value);
    }
    // The project build configuration (one of the entries in the array of makefile.configurations
    // or a default).
    get buildConfiguration() {
        return this._get("buildConfiguration");
    }
    set buildConfiguration(v) {
        this._update("buildConfiguration", v);
    }
    // The project build target (one of the targets defined in the makefile).
    get buildTarget() {
        return this._get("buildTarget");
    }
    set buildTarget(v) {
        this._update("buildTarget", v);
    }
    // The project launch configuration (one of the entries in the array of makefile.launchConfigurations).
    get launchConfiguration() {
        return this._get("launchConfiguration");
    }
    set launchConfiguration(v) {
        this._update("launchConfiguration", v);
    }
    // Whether this project had any configure attempt before
    // (it didn't have to succeed or even complete).
    // Sent as telemetry information and useful to know
    // how many projects are able to configure out of the box.
    get ranConfigureInCodebaseLifetime() {
        return this._get("ranConfigureInCodebaseLifetime") || false;
    }
    set ranConfigureInCodebaseLifetime(v) {
        this._update("ranConfigureInCodebaseLifetime", v);
    }
    // If the project needs a clean configure as a result
    // of an operation that alters the configure state
    // (makefile configuration change, build target change,
    // settings or makefiles edits)
    get configureDirty() {
        let dirty = this._get("configureDirty");
        if (dirty === undefined) {
            dirty = true;
        }
        return dirty;
    }
    set configureDirty(v) {
        this._update("configureDirty", v);
    }
    // Reset all the variables saved in the workspace state.
    reset(reloadWindow = true) {
        this.buildConfiguration = undefined;
        this.buildTarget = undefined;
        this.launchConfiguration = undefined;
        this.ranConfigureInCodebaseLifetime = false;
        this.configureDirty = false;
        if (reloadWindow) {
            vscode.commands.executeCommand("workbench.action.reloadWindow");
        }
    }
}
exports.StateManager = StateManager;


/***/ }),

/***/ 277:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.logConfigureOnOpenTelemetry = exports.analyzeSettings = exports.logEvent = exports.telemetryLogger = exports.deactivate = exports.activate = void 0;
// Telemetry.ts
const configuration = __webpack_require__(604);
const logger = __webpack_require__(464);
const util = __webpack_require__(260);
const extension_telemetry_1 = __webpack_require__(754);
const vscode = __webpack_require__(398);
let telemetryReporter;
function activate() {
    try {
        // Don't create the telemetry object (which will result in no information being sent)
        // when running Makefile Tools tests.
        if (process.env["MAKEFILE_TOOLS_TESTING"] !== "1") {
            telemetryReporter = createReporter();
        }
    }
    catch (e) {
        // can't really do much about this
    }
}
exports.activate = activate;
async function deactivate() {
    if (telemetryReporter) {
        await telemetryReporter.dispose();
    }
}
exports.deactivate = deactivate;
function telemetryLogger(str, loggingLevel) {
    if (vscode.env.isTelemetryEnabled) {
        logger.message(str, loggingLevel);
    }
}
exports.telemetryLogger = telemetryLogger;
function logEvent(eventName, properties, measures) {
    // We don't want to log telemetry in testing.
    if (telemetryReporter && process.env["MAKEFILE_TOOLS_TESTING"] !== "1") {
        try {
            telemetryReporter.sendTelemetryEvent(eventName, properties, measures);
        }
        catch (e) {
            telemetryLogger(e.message);
        }
        telemetryLogger(`Sending telemetry: eventName = ${eventName}`, "Debug");
        if (properties) {
            telemetryLogger(`properties: ${Object.getOwnPropertyNames(properties)
                .map((k) => `${k} = "${properties[k]}"`)
                .concat()}`, "Debug");
        }
        if (measures) {
            telemetryLogger(`measures: ${Object.getOwnPropertyNames(measures)
                .map((k) => `${k} = "${measures[k]}"`)
                .concat()}`, "Debug");
        }
    }
}
exports.logEvent = logEvent;
// Allow-lists for various settings.
function filterSetting(value, key, defaultValue) {
    if (key === "makefile.dryrunSwitches") {
        let dryrunSwitches = value;
        let filteredSwitches = dryrunSwitches.map((sw) => {
            switch (sw) {
                case "--dry-run":
                case "-n":
                case "--just-print":
                case "--recon":
                case "--keep-going":
                case "-k":
                case "--always-make":
                case "-B":
                case "--print-data-base":
                case "-p":
                case "--print-directory":
                case "-w":
                    return sw;
                default:
                    return "...";
            }
        });
        return filteredSwitches.join(";");
    }
    // Even if the key represents a setting that shouldn't share its value,
    // we can still record if it is undefined by the user (removed from settings.json)
    // or equal to the default we set in package.json.
    if (!value) {
        return "undefined";
    }
    else if (value === defaultValue) {
        return "default";
    }
    return "...";
}
// Detect which item from the given array setting is relevant for telemetry.
// Return the index in the array or -1 if we don't find a match.
// The telemetry is not yet collecting settings information from all items of an array.
// Until this will be needed, we pick the item in the array that corresponds
// to some current state value.
// Example: don't report telemetry for all launch configurations but only for
// the current launch configuration.
function activeArrayItem(setting, key) {
    if (key === "makefile.configurations") {
        let makefileConfigurations = configuration.getMakefileConfigurations();
        let currentMakefileConfigurationName = configuration.getCurrentMakefileConfiguration();
        if (!currentMakefileConfigurationName) {
            return -1;
        }
        let currentMakefileConfiguration = makefileConfigurations.find((config) => {
            if (config.name === currentMakefileConfigurationName) {
                return config;
            }
        });
        return currentMakefileConfiguration
            ? makefileConfigurations.indexOf(currentMakefileConfiguration)
            : -1;
    }
    if (key === "makefile.launchConfigurations") {
        let launchConfigurations = configuration.getLaunchConfigurations();
        let currentLaunchConfiguration = launchConfigurations.find((config) => {
            if (util.areEqual(config, configuration.getCurrentLaunchConfiguration())) {
                return config;
            }
        });
        return currentLaunchConfiguration
            ? launchConfigurations.indexOf(currentLaunchConfiguration)
            : -1;
    }
    return -1;
}
// Filter the array item indexes from the key since for now, when we analyze an array,
// we pick one item that corresponds to a current state of the project.
// Example: makefile.configurations.0.name ==> makefile.configurations.name
// The extension currently has a settings structure with only one level of objects arrays
// (makefile.configurations and makefile.launchConfigurations).
// Other arrays are of simple type (like make or executable arguments, dryrun switches)
// and don't create a key that would have 2 numerical properties
// (there is no makefile.configurations.1.makeArgs.2.something).
// So, eliminate only one numerical (if exists) before the last dot in this key string.
// We still need the complete key for anything else than the telemetry properties
// (example: validation errors are more clear when an array item is highlighted).
// This helper should be called when a property is ready to be collected for telemetry.
// Calling this earlier would result in different dot patterns.
function filterKey(key) {
    let filteredKey = key;
    let lastDot = key.lastIndexOf(".");
    let beforeLastDot = key.lastIndexOf(".", lastDot - 1);
    if (lastDot !== -1 && beforeLastDot !== -1) {
        let lastProp = key.substring(beforeLastDot + 1, lastDot);
        let numericalProp = Number.parseInt(lastProp);
        if (!Number.isNaN(numericalProp)) {
            filteredKey = filteredKey.replace(`${numericalProp}.`, "");
        }
    }
    return filteredKey;
}
// Analyze recursively all the settings for telemetry and type validation.
// Return all the telemetry properties that have been collected throughout this recursive process.
// If telemetryProperties is null, this function performs only type validation.
// If analyzeSettings gets called before a configure (or after an unsuccesful one), it is possible to have
// inaccurate or incomplete telemetry information for makefile and launch configurations.
// This is not very critical since any of their state changes will update telemetry for them.
async function analyzeSettings(setting, key, propSchema, ignoreDefault, telemetryProperties) {
    // type can be undefined if setting is null,
    // which happens when the user removes that setting.
    let type = setting ? typeof setting : undefined;
    let jsonType = propSchema.type
        ? propSchema.type
        : undefined;
    // Skip anything else if the current setting represents a function.
    if (type === "function") {
        return telemetryProperties;
    }
    // Interested to continue only for properties that are different than their defaults,
    // unless ignoreDefault requests we report those too (useful when the user is changing
    // from a non default value back to default, usually via removing/undefining a setting).
    if (util.areEqual(propSchema.default, setting) && ignoreDefault) {
        return telemetryProperties;
    }
    // The type "array" defined in package.json is seen as object by the workspace setting type.
    // Not all package.json constructs have a type (example: configuration properties list)
    // but the workspace setting type sees them as object.
    if (jsonType !== type &&
        jsonType !== undefined &&
        type !== undefined &&
        (type !== "object" || jsonType !== "array")) {
        telemetryLogger(`Settings versus package.json type mismatch for "${key}".`);
    }
    // Enum values always safe to report.
    // Validate the allowed values against the expanded variable.
    let enumValues = propSchema.enum;
    if (enumValues && enumValues.length > 0) {
        const regexp = /(makefile\.)(.+)/gm;
        const res = regexp.exec(key);
        let expandedSetting = res
            ? await util.getExpandedSetting(res[2])
            : setting;
        if (!enumValues.includes(expandedSetting)) {
            telemetryLogger(`Invalid value "${expandedSetting}" for enum "${key}". Only "${enumValues.join(";")}" values are allowed."`);
            if (telemetryProperties) {
                telemetryProperties[filterKey(key)] = "invalid";
            }
        }
        else if (telemetryProperties) {
            telemetryProperties[filterKey(key)] = expandedSetting;
        }
        return telemetryProperties;
    }
    // When propSchema does not have a type defined (for example at the root scope)
    // use the setting type. We use the setting type second because it sees array as object.
    switch (jsonType || type) {
        // Report numbers and booleans since there is no private information in such types.
        case "boolean": /* falls through */
        case "number":
            if (telemetryProperties) {
                telemetryProperties[filterKey(key)] = setting;
            }
            break;
        // Apply allow-lists for strings.
        case "string":
            if (telemetryProperties) {
                telemetryProperties[filterKey(key)] = filterSetting(setting, key, propSchema.default);
            }
            break;
        case "array":
            // We are interested in logging arrays of basic types
            if (telemetryProperties &&
                propSchema.items.type !== "object" &&
                propSchema.items.type !== "array") {
                telemetryProperties[filterKey(key)] = filterSetting(setting, key, propSchema.default);
                break;
            }
        /* falls through */
        case "object":
            let settingsProps = Object.getOwnPropertyNames(setting);
            let index = -1;
            let active = 0;
            if (jsonType === "array") {
                active = activeArrayItem(setting, key);
            }
            settingsProps.forEach(async (prop) => {
                index++;
                let jsonProps;
                let newPropObj = setting[prop];
                if (jsonType === "array") {
                    jsonProps = propSchema.items.properties || propSchema.items;
                }
                else {
                    // For a setting like "makefile.name1.name2.name3",
                    // when we need to query for its schema we should use the whole name as index
                    // but when we query for the workspace value, we have to use each sub object name:
                    // setting[name1][name2][name3].
                    // Otherwise we will not read anything useful about such a setting and we will also
                    // report a schema mismatch, even if it is written correctly.
                    let newProp = prop;
                    let newFullProp = key === "makefile" ? key + "." : "";
                    while (jsonProps === undefined && newProp !== "") {
                        newFullProp = newFullProp + newProp;
                        if (propSchema.properties) {
                            jsonProps = Object.getOwnPropertyNames(propSchema.properties).includes(newFullProp)
                                ? propSchema.properties[newFullProp]
                                : undefined;
                        }
                        else {
                            jsonProps = Object.getOwnPropertyNames(propSchema).includes(newFullProp)
                                ? propSchema[newFullProp]
                                : undefined;
                        }
                        if (jsonProps === undefined && typeof newPropObj === "object") {
                            newProp = Object.getOwnPropertyNames(newPropObj)[0];
                            newPropObj = newPropObj[newProp];
                            newProp = "." + newProp;
                        }
                        else {
                            newProp = "";
                        }
                    }
                }
                // The user defined a setting property wrong (example miMode instead of MIMode).
                // Exceptions are 'has', 'get', 'update' and 'inspect' for the makefile root.
                // They are functions and we can use this type to make the exclusion..
                if (jsonProps === undefined) {
                    if (typeof setting[prop] !== "function") {
                        telemetryLogger(`Schema mismatch between settings and package.json for property "${key}.${prop}"`);
                    }
                }
                else {
                    // Skip if the analyzed prop is a function or if it's the length of an array.
                    if (type !== "function" /*&& jsonType !== undefined*/ &&
                        (jsonType !== "array" || prop !== "length")) {
                        let newTelemetryProperties = {};
                        newTelemetryProperties = await analyzeSettings(newPropObj, key + "." + prop, jsonProps, ignoreDefault, jsonType !== "array" || index === active
                            ? newTelemetryProperties
                            : null);
                        // If telemetryProperties is null, it means we're not interested in reporting any telemetry for this subtree
                        if (telemetryProperties) {
                            telemetryProperties = util.mergeProperties(telemetryProperties, newTelemetryProperties);
                        }
                    }
                }
            });
            break;
        default:
            break;
    }
    return telemetryProperties;
}
exports.analyzeSettings = analyzeSettings;
function createReporter() {
    const packageInfo = getPackageInfo();
    if (packageInfo && packageInfo.aiKey) {
        return new extension_telemetry_1.default(packageInfo.aiKey);
    }
    return null;
}
function getPackageInfo() {
    const packageJSON = util.thisExtensionPackage();
    return {
        name: `${packageJSON.publisher}.${packageJSON.name}`,
        version: packageJSON.version,
        aiKey: "0c6ae279ed8443289764825290e4f9e2-1a736e7c-1324-4338-be46-fc2a58ae4d14-7255",
    };
}
function logConfigureOnOpenTelemetry(configureOnOpen, scope = undefined) {
    logEvent("configureOnOpenPopup", {
        configureOnOpen: configureOnOpen.toString(),
        scope: scope !== null && scope !== void 0 ? scope : "N/A",
    });
}
exports.logConfigureOnOpenTelemetry = logConfigureOnOpenTelemetry;


/***/ }),

/***/ 24:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProjectOutlineProvider = exports.BuildLogPathInfoNode = exports.MakePathInfoNode = exports.MakefilePathInfoNode = exports.ConfigurationNode = exports.LaunchTargetNode = exports.BuildTargetNode = void 0;
// Tree.ts
const configuration = __webpack_require__(604);
const path = __webpack_require__(928);
const util = __webpack_require__(260);
const vscode = __webpack_require__(398);
const nls = __webpack_require__(493);
const extension_1 = __webpack_require__(15);
nls.config({
    messageFormat: nls.MessageFormat.bundle,
    bundleFormat: nls.BundleFormat.standalone,
})((__webpack_require__(928).join)(__dirname, 'src\\tree.ts'));
const localize = nls.loadMessageBundle((__webpack_require__(928).join)(__dirname, 'src\\tree.ts'));
class BaseNode {
    constructor(id) {
        this.id = id;
    }
}
class BuildTargetNode extends BaseNode {
    constructor(targetName) {
        super(`buildTarget:${targetName}`);
        this._name = targetName;
    }
    update(targetName) {
        this._name = localize(0, null, `[${targetName}]`);
    }
    getChildren() {
        return [];
    }
    getTreeItem() {
        try {
            const item = new vscode.TreeItem(this._name);
            item.collapsibleState = vscode.TreeItemCollapsibleState.None;
            item.tooltip = localize(1, null);
            item.contextValue = [`nodeType=buildTarget`].join(",");
            return item;
        }
        catch (e) {
            return new vscode.TreeItem(localize(2, null, this._name));
        }
    }
}
exports.BuildTargetNode = BuildTargetNode;
class LaunchTargetNode extends BaseNode {
    // Keep the tree node label as short as possible.
    // The binary path is the most important component of a launch target.
    async getShortLaunchTargetName(completeLaunchTargetName) {
        let launchConfiguration = await configuration.stringToLaunchConfiguration(completeLaunchTargetName);
        let shortName;
        if (!launchConfiguration) {
            shortName = localize(3, null);
        }
        else {
            if (vscode.workspace.workspaceFolders) {
                // In a complete launch target string, the binary path is relative to cwd.
                // In here, since we don't show cwd, make it relative to current workspace folder.
                shortName = util.makeRelPath(launchConfiguration.binaryPath, vscode.workspace.workspaceFolders[0].uri.fsPath);
            }
            else {
                // Just in case, if for some reason we don't have a workspace folder, return full binary path.
                shortName = launchConfiguration.binaryPath;
            }
        }
        return localize(4, null, `[${shortName}]`);
    }
    constructor(targetName) {
        super(`launchTarget:${targetName}`);
        // Show the short name as label
        this._name = targetName;
    }
    async update(targetName) {
        // Show short name as label
        this._name = await this.getShortLaunchTargetName(targetName);
    }
    getChildren() {
        return [];
    }
    getTreeItem() {
        try {
            const item = new vscode.TreeItem(this._name);
            item.collapsibleState = vscode.TreeItemCollapsibleState.None;
            item.tooltip = localize(5, null);
            item.contextValue = [`nodeType=launchTarget`].join(",");
            return item;
        }
        catch (e) {
            return new vscode.TreeItem(localize(6, null, this._name));
        }
    }
}
exports.LaunchTargetNode = LaunchTargetNode;
class ConfigurationNode extends BaseNode {
    constructor(configurationName) {
        super(`configuration:${configurationName}`);
        this._name = configurationName;
    }
    update(configurationName) {
        this._name = localize(7, null, `[${configurationName}]`);
    }
    getChildren() {
        return [];
    }
    getTreeItem() {
        try {
            const item = new vscode.TreeItem(this._name);
            item.collapsibleState = vscode.TreeItemCollapsibleState.None;
            item.tooltip = localize(8, null);
            item.contextValue = [`nodeType=configuration`].join(",");
            return item;
        }
        catch (e) {
            return new vscode.TreeItem(localize(9, null, this._name));
        }
    }
}
exports.ConfigurationNode = ConfigurationNode;
class MakefilePathInfoNode extends BaseNode {
    constructor(pathInSettings, pathDisplayed) {
        super(pathDisplayed);
        this._title = pathDisplayed;
        this._tooltip = pathInSettings;
    }
    update(pathInSettings, pathDisplayed) {
        this._title = localize(10, null, `${pathDisplayed}`);
        this._tooltip = pathInSettings;
    }
    getChildren() {
        return [];
    }
    getTreeItem() {
        try {
            const item = new vscode.TreeItem(this._title);
            item.collapsibleState = vscode.TreeItemCollapsibleState.None;
            item.tooltip = this._tooltip;
            item.contextValue = [`nodeType=makefilePathInfo`].join(",");
            return item;
        }
        catch (e) {
            return new vscode.TreeItem(localize(11, null, this._title));
        }
    }
}
exports.MakefilePathInfoNode = MakefilePathInfoNode;
class MakePathInfoNode extends BaseNode {
    constructor(pathInSettings, pathDisplayed) {
        super(pathDisplayed);
        this._title = pathDisplayed;
        this._tooltip = pathInSettings;
    }
    update(pathInSettings, pathDisplayed) {
        this._title = localize(12, null, `${pathDisplayed}`);
        this._tooltip = pathInSettings;
    }
    getChildren() {
        return [];
    }
    getTreeItem() {
        try {
            const item = new vscode.TreeItem(this._title);
            item.collapsibleState = vscode.TreeItemCollapsibleState.None;
            item.tooltip = this._tooltip;
            item.contextValue = [`nodeType=makePathInfo`].join(",");
            return item;
        }
        catch (e) {
            return new vscode.TreeItem(localize(13, null, this._title));
        }
    }
}
exports.MakePathInfoNode = MakePathInfoNode;
class BuildLogPathInfoNode extends BaseNode {
    constructor(pathInSettings, pathDisplayed) {
        super(pathDisplayed);
        this._title = pathDisplayed;
    }
    update(pathInSettings, pathDisplayed) {
        this._title = localize(14, null, `${pathDisplayed}`);
    }
    getChildren() {
        return [];
    }
    getTreeItem() {
        try {
            const item = new vscode.TreeItem(this._title);
            item.collapsibleState = vscode.TreeItemCollapsibleState.None;
            item.tooltip = localize(15, null);
            item.contextValue = [`nodeType=buildLogPathInfo`].join(",");
            return item;
        }
        catch (e) {
            return new vscode.TreeItem(localize(16, null, this._title));
        }
    }
}
exports.BuildLogPathInfoNode = BuildLogPathInfoNode;
class ProjectOutlineProvider {
    constructor() {
        this._changeEvent = new vscode.EventEmitter();
        this._unsetString = localize(17, null);
        this._currentConfigurationItem = new ConfigurationNode(this._unsetString);
        this._currentBuildTargetItem = new BuildTargetNode(this._unsetString);
        this._currentLaunchTargetItem = new LaunchTargetNode(this._unsetString);
        this._currentMakefilePathInfoItem = new MakefilePathInfoNode(this._unsetString, "");
        this._currentMakePathInfoItem = new MakePathInfoNode(this._unsetString, "");
        this._currentBuildLogPathInfoItem = new BuildLogPathInfoNode(this._unsetString, "");
    }
    get onDidChangeTreeData() {
        return this._changeEvent.event;
    }
    async getTreeItem(node) {
        return node.getTreeItem();
    }
    getChildren(node) {
        if (node) {
            return node.getChildren();
        }
        if (configuration.isOptionalFeatureEnabled("debug") ||
            configuration.isOptionalFeatureEnabled("run")) {
            return [
                this._currentConfigurationItem,
                this._currentBuildTargetItem,
                this._currentLaunchTargetItem,
                this._currentMakefilePathInfoItem,
                this._currentMakePathInfoItem,
                this._currentBuildLogPathInfoItem,
            ];
        }
        else {
            return [
                this._currentConfigurationItem,
                this._currentBuildTargetItem,
                this._currentMakefilePathInfoItem,
                this._currentMakePathInfoItem,
                this._currentBuildLogPathInfoItem,
            ];
        }
    }
    pathDisplayed(pathInSettings, kind, searchInPath, makeRelative) {
        if (!pathInSettings) {
            if (kind === "Build Log") {
                extension_1.extension.updateBuildLogPresent(false);
                kind = localize(18, null);
            }
            else if (kind === "Makefile") {
                extension_1.extension.updateMakefileFilePresent(false);
            }
            const unset = localize(19, null);
            return `${kind}: [${unset}]`;
        }
        const pathInSettingsToTest = process.platform === "win32" &&
            !(pathInSettings === null || pathInSettings === void 0 ? void 0 : pathInSettings.endsWith(".exe")) &&
            kind === "Make"
            ? pathInSettings === null || pathInSettings === void 0 ? void 0 : pathInSettings.concat(".exe")
            : pathInSettings;
        const pathBase = searchInPath && path.parse(pathInSettingsToTest).dir === ""
            ? path.parse(pathInSettingsToTest).base
            : undefined;
        const pathInEnv = pathBase
            ? path.join(util.toolPathInEnv(pathBase) || "", pathBase)
            : undefined;
        const finalPath = pathInEnv || pathInSettingsToTest;
        const checkFileExists = util.checkFileExistsSync(finalPath);
        if (kind === "Build Log") {
            extension_1.extension.updateBuildLogPresent(checkFileExists);
            kind = localize(20, null);
        }
        else if (kind === "Makefile") {
            extension_1.extension.updateMakefileFilePresent(checkFileExists);
        }
        const notFound = localize(21, null);
        return ((!checkFileExists ? `${kind} (${notFound})` : `${kind}`) +
            `: [${makeRelative
                ? util.makeRelPath(finalPath, util.getWorkspaceRoot())
                : finalPath}]`);
    }
    async update(configuration, buildTarget, launchTarget, makefilePathInfo, makePathInfo, buildLogInfo) {
        this._currentConfigurationItem.update(configuration || this._unsetString);
        this._currentBuildTargetItem.update(buildTarget || this._unsetString);
        await this._currentLaunchTargetItem.update(launchTarget || this._unsetString);
        this._currentMakefilePathInfoItem.update(makefilePathInfo || this._unsetString, this.pathDisplayed(makefilePathInfo, "Makefile", false, false));
        this._currentMakePathInfoItem.update(makePathInfo || this._unsetString, this.pathDisplayed(makePathInfo, "Make", true, false));
        this._currentBuildLogPathInfoItem.update(buildLogInfo || this._unsetString, this.pathDisplayed(buildLogInfo, "Build Log", false, false));
        this.updateTree();
    }
    updateConfiguration(configuration) {
        this._currentConfigurationItem.update(configuration);
        this.updateTree();
    }
    updateBuildTarget(buildTarget) {
        this._currentBuildTargetItem.update(buildTarget);
        this.updateTree();
    }
    async updateLaunchTarget(launchTarget) {
        await this._currentLaunchTargetItem.update(launchTarget);
        this.updateTree();
    }
    async updateMakefilePathInfo(makefilePathInfo) {
        this._currentMakefilePathInfoItem.update(makefilePathInfo || this._unsetString, this.pathDisplayed(makefilePathInfo, "Makefile", false, true));
        this.updateTree();
    }
    async updateMakePathInfo(makePathInfo) {
        this._currentMakePathInfoItem.update(makePathInfo || this._unsetString, this.pathDisplayed(makePathInfo, "Make", true, false));
        this.updateTree();
    }
    async updateBuildLogPathInfo(buildLogPathInfo) {
        this._currentBuildLogPathInfoItem.update(buildLogPathInfo || this._unsetString, this.pathDisplayed(buildLogPathInfo, "Build Log", false, true));
        this.updateTree();
    }
    updateTree() {
        this._changeEvent.fire(null);
    }
}
exports.ProjectOutlineProvider = ProjectOutlineProvider;


/***/ }),

/***/ 846:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUI = exports.UI = void 0;
// Deprecated UI support for buttons and quickpicks.
// Replaced by makefile.outline view in the left side bar.
// To be removed, hidden for now.
const vscode = __webpack_require__(398);
let ui;
class UI {
    setConfiguration(configuration) {
        this.configurationButton.text =
            "$(settings) Build configuration: " + configuration;
    }
    setTarget(target) {
        this.targetButton.text = "$(tag) Target to build: " + target;
    }
    setLaunchConfiguration(launchConfigurationStr) {
        if (launchConfigurationStr) {
            this.launchConfigurationButton.text = "$(rocket) Launch configuration: ";
            this.launchConfigurationButton.text += "[";
            this.launchConfigurationButton.text += launchConfigurationStr;
            this.launchConfigurationButton.text += "]";
        }
        else {
            this.launchConfigurationButton.text = "No launch configuration set";
        }
    }
    constructor() {
        this.configurationButton = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 4.6);
        this.configurationButton.command = "makefile.setBuildConfiguration";
        this.configurationButton.tooltip =
            "Click to select the workspace make configuration";
        this.configurationButton.hide();
        this.targetButton = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 4.5);
        this.targetButton.command = "makefile.setBuildTarget";
        this.targetButton.tooltip = "Click to select the target to be run by make";
        this.targetButton.hide();
        this.buildButton = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 4.4);
        this.buildButton.command = "makefile.buildTarget";
        this.buildButton.tooltip = "Click to build the selected target";
        this.buildButton.text = "$(gear) Build";
        this.buildButton.hide();
        this.launchConfigurationButton = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 4.3);
        this.launchConfigurationButton.command = "makefile.setLaunchConfiguration";
        this.launchConfigurationButton.tooltip =
            "Click to select the make launch configuration (binary, args and current path)";
        this.launchConfigurationButton.hide();
        this.debugButton = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 4.2);
        this.debugButton.command = "makefile.launchDebug";
        this.debugButton.tooltip = "Click to debug the selected executable";
        this.debugButton.text = "$(bug) Debug";
        this.debugButton.hide();
        this.runButton = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 4.1);
        this.runButton.command = "makefile.launchRun";
        this.runButton.tooltip = "Click to launch the selected executable";
        this.runButton.text = "$(terminal) Run";
        this.runButton.hide();
    }
    dispose() {
        this.configurationButton.dispose();
        this.targetButton.dispose();
        this.launchConfigurationButton.dispose();
        this.buildButton.dispose();
        this.debugButton.dispose();
        this.runButton.dispose();
    }
}
exports.UI = UI;
function getUI() {
    if (ui === undefined) {
        ui = new UI();
    }
    return ui;
}
exports.getUI = getUI;


/***/ }),

/***/ 260:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.thisExtensionPath = exports.thisExtensionPackage = exports.thisExtension = exports.scheduleAsyncTask = exports.scheduleTask = exports.expandVariablesInSetting = exports.getExpandedSettingVal = exports.getExpandedSetting = exports.booleanify = exports.userHome = exports.resolvePathToRoot = exports.reportDryRunError = exports.sortAndRemoveDuplicates = exports.removeDuplicates = exports.mergeProperties = exports.hasProperties = exports.areEqual = exports.elapsedTimeSince = exports.escapeString = exports.quoteStringIfNeeded = exports.removeSurroundingQuotes = exports.removeQuotes = exports.makeRelPaths = exports.makeRelPath = exports.makeFullPaths = exports.makeFullPath = exports.ensureWindowsPath = exports.cygpath = exports.dropNulls = exports.spawnChildProcess = exports.mergeEnvironment = exports.normalizeEnvironmentVarname = exports.killTree = exports.toolPathInEnv = exports.pathIsCurrentDirectory = exports.looksLikePath = exports.getWorkspaceRoot = exports.parseCompilerArgsScriptFile = exports.tmpDir = exports.writeFile = exports.readFile = exports.deleteFileSync = exports.createDirectorySync = exports.checkDirectoryExistsSync = exports.checkFileExistsSync = void 0;
// Helper APIs used by this extension
const configuration = __webpack_require__(604);
const fs = __webpack_require__(896);
const child_process = __webpack_require__(317);
const logger = __webpack_require__(464);
const make = __webpack_require__(970);
const path = __webpack_require__(928);
const telemetry = __webpack_require__(277);
const vscode = __webpack_require__(398);
const nls = __webpack_require__(493);
const extension_1 = __webpack_require__(15);
nls.config({
    messageFormat: nls.MessageFormat.bundle,
    bundleFormat: nls.BundleFormat.standalone,
})((__webpack_require__(928).join)(__dirname, 'src\\util.ts'));
const localize = nls.loadMessageBundle((__webpack_require__(928).join)(__dirname, 'src\\util.ts'));
function checkFileExistsSync(filePath) {
    try {
        // Often a path is added by the user to the PATH environment variable with surrounding quotes,
        // especially on Windows where they get automatically added after TAB.
        // These quotes become inner (not surrounding) quotes after we append various file names or do oher processing,
        // making file sysem stats fail. Safe to remove here.
        let filePathUnq = filePath;
        filePathUnq = removeQuotes(filePathUnq);
        return fs.statSync(filePathUnq).isFile();
    }
    catch (e) { }
    return false;
}
exports.checkFileExistsSync = checkFileExistsSync;
function checkDirectoryExistsSync(directoryPath) {
    try {
        return fs.statSync(directoryPath).isDirectory();
    }
    catch (e) { }
    return false;
}
exports.checkDirectoryExistsSync = checkDirectoryExistsSync;
function createDirectorySync(directoryPath) {
    try {
        fs.mkdirSync(directoryPath, { recursive: true });
        return true;
    }
    catch { }
    return false;
}
exports.createDirectorySync = createDirectorySync;
function deleteFileSync(filePath) {
    try {
        fs.unlinkSync(filePath);
    }
    catch (e) { }
}
exports.deleteFileSync = deleteFileSync;
function readFile(filePath) {
    try {
        if (checkFileExistsSync(filePath)) {
            return fs.readFileSync(filePath).toString();
        }
    }
    catch (e) { }
    return undefined;
}
exports.readFile = readFile;
function writeFile(filePath, content) {
    try {
        fs.writeFileSync(filePath, content);
    }
    catch (e) { }
    return undefined;
}
exports.writeFile = writeFile;
// Get the platform-specific temporary directory
function tmpDir() {
    if (process.platform === "win32") {
        return process.env["TEMP"] || "";
    }
    else {
        const xdg = process.env["XDG_RUNTIME_DIR"];
        if (xdg) {
            if (!fs.existsSync(xdg)) {
                fs.mkdirSync(xdg);
            }
            return xdg;
        }
        return "/tmp";
    }
}
exports.tmpDir = tmpDir;
// Returns the full path to a temporary script generated by the extension
// and used to parse any additional compiler switches that need to be sent to CppTools.
function parseCompilerArgsScriptFile() {
    const extensionPath = extension_1.extension.extensionContext.extensionPath;
    let scriptFile = path.join(extensionPath, "assets", "parseCompilerArgs");
    if (process.platform === "win32") {
        scriptFile += ".bat";
    }
    else {
        scriptFile += ".sh";
    }
    return scriptFile;
}
exports.parseCompilerArgsScriptFile = parseCompilerArgsScriptFile;
function getWorkspaceRoot() {
    return vscode.workspace.workspaceFolders
        ? vscode.workspace.workspaceFolders[0].uri.fsPath
        : "";
}
exports.getWorkspaceRoot = getWorkspaceRoot;
// Evaluate whether a string looks like a path or not,
// without using fs.stat, since dry-run may output tools
// that are not found yet at certain locations,
// without running the prep targets that would copy them there
function looksLikePath(pathStr) {
    // TODO: to be implemented
    return true;
}
exports.looksLikePath = looksLikePath;
// Evaluate whether the tool is invoked from the current directory
function pathIsCurrentDirectory(pathStr) {
    // Ignore any spaces or tabs before the invocation
    pathStr = pathStr.trimLeft();
    if (pathStr === "") {
        return true;
    }
    if (process.platform === "win32" && process.env.MSYSTEM === undefined) {
        if (pathStr === ".\\") {
            return true;
        }
    }
    else {
        if (pathStr === "./") {
            return true;
        }
    }
    return false;
}
exports.pathIsCurrentDirectory = pathIsCurrentDirectory;
// Helper that searches for a tool in all the paths forming the PATH environment variable
// Returns the first one found or undefined if not found.
// TODO: implement a variation of this helper that scans on disk for the tools installed,
// to help when VSCode is not launched from the proper environment
function toolPathInEnv(name) {
    let envPath = process.env["PATH"];
    let envPathSplit = [];
    if (envPath) {
        envPathSplit = envPath.split(path.delimiter);
    }
    // todo: if the compiler is not found in path, scan on disk and point the user to all the options
    // (the concept of kit for cmake extension)
    return envPathSplit.find((p) => {
        const fullPath = path.join(p, path.basename(name));
        if (checkFileExistsSync(fullPath)) {
            return fullPath;
        }
    });
}
exports.toolPathInEnv = toolPathInEnv;
function taskKill(pid) {
    return new Promise((resolve, reject) => {
        child_process.exec(`taskkill /pid ${pid} /T /F`, (error) => {
            if (error) {
                reject(error);
            }
            else {
                resolve();
            }
        });
    });
}
async function killTree(progress, pid) {
    if (process.platform === "win32") {
        try {
            await taskKill(pid);
        }
        catch (e) {
            logger.message(localize(0, null, pid, e));
        }
        return;
    }
    let children = [];
    let stdoutStr = "";
    let stdout = (result) => {
        stdoutStr += result;
    };
    try {
        // pgrep should run on english, regardless of the system setting.
        const result = await spawnChildProcess("pgrep", ["-P", pid.toString()], getWorkspaceRoot(), true, false, stdout);
        if (!!stdoutStr.length) {
            children = stdoutStr
                .split("\n")
                .map((line) => Number.parseInt(line));
            logger.message(localize(1, null, stdoutStr));
            for (const other of children) {
                if (other) {
                    await killTree(progress, other);
                }
            }
        }
    }
    catch (e) {
        logger.message(e.message);
        throw e;
    }
    try {
        logger.message(localize(2, null, pid));
        progress.report({
            increment: 1,
            message: localize(3, null, pid),
        });
        process.kill(pid, "SIGINT");
    }
    catch (e) {
        if (e.code !== "ESRCH") {
            throw e;
        }
    }
}
exports.killTree = killTree;
function normalizeEnvironmentVarname(varname) {
    return process.platform === "win32" ? varname.toUpperCase() : varname;
}
exports.normalizeEnvironmentVarname = normalizeEnvironmentVarname;
function mergeEnvironment(...env) {
    return env.reduce((acc, vars) => {
        if (process.platform === "win32") {
            // Env vars on windows are case insensitive, so we take the ones from
            // active env and overwrite the ones in our current process env
            const norm_vars = Object.getOwnPropertyNames(vars).reduce((acc2, key) => {
                acc2[normalizeEnvironmentVarname(key)] = vars[key];
                return acc2;
            }, {});
            return { ...acc, ...norm_vars };
        }
        else {
            return { ...acc, ...vars };
        }
    }, {});
}
exports.mergeEnvironment = mergeEnvironment;
// Helper to spawn a child process, hooked to callbacks that are processing stdout/stderr
// forceEnglish is true when the caller relies on parsing english words from the output.
function spawnChildProcess(processName, args, workingDirectory, forceEnglish, ensureQuoted, stdoutCallback, stderrCallback) {
    const localeOverride = {
        LANG: "C",
        LC_ALL: "C",
    };
    // Use english language for this process regardless of the system setting.
    const environment = forceEnglish ? localeOverride : {};
    const finalEnvironment = mergeEnvironment(process.env, environment);
    return new Promise((resolve, reject) => {
        var _a, _b;
        // Honor the "terminal.integrated.automationShell.<platform>" setting.
        // According to documentation (and settings.json schema), the three allowed values for <platform> are "windows", "linux" and "osx".
        // child_process.SpawnOptions accepts a string (which can be read from the above setting) or the boolean true to let VSCode pick a default
        // based on where it is running.
        let shellType;
        let shellPlatform = process.platform === "win32"
            ? "windows"
            : process.platform === "linux"
                ? "linux"
                : "osx";
        let workspaceConfiguration = vscode.workspace.getConfiguration("terminal");
        shellType =
            workspaceConfiguration.get(`integrated.automationProfile.${shellPlatform}`) || // automationShell is deprecated
                workspaceConfiguration.get(`integrated.automationShell.${shellPlatform}`); // and replaced with automationProfile
        // Final quoting decisions for process name and args before being executed.
        let qProcessName = ensureQuoted
            ? quoteStringIfNeeded(processName)
            : processName;
        let qArgs = ensureQuoted
            ? args.map((arg) => {
                return quoteStringIfNeeded(arg);
            })
            : args;
        if (ensureQuoted) {
            logger.message(localize(4, null, qProcessName, qArgs.join(","), workingDirectory, shellType || "default"), "Debug");
        }
        const child = child_process.spawn(qProcessName, qArgs, { cwd: workingDirectory, shell: shellType || true, env: finalEnvironment });
        if (child.pid) {
            make.setCurPID(child.pid);
        }
        if (stdoutCallback) {
            (_a = child.stdout) === null || _a === void 0 ? void 0 : _a.on("data", (data) => {
                stdoutCallback(`${data}`);
            });
        }
        if (stderrCallback) {
            (_b = child.stderr) === null || _b === void 0 ? void 0 : _b.on("data", (data) => {
                stderrCallback(`${data}`);
            });
        }
        child.on("close", (returnCode, signal) => {
            resolve({ returnCode, signal });
        });
        child.on("exit", (returnCode) => {
            resolve({ returnCode, signal: "" });
        });
        if (child.pid === undefined) {
            reject(new Error(`Failed to spawn process: ${processName} ${args}`));
        }
    });
}
exports.spawnChildProcess = spawnChildProcess;
// Helper to eliminate empty items in an array
function dropNulls(items) {
    return items.filter((item) => item !== null && item !== undefined);
}
exports.dropNulls = dropNulls;
// Convert a posix path (/home/dir1/dir2/file.ext) into windows path,
// by calling the cygpah which comes installed with MSYS/MinGW environments
// and which is also aware of the drive under which /home/ is placed.
// result: c:\msys64\home\dir1\dir2\file.ext
// Called usually for Windows subsystems: MinGW, CygWin.
async function cygpath(pathStr) {
    let windowsPath = pathStr;
    let stdout = (result) => {
        windowsPath = result.replace(/\n/gm, ""); // remove the end of line
    };
    // Running cygpath can use the system locale.
    await spawnChildProcess("cygpath", [pathStr, "-w"], "", false, false, stdout);
    return windowsPath;
}
exports.cygpath = cygpath;
// Helper that transforms a posix path (used in various non windows environments on a windows system)
// into a windows style path.
async function ensureWindowsPath(path) {
    if (process.platform !== "win32" || !path.startsWith("/")) {
        return path;
    }
    let winPath = path;
    if (process.env.MSYSTEM !== undefined) {
        // When in MSYS/MinGW/CygWin environments, cygpath can help transform into a windows path
        // that we know CppTools will use when querying us.
        winPath = await cygpath(winPath);
    }
    else {
        // Even in a pure windows environment, there are tools that may report posix paths.
        // Instead of searching a cygpath tool somewhere, do the most basic transformations:
        // Mount drives names like "cygdrive" or "mnt" can be ignored.
        const mountDrives = ["cygdrive", "mnt"];
        for (const drv of mountDrives) {
            if (winPath.startsWith(`/${drv}`)) {
                winPath = winPath.substr(drv.length + 1);
                // Exit the loop, because we don't want to remove anything else
                // in case the path happens to follow with a subfolder with the same name
                // as other mountable drives for various systems/environments.
                break;
            }
        }
        // Remove the slash and add the : for the drive.
        winPath = winPath.substr(1);
        const driveEndIndex = winPath.search("/");
        winPath =
            winPath.substring(0, driveEndIndex) + ":" + winPath.substr(driveEndIndex);
        // Replace / with \.
        winPath = winPath.replace(/\//gm, "\\");
    }
    return winPath;
}
exports.ensureWindowsPath = ensureWindowsPath;
// Helper to reinterpret one relative path (to the given current path) printed by make as full path
async function makeFullPath(relPath, curPath) {
    let fullPath = relPath;
    if (!path.isAbsolute(fullPath) && curPath) {
        fullPath = path.join(curPath, relPath);
    }
    // For win32, ensure we have a windows style path.
    fullPath = await ensureWindowsPath(fullPath);
    return fullPath;
}
exports.makeFullPath = makeFullPath;
// Helper to reinterpret the relative paths (to the given current path) printed by make as full paths
async function makeFullPaths(relPaths, curPath) {
    let fullPaths = [];
    for (const p of relPaths) {
        let fullPath = await makeFullPath(p, curPath);
        fullPaths.push(fullPath);
    }
    return fullPaths;
}
exports.makeFullPaths = makeFullPaths;
// Helper to reinterpret one full path as relative to the given current path
function makeRelPath(fullPath, curPath) {
    let relPath = fullPath;
    if (path.isAbsolute(fullPath) && curPath) {
        relPath = path.relative(curPath, fullPath);
    }
    return relPath;
}
exports.makeRelPath = makeRelPath;
// Helper to reinterpret the relative paths (to the given current path) printed by make as full paths
function makeRelPaths(fullPaths, curPath) {
    let relPaths = [];
    fullPaths.forEach((p) => {
        relPaths.push(makeRelPath(p, curPath));
    });
    return fullPaths;
}
exports.makeRelPaths = makeRelPaths;
// Helper to remove any quotes(", ' or `) from a given string
// because many file operations don't work properly with paths
// having quotes in the middle.
const quotesStr = ["'", '"', "`"];
function removeQuotes(str) {
    for (const p in quotesStr) {
        if (str.includes(quotesStr[p])) {
            let regExpStr = `${quotesStr[p]}`;
            let regExp = RegExp(regExpStr, "g");
            str = str.replace(regExp, "");
        }
    }
    return str;
}
exports.removeQuotes = removeQuotes;
// Remove only the quotes (", ' or `) that are surrounding the given string.
function removeSurroundingQuotes(str) {
    let result = str.trim();
    for (const p in quotesStr) {
        if (result.startsWith(quotesStr[p]) && result.endsWith(quotesStr[p])) {
            result = result.substring(1, str.length - 1);
            return result;
        }
    }
    return str;
}
exports.removeSurroundingQuotes = removeSurroundingQuotes;
// Quote given string if it contains space and is not quoted already
function quoteStringIfNeeded(str) {
    // No need to quote if there is no space or ampersand present.
    if (!str.includes(" ") && !str.includes("&")) {
        return str;
    }
    // Return if already quoted.
    for (const q in quotesStr) {
        if (str.startsWith(quotesStr[q]) && str.endsWith(quotesStr[q])) {
            return str;
        }
    }
    // Quote and return.
    return `"${str}"`;
}
exports.quoteStringIfNeeded = quoteStringIfNeeded;
// Used when constructing a regular expression from file names which can contain
// special characters (+, ", ...etc...).
const escapeChars = /[\\\^\$\*\+\?\{\}\(\)\.\!\=\|\[\]\ \/]/; // characters that should be escaped.
function escapeString(str) {
    let escapedString = "";
    for (const char of str) {
        if (char.match(escapeChars)) {
            escapedString += `\\${char}`;
        }
        else {
            escapedString += char;
        }
    }
    return escapedString;
}
exports.escapeString = escapeString;
function elapsedTimeSince(start) {
    // Real elapsed times not useful in testing mode and we want to avoid diffs.
    // We could alternatively disable the messages from being printed.
    return process.env["MAKEFILE_TOOLS_TESTING"] === "1"
        ? 0
        : (Date.now() - start) / 1000;
}
exports.elapsedTimeSince = elapsedTimeSince;
// Helper to evaluate whether two settings (objects or simple types) represent the same content.
// It recursively analyzes any inner subobjects and is also not affected
// by a different order of properties.
function areEqual(setting1, setting2) {
    if (setting1 === null ||
        setting1 === undefined ||
        setting2 === null ||
        setting2 === undefined) {
        return setting1 === setting2;
    }
    // This is simply type
    if (typeof setting1 !== "function" &&
        typeof setting1 !== "object" &&
        typeof setting2 !== "function" &&
        typeof setting2 !== "object") {
        return setting1 === setting2;
    }
    let properties1 = Object.getOwnPropertyNames(setting1);
    let properties2 = Object.getOwnPropertyNames(setting2);
    if (properties1.length !== properties2.length) {
        return false;
    }
    for (let p = 0; p < properties1.length; p++) {
        let property = properties1[p];
        let isEqual;
        if (typeof setting1[property] === "object" &&
            typeof setting2[property] === "object") {
            isEqual = areEqual(setting1[property], setting2[property]);
        }
        else {
            isEqual = setting1[property] === setting2[property];
        }
        if (!isEqual) {
            return false;
        }
    }
    return true;
}
exports.areEqual = areEqual;
// Answers whether the given object has at least one property.
function hasProperties(obj) {
    if (obj === null || obj === undefined) {
        return false;
    }
    let props = Object.getOwnPropertyNames(obj);
    return props && props.length > 0;
}
exports.hasProperties = hasProperties;
// Apply any properties from source to destination, logging for overwrite.
// To make things simpler for the caller, create a valid dst if given null or undefined.
function mergeProperties(dst, src) {
    let props = src ? Object.getOwnPropertyNames(src) : [];
    props.forEach((prop) => {
        if (!dst) {
            dst = {};
        }
        if (dst[prop] !== undefined) {
            logger.message(localize(5, null, prop, dst[prop], src[prop]), "Debug");
        }
        dst[prop] = src[prop];
    });
    return dst;
}
exports.mergeProperties = mergeProperties;
function removeDuplicates(src) {
    let seen = {};
    let result = [];
    src.forEach((item) => {
        if (!seen[item]) {
            seen[item] = true;
            result.push(item);
        }
    });
    return result;
}
exports.removeDuplicates = removeDuplicates;
function sortAndRemoveDuplicates(src) {
    return removeDuplicates(src.sort());
}
exports.sortAndRemoveDuplicates = sortAndRemoveDuplicates;
function reportDryRunError(dryrunOutputFile) {
    logger.message(localize(6, null, dryrunOutputFile));
    logger.message(localize(7, null));
    logger.message(localize(8, null));
    logger.message(localize(9, null));
    logger.message(localize(10, null));
}
exports.reportDryRunError = reportDryRunError;
// Helper to make paths absolute until the extension handles variables expansion.
function resolvePathToRoot(relPath) {
    if (!path.isAbsolute(relPath)) {
        return path.join(getWorkspaceRoot(), relPath);
    }
    return relPath;
}
exports.resolvePathToRoot = resolvePathToRoot;
// Return the string representing the user home location.
// Inspired from CMake Tools. TODO: implement more such paths and refactor into a separate class.
function userHome() {
    if (process.platform === "win32") {
        return path.join(process.env["HOMEDRIVE"] || "C:", process.env["HOMEPATH"] || "Users\\Public");
    }
    else {
        return process.env["HOME"] || process.env["PROFILE"] || "";
    }
}
exports.userHome = userHome;
// Helper to correctly interpret boolean values out of strings.
// Currently used during settings variable expansion.
function booleanify(value) {
    const truthy = ["true", "True", "1"];
    return truthy.includes(value);
}
exports.booleanify = booleanify;
// Read setting from workspace settings and expand according to various supported patterns.
// Do this for the simple types (converting to boolean or numerals when the varexp syntax
// is used on such types of settings) and for arrays or objects, expand recursively
// until we reach the simple types for submembers. This handles any structure.
async function getExpandedSetting(settingId, propSchema) {
    let workspaceConfiguration = vscode.workspace.getConfiguration("makefile");
    let settingVal = workspaceConfiguration.get(settingId);
    if (!propSchema) {
        propSchema = thisExtensionPackage().contributes.configuration.properties;
        propSchema = propSchema.properties
            ? propSchema.properties[`makefile.${settingId}`]
            : propSchema[`makefile.${settingId}`];
    }
    // Read what's at settingId in the workspace settings and for objects and arrays of complex types make sure
    // to copy into a new counterpart that we will modify, because we don't want to persist expanded values in settings.
    let copySettingVal;
    if (propSchema && propSchema.type === "array") {
        // A simple .concat() is not enough. We need to push(Object.assign) on all object entries in the array.
        copySettingVal = [];
        settingVal.forEach((element) => {
            let copyElement = {};
            copyElement =
                typeof element === "object"
                    ? Object.assign(copyElement, element)
                    : element;
            copySettingVal.push(copyElement);
        });
    }
    else if (propSchema && propSchema.type === "object") {
        copySettingVal = {};
        copySettingVal = Object.assign(copySettingVal, settingVal);
    }
    else {
        copySettingVal = settingVal;
    }
    return getExpandedSettingVal(settingId, copySettingVal, propSchema);
}
exports.getExpandedSetting = getExpandedSetting;
// Same as above but read from an object instead of the settings (as if we get<> before calling this).
// Such approach was needed for tests.
async function getExpandedSettingVal(settingId, settingVal, propSchema) {
    // Currently, we have no ${} variables in the default values of our settings.
    // Skip expanding defaults to keep things faster simpler and safer.
    // Change this when needed.
    const typeJson = propSchema ? propSchema.type : undefined;
    if (settingVal !== undefined &&
        ((propSchema && !areEqual(propSchema.default, settingVal)) || !propSchema)) {
        // This OR is for variables not defined in the extension package.json
        // but the user can define any variable in settings.json to reference later
        if (typeof settingVal === "string") {
            const expandedVal = await expandVariablesInSetting(settingId, settingVal);
            let result = expandedVal;
            if (typeJson === "boolean") {
                result = booleanify(expandedVal);
            }
            else if (typeJson === "number" || typeJson === "integer") {
                result = Number(expandedVal);
            }
            return result;
        }
        else if (typeof settingVal === "object") {
            // arrays are also seen as objects:
            // example: array[5] is seen as property object with index array.5
            // and at the next call we'll see the string.
            let properties = Object.getOwnPropertyNames(settingVal);
            for (let p = 0; p < properties.length; p++) {
                let prop = properties[p];
                let childPropSchema;
                if (propSchema) {
                    if (typeJson === "array") {
                        childPropSchema = propSchema.items;
                    }
                    else {
                        childPropSchema = propSchema.properties
                            ? propSchema.properties[`${prop}`]
                            : propSchema[`${prop}`];
                    }
                }
                try {
                    // The settingVal that was given to this function was already a separate copy from its workspace settings counterpart
                    // but if that contained an array anywhere in its structure, if we don't copy here, this expansion will modify
                    // workspace settings which we want to leave untouched.
                    let copySettingValProp = settingVal[prop];
                    if (childPropSchema && childPropSchema.type === "array") {
                        copySettingValProp = [].concat(settingVal[prop]);
                    }
                    let expandedProp = await getExpandedSettingVal(settingId + "." + prop, copySettingValProp, childPropSchema);
                    if (!areEqual(settingVal[prop], expandedProp)) {
                        settingVal[prop] = expandedProp;
                    }
                }
                catch (e) {
                    logger.message(localize(11, null, settingId, prop, e.message));
                }
            }
        }
    }
    return settingVal;
}
exports.getExpandedSettingVal = getExpandedSettingVal;
// Helper for expanding variables in a setting. The following scenarios are currently supported:
// - predefined VSCode variables (more should be supported with the next release):
//       ${workspaceFolder} (which is the same as the deprecated ${workspaceRoot} which we still support),
//       ${workspaceFolderBasename}, ${userHome}
// - special Makefile Tools variables (implement more in future):
//       ${configuration}, ${buildTarget} (these map to the first two UI elements in the "C/C++" left panel)
// - environment variables: ${env:USERNAME}
// - (any extensions) configuration variables: ${config:extension.setting}
// - command variables: ${command:extension.command} (currently, without commands input variables support)
// - allow for escaping a varexp sequence in case the user wants to pass that through as is.
//   The escape character is backslash and in json one backslash is not allowed inside a string, so we'll always get double.
//   When used in paths, we can't know if a \\ is wanted as a path separator or an escape character so we assume
//   it is always an escape character. Whenever this is not the case, the user can switch to forward slashes in the paths.
//   Example: "drive:\\folder1\\folder2_\\${variable}\\folder3" may be wanted as "drive:\\folder1\\folder2_\\value\\folder3"
//   or as "drive:\\folder1\\folder2_${variable}\\folder3". $ does not make much sense to be left in a path
//   but also the analysis of the meaning of a string (especially if not full path) is not simple.
//   Forward slashes are recommended in paths.
//       NOTES:
//       - ${command:makefile.getConfiguration} is the same as ${configuration}
//       - ${command:makefile.getBuildTarget} is the same as ${buildTarget}
//       - we need the above two commands because launch.json and tasks.json
//         don't work with our predefined variables, only with the VSCode predefined variables.
//         Such data is useful to be accessible to launch/tasks jsons too.
//         But settings.json works with our predefined variables, VSCode predefined variables
//         and any commands.
// TODO: Currently, after applying any expansion pattern, if the result is another expansion pattern
// we log an error but in future let's handle the recursivity and complications of expanding anything
// coming via this entrypoint.
async function expandVariablesInSetting(settingId, settingVal) {
    // Do some string preprocessing first, related to escaping.
    // Since we don't want to change the value persisted in settings but we need to lose the separator
    // (so that the final beneficiaries of these settings don't need to handle the separator character)
    // we will keep the varexp pattern in the final value without the escape character.
    // The escape character is only for our regexp here to know to not expand it.
    // Safe to replace \\${ with ESCAPED_VARIABLE_EXPANSION. This will cause the pattern to be skipped
    // by the regular expression below and also we will replace in reverse at the end (without \\).
    const telemetryProperties = { setting: settingId };
    let preprocStr = settingVal.replace(/\\\$\{/gm, "ESCAPED_VARIABLE_EXPANSION");
    if (preprocStr !== settingVal) {
        logger.message(localize(12, null, settingId, settingVal));
        telemetryProperties.pattern = "escaped";
        telemetry.logEvent("varexp", telemetryProperties);
        settingVal = preprocStr;
    }
    // Try the predefined VSCode variable first. The regexp for ${variable} won't fit the others because of the ":".
    let expandedSetting = settingVal;
    let regexpVSCodeVar = /(\$\{(\w+)\})|(\$\{(\w+):(.+?)\})/gm;
    let result = regexpVSCodeVar.exec(expandedSetting);
    while (result) {
        const telemetryProperties = { setting: settingId };
        let toStr = "";
        if (result[2] === "workspaceFolder" || result[2] === "workspaceRoot") {
            toStr = getWorkspaceRoot();
            telemetryProperties.pattern = result[2];
        }
        else if (result[2] === "workspaceFolderBasename") {
            toStr = path.basename(getWorkspaceRoot());
            telemetryProperties.pattern = result[2];
        }
        else if (result[2] === "userHome") {
            toStr = userHome();
            telemetryProperties.pattern = result[2];
        }
        else if (result[2] === "configuration") {
            toStr = configuration.getCurrentMakefileConfiguration();
            telemetryProperties.pattern = result[2];
        }
        else if (result[2] === "buildTarget") {
            toStr = configuration.getCurrentTarget() || "";
            telemetryProperties.pattern = result[2];
        }
        else if (result[4] === "env" && result[5]) {
            toStr = process.env[result[5]] || "";
            telemetryProperties.pattern = result[4];
        }
        else if (result[4] === "command") {
            telemetryProperties.pattern = result[4];
            telemetryProperties.info = result[5];
            try {
                toStr = await vscode.commands.executeCommand(result[5]);
            }
            catch (e) {
                toStr = "unknown";
                logger.message(localize(13, null, result[5], e.message));
            }
        }
        else if (result[4] === "config" && result[5]) {
            // Extract the name of the extension we read this setting from (before the dot)
            // and the setting follows the first dot.
            telemetryProperties.pattern = result[4];
            telemetryProperties.info = result[5];
            const regexpCfg = /(\w+)\.(.+)/gm;
            const res = regexpCfg.exec(result[5]);
            if (res && res[1] && res[2]) {
                let workspaceCfg = vscode.workspace.getConfiguration(res[1]);
                toStr = workspaceCfg.get(res[2]);
                // The setting is either undefined or maybe we encountered a case with multiple names separated by dot for a property:
                // makefile.set1.set2.set3.set4... which cannot be seen if given the whole setting ID at once.
                // Example:
                // "makefile.set1.set2.set3": {
                //     "set4.set5": "val"
                //     "something.else": "other"
                // }
                // A get on the root workspace cannot see "makefile.set1.set2.set3.set4.set5", returns undefined.
                // In the above case, one get of "makefile.set1.set2.set3" returns an object, then an access on "set4.set5" gets the final value "val".
                // We don't know at which dot to stop for the first and the subsequent get operations, so starting with the workspace root
                // we query for properties and see how much it matches from the full setting id, then we query again on the left over,
                // until we get the final value.
                // In the above case, the root makefile workspace has a property set1 (not set1.set2.set3), then the object retrieved
                // has a set2 property then set3. That last object has a "set4.set5" property (not set4 then set5).
                if (toStr === null || toStr === undefined) {
                    toStr = getSettingMultipleDots(workspaceCfg, res[2]);
                }
                if (toStr === null || toStr === undefined) {
                    toStr = "unknown";
                }
            }
        }
        else {
            logger.message(localize(14, null, result[0]));
            toStr = "unknown";
            telemetryProperties.pattern = "unrecognized";
        }
        telemetry.logEvent("varexp", telemetryProperties);
        // Because we replace at the same time as we evaluate possible consecutive $ patterns
        // we need to start each time the search from the beginning (otherwise the lastIndex gets messed up).
        // It is guaranteed we exit this loop because if we match, we replace with something.
        // That is why we cannot leave the ${} as they are and we replace with "unknown" when they can't resolve.
        // Replacing with empty string was not an option because we want unrecognized patterns to stand out quickly.
        regexpVSCodeVar.lastIndex = 0;
        // Warn if the expanded value contains yet another expansion pattern and leave as is.
        // We will address in future multiple passes.
        if (regexpVSCodeVar.exec(toStr) !== null) {
            logger.message(localize(15, null, result[0], toStr));
            expandedSetting = expandedSetting.replace(result[0], "unknown");
        }
        else {
            expandedSetting = expandedSetting.replace(result[0], toStr);
        }
        regexpVSCodeVar.lastIndex = 0;
        result = regexpVSCodeVar.exec(expandedSetting);
    }
    if (expandedSetting !== settingVal) {
        logger.message(localize(16, null, settingVal, expandedSetting, settingId));
    }
    // Reverse the preprocessing done at the beginning, except that we don't keep the escape character.
    preprocStr = expandedSetting.replace(/ESCAPED_VARIABLE_EXPANSION/gm, "${");
    return preprocStr;
}
exports.expandVariablesInSetting = expandVariablesInSetting;
// Function specialized to get properties with multiple dots in their names.
// In case of more possibilities, return last.
// Example: get the value of "makefile.panel.visibility" or a general hypothetic setting like
// "makefile.set1.set2.set3.set4": {
//      "set5.set6": "val1",
//      "set7.set8": "val2"
// }
// getSettingMultipleDots will return "val2" for "makefile.set1.set2.set3.set4.set7.set8"
// and workspaceConfiguration.get<> will not see it as a whole.
function getSettingMultipleDots(scope, settingId) {
    let result;
    if (scope) {
        let rootProps = Object.getOwnPropertyNames(scope);
        rootProps = rootProps.filter((item) => item && (settingId.startsWith(`${item}.`) || settingId === item));
        rootProps.forEach((prop) => {
            if (settingId === prop) {
                result = scope[prop];
            }
            else {
                result = getSettingMultipleDots(scope[prop], settingId.substring(prop.length + 1, settingId.length));
            }
        });
    }
    return result;
}
// Schedule a task to be run at some future time. This allows other pending tasks to
// execute ahead of the scheduled task and provides a form of async behavior for TypeScript.
function scheduleTask(task) {
    return new Promise((resolve, reject) => {
        setImmediate(() => {
            try {
                const result = task();
                resolve(result);
            }
            catch (e) {
                reject(e);
            }
        });
    });
}
exports.scheduleTask = scheduleTask;
// Async version of scheduleTask
async function scheduleAsyncTask(task) {
    return new Promise((resolve, reject) => {
        setImmediate(async () => {
            try {
                const result = await task();
                resolve(result);
            }
            catch (e) {
                reject(e);
            }
        });
    });
}
exports.scheduleAsyncTask = scheduleAsyncTask;
function thisExtension() {
    const ext = vscode.extensions.getExtension("ms-vscode.makefile-tools");
    if (!ext) {
        throw new Error("Our own extension is null.");
    }
    return ext;
}
exports.thisExtension = thisExtension;
function thisExtensionPackage() {
    const pkg = thisExtension().packageJSON;
    return {
        name: pkg.name,
        publisher: pkg.publisher,
        version: pkg.version,
        contributes: pkg.contributes,
    };
}
exports.thisExtensionPackage = thisExtensionPackage;
function thisExtensionPath() {
    return thisExtension().extensionPath;
}
exports.thisExtensionPath = thisExtensionPath;


/***/ }),

/***/ 874:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  NIL: () => (/* reexport */ nil),
  parse: () => (/* reexport */ esm_node_parse),
  stringify: () => (/* reexport */ esm_node_stringify),
  v1: () => (/* reexport */ esm_node_v1),
  v3: () => (/* reexport */ esm_node_v3),
  v4: () => (/* reexport */ esm_node_v4),
  v5: () => (/* reexport */ esm_node_v5),
  validate: () => (/* reexport */ esm_node_validate),
  version: () => (/* reexport */ esm_node_version)
});

;// CONCATENATED MODULE: external "crypto"
const external_crypto_namespaceObject = require("crypto");
var external_crypto_default = /*#__PURE__*/__webpack_require__.n(external_crypto_namespaceObject);
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-node/rng.js

const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

let poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    external_crypto_default().randomFillSync(rnds8Pool);
    poolPtr = 0;
  }

  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-node/regex.js
/* harmony default export */ const regex = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-node/validate.js


function validate(uuid) {
  return typeof uuid === 'string' && regex.test(uuid);
}

/* harmony default export */ const esm_node_validate = (validate);
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-node/stringify.js

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}

function unsafeStringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!esm_node_validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ const esm_node_stringify = (stringify);
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-node/v1.js

 // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || rng)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || unsafeStringify(b);
}

/* harmony default export */ const esm_node_v1 = (v1);
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-node/parse.js


function parse(uuid) {
  if (!esm_node_validate(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

/* harmony default export */ const esm_node_parse = (parse);
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-node/v35.js



function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;

    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = esm_node_parse(namespace);
    }

    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return unsafeStringify(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-node/md5.js


function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return external_crypto_default().createHash('md5').update(bytes).digest();
}

/* harmony default export */ const esm_node_md5 = (md5);
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-node/v3.js


const v3 = v35('v3', 0x30, esm_node_md5);
/* harmony default export */ const esm_node_v3 = (v3);
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-node/native.js

/* harmony default export */ const esm_node_native = ({
  randomUUID: (external_crypto_default()).randomUUID
});
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-node/v4.js




function v4(options, buf, offset) {
  if (esm_node_native.randomUUID && !buf && !options) {
    return esm_node_native.randomUUID();
  }

  options = options || {};
  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return unsafeStringify(rnds);
}

/* harmony default export */ const esm_node_v4 = (v4);
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-node/sha1.js


function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return external_crypto_default().createHash('sha1').update(bytes).digest();
}

/* harmony default export */ const esm_node_sha1 = (sha1);
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-node/v5.js


const v5 = v35('v5', 0x50, esm_node_sha1);
/* harmony default export */ const esm_node_v5 = (v5);
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-node/nil.js
/* harmony default export */ const nil = ('00000000-0000-0000-0000-000000000000');
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-node/version.js


function version(uuid) {
  if (!esm_node_validate(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.slice(14, 15), 16);
}

/* harmony default export */ const esm_node_version = (version);
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-node/index.js










/***/ }),

/***/ 545:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT license.
 * ------------------------------------------------------------------------------------------ */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCppToolsApi = exports.Version = void 0;
const vscode = __webpack_require__(398);
/**
 * API version information.
 */
var Version;
(function (Version) {
    Version[Version["v0"] = 0] = "v0";
    Version[Version["v1"] = 1] = "v1";
    Version[Version["v2"] = 2] = "v2";
    Version[Version["v3"] = 3] = "v3";
    Version[Version["v4"] = 4] = "v4";
    Version[Version["v5"] = 5] = "v5";
    Version[Version["v6"] = 6] = "v6";
    Version[Version["latest"] = 6] = "latest";
})(Version = exports.Version || (exports.Version = {}));
/**
 * Check if an object satisfies the contract of the CppToolsExtension interface.
 */
function isCppToolsExtension(extension) {
    return extension && extension.getApi;
}
/**
 * Check if an object satisfies the contract of the first version of the CppToolsApi.
 * (The first release of the API only had two functions)
 */
function isLegacyCppToolsApi(api) {
    return api && api.registerCustomConfigurationProvider && api.didChangeCustomConfiguration;
}
/**
 * Helper function to get the CppToolsApi from the cpptools extension.
 * @param version The desired API version
 * @example
```
    import {CppToolsApi, Version, CustomConfigurationProvider, getCppToolsApi} from 'vscode-cpptools';

    let api: CppToolsApi|undefined = await getCppToolsApi(Version.v1);
    if (api) {
        // Inform cpptools that a custom config provider
        // will be able to service the current workspace.
        api.registerCustomConfigurationProvider(provider);

        // Do any required setup that the provider needs.

        // Notify cpptools that the provider is ready to
        // provide IntelliSense configurations.
        api.notifyReady(provider);
    }
    // Dispose of the 'api' in your extension's
    // deactivate() method, or whenever you want to
    // unregister the provider.
```
 */
function getCppToolsApi(version) {
    return __awaiter(this, void 0, void 0, function* () {
        let cpptools = vscode.extensions.getExtension("ms-vscode.cpptools");
        let extension = undefined;
        let api = undefined;
        if (cpptools) {
            if (!cpptools.isActive) {
                try {
                    // activate may throw if VS Code is shutting down.
                    extension = yield cpptools.activate();
                }
                catch (_a) {
                }
            }
            else {
                extension = cpptools.exports;
            }
            if (isCppToolsExtension(extension)) {
                // ms-vscode.cpptools > 0.17.5
                try {
                    api = extension.getApi(version);
                }
                catch (err) {
                    // Unfortunately, ms-vscode.cpptools [0.17.6, 0.18.1] throws a RangeError if you specify a version greater than v1.
                    // These versions of the extension will not be able to act on the newer interface and v2 is a superset of v1, so we can safely fall back to v1.
                    let e = err;
                    if (e && e.message && e.message.startsWith("Invalid version")) {
                        api = extension.getApi(Version.v1);
                    }
                }
                if (version !== Version.v1) {
                    if (!api.getVersion) {
                        console.warn(`[vscode-cpptools-api] version ${version} requested, but is not available in the current version of the cpptools extension. Using version 1 instead.`);
                    }
                    else if (version !== api.getVersion()) {
                        console.warn(`[vscode-cpptools-api] version ${version} requested, but is not available in the current version of the cpptools extension. Using version ${api.getVersion()} instead.`);
                    }
                }
            }
            else if (isLegacyCppToolsApi(extension)) {
                // ms-vscode.cpptools version 0.17.5
                api = extension;
                if (version !== Version.v0) {
                    console.warn(`[vscode-cpptools-api] version ${version} requested, but is not available in version 0.17.5 of the cpptools extension. Using version 0 instead.`);
                }
            }
            else {
                console.warn('[vscode-cpptools-api] No cpptools API was found.');
            }
        }
        else {
            console.warn('[vscode-cpptools-api] C/C++ extension is not installed');
        }
        return api;
    });
}
exports.getCppToolsApi = getCppToolsApi;


/***/ }),

/***/ 254:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.config = exports.loadMessageBundle = exports.localize = exports.format = exports.setPseudo = exports.isPseudo = exports.isDefined = exports.BundleFormat = exports.MessageFormat = void 0;
var ral_1 = __webpack_require__(236);
var MessageFormat;
(function (MessageFormat) {
    MessageFormat["file"] = "file";
    MessageFormat["bundle"] = "bundle";
    MessageFormat["both"] = "both";
})(MessageFormat = exports.MessageFormat || (exports.MessageFormat = {}));
var BundleFormat;
(function (BundleFormat) {
    // the nls.bundle format
    BundleFormat["standalone"] = "standalone";
    BundleFormat["languagePack"] = "languagePack";
})(BundleFormat = exports.BundleFormat || (exports.BundleFormat = {}));
var LocalizeInfo;
(function (LocalizeInfo) {
    function is(value) {
        var candidate = value;
        return candidate && isDefined(candidate.key) && isDefined(candidate.comment);
    }
    LocalizeInfo.is = is;
})(LocalizeInfo || (LocalizeInfo = {}));
function isDefined(value) {
    return typeof value !== 'undefined';
}
exports.isDefined = isDefined;
exports.isPseudo = false;
function setPseudo(pseudo) {
    exports.isPseudo = pseudo;
}
exports.setPseudo = setPseudo;
function format(message, args) {
    var result;
    if (exports.isPseudo) {
        // FF3B and FF3D is the Unicode zenkaku representation for [ and ]
        message = '\uFF3B' + message.replace(/[aouei]/g, '$&$&') + '\uFF3D';
    }
    if (args.length === 0) {
        result = message;
    }
    else {
        result = message.replace(/\{(\d+)\}/g, function (match, rest) {
            var index = rest[0];
            var arg = args[index];
            var replacement = match;
            if (typeof arg === 'string') {
                replacement = arg;
            }
            else if (typeof arg === 'number' || typeof arg === 'boolean' || arg === void 0 || arg === null) {
                replacement = String(arg);
            }
            return replacement;
        });
    }
    return result;
}
exports.format = format;
function localize(_key, message) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    return format(message, args);
}
exports.localize = localize;
function loadMessageBundle(file) {
    return (0, ral_1.default)().loadMessageBundle(file);
}
exports.loadMessageBundle = loadMessageBundle;
function config(opts) {
    return (0, ral_1.default)().config(opts);
}
exports.config = config;
//# sourceMappingURL=common.js.map

/***/ }),

/***/ 236:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var _ral;
function RAL() {
    if (_ral === undefined) {
        throw new Error("No runtime abstraction layer installed");
    }
    return _ral;
}
(function (RAL) {
    function install(ral) {
        if (ral === undefined) {
            throw new Error("No runtime abstraction layer provided");
        }
        _ral = ral;
    }
    RAL.install = install;
})(RAL || (RAL = {}));
exports["default"] = RAL;
//# sourceMappingURL=ral.js.map

/***/ }),

/***/ 493:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.config = exports.loadMessageBundle = exports.BundleFormat = exports.MessageFormat = void 0;
var path = __webpack_require__(928);
var fs = __webpack_require__(896);
var ral_1 = __webpack_require__(236);
var common_1 = __webpack_require__(254);
var common_2 = __webpack_require__(254);
Object.defineProperty(exports, "MessageFormat", ({ enumerable: true, get: function () { return common_2.MessageFormat; } }));
Object.defineProperty(exports, "BundleFormat", ({ enumerable: true, get: function () { return common_2.BundleFormat; } }));
var toString = Object.prototype.toString;
function isNumber(value) {
    return toString.call(value) === '[object Number]';
}
function isString(value) {
    return toString.call(value) === '[object String]';
}
function isBoolean(value) {
    return value === true || value === false;
}
function readJsonFileSync(filename) {
    return JSON.parse(fs.readFileSync(filename, 'utf8'));
}
var resolvedBundles;
var options;
function initializeSettings() {
    options = { locale: undefined, language: undefined, languagePackSupport: false, cacheLanguageResolution: true, messageFormat: common_1.MessageFormat.bundle };
    if (isString(process.env.VSCODE_NLS_CONFIG)) {
        try {
            var vscodeOptions_1 = JSON.parse(process.env.VSCODE_NLS_CONFIG);
            var language = void 0;
            if (vscodeOptions_1.availableLanguages) {
                var value = vscodeOptions_1.availableLanguages['*'];
                if (isString(value)) {
                    language = value;
                }
            }
            if (isString(vscodeOptions_1.locale)) {
                options.locale = vscodeOptions_1.locale.toLowerCase();
            }
            if (language === undefined) {
                options.language = options.locale;
            }
            else if (language !== 'en') {
                options.language = language;
            }
            if (isBoolean(vscodeOptions_1._languagePackSupport)) {
                options.languagePackSupport = vscodeOptions_1._languagePackSupport;
            }
            if (isString(vscodeOptions_1._cacheRoot)) {
                options.cacheRoot = vscodeOptions_1._cacheRoot;
            }
            if (isString(vscodeOptions_1._languagePackId)) {
                options.languagePackId = vscodeOptions_1._languagePackId;
            }
            if (isString(vscodeOptions_1._translationsConfigFile)) {
                options.translationsConfigFile = vscodeOptions_1._translationsConfigFile;
                try {
                    options.translationsConfig = readJsonFileSync(options.translationsConfigFile);
                }
                catch (error) {
                    // We can't read the translation config file. Mark the cache as corrupted.
                    if (vscodeOptions_1._corruptedFile) {
                        var dirname = path.dirname(vscodeOptions_1._corruptedFile);
                        fs.exists(dirname, function (exists) {
                            if (exists) {
                                fs.writeFile(vscodeOptions_1._corruptedFile, 'corrupted', 'utf8', function (err) {
                                    console.error(err);
                                });
                            }
                        });
                    }
                }
            }
        }
        catch (_a) {
            // Do nothing.
        }
    }
    (0, common_1.setPseudo)(options.locale === 'pseudo');
    resolvedBundles = Object.create(null);
}
initializeSettings();
function supportsLanguagePack() {
    return options.languagePackSupport === true && options.cacheRoot !== undefined && options.languagePackId !== undefined && options.translationsConfigFile !== undefined
        && options.translationsConfig !== undefined;
}
function createScopedLocalizeFunction(messages) {
    return function (key, message) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        if (isNumber(key)) {
            if (key >= messages.length) {
                console.error("Broken localize call found. Index out of bounds. Stacktrace is\n: ".concat(new Error('').stack));
                return;
            }
            return (0, common_1.format)(messages[key], args);
        }
        else {
            if (isString(message)) {
                console.warn("Message ".concat(message, " didn't get externalized correctly."));
                return (0, common_1.format)(message, args);
            }
            else {
                console.error("Broken localize call found. Stacktrace is\n: ".concat(new Error('').stack));
            }
        }
    };
}
function resolveLanguage(file) {
    var resolvedLanguage;
    if (options.cacheLanguageResolution && resolvedLanguage) {
        resolvedLanguage = resolvedLanguage;
    }
    else {
        if (common_1.isPseudo || !options.language) {
            resolvedLanguage = '.nls.json';
        }
        else {
            var locale = options.language;
            while (locale) {
                var candidate = '.nls.' + locale + '.json';
                if (fs.existsSync(file + candidate)) {
                    resolvedLanguage = candidate;
                    break;
                }
                else {
                    var index = locale.lastIndexOf('-');
                    if (index > 0) {
                        locale = locale.substring(0, index);
                    }
                    else {
                        resolvedLanguage = '.nls.json';
                        locale = null;
                    }
                }
            }
        }
        if (options.cacheLanguageResolution) {
            resolvedLanguage = resolvedLanguage;
        }
    }
    return file + resolvedLanguage;
}
function findInTheBoxBundle(root) {
    var language = options.language;
    while (language) {
        var candidate = path.join(root, "nls.bundle.".concat(language, ".json"));
        if (fs.existsSync(candidate)) {
            return candidate;
        }
        else {
            var index = language.lastIndexOf('-');
            if (index > 0) {
                language = language.substring(0, index);
            }
            else {
                language = undefined;
            }
        }
    }
    // Test if we can reslove the default bundle.
    if (language === undefined) {
        var candidate = path.join(root, 'nls.bundle.json');
        if (fs.existsSync(candidate)) {
            return candidate;
        }
    }
    return undefined;
}
function mkdir(directory) {
    try {
        fs.mkdirSync(directory);
    }
    catch (err) {
        if (err.code === 'EEXIST') {
            return;
        }
        else if (err.code === 'ENOENT') {
            var parent = path.dirname(directory);
            if (parent !== directory) {
                mkdir(parent);
                fs.mkdirSync(directory);
            }
        }
        else {
            throw err;
        }
    }
}
function createDefaultNlsBundle(folder) {
    var metaData = readJsonFileSync(path.join(folder, 'nls.metadata.json'));
    var result = Object.create(null);
    for (var module_1 in metaData) {
        var entry = metaData[module_1];
        result[module_1] = entry.messages;
    }
    return result;
}
function createNLSBundle(header, metaDataPath) {
    var languagePackLocation = options.translationsConfig[header.id];
    if (!languagePackLocation) {
        return undefined;
    }
    var languagePack = readJsonFileSync(languagePackLocation).contents;
    var metaData = readJsonFileSync(path.join(metaDataPath, 'nls.metadata.json'));
    var result = Object.create(null);
    for (var module_2 in metaData) {
        var entry = metaData[module_2];
        var translations = languagePack["".concat(header.outDir, "/").concat(module_2)];
        if (translations) {
            var resultMessages = [];
            for (var i = 0; i < entry.keys.length; i++) {
                var messageKey = entry.keys[i];
                var key = isString(messageKey) ? messageKey : messageKey.key;
                var translatedMessage = translations[key];
                if (translatedMessage === undefined) {
                    translatedMessage = entry.messages[i];
                }
                resultMessages.push(translatedMessage);
            }
            result[module_2] = resultMessages;
        }
        else {
            result[module_2] = entry.messages;
        }
    }
    return result;
}
function touch(file) {
    var d = new Date();
    fs.utimes(file, d, d, function () {
        // Do nothing. Ignore
    });
}
function cacheBundle(key, bundle) {
    resolvedBundles[key] = bundle;
    return bundle;
}
function loadNlsBundleOrCreateFromI18n(header, bundlePath) {
    var result;
    var bundle = path.join(options.cacheRoot, "".concat(header.id, "-").concat(header.hash, ".json"));
    var useMemoryOnly = false;
    var writeBundle = false;
    try {
        result = JSON.parse(fs.readFileSync(bundle, { encoding: 'utf8', flag: 'r' }));
        touch(bundle);
        return result;
    }
    catch (err) {
        if (err.code === 'ENOENT') {
            writeBundle = true;
        }
        else if (err instanceof SyntaxError) {
            // We have a syntax error. So no valid JSON. Use
            console.log("Syntax error parsing message bundle: ".concat(err.message, "."));
            fs.unlink(bundle, function (err) {
                if (err) {
                    console.error("Deleting corrupted bundle ".concat(bundle, " failed."));
                }
            });
            useMemoryOnly = true;
        }
        else {
            throw err;
        }
    }
    result = createNLSBundle(header, bundlePath);
    if (!result || useMemoryOnly) {
        return result;
    }
    if (writeBundle) {
        try {
            fs.writeFileSync(bundle, JSON.stringify(result), { encoding: 'utf8', flag: 'wx' });
        }
        catch (err) {
            if (err.code === 'EEXIST') {
                return result;
            }
            throw err;
        }
    }
    return result;
}
function loadDefaultNlsBundle(bundlePath) {
    try {
        return createDefaultNlsBundle(bundlePath);
    }
    catch (err) {
        console.log("Generating default bundle from meta data failed.", err);
        return undefined;
    }
}
function loadNlsBundle(header, bundlePath) {
    var result;
    // Core decided to use a language pack. Do the same in the extension
    if (supportsLanguagePack()) {
        try {
            result = loadNlsBundleOrCreateFromI18n(header, bundlePath);
        }
        catch (err) {
            console.log("Load or create bundle failed ", err);
        }
    }
    if (!result) {
        // No language pack found, but core is running in language pack mode
        // Don't try to use old in the box bundles since the might be stale
        // Fall right back to the default bundle.
        if (options.languagePackSupport) {
            return loadDefaultNlsBundle(bundlePath);
        }
        var candidate = findInTheBoxBundle(bundlePath);
        if (candidate) {
            try {
                return readJsonFileSync(candidate);
            }
            catch (err) {
                console.log("Loading in the box message bundle failed.", err);
            }
        }
        result = loadDefaultNlsBundle(bundlePath);
    }
    return result;
}
function tryFindMetaDataHeaderFile(file) {
    var result;
    var dirname = path.dirname(file);
    while (true) {
        result = path.join(dirname, 'nls.metadata.header.json');
        if (fs.existsSync(result)) {
            break;
        }
        var parent = path.dirname(dirname);
        if (parent === dirname) {
            result = undefined;
            break;
        }
        else {
            dirname = parent;
        }
    }
    return result;
}
function loadMessageBundle(file) {
    if (!file) {
        // No file. We are in dev mode. Return the default
        // localize function.
        return common_1.localize;
    }
    // Remove extension since we load json files.
    var ext = path.extname(file);
    if (ext) {
        file = file.substr(0, file.length - ext.length);
    }
    if (options.messageFormat === common_1.MessageFormat.both || options.messageFormat === common_1.MessageFormat.bundle) {
        var headerFile = tryFindMetaDataHeaderFile(file);
        if (headerFile) {
            var bundlePath = path.dirname(headerFile);
            var bundle = resolvedBundles[bundlePath];
            if (bundle === undefined) {
                try {
                    var header = JSON.parse(fs.readFileSync(headerFile, 'utf8'));
                    try {
                        var nlsBundle = loadNlsBundle(header, bundlePath);
                        bundle = cacheBundle(bundlePath, nlsBundle ? { header: header, nlsBundle: nlsBundle } : null);
                    }
                    catch (err) {
                        console.error('Failed to load nls bundle', err);
                        bundle = cacheBundle(bundlePath, null);
                    }
                }
                catch (err) {
                    console.error('Failed to read header file', err);
                    bundle = cacheBundle(bundlePath, null);
                }
            }
            if (bundle) {
                var module_3 = file.substr(bundlePath.length + 1).replace(/\\/g, '/');
                var messages = bundle.nlsBundle[module_3];
                if (messages === undefined) {
                    console.error("Messages for file ".concat(file, " not found. See console for details."));
                    return function () {
                        return 'Messages not found.';
                    };
                }
                return createScopedLocalizeFunction(messages);
            }
        }
    }
    if (options.messageFormat === common_1.MessageFormat.both || options.messageFormat === common_1.MessageFormat.file) {
        // Try to load a single file bundle
        try {
            var json = readJsonFileSync(resolveLanguage(file));
            if (Array.isArray(json)) {
                return createScopedLocalizeFunction(json);
            }
            else {
                if ((0, common_1.isDefined)(json.messages) && (0, common_1.isDefined)(json.keys)) {
                    return createScopedLocalizeFunction(json.messages);
                }
                else {
                    console.error("String bundle '".concat(file, "' uses an unsupported format."));
                    return function () {
                        return 'File bundle has unsupported format. See console for details';
                    };
                }
            }
        }
        catch (err) {
            if (err.code !== 'ENOENT') {
                console.error('Failed to load single file bundle', err);
            }
        }
    }
    console.error("Failed to load message bundle for file ".concat(file));
    return function () {
        return 'Failed to load message bundle. See console for details.';
    };
}
exports.loadMessageBundle = loadMessageBundle;
function config(opts) {
    if (opts) {
        if (isString(opts.locale)) {
            options.locale = opts.locale.toLowerCase();
            options.language = options.locale;
            resolvedBundles = Object.create(null);
        }
        if (opts.messageFormat !== undefined) {
            options.messageFormat = opts.messageFormat;
        }
        if (opts.bundleFormat === common_1.BundleFormat.standalone && options.languagePackSupport === true) {
            options.languagePackSupport = false;
        }
    }
    (0, common_1.setPseudo)(options.locale === 'pseudo');
    return loadMessageBundle;
}
exports.config = config;
ral_1.default.install(Object.freeze({
    loadMessageBundle: loadMessageBundle,
    config: config
}));
//# sourceMappingURL=main.js.map

/***/ }),

/***/ 398:
/***/ ((module) => {

"use strict";
module.exports = require("vscode");

/***/ }),

/***/ 317:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ 896:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 692:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 857:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 928:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(15);
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=main.js.map